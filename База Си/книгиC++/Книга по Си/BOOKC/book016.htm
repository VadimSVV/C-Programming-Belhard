<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>Документация по Cи, C++ и Visual C++</title>
</head>

<body background="../../background/bg6.gif" link="Black" vlink="Black" topmargin=2
leftmargin="5" bgcolor="Aqua">

<p align="center"><br>
<font face="Arial" color="Maroon"><strong><big>УКАЗАТЕЛИ</big></strong></font></p>
<div align="center"><center>

<table width="90%" height="132" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" height="132" valign="middle"><p align="left"><strong><font face="Arial"
    color="#0080FF"><big>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Стр. 16 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </big></font><font
    face="Arial" color="#800000"><small>&lt; <a href="../visual_docum1.htm" target="_self"
    style="color: rgb(128,64,64)">оглавление </a>&gt;</small></font></strong><font
    face="Times New Roman" color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Указатель - </strong>это
    переменная, значением которой является <strong>адресс
    </strong>другой переменной. Так как указатель может
    ссылаться на переменные разных типов, с
    указателем в языке Си связывается тип того
    объекта, на который он ссылается. Для описания
    указателей используется операция косвенной
    адресации <strong>*.</strong> Например, указатель целого
    типа <strong>uk </strong>описывается так : <strong>int *uk. </strong>Унарная
    операция <strong>&amp;</strong>, примененная к некоторой
    переменной, показывает, что нам нужен адресс этой
    переменной, а не ее текущее значение. Если
    переменная <strong>uk </strong>объявлена как указатель,
    то оператор присваивания <strong>uk=&amp;x </strong>означает:
    &quot;<strong>взять адресс переменной x и присвоить его
    значение переменной-указателю uk</strong>&quot;<strong>.</strong></p>
    <p align="left"><strong>&nbsp; </strong>Унарная операция <strong>*. </strong>примененная
    к указателю, обеспечивает доступ к содержимому
    ячейки памяти, на которую ссылается указатель.
    Например, <strong>*uk </strong>можно описать словами как
    &quot;<strong>то, что содержится по адресу, на который
    указывает uk</strong>&quot;<strong>. </strong>Указатели могут
    использоваться в выражениях. Если. например,
    переменная <strong>uk </strong>указывает на целое <strong>x</strong>,
    то <strong>*uk </strong>может во всех случаях
    использоваться вместо <strong>x; </strong>так, <strong>*uk+1 </strong>увеличивает
    <strong>x </strong>на единицу, а <strong>*uk=0 </strong>равносильно <strong>x=0.
    </strong>Два оператора присваивания <strong>uk=&amp;x;y=*uk; </strong>выполняет
    то же самое, что и один оператор <strong>y=x. </strong>Польза
    от применения указателей в таких ситуациях,
    мягко выражаясь, невелика. </p>
    <p align="left">&nbsp;&nbsp; Наиболее полно их преимущества
    при обработке массивов и, в частности, символьных
    строк. Указатели и массивы тесно связаны друг с
    другом. Прежде чем рассмотреть эту связь
    подробно, заметим, что если <strong>uk </strong>- некоторый
    указатель, то <strong>uk++ </strong>увеличивает его
    значение и он теперь указывает на следющий,
    соседний адресуемый объект. Значение <strong>uk </strong>используется
    в выражении, а затем увеличивается. Аналогично
    определяются операции <strong>uk--, ++uk</strong>, <strong>--uk. </strong>В
    общем случае указатель <strong>uk </strong>можно
    скаладывать с целым числом <strong>i. </strong>Оператор <strong>uk+=i
    </strong>передвигает ссылку на <strong>i </strong>элементов
    относительно текущего значения. Эти конструкции
    подчиняются правилам адресной арифметики.</p>
    <p align="left">&nbsp; А теперь вернемся к массивам. Пусть
    имеется описание <strong>int a[5]; </strong>Оно определяет
    массив размером 5 элементов, т.е. пять
    последовательно расположенных ячеек памяти <strong>a[0],
    a[1], a[2], a[3], a[4]. </strong>Адресс <strong>i</strong>-го элемента
    массива равен сумме адреса начального елемента
    массива и смещения этого элемента на <strong>i </strong>единиц
    от начала массива. Это достигается
    индексированием: <strong>a[i]-i </strong>-й элемент массива.
    Но доступ к любому элементу массива может быть
    выполнен и с помощью указателей, причем, более
    эффективно. Если <strong>uk -</strong>указатель на целое,
    описанный как <strong>int *uk</strong>, то <strong>uk </strong>после
    выполнения операции <strong>uk=&amp;a[0] </strong>содержит
    адресс <strong>a[0], </strong>а <strong>uk+i&nbsp; </strong>указывает на
    <strong>i -й</strong> элемент массива. Таким образом, <strong>uk+i
    </strong>является адрессом <strong>a[i]</strong>,<strong> </strong>а <strong>*(uk=1)
    </strong>- содержимым <strong>i- го </strong>элемента(операции
    <strong>* </strong>и <strong>&amp;</strong> более приоритетны, чем
    арифметические операции). Так как имя массива в
    программе отождествляется с адресом его первого
    элемента, то выражение <strong>uk=&amp;a[0] </strong>эквивалентно
    такому: <strong>uk=a. </strong>Поэтому значение<strong> a[i] </strong>можно
    записать как <strong>*(a+i). </strong>Применив к этим двум
    элементам операцию взятия адреса, получим, что <strong>&amp;a[i]
    </strong>и <strong>a+i </strong>идеитичны.</p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Раньше, в
    связи с использованием функции <strong>scanf, </strong>мы
    говорили, что применение указателей в качестве
    аргументов функции дает способ обхода защиты
    значений вызывающей функции от действий
    вызванной функции. На примере 5.4 приведен текст
    программы с функцией <strong>obmen(x,y), </strong>которая
    меняет местами значения двух целых величин. Так
    как <strong>x,y - </strong>адреса переменных <strong>a </strong>и<strong>
    b, </strong>то <strong>*x </strong>и <strong>*y</strong> обеспечивают
    косвенный доступ значениям <strong>a </strong>и <strong>b. </strong>К
    сказанному добавим, что использование
    указателей позволяет нам обходить ограничения
    языка Си, согласно которым функциям может
    возращать только одно значение. </p>
    <p align="left">&nbsp;&nbsp; Если в качестве функции
    передается имя массива, то оно фактически
    определяет адрес начала массива, т.е. является
    указателем. В качестве илюстрации напишем
    очередную версию функции <strong>length, </strong>вычисляющей
    длину строки. Если имя массива передается
    функции, то в самой функции можно исходить из
    того, что она работает с массивом, а можно
    исходить из того, что она работает с указателем.</p>
    <p align="left">&nbsp; Пример 5.4 </p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="51%">
      <tr>
        <td width="100%"><strong>/*обмен a и b */<br>
        obmen(int *x,int *y)<br>
        {<br>
        int t;<br>
        t=*x;<br>
        *x=*y;<br>
        *y=t;<br>
        }<br>
        #include &lt;stdio.h&gt;<br>
        main()<br>
        {<br>
        int a,b;<br>
        a=3;b=7;<br>
        obmen(a,b);<br>
        printf(&quot;a=%d b=%d&quot;,a,b);<br>
        }<br>
        </strong></td>
      </tr>
    </table>
    </center></div><p align="left">&nbsp; В определении функции
    формальные параметры <strong>char s[] </strong>и <strong>char *s </strong>совершенно
    идеитичны. Операция <strong><small>s++ (</small></strong>пример 5.5<strong><small>)
    </small></strong>увеличение на единицу текущее значение
    указателя, первоначально указывающее на первый
    символ строки, а операция <strong>*s!='\0' </strong>сравнивает
    очередной символс признаком конца строки. </p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример 5.5</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="42%">
      <tr>
        <td width="100%"><strong>/*длина строки*/<br>
        length(s)<br>
        char *s;<br>
        {<br>
        int i;<br>
        for(i=0; *s!='\0';s++)<br>
        i+++;<br>
        return(i);<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">&nbsp; Кроме ранее расмотренных
    операций адресной арифметики, к указателям можно
    применить операции сравнения <strong>== </strong>и <strong>!=. </strong>Даже
    операции отношения Б &lt;,&gt;= и т.п. работают
    правильно, если указатели ссылаются на элементы
    одного и того же&nbsp; массива. В последнем случае
    возможно даже вычитание ссылок: если <strong>u </strong>и <strong>s
    </strong>ссылаются на элементы одного массива, то <strong>u-s
    </strong>есть число элементов между <strong>u </strong>и <strong>s.
    </strong>Используем этот факт для составления еще
    одной версии функции <strong>length (</strong>пример 5.6<strong>).
    </strong>Cначала <strong>u </strong>указывает на первый
    символ строки (<strong>char *u</strong> =<strong>s</strong>). Затем в
    цикле по очереди проверяется каждый символ, пока
    в конце концов не будет обнаружен <strong>&quot;\0&quot;. </strong>Разность
    <strong>u-s </strong>дает как раз длину строки.</p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример 5.6</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="37%">
      <tr>
        <td width="100%"><strong>/*длина строки*/<br>
        length(s)<br>
        char *s;<br>
        {<br>
        char *u=s;<br>
        while(*u!='\0')<br>
        u++;<br>
        return(u-s);<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">Для илюстрации основных
    аспектов применения указателей в СИ рассмотрим
    функцию копирования строки <strong>s1 </strong>в строку <strong>s2</strong>.
    Сначала приведем версию, основанную на работе с
    массивами(пример 5.7). Для сравнения рядом
    помещена версия с использованием
    указателей(пример 5.8).</p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Пример 5.7</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="37%">
      <tr>
        <td width="100%"><strong>/*копия строки*/<br>
        copy(s1,s2)<br>
        char s1[],s2[];<br>
        {<br>
        int i=0;<br>
        while((s2[i]=s1[i])!='\0')<br>
        i++;<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">&nbsp;&nbsp; Пример 5.8</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="37%">
      <tr>
        <td width="100%"><strong>/*копия строки*/<br>
        copy(s1,s2)<br>
        char *s1,*s2;<br>
        {<br>
        while((*s2=*s1)!='\0')<br>
        {<br>
        s2++;s1++;<br>
        }<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">&nbsp;&nbsp; Здесь операция
    копирования помещена непосредственно в условие,
    определяющее момент цикла: <strong>while((*s2=*s1)!='\0'). </strong>Продвижение
    вдоль массивов вплоть до тех пор, пока не
    встретится <strong>&quot;\0&quot;, </strong>обеспечивают
    операторы <strong>s2++ </strong>и <strong>s1++</strong>. Их, однако,
    тоже можно поместить в проверку (пример 5.9). </p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример 5.9</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="37%">
      <tr>
        <td width="100%"><strong>/*копия строки*/<br>
        copy(s1,s2)<br>
        char *s1,*s2;<br>
        {<br>
        while((*s2++=*s1++)!='\0');<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">Еще раз напомним, что унарные
    операции типа <strong>* </strong>и<strong> ++ </strong>выполняются
    справа налево. Значение <strong>*s++ c</strong>есть символ,
    на который указывает <strong>s </strong>до его
    увеличения. Так как значение &quot;\0&quot; есть нуль, а
    цикл <strong>while </strong>проверет, не нуль ли выражение в
    скобках, то это позволяет опустить явное
    сравнение с нулем(пример 6.0) . Так постепенно
    функция копирования становится все более
    компактной и ... все менее понятной. Но&nbsp; в
    системном программировании предпостение чаще
    отдают именно компактным и, следовательно, более
    эффективным по быстродействиб программам.</p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример 6.0</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="37%">
      <tr>
        <td width="100%"><strong>/*копия строки*/<br>
        copy(s1,s2)<br>
        char *s1,*s2;<br>
        {<br>
        while(*s2++=*s1++);<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">&nbsp;&nbsp; В языке Си, что некоторая
    литерная строка, выраженная как &quot;строка&quot; ,
    фактически рассматривается как указатель на
    нулевой элемент массива &quot; строка&quot;.
    Допускается, например, такая интересная запись: </p>
    <p align="left"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    char *uk; uk=&quot;ИНФОРМАТИКА&quot;;</strong></p>
    <p align="left">&nbsp;&nbsp; Последний оператор присваивает
    указателю адрес нулевого элемента строки, т.е.
    символа &quot;<strong>И</strong>&quot;. Возникает вопрос, где
    находится массив, содержащий символы &quot;<strong>ИНФОРМАТИКА</strong>&quot;?
    Мы его нигде не описывали. Ответ такой: эта строка
    - константа; она является частью функции, в
    которой встречается, точно также, как целая
    константа <strong>4 </strong>или символьная константа <strong>&quot;А&quot;
    </strong>в операторах <strong>i=4; c=&quot;A&quot;;. </strong>Более
    детально пояснит сказанное программа на пример
    6.1, которая печатает строку символов в обратном
    порядке.</p>
    <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример 6.1</p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="46%">
      <tr>
        <td width="100%"><strong>#include &lt;stdio.h&gt;<br>
        main()<br>
        {<br>
        char *uk1,*uk2;<br>
        uk1=uk2=&quot;ИНФОРМАТИКА&quot;;<br>
        while(*uk2!='\0')<br>
        &nbsp; putchar(*uk2++);<br>
        putchar('\n');<br>
        while(--uk2 &gt;= uk1)<br>
        putchar(*uk2);<br>
        putchar('\n');<br>
        }</strong></td>
      </tr>
    </table>
    </center></div><p align="left">В самом начале указателям <strong>uk1
    </strong>и <strong>uk2 </strong>присваивается начальный
    адресс строки &quot;<strong>ИНФОРМАТИКА</strong>&quot;. Затем
    строка посимвольно печатается и одновременно
    указатель <strong>uk2 </strong>смещается вдоль строки. В
    конце вывода <strong>uk2 </strong>указывает на последний
    символ исходной строки. Во втором цикле <strong>while </strong>все
    тот же указатель <strong>uk2 </strong>начинает изменяться
    в обратном направлении, уменьнаясь до тех пор,
    пока он не будет указывать на нулевой элемент
    массива, обеспечивая выдачу строки в обратном
    порядке.</p>
    <p align="center"><font face="Arial" color="#804040"><small><strong>&lt;<a
    href="book015.htm" target="_self" style="color: rgb(128,64,64)">Назад</a> &gt;
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; <a href="book017.htm"
    style="color: rgb(128,64,0)">Дальше</a> &gt;</strong></small></font><br>
    </td>
  </tr>
</table>
</center></div>
</body>
</html>
