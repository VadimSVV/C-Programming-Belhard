<HTML>
<HEAD>
<TITLE>Untitled Document</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</HEAD>

<BODY BGCOLOR="#FFFFFF" BACKGROUND="bgrwhite.gif">
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif">Урок 32</FONT></H2>
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif"> Управление свободной 
  памятью</FONT></H2>
<P> <FONT FACE="Times New Roman, Times, serif"></FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">Из 
  урока 31 вы узнали, что при выполнении ваши программы могут использовать оператор</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> для динамического 
  распределения памяти из свободной памяти. Если оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  успешно выделяет память, ваша программа получает на нее указатель. Если оператор</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> не может выделить 
  требуемую память, он присваивает вашей переменной-указателю значение NULL. В 
  зависимости от назначения вашей программы, вы, возможно, захотите, чтобы программа 
  выполнила определенные операции, если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не может удовлетворить запрос на память. Из этого урока вы узнаете, как заставить 
  C++ вызвать специальную функцию, если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не может удовлетворить запрос на память. К концу данного урока вы освоите следующие 
  основные концепции:</FONT></P>
<UL>
  <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">Вы можете создать свой 
    собственный обработчик ситуации, когда памяти недостаточно — функции, которую 
    C++ вызывает, если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new 
    не</I> может удовлетворить запрос на память.</FONT></LI>
  <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">C++ позволяет вам определить 
    собственный оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new 
    для</I> выделения и, возможно, инициализации памяти.</FONT></LI>
  <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">C++ позволяет вам определить 
    собственный оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete</I> 
    для освобождения памяти.</FONT></LI>
</UL>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">Как вы узнаете, с помощью 
  собственных операторов</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  и</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete</I> вы 
  можете лучше управлять ошибками при недостаточности памяти.</FONT></P>
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif">СОЗДАНИЕ ОБРАБОТЧИКА 
  ДЛЯ ОПЕРАЦИЙ СО СВОБОДНОЙ ПАМЯТЬЮ</FONT></H2>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, Times, serif" SIZE="3">Как вы 
  уже знаете из урока 31, если оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не может выделить требуемую память из свободной памяти, он присваивает значение 
  NULL вашей переменной-указателю. Следующая программа USE_FREE.CPP неоднократно 
  вызывает оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new,</I> 
  выделяя каждый раз 1000 байт, пока свободная память не исчерпается:</FONT></P>
<BLOCKQUOTE> 
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;iostream.h&gt;</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void main (void) </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char 
    *pointer;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;do 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer 
    = new char[1000];<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if 
    (pointer 1= NULL) </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">cout 
    &lt;&lt; "Выделено 1000 байт"</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3">&lt;&lt; 
    endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">cout &lt;&lt; "Свободной 
    памяти нет</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3">" &lt;&lt; 
    endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;} 
    while (pointer);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
</BLOCKQUOTE>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">Как видите, программа просто 
  выполняет цикл, пока</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не присвоит указателю значение NULL. Если вы хотите, чтобы</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  выполнил другие действия (что-нибудь отличное от тупого возвращения значения 
  NULL), когда он не может удовлетворить запрос на память, то сначала вам следует 
  определить функцию, которую должна вызывать ваша программа, если памяти недостаточно 
  для удовлетворения запроса. Например, следующая функция</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>end_pro-gram</I> 
  выводит на экран сообщение, а затем использует функцию библиотеки этапа выполнения</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>exit для</I> завершения 
  программы:</FONT></P>
<BLOCKQUOTE> 
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void end_program(void)</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;cout 
    &lt;&lt; "Запрос на память не может быть удовлетворен" </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&lt;&lt; 
    endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;exit(l);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
</BLOCKQUOTE>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">Чтобы заставить C++ вызывать 
  функцию</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>end_program,</I> 
  если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> не 
  может удовлетворить запрос на память, вам необходимо вызвать функцию <I>set_new_handler,</I> 
  указав ей функцию</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>end_program</I> 
  в качестве параметра, как показано ниже:</FONT></P>
<BLOCKQUOTE>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">set_new_handler(end_program);</FONT></P>
</BLOCKQUOTE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, Times, serif" SIZE="3">Следующая 
  программа END_FREE.CPP вызывает функцию</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>end_program, 
  </I>если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не может удовлетворить запрос на память:</FONT></P>
<BLOCKQUOTE> 
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;iostream.h&gt;</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;stdlib.h&gt; 
    // Прототип exit</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;new.h&gt; 
    // Прототип set_new_handler</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void end_program(void)</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;cout 
    &lt;&lt; "Запрос на память не может быть удовлетворен" &lt;&lt; endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;exit(l);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void main(void) </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char* 
    pointer;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;set_new_handler(end_program);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;do 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer 
    = new char[10000];<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout 
    &lt;&lt; "Выделено 10000 байт"</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3">&lt;&lt; 
    endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;} 
    while (1);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
</BLOCKQUOTE>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">В данном случае программа 
  просто завершается, если</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  не может выделить память из свободной памяти. В зависимости от потребностей 
  вашей программы вы могли бы использовать функцию для выделения памяти из другого 
  источника, например из расширенной памяти компьютера, которая существует в среде 
  MS-DOS. Кроме того, ваша программа могла бы освободить память распределенную 
  ею для других целей, чтобы сделать доступной свободную память. Обеспечивая вашим 
  программам возможность создавать обработчик ситуации отсутствия памяти, C++ 
  предоставляет вам полный контроль над процессом распределения памяти.</FONT></P>
<H2 ALIGN="CENTER"> <FONT FACE="Arial, Helvetica, sans-serif">СОЗДАНИЕ СОБСТВЕННЫХ 
  ОПЕРАТОРОВ <I>new</I> И <I>delete</I></FONT></H2>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, Times, serif" SIZE="3">Как вы 
  знаете, C++ позволяет вашим программам перегружать операторы. Аналогично вы 
  можете перегрузить операторы</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
  и</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete,</I> 
  чтобы изменить их поведение. Например, предположим, что вы выделяете 100 байт 
  памяти для хранения супер-секретных данных о вашей компании. Когда вы в дальнейшем 
  освобождаете эту память с помощью оператора</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete,</I> 
  освобождается буфер, который содержал эту память, т.е. те самые 100 байт, содержащие 
  супер-секретные данные о вашей компании. Предположим, корпоративный шпион (и 
  программист) имеет доступ к вашему компьютеру, его программа теоретически может 
  распределить тот же 100-байтный массив в памяти вашего компьютера и изучить 
  ваши супер-секреты. Перегружая</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3">оператор</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete,</I> ваша программа 
  может сначала заполнить этот буфер нулями или другими бессмысленными символами, 
  а потом освободить эту память. Следующая программа MYDELETE.CPP перегружает 
  оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete.</I> 
  Она сначала перезаписывает 100 байт, на которые указывает указатель, а затем 
  освобождает память, используя для этого функцию библиотеки этапа выполнения</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>free:</I></FONT></P>
<BLOCKQUOTE> 
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;iostream.h&gt; 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;stdlib.h&gt; 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;string.h&gt;</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">static void operator 
    delete(void *pointer) </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char 
    *data = (char *) pointer;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;int 
    i;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;for 
    (i = 0; i &lt; 100; i++) data[i] = 0;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;cout 
    &lt;&lt; "Секрет в безопасности!"</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3">&lt;&lt; 
    endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;free(pointer);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void main(void)</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char 
    *pointer = new char[100];<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;strcpy(pointer, 
    "Секреты моей компании");<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;delete 
    pointer;<BR>
    }</FONT></P>
</BLOCKQUOTE>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">При запуске программа выделяет 
  память для строкового массива с помощью оператора</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new.</I> 
  Затем она копирует секреты компании в эту строку. В дальнейшем программа использует 
  перегруженный оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete</I> 
  для освобождения памяти. Внутри функции</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete</I> 
  приведенный ниже оператор присваивает значение переменной</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>pointer</I> 
  указателю на символьную строку:</FONT></P>
<BLOCKQUOTE>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">char *data = (char *) 
    pointer;</FONT></P>
</BLOCKQUOTE>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, Times, serif" SIZE="3">Символы</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>(char *),</I> которые 
  называются <I>оператором приведения типов,</I> предназначены только для того, 
  чтобы сообщить компилятору C++, что функция знает, что она присваивает указатель 
  типа</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>void (см.</I> 
  выше параметры функции) указателю типа</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>char.</I> 
  Если вы опустите оператор приведения типов, программа не откомпилируется. Затем 
  функция копирует нули в 100 байт буфера и освобождает память, используя для 
  этого функцию библиотеки этапа выполнения <I>free.</I> Очень важно отметить, 
  что эта функция (оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>delete)</I> 
  работает только с областью памяти размером 100 байт. Поскольку данная программа 
  выделяет память только один раз, она работает корректно. Если вы измените программу 
  таким образом, чтобы выделялось только десять байт памяти и не сделаете подобных 
  изменений в этой функции, то она перезапишет 90 байт памяти, которые ваша программа, 
  возможно, использовала для других целей, приведя к ошибке. Однако, используя 
  функции библиотеки этапа выполнения, ваши программы могут получить больше информации 
  о размере области памяти, на которую указывает определенный указатель.</FONT></P>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman, Times, serif" SIZE="3">Подобным 
  образом следующая программа NEW_OVER.CPP перегружает оператор C++ <I>new.</I> 
  В данном случае перегруженная функция помещает символьную строку "Учимся программировать 
  на языке C++!" в начало выделяемой памяти:</FONT></P>
<BLOCKQUOTE> 
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;iostream.h&gt; 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;alloc.h&gt; 
    </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">#include &lt;string.h&gt;</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">static void *operator 
    new(size_t size) </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char 
    *pointer;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;pointer 
    = (char *) malloc(size);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;if 
    (size &gt; strlen( "Учимся программировать на языке C++!")) <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(pointer, "Учимся программировать 
    на языке &nbsp;&nbsp;&nbsp;C++!");<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;return(pointer);<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">void main(void) </FONT></P>
  <P><FONT FACE="Times New Roman, Times, serif" SIZE="3">{<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;char 
    *str = new char[100];<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">&nbsp;&nbsp;&nbsp;cout 
    &lt;&lt; str &lt;&lt; endl;<BR>
    </FONT><FONT FACE="Times New Roman, Times, serif" SIZE="3">}</FONT></P>
</BLOCKQUOTE>
<P><FONT FACE="Times New Roman, Times, serif" SIZE="3">Как видите, функция</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> использует для 
  выделения памяти функцию <I>malloc</I> библиотеки этапа выполнения. Если размер 
  выделяемой памяти достаточен для хранения строки "Учимся программировать на 
  языке C++!", данная функция использует функцию</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>strcpy</I> 
  библиотеки этапа выполнения для копирования строки в область памяти.</FONT></P>
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif">ЧТО ВАМ НЕОБХОДИМО 
  ЗНАТЬ</FONT></H2>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, Times, serif" SIZE="3">По мере 
  того как ваши программы становятся более сложными, вы будете выделять память 
  в процессе выполнения, используя оператор</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new.</I> 
  Из этого урока вы узнали, как изменить поведение оператора</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new,</I> 
  сначала определяя функцию-обработчик, которую вызывает ваша программа, если</FONT> 
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> не может удовлетворить 
  запрос на память, а затем с помощью перегрузки самого оператора</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new.</I> 
  Из урока 33 вы узнаете новые способы использования входного потока</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>cm</I> 
  и выходного потока <I>соut </I>для усовершенствования возможностей ввода и вывода 
  ваших программ. Прежде чем перейти к уроку 33, убедитесь, что вы изучили следующее:</FONT></P>
<OL>
  <OL>
    <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">Если оператор</FONT> 
      <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> не может 
      удовлетворить запрос на память, то по умолчанию он присваивает значение 
      NULL соответствующему указателю.</FONT></LI>
    <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">Если вашим программам 
      необходима другая обработка в том случае, когда</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
      не может удовлетворить запрос на память, ваши программы могут определить 
      свои собственные обработчики. Используя функцию <I>set_new_handler,</I> 
      программа может заставить</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
      вызвать вашу функцию, если невозможно удовлетворить запрос на память.</FONT></LI>
    <LI><FONT FACE="Times New Roman, Times, serif" SIZE="3">C++ позволяет вашим 
      программам перегружать операторы</FONT> <FONT FACE="Times New Roman, Times, serif" SIZE="3"><I>new</I> 
      и <I>delete.</I> Однако, прежде чем это сделать, вы должны иметь четкое 
      представление о свободной памяти (куче) и функциях библиотеки этапа выполнения, 
      которые ею манипулируют.</FONT></LI>
  </OL>
</OL>
<CENTER>
  <A HREF="Урок 31.html"><FONT FACE="Times New Roman, Times, serif" SIZE="3">Предыдущий 
  урок </FONT></A><FONT FACE="Times New Roman, Times, serif" SIZE="3">| <A HREF="Урок 33.html">Следующий 
  урок</A> </FONT> 
</CENTER>
</BODY>
</HTML>
