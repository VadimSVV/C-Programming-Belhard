<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Урок 10 Изменение значений параметров</TITLE>
</HEAD>
<BODY BACKGROUND="bgrwhite.gif">
<FONT FACE="Times New Roman"> </FONT> 
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif">Урок 10 </FONT></H2>
<H2 ALIGN="CENTER"><FONT FACE="Arial, Helvetica, sans-serif">Изменение значений 
  параметров</FONT></H2>
<P ALIGN="JUSTIFY"><FONT SIZE="3" FACE="Times New Roman">Из урока 9 вы узнали, 
  как разделить ваши программы на небольшие легко управляемые части, называемые 
  функциями. Как вы уже знаете, программы могут передавать информацию (параметры) 
  функциям. Представленные в уроке 9 программы использовали или выводили значения 
  параметров, но не меняли их. Из этого урока вы узнаете, как изменить значение 
  параметра в функции. Вы обнаружите, что для изменения параметров в функции фактически 
  требуется больше шагов, чем можно предположить. Однако этот урок обучит вас 
  всем шагам, которые необходимо знать. К концу данного урока вы освоите следующие 
  основные концепции:</FONT></P>
<FONT FACE="Times New Roman"> 
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">• Если функция не использует указатели или 
    ссылки,<B> она</B> не может изменить значение параметра.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">• Для изменения значения параметра функция 
    должна знать адрес параметра в памяти.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">• Оператор адреса C++ (&amp;) позволяет вашей 
    программе определить адрес переменной в памяти.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">• Когда ваша программа узнает адрес памяти, 
    она сможет использовать операцию разыменования C++ (*) для определения значения, 
    хранимого по данному адресу.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">• Если программе нужно изменить значение параметров 
    функции, программа передает в функцию адрес параметра.</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">Изменение значения параметра функции представляет 
    собой обычную операцию. Экспериментируйте с программами, представленными в 
    этом уроке, чтобы убедиться, что вы полностью освоили этот процесс.</FONT></P>
</DIR>
</FONT>
<H2 ALIGN="CENTER"><FONT FACE="Times New Roman"><I><FONT FACE="Arial, Helvetica, sans-serif">ПОЧЕМУ 
  ФУНКЦИИ ОБЫЧНО НЕ МОГУТ ИЗМЕНИТЬ ЗНАЧЕНИЯ ПАРАМЕТРОВ</FONT></I></FONT></H2>
<FONT FACE="Arial, Helvetica, sans-serif"></FONT><FONT FACE="Times New Roman"> 
<P ALIGN="JUSTIFY"><FONT SIZE="3">Следующая программа NOCHANGE.CPP передает два 
  параметра с именами <I>big</I> и <I>small</I> в функцию <I>display_values.</I> 
  Функция <I>display_values,</I> в свою очередь, присваивает обоим параметрам 
  число 1001 и затем выводит значение каждого параметра. Когда функция завершается, 
  программа возобновляется и выводит значения этих же параметров:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">#include &lt;iostream.h&gt;</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void display_values(int a, int b)</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">{</FONT> 
  <FONT SIZE="3">&nbsp;&nbsp;&nbsp;a = 1001;<BR>
  </FONT><FONT SIZE="3">&nbsp;&nbsp;&nbsp;b = 1001;<BR>
  </FONT><FONT SIZE="3">&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения в функции display_values 
  равны " &lt;&lt; а &lt;&lt; " и " &lt;&lt; b &lt;&lt; endl;</FONT><BR>
  <FONT SIZE="3">}</FONT> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void main(void)</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">{<BR>
    &nbsp;&nbsp;&nbsp;</FONT><FONT SIZE="3">int big = 2002, small = 0;<BR>
    </FONT><FONT SIZE="3">&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения до функции 
    " &lt;&lt; big &lt;&lt; " и" &lt;&lt; small &lt;&lt; endl;<BR>
    </FONT><FONT SIZE="3">&nbsp;&nbsp;&nbsp;display_values(big, small);<BR>
    </FONT><FONT SIZE="3">&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения после функции 
    " &lt;&lt; big &lt;&lt; " и " &lt;&lt; small &lt;&lt; endl;<BR>
    </FONT><FONT SIZE="3">}</FONT> 
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Когда вы откомпилируете и запустите эту программу, 
  на экране появится следующий вывод:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3"><B>С:\&gt; NOCHANGE &lt;ENTER&gt;</B></FONT></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3"> Значения до функции 2002 и 0</FONT></B></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3">Значения в функции display_values равны 
    1001&#9;и 1001</FONT></B></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3"> Значения после функции 2002 и 0</FONT></B></P>
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Как видите, значения параметров в функции <I>display_values</I> 
  были изменены (1001). Однако после завершения функции значения переменных <I>big</I> 
  и small в <I>main</I> остались прежними. Чтобы понять, почему изменение параметров 
  не повлияло на переменные <I>big</I> и <I>small</I> в <I>main,</I> вам необходимо 
  понять, как C++ передает параметры в функции.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Когда ваши программы передают параметр в функцию, 
  то по умолчанию С++ делает копию значения параметра и помещает эту копию во 
  временный участок памяти, называемый <I>стеком.</I> Затем функция использует 
  <I>копию</I> значения для выполнения своих операций. Когда функция завершается, 
  C++ сбрасывает содержимое стека и все изменения, сделанные функцией в копиях 
  эначений параметра.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Как вы знаете, переменная представляет собой 
  имя, присваиваемое вашей программой ячейке памяти, которая хранит значение определенного 
  типа. Предположим, например, что переменные <I>big</I> и <I>small</I> находятся 
  в ячейках памяти 10 и 12. Если вы передадите переменные в функцию <I>display_values,</I> 
  C++ поместит копии значений этих переменных в стек. На рис. 10.1 показано, что 
  далее функция <I>display_values</I> будет использовать копии значений переменных.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3"><IMG SRC="p10_1.gif" WIDTH=430 HEIGHT=250></FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3"><B>Рис. 10.1.</B> C++ размещает копии значений 
  параметров во временном участке памяти, называемом стеком.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Как видите, функция <I>display_values</I> может 
  обращаться к содержимому стека, в котором находятся копии значений 2002 и 0. 
  Так как функция <I>display_values</I> ничего не знает о ячейках памяти <I>big</I> 
  и <I>small</I> (адреса 10 и 12), функция не может изменить реальные значения 
  переменных.</FONT></P>
</FONT> 
<DIR></DIR>
<FONT FACE="Times New Roman"> 
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3"><B><I>Почему функции C++ обычно не могут изменить 
    значения параметров</I></B></FONT></P>
  <P ALIGN="JUSTIFY"><I><B><FONT SIZE="3">Когда вы передаете параметры в функцию, 
    C++ размещает копии значений параметров во временном участке памяти, называемом 
    стеком. Любые изменения, выполняемые функцией над параметрами, проявляются 
    только внутри стека. Когда функция завершается, C++ сбрасывает содержимое 
    стека вместе с любыми изменениями, которые функция произвела в параметрах. 
    Поскольку функция не знает адрес памяти параметра, она не может изменить его 
    значение.</FONT></B></I></P>
</DIR>
</FONT>
<H2 ALIGN="CENTER"><FONT FACE="Times New Roman"><I><FONT FACE="Arial, Helvetica, sans-serif">ИЗМЕНЕНИЕ 
  ЗНАЧЕНИЯ ПАРАМЕТРА</FONT></I></FONT></H2>
<FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY"><FONT SIZE="3">Для изменения значения параметра функция должна 
  знать адрес памяти параметра. Чтобы сообщить функции адрес параметра, ваши программы 
  должны использовать оператор адреса C++ (&amp;). Следующий вызов функции иллюстрирует, 
  как программа будет использовать оператор адреса для передачи адресов переменных 
  <I>big</I> и <I>small</I> в функцию <I>change_values:</I></FONT></P>
</FONT> 
<BLOCKQUOTE>
  <P><FONT FACE="Times New Roman"><FONT SIZE="3">change_values (<U>&amp;big, &amp;small</U>); 
    <I><B>--&gt;</B></I><B><I>Передача параметров по адресу</I></B></FONT></FONT></P>
</BLOCKQUOTE>
<FONT FACE="Times New Roman"> 
<P ALIGN="JUSTIFY"><FONT SIZE="3">Внутри функции вы должны сообщить C++ , что 
  программа будет передавать параметры с помощью адреса. Для этого вы объявляете 
  <I>переменные-указатели, </I>предваряя имя каждой переменной звездочкой, как 
  показано ниже:</FONT></P>
</FONT>
<BLOCKQUOTE>
  <P><FONT FACE="Times New Roman"><FONT SIZE="3">void сhange_values (<U>int. *big, 
    int. *small</U>)<B> <I>---&gt; Указатель на тип int</I></B></FONT></FONT></P>
</BLOCKQUOTE>
<FONT FACE="Times New Roman"> 
<P ALIGN="JUSTIFY"><FONT SIZE="3">Переменная-указатель представляет собой переменную, 
  которая содержит адрес памяти. Внутри функции вы должны сообщить C++ , что функция 
  работает с адресом параметра. Для этого вы предваряете имя параметра звездочкой, 
  как показано ниже:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">*big <SUP>=</SUP> <SUP>1001;<BR>
    </SUP>*small = 1001;</FONT></P>
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Следующая программа CHGPARAM.CPP использует 
  оператор адреса для передачи адресов параметров <I>big</I> и <I>small</I> в 
  функцию <I>change_values.</I> Функция, в свою очередь, использует указатели 
  участков памяти параметров. Следовательно, изменения параметров, сделанные функцией, 
  остаются и после завершения функции:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">#include &lt;iostream.h&gt;</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void change_values (int *a, int *b) </FONT></P>
  <P ALIGN="JUSTIFY"> {<BR>
    &nbsp;&nbsp;&nbsp;<FONT SIZE="3">*a = 1001;<BR>
    &nbsp;&nbsp;&nbsp;*b = 1001;<BR>
    </FONT>&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения в функции display_values" 
    &lt;&lt; " равны " &lt;&lt; *а &lt;&lt; " и " &lt;&lt; *b &lt;&lt; endl;<BR>
    <FONT SIZE="3">}</FONT> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void main(void) </FONT></P>
  <P ALIGN="JUSTIFY"> {<BR>
    &nbsp;&nbsp;&nbsp;<FONT SIZE="3">int big = 2002, small = 0;<BR>
    &nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения перед функцией " &lt;&lt; big &lt;&lt; 
    " и " &lt;&lt; small &lt;&lt; endl;<BR>
    &nbsp;&nbsp;&nbsp;change_values(&amp;big, &amp;small);<BR>
    </FONT>&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Значения после функции " &lt;&lt; 
    big &lt;&lt; " и " &lt;&lt; small &lt;&lt; endl;<BR>
    <FONT SIZE="3">}</FONT> 
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Когда вы откомпилируете и запустите эту программу, 
  на экране появится следующий вывод:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3"><B>C:\&gt; CHGPARAM &lt;ENTER&gt;</B></FONT></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3">Значения перед функцией 2002 и 0</FONT></B></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3">Значения в функции display_values равны 
    1001 и 1001</FONT></B></P>
  <P ALIGN="JUSTIFY"><B><FONT SIZE="3"> Значения после функции 1001 и 1001</FONT></B></P>
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Как видите, значения, которые функция <I>change_values</I> 
  присваивает параметрам, остаются и после завершения функции. Чтобы понять, почему 
  изменения, которые функция выполнила над переменными, остались после ее завершения, 
  необходимо вспомнить, что функция имеет доступ к ячейке памяти каждой переменной. 
  Если вы передаете параметры по адресу, C++ помещает адрес каждой переменной 
  в стек, как показано на рис. 10.2.</FONT></P>
<FONT SIZE="3"><IMG SRC="p10_2.gif" WIDTH=430 HEIGHT=250></FONT> 
<P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY"><FONT SIZE="3"><B>Рис. 10.2.</B> Передача параметров по адресу.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Используя указатели (адреса памяти) внутри функции, 
  <I>change_values</I> может обратиться к памяти по адресу каждого параметра, 
  изменяя значения параметров, что и требуется.</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3"><B><I>Изменение значений параметров в функциях</I></B></FONT></P>
  <P ALIGN="JUSTIFY"><I><B><FONT SIZE="3">Для изменения значения параметра в функции, 
    функция должна знать адрес параметра в памяти. Следовательно, ваша программа 
    должна передать адрес параметра с помощью оператора адреса C++ :</FONT></B></I></P>
  <BLOCKQUOTE> 
    <P><I><B><FONT SIZE="3">some_function(&amp;some_variable);</FONT></B></I></P>
  </BLOCKQUOTE>
  <P ALIGN="JUSTIFY"><I><B><FONT SIZE="3">Внутри функции вы должны сообщить C++ 
    , что функция будет работать с адресом памяти (указателем). Для этого при 
    объявлении вы предваряете имя параметра звездочкой:</FONT></B></I></P>
  <BLOCKQUOTE> 
    <P><I><B><FONT SIZE="3">void some_function(int *some_variable);</FONT></B></I></P>
  </BLOCKQUOTE>
  <P ALIGN="JUSTIFY"><I><B><FONT SIZE="3">Далее внутри функции вы должны употреблять 
    звездочку перед именем переменной:</FONT></B></I></P>
  <BLOCKQUOTE> 
    <P><I><B><FONT SIZE="3">*some_variable = 1001;<BR>
      cout &lt;&lt; *some_variable;</FONT></B></I></P>
  </BLOCKQUOTE>
  <P ALIGN="JUSTIFY"><I><B><FONT SIZE="3">Во избежание ошибок C++ не позволит 
    вашей программе передать адрес переменной в функцию, которая не ожидает указатль 
    в качестве параметра. Кроме того, C++ обычно генерирует предупреждение компилятора, 
    когда ваша программа пытается передать значение в функцию, которая ожидает 
    указатель в качестве параметра.</FONT></B></I></P>
</DIR>
</FONT>
<H3 ALIGN="JUSTIFY"><FONT FACE="Times New Roman"><I><B><FONT FACE="Arial, Helvetica, sans-serif">Второй 
  пример</FONT></B></I></FONT></H3>
<FONT FACE="Times New Roman"> 
<P ALIGN="JUSTIFY"><FONT SIZE="3">Если ваша программа передает указатели на параметры, 
  параметры могут быгь любого типа, например int, float или char. Функция, которая 
  использует указатели, объявляет переменные соответствующего типа, предваряя 
  имя каждой переменной звездочкой, подтверждающей, что такая переменная является 
  указателем. Следующая программа SWAPVALS.CPP передает адреса двух параметров 
  <I>типа float</I> в функцию <I>swap_values.</I> Функция в свою очередь использует 
  указатели на каждый параметр, чтобы обменять значения параметров:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">#include &lt;iostream.h&gt;</FONT></P>
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void swap_values(float *a, float *b) </FONT></P>
  <P ALIGN="JUSTIFY"> {<BR>
    &nbsp;&nbsp;&nbsp;<FONT SIZE="3">float temp;<BR>
    &nbsp;&nbsp;&nbsp;temp =<B> *a;<BR>
    </B>&nbsp;&nbsp;&nbsp;*a = *b;<BR>
    </FONT>&nbsp;&nbsp;&nbsp;*b = temp;<BR>
    <FONT SIZE="3">}</FONT> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">void main(void) </FONT></P>
  <P ALIGN="JUSTIFY"> {<BR>
    &nbsp;&nbsp;&nbsp;<FONT SIZE="3">float big = 10000.0;<BR>
    &nbsp;&nbsp;&nbsp;float small = 0.00001;<BR>
    &nbsp;&nbsp;&nbsp;swap_values(&amp;big, &amp;small);<BR>
    &nbsp;&nbsp;&nbsp;cout &lt;&lt; "Big содержит " &lt;&lt; big &lt;&lt; endl;<BR>
    </FONT>&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Small содержит " &lt;&lt; small &lt;&lt; 
    endl;<BR>
    <FONT SIZE="3">}</FONT> 
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Как видите, программа передает параметры в функцию 
  <I>swap_values</I> по адресу. Внутри функции программа использует указатели 
  на ячейки памяти параметров. Давайте более внимательно посмотрим на действия 
  внутри функции swap_va<I>lues.</I> Как видите, функция объявляет <I>а</I> и 
  <I>b</I> как указатели на значения типа float: </FONT></P>
</FONT>
<BLOCKQUOTE>
  <P><FONT FACE="Times New Roman"><FONT SIZE="3">void swap_values(float *a, float 
    *b) </FONT></FONT></P>
</BLOCKQUOTE>
<FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY"><FONT SIZE="3">Однако функция объявляет переменную <I>temp</I> 
  просто <I>как float, а</I> не как указатель <I>на float. </I>float temp;</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Рассмотрим следующий оператор:</FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">temp = *а;</FONT></P>
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Этот оператор побуждает C++ присвоить переменной 
  <I>temp</I> значение указываемое переменной <I>а</I> (т. е. значение переменной 
  <I>big,</I> равное 10000.0). Поскольку <I>temp</I> имеет тип <I>float,</I> присваивание 
  корректно. Переменная-указатель представляет собой переменную, которая хранит 
  адрес. Следующий оператор объявляет <I>temp</I> как указатель на ячейку памяти, 
  содержащую значение <I>типа float.</I></FONT></P>
<DIR> 
  <P ALIGN="JUSTIFY"><FONT SIZE="3">float *temp;</FONT></P>
</DIR>
<P ALIGN="JUSTIFY"><FONT SIZE="3">В данном случае <I>temp</I> может хранить адрес 
  значения с плавающей точкой но не само значение.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Если вы удалите оператор разыменования (*), 
  стоящий перед переменной <I>а</I> внутри присваивания, то оператор будет пытаться 
  присвоить значение, хранимое в <I>а</I> (которое является адресом), переменной 
  <I>temp.</I> Поскольку <I>temp </I>может содержать значение с плавающей точкой, 
  но не адрес значения с плавающей точкой, возникнет ошибка.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Не беспокойтесь, если вы не можете свободно 
  обращаться с указателями, вы будете изучать их более подробно в части 3. На 
  настоящий момент, однако, просто поймите, что, если хотите изменить в ваших 
  функциях значения параметров, вы должны использовать указатели.</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Использование ассемблерных листингов для лучшего 
  понимания работы компилятора</FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Лучшим способом понять, как компилятор C++ трактует 
  указатели, является исследование ассемблерного вывода компилятора. Большинство 
  компиляторов C++ обеспечивают ключ командной строки, который вы можете использовать, 
  чтобы указать компилятору выводить ассемблерный листинг. Читая ассемблерный 
  листинг, вы можете лучше понять, как компилятор использует стек, когда передает 
  параметры в функцию.</FONT></P>
</FONT> 
<H2 ALIGN="CENTER"><FONT FACE="Times New Roman"><I><FONT FACE="Arial, Helvetica, sans-serif">ЧТО 
  ВАМ НЕОБХОДИМО ЗНАТЬ</FONT></I></FONT></H2>
<FONT FACE="Times New Roman"> 
<P ALIGN="JUSTIFY"><FONT SIZE="3">Из данного урока вы узнали, как изменить значение 
  параметра внутри <I>фун</I>кции. Для этого ваши функции должны использовать 
  указатели. Сначала вы можете найти указатели слишком сложными. Из урока 14 вы 
  узнаете, как использовать ссылки C++ , которые упрощают процесс изменения параметров 
  внутри функции. Однако, поскольку многие программисты С используют указатели 
  для изменения параметров, вам необходимо знать и такой вариант программирования. 
  </FONT></P>
<P ALIGN="JUSTIFY"><FONT SIZE="3">Из урока 11 вы выясните, как функции библиотеки 
  этапа выполнения, обеспечиваемые компилятором C++ , могут ускорить программирование, 
  позволяя быстро разрабатывать сложные программы. Однако до изучения урока 11 
  убедитесь, что вы освоили следующие основные Концепции:</FONT></P>
</FONT> 
<OL>
  <OL>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Пока вы не используете указатели 
      или ссылки C++ , функция не может изменить значение параметра.</FONT></FONT></LI>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Когда ваша программа передает 
      параметр в функцию, C++ помещает копию значения параметра во временный участок 
      памяти, называемый стеком. Любые изменения, которые функция осуществляет 
      над параметром, влияют только на эту копию, расположенную в стеке.</FONT></FONT></LI>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Для изменения значения параметра 
      функция должна знать адрес соответствующей переменной.</FONT></FONT></LI>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Используя оператор адреса 
      C++ (&amp;), ваши программы могут передать адрес переменной в функцию.</FONT></FONT></LI>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Когда функция получает адрес 
      переменной, она должна объявить переменную параметра как указатель (предваряя 
      имя переменной звездочкой).</FONT></FONT></LI>
    <LI><FONT FACE="Times New Roman"><FONT SIZE="3">Если функции требуется использовать 
      значение, на которое ссылаются (указывают) по указателю, функция должна 
      предварять имя переменной-указателя звездочкой, т. е. оператором разыменования 
      C++.</FONT> </FONT></LI>
  </OL>
</OL>
<CENTER>
  <FONT FACE="Times New Roman, Times, serif" SIZE="3"><A HREF="Урок 09.html">Предыдущий 
  урок</A> | <A HREF="Урок 11.html">Следующий урок </A></FONT> 
</CENTER>
</BODY>
</HTML>
