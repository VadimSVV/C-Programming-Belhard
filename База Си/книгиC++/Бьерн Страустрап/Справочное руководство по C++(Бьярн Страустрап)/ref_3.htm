<html><head>
<title>Объекты и LVALUE(адреса). Справочное руководство по C++</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<a name=5></a>
<h3>5.  Объекты и LVALUE(адреса) </h3>
<p align=justify>Объект  есть   область  памяти; lvalue   (адрес)  есть  выражение,
ссылающееся   на объект. Очевидный пример адресного выражения - имя
объекта. Есть операции, дающие адресные выражения: например, если Е
- выражение типа указатель, то *Е - адресное выражение, ссылающееся
на объект,  на который  указывает Е.  Термин "lvalue" происходит из
выражения присваивания  Е1=Е2, в  котором левый  операнд Е1  должен
быть адресным  (value) выражением.  Ниже при    обсуждении  каждого
оператора  указывается,   требует     ли  он  адресные  операнды  и
возвращает ли он адресное значение.
<a name=6></a>
<h3>6.  Преобразования</h3>
<p align=justify>Определенные  операции   могут  в  зависимости  от  их  операндов
вызывать преобразование значения операнда от одного типа к другому.
В  этой   части  объясняется,   каков  ожидаемый   результат  таких
преобразований. В  <a href=ref_3.htm#6_6>#6.6</a> содержится краткое описание преобразований,
требуемых наиболее  стандартными операциями;  оно будет дополняться
по мере  надобности в процессе обсуждения каждой операции. В <a href=ref_5.htm#8_5_6>#8.5.6</a>
описываются преобразования, определяемые пользователем.
<a name=6_1></a>
<h4>6.1 Символы и целые</h4>
<p align=justify>Символ  или  короткое  целое  могут  использоваться,  если  может
использоваться целое.  Во всех  случаях  значение  преобразуется  к
целому. Преобразование  короткого целого к длинному всегда включает
в себя  знаковое расширение;  целые являются  величинами со знаком.
Содержат  символы   знаковый  разряд   или  нет,  является  машинно-зависимым; см.  <a href=ref_1.htm#2_6>#2.6</a>. Более  явный тип   unsigned char ограничивает
изменение значения от 0 до машинно-зависимого максимума.
<p align=justify>В  машинах,   где  символы   рассматриваются  как   имеющие  знак
(знаковые), символы  множества кода ASCII  являются положительными.
Однако,   символьная    константа,   заданная   восьмеричной   esc-
последовательностью подвергается знаковому расширению и может стать
отрицательным числом; так например, '\377' имеет значение -1.
<p align=justify>Когда длинное  целое преобразуется  в короткое  или в  char,  оно
урезается влево; избыточные биты просто теряются.
<a name=6_2></a>
<h4>6.2 Float и doublе</h4>
<p align=justify>Для выражений  float  могут  выполняться  действия  арифметики  с
плавающей точкой  одинарной точности.  Преобразования между числами
одинарной и  двойной точности  выполняются настолько  математически
корректно, насколько позволяет аппаратура.
<a name=6_3></a>
<h4>6.3 Плавающие и целые</h4>
<p align=justify>Преобразования  плавающих   значений  в  интегральный  тип  имеет
склонность  быть   машинно-зависимым.   В  частности,  направление
усечения отрицательных  чисел различается  от машины к машине. Если
предоставляемого пространства для значения не хватает, то результат
не определен.
<p align=justify>Преобразование интегрального значения в плавающий тип выполняются
хорошо.  При   нехватке  в   аппаратной  реализации  требуемых  бит
возникает некоторая потеря точности.
<a name=6_4></a>
<h4>6.4 Указатели и целые</h4>
<p align=justify>Выражение целого  типа можно прибавить к указателю или вычесть из
него; в  таком случае  первый преобразуется,  как  указывается  при
обсуждении операции сложения.
<p align=justify>Можно производить  вычитание над  двумя  указателями  на  объекты
одного типа;  в этом  случае результат преобразуется к типу int или
long в зависимости от машины; см. <a href=ref_4.htm#7_4>#7.4</a>.
<a name=6_5></a>
<h4>6.5 Unsigned</h4>
<p align=justify>Всегда при  сочетании целого  без знака и обычного целого обычное
целое  преобразуется  к  типу  unsigned    и  результат  имеет  тип
unsigned. Значением  является наименьшее  целое без  знака,  равное
целому со знаком (mod 2**(размер слова)) (т.е. по модулю 2**(размер
слова)). В дополнительном двоичном представлении это преобразование
является  пустым,   и  никаких   реальных  изменений   в   двоичном
представлении не происходит.
<p align=justify>При преобразовании целого без знака в длинное значение результата
численно совпадает  со значением   целого без знака. Таким образом,
преобразование сводится к дополнению нулями слева.
<a name=6_6></a>
<h4>6.6 Арифметические преобразования</h4>
<p align=justify>Большое количество  операций вызывают  преобразования и  дают тип
результата одинаковым  образом.  Этот  стереотип  будет  называться
"обычным арифметическим преобразованием".
<p align=justify>Во-первых, любые операнды типа char, unsigned char или short
  преобразуются к типу int.
<p align=justify>Далее, если один из операндов имеет тип double, то другой
  преобразуется к типу double и тот же тип имеет результат.
<p align=justify>Иначе, если один из операндов имеет тип unsigned long, то другой
  преобразуется к типу unsigned long и таков же тип результата.
<p align=justify>Иначе, если один из операндов имеет тип long, то другой
  преобразуется к типу long и таков же тип результата.
<p align=justify>Иначе, если один из операндов имеет тип unsigned, то другой
  преобразуется к типу unsigned и таков же тип результата.
<p align=justify>Иначе оба операнда должны иметь тип int и таков же тип
  результата.
<a name=6_7></a>
<h4>6.7 Преобразования указателей</h4>
<p align=justify>Везде,    где    указатели    присваиваются,    инициализируются,
сравниваются и т.д. могут выполняться следующие преобразования.
<p align=justify>Константа 0 может преобразовываться в указатель, и гарантируется,
  что это значение породит указатель, отличный от указателя на
  любой объект.
<p align=justify>Указатель любого типа может преобразовываться в void*.
<p align=justify>Указатель на класс может преобразовываться в указатель на
  открытый базовый класс этого класса; см. <a href=ref_5.htm#8_5_3>#8.5.3</a>.
<p align=justify>Имя вектора может преобразовываться в указатель на его первый
  элемент.
<p align=justify>Идентификатор, описанный как "функция, возвращающая ...", всегда,
  когда он не используется в позиции имени функции в вызове,
  преобразуется в "указатель на функцию, возвращающую ...".
<a name=6_8></a>
<h4>6.8 Преобразования ссылок</h4>
<p align=justify>Везде, где  инициализируются ссылки, может выполняться следующее преобразование.
<p align=justify>Ссылка на класс может преобразовываться в ссылку на открытый
  базовый класс этого класса; см. <a href=ref_5.htm#8_6_3>#8.6.3</a>.
<p><center><p>
<font size=-1>
<a href="ref_2.htm">Назад</a> | <a href="index.htm">Содержание</a> | <a href="ref_4.htm">Вперед</a></font></center></p>
<br>
<div align="center"><a href="http://www.linkexchange.ru/users/000729/goto.map" target="_blank"><img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?729?28340234" alt="Russian LinkExchange Advertising Network" border=0 height=60 width=468 vspace=0></a></div>
</body></html>
