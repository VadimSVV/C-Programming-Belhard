<html><head>
<title>Свободная память. Справочное руководство по C++</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<a name=17></a>
<h3> 17. Свободная память </h3>
<p align=justify>Операция new (<a href=ref_4.htm#7_2>#7.2</a>) вызывает функцию
<pre>
	extern void* _new (long);
</pre>
для получения  памяти.  Параметр  задает  число  требуемых  байтов.
Память будет  инициализирована. Если  _new не может найти требуемое
количество памяти, то она возвращает ноль.
<p align=justify>Операция delete вызывает функцию
<pre>
	 extern void _delete (void*);
</pre>
чтобы  освободить  память,  указанную  указателем,  для  повторного
использования. Результат  вызова _delete()   для указателя, который
не был  получен из  _new(),  не определен,  это  же  относится  и  к
повторному вызову  _delete() для одного и того же указателя. Однако
уничтожение с помощью delete указателя со значением ноль безвредно.
<p align=justify>Предоставляются  стандартные   версии  _new()   и  _delete(),  но
пользователь  может   применять  другие,   более   подходящие   для
конкретных приложений.
<p align=justify>Когда с  помощью операции  new создается классовый объект, то для
получения   необходимой    памяти   конструктор    будет   (неявно)
использовать new.  Конструктор может  осуществить свое  собственное
резервирование памяти  посредством присваивания  указателю this  до
каких-либо использований. С помощью присваивания this значения ноль
деструктор может  избежать  стандартной  операции  дерезервирования
памяти для объекта его класса. Например:
<pre>
	class cl
	  {
	    int v[10];
	    cl () { this = my_own_allocator (sizeof (cl)); }
	    ~cl () { my_own_deallocator (this); this = 0; }
	  }
</pre>
<p align=justify>На  входе   в   конструктор   this   является   не-нулем,   если
резервирование памяти  уже имело  место (как  это имеет  место  для
автоматических объектов), и нулем в остальных случаях.
<p align=justify>Если производный  класс осуществляет  присваивание this, то вызов
конструктора (если он есть) базового класса будет иметь место после
присваивания, так  что конструктор  базового  класса  ссылаться  на
объект   посредством   конструктора   производного   класса.   Если
конструктор базового  класса  осуществляет  присваивание  this,  то
значение также  будет использоваться  конструктором  (если  таковой
есть)  производного класса.
<a name=18></a>
<h3> 18. Краткое изложение синтаксиса </h3>
<p align=justify>Мы надеемся,  что эта  краткая сводка  синтаксиса    C++  поможет
пониманию. Она не является точным изложением языка.
<a name=18_1></a>
<h4>18.1 Выражения</h4>
<pre>
	   выражение:
	     терм
	     выражение           бинарная_операция           выражение
	     выражение       ?       выражение       :       выражение
	     список_выражений
	терм:
	     первичный
	     *                                                    терм
	     &                                                    терм
	     -                                                    терм
	     !                                                    терм
	     ~                                                    терм
	     ++терм
	     --терм
	     терм++
	     терм--
	     (                   имя_типа)                   выражение
	     имя_простого_типа           (           список_выражений)
	     sizeof                                          выражение
	     sizeof             (              имя_типа              )
	     new                                              имя_типа
	     new ( имя_типа )
	первичный:
	     id
	     ::                                          идентификатор
	     константа
	     строка
	     this
	     (                       выражение                       )
	     первичный[                  выражение                   ]
	     первичный      (       список_выражений       opt       )
	     первичный.id
	     первичный->id
	id:
	     идентификатор
	     typedef-имя :: идентификатор
	список_выражений:
	     выражение
	     список_выражений, выражение
	операция:
	     унарная_операция
	     бинарная_операция
	     специальная_операция
</pre>
  Бинарные операции имеют приоритет, убывающий в указанном порядке:
<pre>
	бинарная_операция:
	     *                          /                            %
	     +                                                       -
	     &lt;&lt;                                                     >>
	     &lt;                                                       >
	     ==                                                     !=
	     &
	     ^
	     |
	     &&
	     ||
	     =   +=  -=  *=  /=  %=  ^=  &=  |=  >>=  <<=
	унарная_операция:
	      *   &   -   ~   !   ++   --
	специальная_операция:
	     ()       []
	имя_типа:
	     спецификаторы_описания абстрактный_описатель
	абстрактный_описатель:
	     пустой
	     *                                   абстрактный_описатель
	     абстрактный_описатель  (   список_описаний_параметров   )
	     абстрактный_описатель  [   константное_выражение  opt   ]
	     ( абстрактный_описатель )
	простое_имя_типа:
	     typedef-имя
	     char
	     short
	     int
	     long
	     unsigned
	     float
	     double
	typedef-имя:
	     идентификатор
</pre>
<a name=18_2></a>
<h4>18.2 Описания</h4>
<pre>
	описание:
	     спецификаторы_описания  opt   список_описателей   opt   ;
	     описание_имени
	     asm-описание
	описание_имени:
	     агрег                   идентификатор                   ;
	     enum  идентификатор ;
	агрег:
	     class
	     struct
	     union
	asm-описание:
	     asm ( строка );
	спецификаторы_описания:
	     спецификатор_описания спецификатор_описания opt
	спецификатор_описания:
	     имя_простого_типа
	     спецификатор_класса
	     enum_спецификатор
	     sc_спецификатор
	     фнк_спецификатор
	     typedef
	     friend
	     const
	     void
	sc_спецификатор:
	     auto
	     extern
	     register
	     static
	фнк-спецификатор:
	     inline
	     overload
	     virtual
	список_описателей:
	     иниц-описатель
	     иниц-описатель , список_описателей
	иниц-описатель:
	     описатель инициализатор opt
	описатель:
	     оп_имя
	     (                       описатель                       )
	     *             const             opt             описатель
	     &             const             opt             описатель
	     описатель      (       список_описаний_параметров       )
	     описатель [ константное_выражение opt ]
	оп_имя:
	     простое_оп_имя
	     typedef-имя . простое_оп_имя
	простое_оп_имя:
	     идентификатор
	     typedef-имя
	     -                                             typedef-имя
	     имя_функции_операции
	имя_функции_операции:
	     операция операция
	список_описаний_параметров:
	     список_описаний_прм opt ... opt
	список_описаний_прм                                          :
	     список_описаний_прм         ,          описание_параметра
	     описание_параметра
	описание_параметра:
	     спецификаторы_описания                          описатель
	     спецификаторы_описания описатель = константное_выражение
	спецификатор_класса:
	     заголовок_класса       {список_членов        opt        }
	     заголовок_класса    {список_членов     opt    public    :
	список_членов opt }
	заголовок_класса                                             :
	     агрег                  идентификатор                  opt
	     агрег идентификатор opt : public opt typedef-имя
	список_членов                                                :
	     описание_члена список_членов opt
	описание_члена:
	     спецификаторы_описания opt описатель_члена ;
	описатель_члена:
	     описатель
	     идентификатор opt : константное_выражение
	инициализатор:
	     =                                               выражение
	     =                {                список_инициализаторов}
	     =       {        список_инициализаторов,                }
	     (список_выражений )
	список_инициализаторов                                       :
	     выражение
	     список_инициализаторов        ,    список_инициализаторов
	     { список_инициализаторов }
	enum-спецификатор:
	     enum идентификатор opt { enum-список }
	enum-список:
	     перечислитель
	     enum-список , перечислитель
	перечислитель:
	     идентификатор
	     идентификатор = константное_выражение
</pre>
<a name=18_3></a>
<h4>18.3 Операторы</h4>
<pre>
	составной_оператор:
	     { список_описаний opt список_операторов opt }
	список_описаний:
	     описание
	     описание список_описаний
	список_операторов:
	     оператор
	     оператор список_операторов
	оператор:
	     выражение                                               ;
	     if         (         выражение         )         оператор
	     if    (    выражение    )    оператор    else    оператор
	     while        (         выражение        )        оператор
	     do     оператор     while     (     выражение     )     ;
	     for (  выражение opt  ; выражение  opt ;  выражение opt )
	          оператор
	     switch        (        выражение        )        оператор
	     case      константное      выражение      :      оператор
	     default                    :                     оператор
	     break;
	     continue;
	     return            выражение             opt             ;
	     goto                   идентификатор                    ;
	     идентификатор                 :                  оператор
	     delete                    выражение                     ;
	     asm           (            строка           )           ;
	     ;
</pre>
<a name=18_4></a>
<h4>18.4 Внешние определения</h4>
<pre>
	программа:
	     внешнее_определение
	     внешнее_определение программа
	внешнее_определение:
	     определение_функции
	     описание
	определение_функции:
	     спецификаторы_описания       opt        описатель_функции
	инициализатор_базового_класса opt тело_функции
	описатель_функции:
	     описатель ( список_описаний_параметров)
	тело_функции:
	     составной_оператор
	инициализатор_базового_класса:
	     : ( список_параметров opt )
</pre>
<a name=18_5></a>
<h4>18.5 Препроцессор</h4>
<pre>
	#define идент строка_символов
	#define идент( идент,...,идент ) строка символов
	#else
	#endif
	#if выражение
	#ifdef идент
	#ifndef идент
	#include "имя_файла"
	#include <имя_файла>
	#line константа "имя_файла"
	#undef идент
</pre>
<a name=19></a>
<h3> 19. Отличия от "старого C" </h3>
<a name=19_1></a>
<h4>19.1 Расширения</h4>
<p align=justify>Типы  параметров   функции  могут  быть  заданы  (<a href=ref_5.htm#8_4>#8.4</a>)  и  будут
проверяться (<a href=ref_4.htm#7_1>#7.1</a>). Могут выполняться преобразования типов.
<p align=justify>Для выражений  с числами  с плавающей точкой может использоваться
плавающая арифметика одинарной точности; <a href=ref_3.htm#6_2>#6.2</a>.
<p align=justify>Имена функций могут быть перегружены; <a href=ref_5.htm#8_6>#8.6</a>
<p align=justify>Операции могут быть перегружены; <a href=ref_4.htm#7_16>#7.16</a>, <a href=ref_5.htm#8_5_10>#8.5.10</a>.
<p align=justify>Может осуществляться inline-подстановка функций; <a href=ref_5.htm#8_1>#8.1</a>.
<p align=justify>Объекты данных могут быть константными (const); <a href=ref_5.htm#8_3>#8.3</a>.
<p align=justify>Могут быть описаны объекты ссылочного типа; <a href=ref_5.htm#8_3>#8.3</a>, <a href=ref_5.htm#8_6_3>#8.6.3</a>
<p align=justify>Операции new  и delete  обеспечивают свободное хранение в памяти;
<a href=ref_9.htm#17>#17</a>.
<p align=justify>Класс может обеспечивать скрытые данные (<a href=ref_5.htm#8_5_8>#8.5.8</a>), гарантированную
инициализацию (<a href=ref_5.htm#8_6_2>#8.6.2</a>),  определяемые  пользователем  преобразования
(<a href=ref_5.htm#8_5_6>#8.5.6</a>),  и   динамическое  задание   типов  через   использование
виртуальных функций (<a href=ref_5.htm#8_5_4>#8.5.4</a>).
<p align=justify>Имя класса является именем типа; <a href=ref_5.htm#8_5>#8.5</a>.
<p align=justify>Любой  указатель   может  присваиваться   [указателю]  void*  без
приведения типов; <a href=ref_4.htm#7_14>#7.14</a>.
<p><center><p>
<font size=-1>
<a href="ref_8.htm">Назад</a> | <a href="index.htm">Содержание</a></font></center></p>
<br>
<div align="center"><a href="http://www.linkexchange.ru/users/000729/goto.map" target="_blank"><img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?729?29340234" alt="Russian LinkExchange Advertising Network" border=0 height=60 width=468 vspace=0></a></div>
</body></html>
