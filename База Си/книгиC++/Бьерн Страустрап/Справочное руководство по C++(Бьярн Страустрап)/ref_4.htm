<html><head>
<title>Выражения. Справочное руководство по C++</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<a name=7></a>
<h3> 7. Выражения</h3>
<p align=justify>Приоритет операций  в выражениях  такой же,  как и порядок главных
подразделов в  этом разделе,  наибольший приоритет  у первого.  Так
например, выражения,  о которых говорится как об операндах операции
+ (<a href=ref_4.htm#7_4>#7.4</a>)  - это  те выражения,  которые определены  в    #<a href=ref_4.htm#7_1>#7.1</a>-7.4.
Внутри каждого  подраздела операции  имеют одинаковый  приоритет. В
каждом подразделе  для рассматриваемых в нем операций  определяется
их левая  или правая ассоциативность (порядок обработки операндов).
Приоритет и  ассоциативность всех операций собран вместе в описании
грамматики в <a href=ref_8.htm#14>#14</a> .
<p align=justify>В остальных  случаях порядок  вычисления  выражения  не определен.
Точнее, компилятор  волен вычислять  подвыражения  в  том  порядке,
который он  считает более  эффективным,  даже  если    подвыражения
вызывают побочные  эффекты. Порядок возникновения побочных эффектов
не определен.  Выражения,   включающие  в   себя   коммутативные   и
ассоциативные операции (*, +,  &, |, ^), могут быть реорганизованы
произвольным  образом,   даже  при   наличии  скобок;  для  задания
определенного порядка  вычисления выражения необходимо использовать
явную временную переменную.
<p align=justify>Обработка  переполнения   и  контроль   деления  при   вычислении
выражения машинно-зависимы. В  большинстве существующих реализаций
C++ переполнение целого игнорируется; обработка деления на 0 и всех
исключительных ситуаций с числами с плавающей точкой различаются от
машины  к   машине  и  обычно  могут  регулироваться  библиотечными
функциями.
<p align=justify>Кроме стандартного  значения, описанного  в  <a href=ref_4.htm#7_2>#7.2</a>-7.15,  операции
могут быть перегружены<a href=#prim><sup>*</sup></a>, то есть, могут быть заданы их значения для
случая их  применения к   типам,  определяемым  пользователем;  см.
<a href=ref_4.htm#7_1_6>#7.1.6</a>.
<a name=7_1></a>
<h4>7.1 Основные выражения</h4>
<p align=justify>Основные выражения, включающие в себя . , -> ,   индексирование и вызовы функций, группируются слева направо.
<pre>
	список_выражений:
	     выражение
	     список_выражений , выражение
	id:
	     идентификатор
	     имя_функции_операции
	     typedef-имя               ::                идентификатор
	     typedef-имя :: имя_функции_операции
	первичное_выражение:
	     id
	     ::                                          идентификатор
	     константа
	     строка
	     this
	     (                       выражение                       )
	     первичное_выражение                [      выражение     ]
	     первичное_выражение        (   список_выражений   opt   )
	     первичное_выражение                     .              id
	     первичное_выражение   -> id
</pre>
<p align=justify>Идентификатор есть  первичное  выражение,  причем  соответственно
описанное  (<a href=ref_5.htm#8>#8</a>).   Имя_функции_операции   есть   идентификатор   со
специальным значением; см. <a href=ref_4.htm#7_1_6>#7.1.6</a> и <a href=ref_5.htm#8_5_1>#8.5.1</a>.
<p align=justify>Операция ::, за которой следует идентификатор из файловой области
видимости, есть то же, что и идентификатор. Это позволяет ссылаться
на объект даже в том случае, когда его идентификатор скрыт (<a href=ref_2.htm#4_1>#4.1</a>).
<p align=justify>Typedef-имя (<a href=ref_5.htm#8_8>#8.8</a>)  , за  которым следует  ::, после чего следует
идентификатор, является  первичным выражением.  Typedef-имя  должно
обозначать класс  (<a href=ref_5.htm#8_5>#8.5</a>), и  идентификатор должен  обозначать  член
этого класса.  Его тип  специфицируется  описанием  идентификатора.
Typedef-имя может  быть скрыто  именем, которое  не является именем
типа. В  этом случае typedef-имя все равно может быть найдено и его
можно использовать.
<p align=justify>Константа является  первичным выражением. Ее тип должен быть int, long или double в зависимости от ее формы.
<p align=justify>Строка является первичным выражением. Ее тип - "массив символов". Обычно он  сразу же  преобразуется в  указатель на ее первый символ
(<a href=ref_3.htm#6_7>#6.7</a>).
<p align=justify>Ключевое слово this  является локальной переменной в теле функции члена (см.  <a href=ref_5.htm#8_5>#8.5</a>) . Оно является указателем на объект, для которого
функция была вызвана.
<p align=justify>Выражение,  заключенное  в  круглые  скобки,  является  первичным выражением, чей  тип и  значение те  же, что  и у  незаключенного в
скобки  выражения.   Наличие  скобок  не  влияет  на  то,  является
выражение lvalue или нет.
<p align=justify>Первичное выражение,  за которым  следует выражение  в квадратных
скобках, является первичным выражением. Интуитивный смысл - индекс.
Обычно  первичное   выражение  имеет   тип  "указатель   на   ...",
индексирующее выражение  имеет тип int и тип результата есть "...".
Выражение Е1[Е2] идентично (по определению) выражению *((E1)+(E2)).
Все тонкие места, необходимые для понимания этой записи, содержатся
в этом  разделе вместе  с  обсуждением  в  ##  7.1,    7.2  и  7.4,
соответственно, идентификаторов, * и + ; ниже,  в <a href=ref_5.htm#8_4_2>#8.4.2</a> приводятся
следствия из этого.
<p align=justify>Вызов функции  является первичным  выражением, за которым следуют
скобки, содержащие  список (возможно,  пустой) разделенных запятыми
выражений,  составляющих   фактические   параметры   для   функции.
Первичное выражение  должно иметь  тип "функция,  возвращающая ..."
или "указатель  на функцию,  возвращающую ...",  и результат вызова
функции имеет тип "...".
<p align=justify>Каждый   формальный    параметр   инициализируется    фактическим
параметром (<a href=ref_5.htm#8_6>#8.6</a>).  Выполняются стандартные (<a href=ref_3.htm#6_6>#6.6</a>-8) и определяемые
пользователем  преобразования   (<a href=ref_5.htm#8_5_6>#8.5.6</a>).  Функция  может  изменять
значения своих  формальных параметров,  но эти  изменения не  могут
повлиять на значения фактических  параметров за исключением случая,
когда формальный параметр имеет ссылочный тип.
<p align=justify>Функция может  быть описана  как  получающая  меньше  или  больше
параметров, чем  специфицировано в  описании функции (<a href=ref_5.htm#8_4>#8.4</a>). Каждый
фактический параметр  типа  float,  для  которого  нет  формального
параметра, преобразуются  к типу   double;  и,  как  обычно,  имена
массивов преобразуются  к указателям. Порядок вычисления параметров
не определен языком; имейте в виду различия между компиляторами.
<p align=justify>Допустимы рекурсивные вызовы любых функций.
<p align=justify>Первичное выражение,  после  которого  стоит  точка,  за  которой
следует идентификатор (или идентификатор, уточненный typedef-именем
с помощью операции ::) является выражением. Первое выражение должно
быть объектом  класса, а  идентификатор должен именовать член этого
класса. Значением является именованный член объекта, и оно является
адресным,  если   первое  выражение   является  адресным.   Следует
отметить, что  "классовые объекты" могут быть структурами (<a href=ref_5.htm#8_5_12>#8.5.12</a>)
или объединениями (<a href=ref_5.htm#8_5_13>#8.5.13</a>).
<p align=justify>Первичное выражение,  после которого  стоит  стрелка  ( -> ),  за
которой  следует   идентификатор  (или   идентификатор,  уточненный
typedef-именем с  помощью операции ::) является выражением.  Первое
выражение должно  быть указателем на объект класса, а идентификатор
должен именовать  член этого  класса.  Значение  является  адресом,
ссылающимся  на  именованный  член  класса,  на  который  указывает
указательное выражение.  Так, выражение  E1->MOS  есть то же, что и
(*E1).MOS. Классы обсуждаются в <a href=ref_5.htm#8_5>#8.5</a>.
<p align=justify>Если первичное  выражение дает  значение типа  "указатель на ..." (см.  <a href=ref_5.htm#8_4>#8.4</a>     and   <a href=ref_5.htm#8_6_3>#8.6.3</a>),  значением   выражения  был   объект,
обозначаемый ссылкой.  Ссылку можно  считать  именем  объекта;  см. <a href=ref_5.htm#8_6_3>#8.6.3</a>.
<a name=7_2></a>
<h4>7.2 Унарные операции</h4>
<p align=justify>Выражения с унарными операциями группируют справа налево:
<pre>
	унарное_выражение:
	     унарная_операция                                выражение
	     выражение                                              ++
	     выражение                                              --
	     sizeof                                          выражение
	     sizeof             (              имя_типа              )
	     (            имя_типа             )             выражение
	     простое_имя_типа       (        список_выражений        )
	     new               имя_типа       инициализатор        opt
	     new              (               имя_типа               )
	     delete                                          выражение
	     delete [ выражение ] выражение
	унарная_операция:                   одна                    из
	     *  &  -  !  ~  ++  --
</pre>
<p align=justify>Унарная операция * означает косвенное обращение: выражение должно
быть указателем  и результатом будет lvalue, ссылающееся на объект,
на который указывает выражение. Если выражение имеет тип "указатель
на ...", то тип результата есть "...".
<p align=justify>Результатом унарной  операции &  является указатель на объект, на
который  ссылается   операнд.  Операнд  должен  быть  lvalue.  Если
выражение имеет  тип "...",  то тип  результата есть  "указатель на
...".
<p align=justify>Результатом унарной  операции +  является  значение  ее  операнда
после выполнения  обычных  арифметических  преобразований.  Операнд
должен быть арифметического типа.
<p align=justify>Результатом унарной операции - является отрицательное значение ее
операнда. Операнд  должен  иметь  целый  тип.  Выполняются  обычные
арифметические преобразования.  Отрицательное  значение  беззнаковой
величины вычислятся посредством вычитания ее значения из  2n, где n
-число битов в целом типа int.
<p align=justify>Результатом операции  логического отрицания  ! является  1,  если
значение операнда  0, и  0, если  значение операнда не 0. Результат
имеет тип  int. Применима  к  любому  арифметическому  типу  или  к
указателям.
<p align=justify>Операция  ~   дает  дополнение   значения  операнда  до  единицы.
Выполняются   обычные арифметические преобразования. Операнд должен
иметь интегральный тип.
<a name=7_2_1></a>
<h4><i>7.2.1 Увеличение и Уменьшение</i></h4>
<p align=justify>Операнд префиксного  ++ получает  приращение. Операнд должен быть
адресным .  Значением является  новое значение  операнда, но оно не
адресное. Выражение  ++x эквивалентно  x+=1.  По  поводу  данных  о
преобразованиях  см.   обсуждение  операций   сложения   (<a href=ref_4.htm#7_4>#7.4</a>)   и
присваивания (<a href=ref_4.htm#7_14>#7.14</a>).
<p align=justify>Операнд префиксного -- уменьшается аналогично действию префиксной
операции ++.
<p align=justify>Значение, получаемое  при  использовании  постфиксного  ++,  есть
значение операнда.  Операнд должен  быть адресным.  После того, как
результат отмечен,  объект увеличивается так же, как и в префиксной
операции ++. Тип результата тот же, что и тип операнда.
<p align=justify>Значение,    получаемое     при    использовании      постфиксной
 --, есть  значение операнда.  Операнд должен  быть адресным. После
того, как  результат отмечен,  объект увеличивается так же, как и в
префиксной операции ++. Тип результата тот же, что и тип операнда.
<a name=7_2_2></a>
<h4><i>7.2.2 Sizeof</i></h4>
<p align=justify>Операция  sizeof   дает  размер   операнда  в  байтах.  (Байт  не
определяется языком  иначе, чем  через значение  sizeof. Однако, во
всех существующих  реализациях байт  есть пространство, необходимое
для хранения  char.) При  применении к массиву результатом является
полное количество байтов в массиве. Размер определяется из описаний
объектов, входящих в выражение. Семантически это выражение является
беззнаковой константой и может быть использовано в любом месте, где
требуется константа.
<p align=justify>Операцию sizeof  можно также  применять к  заключенному в  скобки
имени типа.  В этом  случае она  дает  размер,  в  байтах,  объекта
указанного типа.
<a name=7_2_3></a>
<h4><i>7.2.3 Явное Преобразование Типа</i></h4>
<p align=justify>Простое_имя_типа  (<a href=ref_5.htm#8_2>#8.2</a>),  возможно,  заключенное  в  скобки,  за
которым идет  заключенное в скобки выражение (или список_выражений,
если тип  является  классом  с  соответствующим  образом  описанным
конструктором <a href=ref_5.htm#8_5_5>#8.5.5</a>)  влечет преобразование  значения выражения  в
названный тип.  Чтобы записать  преобразование в  тип,  не  имеющий
простого имени,  имя_типа (<a href=ref_5.htm#8_7>#8.7</a>)  должно быть  заключено в  скобки.
Если имя  типа заключено  в скобки,  выражение заключать  в  скобки
необязательно. Такая запись называется приведением к типу.
<p align=justify>Указатель может  быть явно  преобразован к любому из интегральных
типов, достаточно  по величине для его хранения. То, какой из int и
long требуется,  является машинно-зависимым. Отображающая  функция
также является  машинно-зависимой,  но предполагается,  что она  не
содержит сюрпризов  для  того,  кто  знает  структуру  адресации  в
машине. Подробности для некоторых конкретных машин были приведены в
<a href=ref_1.htm#2_6>#2.6</a>.
<p align=justify>Объект  интегрального   типа  может   быть  явно  преобразован  в
указатель. Отображающая функция всегда превращает целое, полученное
из указателя,  обратно в  тот же  указатель, но в остальных случаях
является машинно зависимой.
<p align=justify>Указатель на один тип может быть явно преобразован в указатель на
другой тип.  Использование полученного в результате указателя может
привести  к   исключительной  ситуации   адресации,  если  исходный
указатель  не   указывает  на   объект,   соответствующим   образом
выравненный  в  памяти.  Гарантируется,  что  указатель  на  объект
данного размера  может быть  преобразован  в  указатель  на  объект
меньшего размера  и обратно  без изменений.  Различные машины могут
различаться по  числу бит в указателях и требованиям к выравниванию
объектов. Составные объекты выравниваются по самой строгой границе,
требуемой каким-либо из его составляющих.
<p align=justify>Объект может  преобразовываться в  объект класса  только если был
описан  соответствующий  конструктор  или  операция  преобразования
(<a href=ref_5.htm#8_5_6>#8.5.6</a>).
<p align=justify>Объект может  явно преобразовываться  в ссылочный  тип  &X,  если
указатель на этот объект может явно преобразовываться в X*.
<a name=7_2_4></a>
<h4><i>7.2.4 Свободная Память</i></h4>
<p align=justify>Операция new создает объект  типа имя_типа (см. <a href=ref_5.htm#8_7>#8.7</a>), к которому
он применен.  Время жизни  объекта, созданного  с помощью  new,  не
ограничено областью  видимости, в  которой он  создан. Операция new
возвращает указатель  на созданный ей объект. Когда объект является
массивом, возвращается указатель на его первый элемент. Например, и
new   int и  new int[10]  возвращают int*.  Для объектов  некоторых
классов надо  предоставлять инициализатор  (<a href=ref_5.htm#8_6_2>#8.6.2</a>).  Операция  new
(<a href=ref_4.htm#7_2>#7.2</a>) для получения памяти вызывает функцию
<pre>
	void* operator new (long);
</pre>
Параметр   задает    требуемое   число    байтов.   Память    будет
инициализирована. Если  operator new()  не  может  найти  требуемое
количество памяти, то она возвращает ноль.
<p align=justify>Операция delete  уничтожает объект,  созданный операцией  new. Ее
результат является  void. Операнд  delete должен  быть  указателем,
возвращенным new.  Результат применения delete к указателю, который
не был получен с помощью операции new. Однако уничтожение с помощью
delete указателя со значением ноль безвредно.
<p align=justify>Чтобы  освободить  указанную  память,  операция  delete  вызывает
функцию
<pre>
	void operator delete (void*);
</pre>
В форме
<pre>
	delete [ выражение ] выражение
</pre>
второй параметр  указывает на  вектор, а  первое  выражение  задает
число элементов  этого вектора.  Задание числа  элементов  является
избыточным за  исключением случаев  уничтожения векторов  некоторых
классов; см. <a href=ref_5.htm#8_5_8>#8.5.8</a>.
<a name=7_3></a>
<h4>7.3 Мультипликативные операции</h4>
<p align=justify>Мультипликативные операции  *,   / и  % группируют слева направо.
Выполняются обычные арифметические преобразования.
<pre>
	мультипликативное_выражение:
	    выражение * выражение
	    выражение  /  выражение
	    выражение  % выражение
</pre>
<p align=justify>Бинарная операция * определяет умножение. Операция * ассоциативна
и выражения  с несколькими  умножениями на  одном уровне могут быть
реорганизованы компилятором.
<p align=justify>Бинарная операция / определяет деление. При делении положительных
целых округление  осуществляется в сторону 0, но если какой-либо из
операндов  отрицателен,   то  форма   округления  является  машинно-зависимой.  На  всех  машинах,  охватываемых  данным  руководством,
остаток имеет  тот же  знак, что  и делимое.  Всегда истинно,  что
(a/b)*b + a%b равно  a (если b не 0).
<p align=justify>Бинарная операция  % дает остаток от деления первого выражения на
второе. Выполняются обычные арифметические преобразования. Операнды
не должны быть числами с плавающей точкой.
<a name=7_4></a>
<h4>7.4 Аддитивные операции</h4>
<p align=justify>Аддитивные операции  + и  - группируют слева направо. Выполняюься
обычные  арифметические   преобразования.  Каждая   операция  имеет
некоторые дополнительные возможности, связанные с типами.
<pre>
	аддитивное_выражение:
	    выражение + выражение
	    выражение  -  выражение
</pre>
<p align=justify>Результатом  операции   +   является   сумма   операндов.   Можно
суммировать указатель  на объект  массива и  значение целого  типа.
Последнее во всех случаях преобразуется к смещению адреса с помощью
умножения его  на длину  объекта, на  который указывает  указатель.
Результатом  является  указатель  того  же  типа,  что  и  исходный
указатель,  указывающий   на  другой   объект  того   же  массива  и
соответствующим образом  смещенный от первоначального объекта. Так,
если P  есть указатель  на объект  массива, то  выражение P+1  есть
указатель на следующий объект массива.
<p align=justify>Никакие другие комбинации типов для указателей не допустимы.
<p align=justify>Операция +  ассоциативна и выражение с несколькими умножениями на
одном уровне может быть реорганизовано компилятором.
<p align=justify>Результатом операции  - является  разность операндов. Выполняются
обычные арифметические  преобразования. Кроме того, значение любого
целого  типа   может  вычитаться   из  указателя,   в  этом  случае
применяются те же преобразования, что и к сложению.
<p align=justify>Если вычитаются  указатели на  объекты  одного типа, то результат
преобразуется (посредством  деления на  длину  объекта)  к  целому,
представляющему  собой   число   объектов,   разделяющих   объекты,
указанные указателями. В зависимости от машины результирующее целое
может быть  или типа  int, или  типа long; см. <a href=ref_1.htm#2_6>#2.6</a>. Вообще говоря,
это преобразование  будет давать неопределенный результат кроме тех
случаев, когда  указатели  указывают  на  объекты  одного  массива,
поскольку  указатели,   даже  на   объекты  одинакового   типа,  не
обязательно различаются на величину, кратную длине объекта.
<a name=7_5></a>
<h4>7.5 Операции сдвига</h4>
<p align=justify>Операции сдвига  &lt;&lt; и  >> группируют слева направо. Обе выполняют
одно обычное  арифметическое преобразование  над своими операндами,
каждый из  которых должен  быть целым. В этом случае правый операнд
преобразуется к  типу int;  тип результата совпадает с типом левого
операнда. Результат  не определен, если  правый операнд  отрицателен
или больше или равен длине объекта в битах.
<pre>
	сдвиговое_выражение:
	     выражение                  &lt;&lt;                   выражение
	     выражение >> выражение
</pre>
<p align=justify>Значением Е1  &lt;&lt; Е2  является  Е1  (рассматриваемое  как  битовое
представление), сдвинутое  влево на  Е2 битов;  освободившиеся биты
заполняются нулями.  Значением Е1  >> Е2  является Е1  ,  сдвинутое
вправо на  Е2 битовых  позиций.  Гарантируется,  что  сдвиг  вправо
является логическим (заполнение нулями), если Е1 является unsigned;
в противном  случае он может быть арифметическим (заполнение копией
знакового бита).
<a name=7_6></a>
<h4>7.6 Операции отношения</h4>
<p align=justify>Операции отношения  (сравнения) группируют слева направо, но этот
факт не очень-то полезен: a &lt; b &lt; c не означает то, чем кажется.
<pre>
	выражение_отношения:
	     выражение                   &lt;                   выражение
	     выражение                   >                   выражение
	     выражение                  <=                   выражение
	     выражение >= выражение
</pre>
<p align=justify>Операции &lt; (меньше чем), > (больше чем), <= и >= все дают 0, если
заданное соотношение  ложно, и  1, если оно истинно. Тип результата
int.  Выполняются   обычные  арифметические  преобразования.  Могут
сравниваться два  указателя; результат  зависит  от  относительного
положения объектов,  на которые  указывают  указатели,  в  адресном
пространстве. Сравнение указателей переносимо только если указатели
указывают на объекты одного массива.
<a name=7_7></a>
<h4>7.7 Операции равенства</h4>
<pre>
	выражение_равенства:
	     выражение                   ==                  выражение
	     выражение  !=  выражение
</pre>
<p align=justify> Операции  ==  и  !=  в  точности  аналогичны  операциям
сравнения за исключением их низкого приоритета. (Так, a &lt; b  ==
c  &lt;  d  есть  1  всегда,  когда a &lt; b и c &lt; d имеют одинаковое
истинностное значение.)
<p align=justify>Указатель может сравниваться с 0.
<a name=7_8></a>
<h4>7.8 Операция побитовое И</h4>
<pre>
	И-выражение:   выражение & выражение
</pre>
<p align=justify>Операция  &   ассоциативна,  и  выражения,  содержащие  &,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом является побитовая функция И операндов.
Операция применяется только к целым операндам.
<a name=7_9></a>
<h4>7.9 Операция побитовое исключающее ИЛИ</h4>
<pre>
	исключающее_ИЛИ_выражение:
	     выражение ^ выражение
</pre>
<p align=justify>Операция  ^   ассоциативна,  и  выражения,  содержащие  ^,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом  является побитовая функция исключающее
ИЛИ операндов. Операция применяется только к целым операндам.
<a name=7_10></a>
<h4>7.10 Операция побитовое включающее ИЛИ</h4>
<pre>
	включающее_ИЛИ_выражение:
	     выражение | выражение
</pre>
<p align=justify>Операция  |   ассоциативна,  и  выражения,  содержащие  |,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом  является побитовая  функция включающее
ИЛИ операндов. Операция применяется только к целым операндам.
<a name=7_11></a>
<h4>7.11 Операция логическое И</h4>
<pre>
	логическое_И_выражение:
	     выражение && выражение
</pre>
<p align=justify>Операция &&  группирует слева направо. Она возвращает 1, если оба
операнда ненулевые,  и 0  в противном  случае. В  противоположность
операции & операция  && гарантирует вычисление слева направо; более
того, второй операнд не вычисляется, если первый операнд есть 0.
<p align=justify>Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.
<a name=7_12></a>
<h4>7.12 Операция логическое ИЛИ</h4>
<pre>
	логическое_ИЛИ_выражение:
	     выражение || выражение
</pre>
<p align=justify>Операция || группирует слева направо. Она возвращает 1, если хотя
бы один  из ее  операндов ненулевой,  и 0  в  противном  случае.  В
противоположность операции  | операция  ||  гарантирует  вычисление
слева направо;  более того,  второй операнд  не  вычисляется,  если
первый операнд не есть 0.
<p align=justify>Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.
<a name=7_13></a>
<h4>7.13 Условная операция</h4>
<pre>
	условное_выражение:
	     выражение ? выражение : выражение
</pre>
<p align=justify>Условная операция  группирует слева  направо. Вычисляется  первое
выражение, и  если оно  не  0,  то  результатом  является  значение
второго выражения,  в противном случае значение третьего выражения.
Если  это   возможно,   то   выполняются   обычные   арифметические
преобразования для приведения второго и третьего выражения к общему
типу. Если  это возможно,  то выполняются преобразования указателей
для  приведения   второго  и  третьего  выражения  к  общему  типу.
Вычисляется только одно из второго и третьего выражений.
<a name=7_14></a>
<h4>7.14 Операции присваивания</h4>
<p align=justify>Есть много  операций присваивания,  все группируют слева направо.
Все в  качестве левого  операнда требуют  lvalue, и  тип  выражения
присваивания тот  же, что  и у  его левого  операнда. Это lvalue не
может ссылаться  на константу (имя массива, имя функции или const).
Значением является  значение, хранящееся  в левом  операнде  после
выполнения присваивания.
<pre>
	выражение_присваивания:
	    выражение  операция_присваивания  выражение
	операция_присваивания: одна из
	    =  +=  -=  *=  /=  %=  >>=  <<=  &=  ~=  |=
</pre>
<p align=justify>В простом  присваивании с  = значение  выражения  замещает  собой
значение объекта,  на который ссылается операнд в левой части. Если
оба  операнда   имеют  арифметический  тип,  то  при  подготовке  к
присваиванию правый  операнд  преобразуется  к  типу  левого.  Если
аргумент в  левой части  имеет указательный  тип, аргумент в правой
части должен  быть  того  же  типа  или  типа,  который  может  быть
преобразован к  нему, см.  <a href=ref_3.htm#6_7>#6.7</a>. Оба  операнда могут быть объектами
одного класса.  Могут присваиваться  объекты некоторых  производных
классов; см. <a href=ref_5.htm#8_5_3>#8.5.3</a>.
<p align=justify>Присваивание   объекту   типа   "указатель   на   ..."   выполнит
присваивание объекту, денотируемому ссылкой.
<p align=justify>Выполнение выражения  вида E1  op= E2  можно представить себе как
эквивалентное E1 = E1 op (E2); но E1 вычисляется только один раз. В
+= и  -= левый  операнд может  быть указателем,  и  в  этом  случае
(интегральный) правый  операнд преобразуется так, как объяснялось в
<a href=ref_4.htm#7_4>#7.4</a>; все  правые операнды и не являющиеся указателями левые должны
иметь арифметический тип.
<a name=7_15></a>
<h4>7.15 Операция запятая</h4>
<pre>
	запятая_выражение:
	    выражение , выражение
</pre>
<p align=justify>Пара выражений,  разделенных запятой,  вычисляется слева направо,
значение левого  выражения  теряется.  Тип  и  значение  результата
являются  типом   и  значением   правого  операнда.   Эта  операция
группирует  слева   направо.  В   контексте,  где   запятая   имеет
специальное значение,  как например в списке фактических параметров
функции  (<a href=ref_4.htm#7_1>#7.1</a>)    и  в  списке  инициализаторов  (<a href=ref_5.htm#8_6>#8.6</a>),  операция
запятая, как  она описана в этом разделе, может появляться только в
скобках; например,
<pre>
	f (a,(t=3,t+2),c)
</pre>
имеет три параметра, вторым из которых является значение 5.
<a name=7_16></a>
<h4>7.16 Перегруженные операции</h4>
<p align=justify>Большинство операций  может быть  перегружено, то  есть,  описано
так, чтобы  они получали  в качестве операндов объекты классов (см.
<a href=ref_5.htm#8_5_11>#8.5.11</a>).  Изменить   приоритет  операций   невозможно.  Невозможно
изменить смысл  операций при  применении их к неклассовым объектам.
Предопределенный смысл операций = и & (унарной) при применении их к
объектам классов может быть изменен.
<p align=justify>Эквивалентность операций, применяемых к основным типам (например,
++a эквивалентно  a+=1), не  обязательно выполняется  для операций,
применяемых  к   классовым  типам.  Некоторые  операции,  например,
присваивание, в  случае применения  к основным типам требуют, чтобы
операнд был  lvalue; это  не требуется  для операций, описанных для
классовых типов.
<a name=7_16_1></a>
<h4>7.16.1 Унарные операции</i></h4>
<p align=justify>Унарная  операция,   префиксная  или   постфиксная,  может   быть
определена или  с помощью функции члена (см. <a href=ref_5.htm#8_5_4>#8.5.4</a>), не получающей
параметров, или  с помощью  функции друга (см. <a href=ref_5.htm#8_5_10>#8.5.10</a>), получающей
один параметр,  но не  двумя способами одновременно. Так, для любой
унарной  операции   @,  x@   и  @x   могут  интерпретироваться  как
x.операция@() или  операция@(x). При  перегрузке операций  ++ и  --
невозможно различить префиксное и постфиксное использование.
<a name=7_16_2></a>
<h4>7.16.2 Бинарные операции</i></h4>
<p align=justify>Бинарная операция  может быть  определена или  с помощью  функции
члена (см. <a href=ref_5.htm#8_5_4>#8.5.4</a>), получающей один параметр, или с помощью функции
друга (см. <a href=ref_5.htm#8_5_9>#8.5.9</a>), получающей два параметра, но не двумя способами
одновременно. Так,  для любой  бинарной операции  @, x@y может быть
проинтерпретировано как x.операция@(y) или операция@(x,y).
<a name=7_16_3></a>
<h4>7.16.3 Особые операции</i></h4>
<p align=justify>Вызов функции
<pre>
	первичное_выражение ( список_выражений opt )
</pre>
и индексирование
<pre>
	первичное_выражение [ выражение ]
</pre>
считаются  бинарными   операциями.  Именами   определяющей  функции
являются соответственно  operator()   и operator[]. Обращение x(arg)
интерпретируется как  x.operator()(arg) для  классового объекта  x.
Индексирование x[y] интерпретируется как x.operator[](y).
<a name=prim></a><small>
<p align=justify>* Этот  термин применяется  для описания  использования  в  языке одной и  той же  лексемы для  обозначения различных  процедур;  вид
процедуры  выбирается   компилятором  на  основании  дополнительной
информации в виде числа и типа аргументов и т.п.</small>
<p><center><p>
<font size=-1>
<a href="ref_3.htm">Назад</a> | <a href="index.htm">Содержание</a> | <a href="ref_5.htm">Вперед</a></font></center></p>
<br>
<div align="center"><a href="http://www.linkexchange.ru/users/000729/goto.map" target="_blank"><img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?729?324561123" alt="Russian LinkExchange Advertising Network" border=0 height=60 width=468 vspace=0></a></div>
</body></html>
