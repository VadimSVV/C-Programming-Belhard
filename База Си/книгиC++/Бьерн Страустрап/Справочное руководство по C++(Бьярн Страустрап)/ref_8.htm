<html><head>
<title>Обзор типов. Справочное руководство по C++</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<a name=14></a>
<h3> 14. Обзор типов </h3>
<p align=justify>В этом  разделе кратко  собрано описание  действий, которые могут
совершаться над объектами различных типов.
<a name=14_1></a>
<h4>14.1 Классы</h4>
<p align=justify>Классовые объекты  могут присваиваться, передаваться функциям как
параметры и возвращаться функциями. Другие возможные операции, как,
например, проверка  равенства, могут быть определены пользователем;
см. <a href=ref_5.htm#8_5_10>#8.5.10</a>.
<a name=14_2></a>
<h4>14.2 Функции</h4>
<p align=justify>Есть только  две вещи,  которые  можно  проделывать  с  функцией:
вызывать ее  и  брать  ее  адрес.  Если  в  выражении  имя  функции
возникает не  в положении  имени функции  в вызове, то генерируется
указатель на  функцию. Так, для передачи одной функции другой можно
написать
<pre>
	typedef int (*PF) ();
	extern g (PF);
	extern f ();
	...
	g (f);
</pre>
  Тогда определение g может иметь следующий вид:
<pre>
	g (PF funcp)
	  {
	    ...
	    (*funcp) ();
	    ...
	  }
</pre>
<p align=justify>Заметьте, что  f должна быть описана явно в вызывающей программе,
поскольку ее появление в g(f) не сопровождалось (.
<a name=14_3></a>
<h4>14.3 Массивы, указатели и индексирование</h4>
<p align=justify>Всякий раз,  когда  в  выражении  появляется  идентификатор  типа
массива, он преобразуется в указатель на первый член массива. Из-за
преобразований  массивы   не  являются   адресами.  По  определению
операция индексирования  []  интерпретируется  таким  образом,  что
E1[E2]  идентично   *((E1)+(E2)).  В  силу  правил  преобразования,
применяемых к  +, если E1 массив и E2 целое, то E1[E2] относится к
E2-ому члену  E1. Поэтому, несмотря на такое проявление асимметрии,
индексирование является коммутативной операцией.
<p align=justify>Это правило  сообразным образом применяется в случае многомерного
массива. Если  E является  n-мерным массивом  ранга i*j*...*k,   то
возникающее в выражении E преобразуется в указатель на (n-1)-мерный
массив ранга j*...*k.  Если к этому указателю, явно или неявно, как
результат индексирования,  применяется операция  *, ее  результатом
является (n-1)-мерный  массив, на  который указывалось, который сам
тут же преобразуется в указатель.
<p align=justify>Рассмотрим, например,
<pre>
	int x[3][5];
</pre>
<p align=justify>Здесь x  -  массив  целых  размером  3*5.  Когда  x  возникает  в
выражении, он  преобразуется в указатель на (первый из трех) массив
из 5  целых. В  выражении  x[i],  которое  эквивалентно  *(x+1),  x
сначала  преобразуется,   как  описано,   в  указатель,   затем   1
преобразуется к  типу x,  что включает  в себя умножение 1 на длину
объекта, на  который указывает  указатель, а  именно  объект  из  5
целых. Результаты  складываются, и используется косвенная адресация
для  получения  массива  (из  5  целых),  который  в  свою  очередь
преобразуется в  указатель на  первое из  целых. Если есть еще один
индекс, снова  используется  тот же параметр; на этот раз результат
является целым.
<p align=justify>Именно из всего этого проистекает то, что массивы в C хранятся по
строкам (быстрее  всего  изменяется  последний  индекс),  и  что  в
описании     первый  индекс   помогает  определить   объем  памяти,
поглощаемый  массивом,   но  не   играет  никакой   другой  роли  в
вычислениях индекса.
<a name=14_4></a>
<h4>14.4 Явные преобразования указателей</h4>
<p align=justify>Определенные преобразования,  включающие массивы, выполняются, но
имеют зависящие  от реализации  аспекты. Все они задаются с помощью
явной операции преобразования типов, см. <a href=ref_4.htm#7_2>#7.2</a> и <a href=ref_5.htm#8_7>#8.7</a>.
<p align=justify>Указатель иожет  быть  преобразован  к  любому  из  целых  типов,
достаточно больших  для его  хранения. То,  какой  из  int  и  long
требуется, является  машинно-зависимым. Преобразующая функция также
является машинно-зависимой, но предполагается, что она не содержит
сюрпризов  для  того,  кто  знает  структуру  адресации  в  машине.
Подробности для некоторых конкретных машин были даны в <a href=ref_1.htm#2_6>#2.6</a>.
<p align=justify>Объект целого  типа может  быть явно  преобразован  в  указатель.
Преобразующая  функция   всегда  превращает  целое,  полученное  из
указателя, обратно  в тот  же указатель,  но  в  остальных  случаях
является машинно-зависимой.
<p align=justify>Указатель на  один тип  может быть  преобразован в  указатель  на
другой тип.  Использование результирующего указателя может вызывать
особые ситуации,  если исходный  указатель не  указывает на объект,
соответствующим образом  выравненный в  памяти. Гарантируется,  что
указатель на  объект данного  размера  может  быть  преобразован  в
указатель на объект меньшего размера и обратно без изменений.
<p align=justify>Например, программа,  выделяющая память, может получать размер (в
байтах) размещаемого  объекта и  возвращать указатель  на char; это
можно использовать следующим образом.
<pre>
	extern void* alloc ();
	double* dp;
	dp = (double*) alloc (sizeof (double));
	*dp= 22.0 / 7.0;
</pre>
alloc   должна обеспечивать  (машинно-зависимым  образом)  то,  что
возвращаемое ею значение подходит для преобразования в указатель на
double;   в этом  случае использование  функции мобильно. Различные
машины различаются  по числу  бит  в  указателях  и  требованиям  к
выравниванию объектов.  Составные объекты  выравниваются  по  самой
строгой границе, требуемой каким-либо из его составляющих.
<a name=15></a>
<h3> 15. Константные выражения </h3>
<p align=justify>В нескольких  местах C++  требует выражения,  вычисление  которых
дает  константу:   в  качестве   границы  массива  (<a href=ref_5.htm#8_3>#8.3</a>),  в  case
выражениях  (<a href=ref_6.htm#9_7>#9.7</a>),   в  качестве   значений  параметров   функции,
присваиваемых по  умолчанию, (<a href=ref_5.htm#8_3>#8.3</a>),  и в инициализаторах (<a href=ref_5.htm#8_6>#8.6</a>). В
первом случае  выражение может  включать  только  целые  константы,
символьные константы,  константы, описанные  как  имена,  и  sizeof
выражения, возможно, связанные бинарными операциями
<pre>
	 + - * / % & | ^ &lt;&lt; >> == != &lt; > <= >= && ||
</pre>
 или унарными операциями
<pre>
	- ~ !
</pre>
или тернарными операциями
<pre>
	? :
</pre>
<p align=justify>Скобки могут  использоваться для  группирования, но не для вызова функций.
<p align=justify>Большая   широта    допустима   для    остальных   трех   случаев
использования; помимо  константных выражений,  обсуждавшихся  выше,
допускаются константы  с плавающей  точкой, и можно также применять
унарную операцию  & к  внешним  или  статическим  объектам,  или  к
внешним  или   статическим  массивам,  индексированным  константным
выражением. Унарная  операция & может также быть применена неявно с
помощью употребления неиндексированных массивов и функций. Основное
правило состоит  в том,  что инициализаторы  должны при  вычислении
давать  константу   или  адрес   ранее  описанного   внешнего   или
статического объекта плюс или минус константа.
<p align=justify>Меньшая широта  допустима для  константных выражений  после  #if:
константы, описанные  как имена,  sizeof выражения  и  перечислимые
константы недопустимы.
<a name=16></a>
<h3> 16. Соображения мобильности </h3>
<p align=justify>Определенные части C++ являются машинно-зависимыми по своей сути.
Следующий ниже  список мест  возможных затруднений не претендует на
полноту, но может указать на основные из них.
<p align=justify>Как показала  практика, характеристики  аппаратуры в чистом виде,
такие, как  размер слова,  свойства плавающей  арифметики и  целого
деления, не  создают  особых  проблем.  Другие  аппаратные  аспекты
отражаются на  различных программных разработках. Некоторые из них,
особенно знаковое расширение (преобразование отрицательного символа
в отрицательное  целое) и  порядок  расположения  байтов  в  слове,
являются досадными  помехами, за  которыми надо  тщательно следить.
Большинство других являются всего лишь мелкими сложностями.
<p align=justify>Число  регистровых  переменных,  которые  фактически  могут  быть
помещены  в  регистры,  различается  от  машины  к  машине,  как  и
множество фактических  типов. Тем  не  менее,  все  компиляторы  на
"своей" машине  все делают  правильно; избыточные или недействующие
описания register игнорируются.
<p align=justify>Некоторые сложности  возникают  при  использовании  двусмысленной
манеры программирования.  Писать программы, зависящие от какой-либо
из этих особенностей, районе неблагоразумно.
<p align=justify>В языке  не определен порядок  вычисления параметров  функции.  На
некоторых машинах  он слева  направо, а на некоторых справа налево.
Порядок    появления     некоторых    побочных     эффектов    также
недетерминирован.
<p align=justify>Поскольку  символьные   константы  в   действительности  являются
объектами  типа   int,  то  могут  быть  допустимы  многосимвольные
константы. Однако  конкретная реализация  очень сильно  зависит  от
машины, поскольку  порядок, в  котором символы присваиваются слову,
различается от  машины к  машине. На некоторых машинах поля в слове
присваиваются слева направо, на других справа налево.
<p align=justify>Эти различия  невидны для отдельных программ, не позволяющих себе
каламбуров с  типами (например, преобразования int указателя в char
указатель и  просмотр памяти,  на которую  указывает указатель), но
должны приниматься во внимание при согласовании внешне предписанных
форматов памяти.
<p><center><p>
<font size=-1>
<a href="ref_7.htm">Назад</a> | <a href="index.htm">Содержание</a> | <a href="ref_9.htm">Вперед</a></font></center></p>
<br>
<div align="center"><a href="http://www.linkexchange.ru/users/000729/goto.map" target="_blank"><img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?729?28340234" alt="Russian LinkExchange Advertising Network" border=0 height=60 width=468 vspace=0></a></div>
</body></html>
