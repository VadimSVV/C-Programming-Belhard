<html><head>
<title>Внешние определения. Справочное руководство по C++</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<a name=10></a>
<h3> 10. Внешние определения </h3>
<p align=justify>Программа  на   C++   состоит   из   последовательности   внешних
определений.  Внешнее   определение  описывает  идентификатор  как
имеющий класс памяти static и определяет его тип. Спецификатор типа
(<a href=ref_5.htm#8_2>#8.2</a>) может  также быть  пустым, и  в этом случае принимается  тип
int. Область  видимости внешних  определений простирается  до конца
файла, в  котором  они  описаны,  так  же,  как  действие  описаний
сохраняется до  конца блока.  Синтаксис внешних определений тот же,
что и  у описаний, за исключением того, что только на этом уровне и
внутри описаний  классов может  быть задан  код  (текст  программы)
функции.
<a name=10_1></a>
<h4>10.1  Определения функций</h4>
<p align=justify>Определения функций имеют вид
<pre>
	определение_функции:
	     спецификаторы_описания описатель_функции  opt инициализа-
	тор_базового_класса                                        opt
	     тело_функции
</pre>
<p align=justify>Единственными спецификаторами класса памяти (sc-спецификаторами),
допустимыми  среди   спецификаторов  описания,   являются   extern,
static, overload,   inline  и virtual.   Описатель функции похож на
описатель "функции,  возвращающей ...", за исключением того, что он
включает в  себя имена  формальных параметров определяемой функции.
Описатель функции имеет вид
<pre>
	описатель_функции:
	     описатель ( список_описаний_параметров )
</pre>
<p align=justify>Форма списка описаний параметров определена в <a href=ref_5.htm#8_4>#8.4</a>.  Единственный
класс памяти,  который может  быть  задан,  это  тот,  при  котором
соответствующий фактический  параметр будет  скопирован,  если  это
возможно,  в   регистр  при   входе  в  функцию.  Если  в  качестве
инициализатора для  параметра задано  константное выражение, то это
значение используется как значение параметра по умолчанию.
<p align=justify>Тело функции имеет вид
<pre>
	тело_функции:
	     составной_оператор
</pre>
  Вот простой пример полного определения функции:
<pre>
	int max (int a,int b,int c)
	  {
	    int m = (a > b) ? a : b;
	    return  (m > c) ? m : c;
	  }
</pre>
<p align=justify>Здесь int  является спецификатором  типа ; max (int a, int b, int
c) является  описателем функции  ; {  ... }  - блок, задающий текст
программы (код) оператора.
<p align=justify>Поскольку в  контексте выражения  имя (точнее, имя как формальный
параметр) считается означающим указатель на первый элемент массива,
то описания  формальных параметров,  описанных как "массив из ...",
корректируются так, чтобы читалось "указатель на ...".
<p align=justify>Инициализатор базового класса имеет вид
<pre>
	инициализатор_базового_класса:
	     : ( список_параметров opt )
</pre>
 Он  используется  для  задания  параметров  конструктора  базового
класса в конструкторе производного класса. Например:
<pre>
	struct base { base (int); ... };
	struct derived : base { derived (int); ... };
	derived.derived (int a) : (a+1) { ... }
	derived d (10);
</pre>
Конструктор базового  класса вызывается  для объекта d с параметром
11.
<a name=10_2></a>
<h4>10.2 Определения внешних данных</h4>
<p align=justify>Определения внешних данных имеют вид
<pre>
	определение_данных:
	     описание
</pre>
<p align=justify>Класс памяти таких данных статический.
<p align=justify>Если есть  более одного определения внешних данных одного имени, то определения  должны  точно  согласовываться  по  типу  и  классу
памяти, и  инициализаторы (если  они есть), должны иметь одинаковое
значение.
<a name=11></a>
<h3>  11. Правила области видимости </h3>
<p align=justify>См. <a href=ref_2.htm#4_1>#4.1</a>.
<a name=12></a>
<h3>  12. Командные строки компилятора </h3>
<p align=justify>Компилятор языка  C++ содержит  препроцессор, способный выполнять
макроподстановки,  условную   компиляцию  и  включение  именованных
файлов. Строки,  начинающиеся с  #, относятся  к препроцессору. Эти
строки имеют  независимый от  остального языка синтаксис; они могут
появляться   в    любом   месте    оказывать    влияние,    которое
распространяется  (независимо   от  области   видимости)  до  конца
исходного файла программы.
<p align=justify>Заметьте, что  определения const  и inline  дают альтернативы для
большинства использований #define.
<a name=12_1></a>
<h4>12.1 Замена идентификаторов</h4>
<p align=justify>Командная строка компилятора имеет вид
<pre>
	#define идент строка_символов
</pre>
вызывает    замену     препроцессором     последующих     вхождений
идентификатора, заданного  строкой символов. Точка с запятой внутри
(или в конце) строки символов является частью этой строки.
<p align=justify>Строка вида
<pre>
	#define идент( идент , ..., идент ) строка_символов
</pre>
где отсутсвует  пробел между  первым идентификатором  и (, является
макроопределением  с  параметрами.  Последующие  вхождения  первого
идентификатора с  идущими за  ним (,  последовательностью символов,
разграниченной запятыми, и ), заменяются строкой символов, заданной
в определении.  Каждое местоположение идентификатора, замеченного в
списке параметров  определения, заменяется  соответствующей строкой
из  вызова.   Фактическими  параметрами   вызова  являются   строки
символов,  разделенные   запятыми;   однако   запятые   в   строке,
заключенной  в   кавычки,  или   в  круглых   скобках  не  являются
разделителями параметров. Число формальных и фактических параметров
должно совпадать. Строки и символьные константы в символьной строке
сканируются в поисках формальных параметров, но строки и символьные
константы  в   остальной  программе   не  сканируются   в   поисках
определенных (с помощью define) идентификаторов.
<p align=justify>В обоих  случаях строка  замещения еще  раз сканируется в поисках
других  определенных   идентификаторов.  В   обоих  случаях  длинное
определение может быть продолжено на другой строке с помощью записи
\ в конце продолжаемой строки.
<p align=justify>Командная строка вида
<pre>
	#undef идент
</pre>
влечет отмену препроцессорного определения идентификатора.
<a name=12_2></a>
<h4>12.2 Включение файлов</h4>
<p align=justify>Командная строка компилятора вида
<pre>
	#include "имя_файла"
</pre>
вызывает замену  этой строки  полным  содержимым  файла  имя_файла.
Сначала  именованный   файл  ищется  в  директории  первоначального
исходного  файла,  а  затем  в  стандартных  или  заданных  местах.
Альтернативный вариант, командная строка вида
<pre>
	 #include <имя_файла>
</pre>
производит поиск только в стандартном или заданном месте, и не ищет
в директории  первоначального исходного  файла. (То,  как эти места
задаются, не является частью языка.)
<p align=justify>Включения с помощью #include могут быть вложенными.
<a name=12_3></a>
<h4>12.3 Условная компиляция</h4>
<p align=justify>Командная строка компилятора вида
<pre>
	#if выражение
</pre>
проверяет, является  ли результатом  вычисления выражения  не-ноль.
Выражение должно быть константным выражением, которые обсуждаются в
<a href=ref_8.htm#15>#15</a>;  применительно   к   использованию   данной   директивы   есть
дополнительные  ограничения:   константное   выражение   не   может
содержать sizeof или перечислимые константы. Кроме обычных операций
C     может  использоваться  унарная  операция  defined.  В  случае
применения к  идентификатору она  дает значение  не-ноль, если этот
идентификатор был  ранее определен  с помощью #define и после этого
не было отмены определения с помощью #undef; иначе ее значение 0.
<p align=justify>Командная строка вида
<pre>
	#ifdef идент
</pre>
проверяет, определен  ли идентификатор  в  препроцессоре  в  данный
момент; то есть, был ли он объектом командной строки #define.
<p align=justify>Командная строка вида
<pre>
	#ifndef идент
</pre>
проверяет, является ли идентификатор неопределенным в препроцессоре
в данный момент.
<p align=justify>После строки  каждого из  трех видов  может  стоять  произвольное
количество строк, возможно, содержащих командную строку
<pre>
	#else
</pre>
и далее до командной строки
<pre>
	#endif
</pre>
<p align=justify>Если проверенное  условие истинно,  то все  строки между #else  и
#endif игнорируются.  Если проверенное условие ложно, то все строки
между проверкой  и #else  или, в  случае отсутствия  #else, #endif,
игнорируются.
<p align=justify>Эти конструкции могут быть вложенными.
<a name=12_4></a>
<h4>12.4 Управление строкой</h4>
<p align=justify>Для помощи  другим препроцессорам,  генерирующим программы  на C, строка вида
<pre>
	#line константа "имя_файла"
</pre>
заставляет  компилятор   считать,  например,  в  целях  диагностики
ошибок, что константа задает номер следующей строки исходного файла,
и   текущий    входной   файл   именуется   идентификатором.   Если
идентификатор отсутствует, то запомненное имя файла не изменяется.
<a name=></a>
<h3>  13. Неявные описания </h3>
<p align=justify>См. <a href=ref_5.htm#8_1>#8.1</a>.
<p><center><p>
<font size=-1>
<a href="ref_6.htm">Назад</a> | <a href="index.htm">Содержание</a> | <a href="ref_8.htm">Вперед</a></font></center></p>
<br>
<div align="center"><a href="http://www.linkexchange.ru/users/000729/goto.map" target="_blank"><img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?729?10034823" alt="Russian LinkExchange Advertising Network" border=0 height=60 width=468 vspace=0></a></div>
</body></html>
