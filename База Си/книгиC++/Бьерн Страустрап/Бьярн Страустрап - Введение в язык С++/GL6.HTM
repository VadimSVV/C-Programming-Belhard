<htm>
<head>





<title>Бьярн Страустрап. Введение в язык Си++, Перегрузка Операций</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<basefont size="3"><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<a name=gl6>
<h1 align=center>               Глава 6 </h1>
<h2 ALIGN=CENTER>      Перегрузка Операций </h2>
<p><center>               Здесь водятся Драконы! - старинная карта
</center>
<p>  В этой  главе описывается  аппарат,  предоставляемый  в  C++  для
перегрузки операций.  Программист может  определять смысл  операций
при  их   применении  к   объектам  определенного   класса.   Кроме
арифметических,  можно   определять  еще   и  логические  операции,
операции сравнения,  вызова ()  и индексирования  [], а также можно
переопределять присваивание и инициализацию. Можно определить явное
и  неявное   преобразование  между  определяемыми  пользователем  и
основными типами.  Показано, как  определить класс, объект которого
не может  быть никак  иначе  скопирован  или  уничтожен  кроме  как
специальными определенными пользователем функциями.
<a name=gl6.1>
<h2 align=center>                 6.1 Введение </h2>
<p>  Часто  программы   работают   с   объектами,   которые   являются
конкретными  представлениями  абстрактных  понятий.  Например,  тип
данных  int   в  C++  вместе  с  операциями  +,  -,  *,  /  и  т.д.
предоставляет  реализацию  (ограниченную)  математического  понятия
целых  чисел.  Такие  понятия  обычно  включают  в  себя  множество
операций, которые  кратко, удобно  и привычно представляют основные
действия над  объектами. К  сожалению, язык  программирования может
непосредственно поддерживать  лишь очень малое число таких понятий.
Например, такие  понятия,  как  комплексная  арифметика,  матричная
алгебра, логические сигналы и строки не получили прямой поддержки в
C++.  Классы   дают  средство   спецификации  в  C++  представления
неэлементарных объектов вместе с множеством действий, которые могут
над этими  объектами  выполняться.  Иногда  определение  того,  как
действуют  операции  на  объекты  классов,  позволяет  программисту
обеспечить более  общепринятую и  удобную  запись  для  манипуляции
объектами классов,  чем та,  которую можно  достичь используя  лишь
основную функциональную запись. Например:
<pre>
  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };
</pre>
<br>определяет простую реализацию понятия комплексного числа, в которой
число  представляется   парой  чисел  с  плавающей  точкой  двойной
точности, работа с которыми осуществляется посредством операций + и
* (и  только). Программист  задает смысл  операций +  и * с помощью
определения  функций   с  именами   operator+  и  operator*.  Если,
например, даны b и c типа complex, то b+c означает (по определению)
operator+(b,c). Теперь  есть  возможность  приблизить  общепринятую
интерпретацию комплексных выражений. Например:
<pre>
  void f()
  {
      complex a = complex(1, 3.1);
      complex b = complex(1.2, 2);
      complex c = b;

      a = b+c;
      b = b+c*a;
      c = a*b+complex(1,2);
  }
</pre>
<br>Выполняются обычные  правила приоритетов,  поэтому второй  оператор
означает b=b+(c*a), а не b=(b+c)*a.
<a name=gl6.2>
<h2 align=center>     6.2 Функции Операции </h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl6.2.1> 6.2.1 Бинарные и Унарные Операции
</a>           
<tr><td width=10></td><TD>  <a HREF=#gl6.2.2> 6.2.2 Предопределенные Значения Операций   </a>      
<tr><td width=10></td><TD>  <a HREF=#gl6.2.3>  6.2.3 Операции и Определяемые Пользователем Типы </a>
</table>
<p>  Можно  описывать   функции,   определяющие   значения   следующих
операций:
<pre>
  +   -   *   /   %   ^   &   |   ~   !
  =   <   >   +=  -=  *=  /=  %=  ^=  &=
  |=  <<  >>  >>= <<= ==  !=  <=  >=  &&
  ||  ++  --  []  ()  new delete
</pre>
<br>  Последние четыре  -  это  индексирование  (<a HREF=#gl6.7>#6.7</a>),  вызов  функции (<a HREF=#gl6.8>#6.8</a>), выделение  свободной памяти и освобождение свободной памяти (<a HREF=gl3.htm#gl3.2.6>#3.2.6</a>). Изменить  приоритеты перечисленных  операций  невозможно, как невозможно  изменить и  синтаксис выражений.  Нельзя, например, определить унарную операцию % или бинарную !. Невозможно определить
новые  лексические  символы  операций,  но  в  тех  случаях,  когда
множество  операций  недостаточно,  вы  можете  использовать  запись
вызова  функции.   Используйте  например,   не  **,  а  pow().  Эти
ограничения могут показаться драконовскими, но более гибкие правила
могут очень  легко привести к неоднозначностям. Например, на первый
взгляд определение  операции **,  означающей возведение  в степень,
может показаться очевидной и простой задачей, но подумайте еще раз.
Должна ли  ** связываться  влево (как  в Фортране) или вправо (как в
Алголе)? Выражение  a**p должно  интерпретироваться как  a*(*p) или
как (a)**(p)?
<br>  Имя функции  операции есть  ключевое  слово  operator  (то  есть,
операция), за  которым следует сама операция, например, operator<<.
Функция операция  описывается и  может вызываться так же, как любая
другая функция.  Использование  операции  -  это  лишь  сокращенная
запись явного вызова функции операции. Например:
<pre>
  void f(complex a, complex b)
  {
      complex c = a + b;          // сокращенная запись
      complex d = operator+(a,b); // явный вызов
  }
</pre>
<br>При  наличии   предыдущего  описания   complex  оба  инициализатора
являются синонимами.
<a name=gl6.2.1>
<h3 align=center>     6.2.1 Бинарные и Унарные Операции </h3>
<p>  Бинарная операция  может быть  определена или  как функция  член,
получающая один  параметр, или  как функция  друг,  получающая  два
параметра. Таким образом, для любой бинарной операции @ aa@bb может
интерпретироваться    или    как    aa.operator@(bb),    или    как
operator@(aa,bb). Если  определены обе,  то aa@bb является ошибкой.
Унарная операция, префиксная или постфиксная, может быть определена
или как  функция член,  не получающая  параметров, или  как функция
друг, получающая  один параметр.  Таким образом,  для любой унарной
операции  @   aa@  или   @aa  может   интерпретироваться  или   как
aa.operator@(), или  как operator@(aa).  Если определена  и  то,  и
другое, то  и aa@  и @aa  являются ошибками.  Рассмотрим  следующие
примеры:
<pre>
  class X {
  // друзья

      friend X operator-(X);      // унарный минус
      friend X operator-(X,X);    // бинарный минус
      friend X operator-();       // ошибка: нет операндов
      friend X operator-(X,X,X);  // ошибка: тернарная

  // члены (с неявным первым параметром: this)

      X* operator&(); // унарное & (взятие адреса)
      X operator&(X); // бинарное & (операция И)
      X operator&(X,X);   // ошибка: тернарное

  };
</pre>
<br>  Когда операции  ++ и  -- перегружены,  префиксное использование и
постфиксное различить невозможно.
<a name=gl6.2.2>
<h3 align=center>    6.2.2 Предопределенные Значения Операций </h3>
<p>  Относительно  смысла  операций,  определяемых  пользователем,  не
делается  никаких   предположений.  В   частности,   поскольку   не
предполагается,  что  перегруженное  =  реализует  присваивание  ее
первому   операнду,    не   делается    никакой   проверки,   чтобы
удостовериться, является ли этот операнд lvalue (#с.6).
<br>  Значения   некоторых    встроенный   операций    определены   как
равносильные определенным  комбинациям других  операций над теми же
аргументами. Например,  если a  является int, то ++a означает a+=1,
что  в   свою  очередь   означает  a=a+1.   Такие  соотношения  для
определенных пользователем  операций не выполняются, если только не
случилось так,  что пользователь  сам определил  их таким  образом.
Например, определение  operator+=() для  типа complex не может быть
выведено      из       определений      complex::operator+()      и
complex::operator=().
<br>  По историческому совпадению операции = и & имеют предопределенный
смысл  для   объектов   классов.   Никакого   элегантного   способа
"не определить" эти  две операции  не существует.  Их можно, однако,
сделать недееспособными  для класса  X.  Можно,  например,  описать
X::operator&(),  не  задав  ее  определения.  Если  где-либо  будет
браться адрес объекта класса X, то компоновщик обнаружит отсутствие
определения<a HREF=#*6.1>*<sup>1</sup></a>. Или,  другой способ,  можно определить X::operator&() так, чтобы вызывала ошибку во время выполнения.
<a name=gl6.2.3>
<h3 align=center>   6.2.3 Операции и Определяемые Пользователем Типы </h3>
<p>  Функция операция  должна или быть членом, или получать в качестве
параметра по  меньшей мере  один объект  класса (функциям,  которые
переопределяют операции  new и  delete, это  делать необязательно).
Это правило  гарантирует, что  пользователь не может изменить смысл
никакого   выражения,   не   включающего   в   себя   определенного
пользователем типа.  В частности,  невозможно  определить  функцию,
которая действует исключительно на указатели.
<br>  Функция  операция,   первым  параметром   которой  предполагается
основной тип,  не может быть функцией членом. Рассмотрим, например,
сложение комплексной переменной aa с целым 2: aa+2,  при подходящим
образом описанной функции члене, может быть проинтерпретировано как
aa.operator+(2), но  с 2+aa  это не  может быть сделано, потому что
нет такого класса int, для которого можно было бы определить + так,
чтобы это  означало 2.operator+(aa). Даже если бы такой тип был, то
для того,  чтобы обработать  и 2+aa  и aa+2,  понадобилось  бы  две
различных функции  члена. Так  как компилятор  не знает  смысла  +,
определенного пользователем,  то  не  может  предполагать,  что  он
коммутативен, и  интерпретировать 2+aa  как aa+2.  С этим  примером
могут легко справиться функции друзья.
<br>  Все функции операции по определению перегружены. Функция операция
задает новый смысл операции в дополнение к встроенному определению,
и может  существовать несколько  функций операций  с одним и тем же
именем, если  в типах их параметров имеются отличия, различимые для
компилятора, чтобы он мог различать их при обращении (см. <a HREF=gl4.htm#gl4.6.7>#4.6.7</a>).
<a name=gl6.3>
<h2 align=center>    6.3 Определяемое Преобразование Типа</h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl6.3.1>        6.3.1 Конструкторы   </a>                            
<tr><td width=10></td><TD>    <a HREF=#gl6.3.2>    6.3.2 Операции Преобразования</a>                   
<tr><td width=10></td><TD>     <a HREF=#gl6.3.3>   6.3.3 Неоднозначности              </a>              
</table>
<p>  Приведенная во  введении  реализация  комплексных  чисел  слишком
ограничена, чтобы  она могла  устроить кого-либо,  поэтому ее нужно
расширить. Это будет в основном повторением описанных выше методов.
Например:
<pre>
  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator+(complex, double);
      friend complex operator+(double, complex);

      friend complex operator-(complex, complex);
      friend complex operator-(complex, double);
      friend complex operator-(double, complex);
      complex operator-()     // унарный -

      friend complex operator*(complex, complex);
      friend complex operator*(complex, double);
      friend complex operator*(double, complex);

      // ...
  };
</pre>
<br>  Теперь, имея описание complex, мы можем написать:
<pre>
  void f()
  {
      complex a(1,1), b(2,2), c(3,3), d(4,4), e(5,5);
      a = -b-c;
      b = c*2.0*c;
      c = (d+e)*a;
  }
</pre>
<br>Но писать  функцию для  каждого сочетания complex и double, как это
делалось  выше  для  operator+(),  невыносимо  нудно.  Кроме  того,
близкие  к   реальности  средства   комплексной  арифметики  должны
предоставлять по  меньшей мере  дюжину таких  функций;  посмотрите,
например, на тип complex.
<a name=gl6.3.1>
<h3 ALIGN=CENTER>     6.3.1 Конструкторы </h3>
<p>  Альтернативу  использованию   нескольких  функций  (перегруженных)
составляет  описание   конструктора,  который  по  заданному  double
создает complex. Например:
<pre>
  class complex {
      // ...
      complex(double r) { re=r; im=0; }
  };
</pre>
<br>Конструктор, требующий только один параметр, необязательно вызывать
явно:
<pre>
  complex z1 = complex(23);
  complex z2 = 23;
</pre>
<br>И z1, и z2 будут инициализированы вызовом complex(23).
<br>Конструктор -  это предписание,  как создавать  значение  данного
типа. Когда  требуется значение  типа, и когда такое значение может
быть создано  конструктором, тогда,  если такое значение дается для
присваивания, вызывается конструктор. Например, класс complex можно
было бы описать так:
<pre>
  class complex {
      double re, im;
  public:
      complex(double r, double i = 0) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };
</pre>
<br>и действия,  в которые  будут входить  переменные complex  и  целые
константы,   стали    бы   допустимы.    Целая   константа    будет
интерпретироваться как  complex с  нулевой мнимой частью. Например,
a=b*2 означает:
<pre>
  a=operator*( b, complex( double(2), double(0) ) )
</pre>
<br>  Определенное пользователем преобразование типа применяется неявно
только тогда, когда оно является единственным.
<br>  Объект, сконструированный  с помощью  явного или  неявного вызова
конструктора, является  автоматическим и будет уничтожен при первой
возможности, обычно  сразу же  после оператора,  в котором  он  был
создан.
<a name=gl6.3.2>
<h3 ALIGN=CENTER>     6.3.2 Операции Преобразования </h3>
<p>  Использование  конструктора   для  задания   преобразования  типа
является удобным,  но  имеет  следствия,  которые  могут  оказаться
нежелательными:
<br>  [1]  Не  может  быть  неявного  преобразования  из  определенного
     пользователем типа  в основной тип (поскольку основные типы не
     являются классами);
<br>  [2] Невозможно  задать преобразование из нового типа в старый, не
     изменяя описание старого; и
<br>  [3] Невозможно  иметь конструктор с одним параметром, не имея при
     этом преобразования.
<br>  Последнее не  является серьезной  проблемой, а  с  первыми  двумя
можно   справиться,   определив   для   исходного   типа   операцию
преобразования. Функция  член X::operator  T(), где  T -  имя типа,
определяет преобразование  из X в T. Например, можно определить тип
tiny (крошечный),  который может  иметь значение только в диапазоне
0...63,  но   все  равно  может  свободно  сочетаться  в  целыми  в
арифметических операциях:
<pre>
  class tiny {
      char v;
      int assign(int i)
      { return v = (i&~63) ? (error("ошибка диапазона"),0) : i; }
  public:
      tiny(int i)            { assign(i); }
      tiny(tiny& i)          { v = t.v; }
      int operator=(tiny& i) { return v = t.v; }
      int operator=(int i)   { return assign(i); }
      operator int()         { return v; }
  }
</pre>
<br>Диапазон значения  проверяется всегда,  когда tiny инициализируется
int, и  всегда,  когда  ему  присваивается  int.  Одно  tiny  может
присваиваться  другому  без  проверки  диапазона.  Чтобы  разрешить
выполнять над переменными tiny обычные целые операции, определяется
tiny::operator int(), неявное преобразование из int в tiny. Всегда,
когда в том месте, где требуется int, появляется tiny, используется
соответствующее ему int. Например:
<pre>
  void main()
  {
      tiny c1 = 2;
      tiny c2 = 62;
      tiny c3 = c2 - c1;  // c3 = 60
      tiny c4 = c3;       // нет проверки диапазона (необязательна)
      int i = c1 + c2;    // i = 64
      c1 = c2 + 2 * c1;   // ошибка диапазона: c1 = 0 (а не 66)
      c2 = c1 -i;         // ошибка диапазона: c2 = 0
      c3 = c2;            // нет проверки диапазона (необязательна)
  }
</pre>
<br>  Тип вектор  из tiny  может оказаться более полезным, поскольку он
экономит пространство.  Чтобы сделать  этот  тип  более  удобным  в
обращении, можно использовать операцию индексирования.
<br>  Другое применение  определяемых  операций  преобразования  -  это
типы,  которые   предоставляют  нестандартные  представления  чисел
(арифметика по  основанию 100,  арифметика с  фиксированной точкой,
двоично-десятичное  представление   и  т.п.).   При   этом   обычно
переопределяются такие операции, как + и *.
<br>  Функции преобразования  оказываются особенно полезными для работы
со структурами  данных, когда  чтение  (реализованное  посредством
операции преобразования)  тривиально, в то время как присваивание и
инициализация заметно более сложны.
<br>  Типы istream и ostream опираются на функцию преобразования, чтобы
сделать возможными такие операторы, как  while (cin>>x) cout<>x выше возвращает istream&. Это значение неявно преобразуется к  значению, которое  указывает состояние  cin, а уже
это значение  может  проверяться  оператором  while  (см. <a HREF=gl8.htm#gl8.4.2> #8.4.2</a>). Однако определять  преобразование из  оного типа  в другой так, что
при этом теряется информация, обычно не стоит.
<a name=gl6.3.3>
<h3 ALIGN=CENTER>6.3.3 Неоднозначности </h3>
<p>  Присваивание  объекту   (или  инициализация   объекта)  класса  X
является допустимым,  если или  присваиваемое значение  является X,
или существует  единственное преобразование присваиваемого значения
в тип X.
<br>  В некоторых случаях значение нужного типа может сконструироваться
с  помощью   нескольких  применений   конструкторов  или   операций
преобразования. Это  должно делаться  явно;  допустим  только  один
уровень неявных  преобразований, определенных пользователем. Иногда
значение нужного  типа может  быть сконструировано  более чем одним
способом. Такие случаи являются недопустимыми. Например:
<pre>
  class x { /* ... */ x(int); x(char*); };
  class y { /* ... */ y(int); };
  class z { /* ... */ z(x); };

  overload f;
  x f(x);
  y f(y);

  z g(z);

  f(1);         // недопустимо: неоднозначность f(x(1)) или f(y(1))
  f(x(1));
  f(y(1));
  g("asdf");     // недопустимо: g(z(x("asdf"))) не пробуется
  g(z("asdf"));
</pre>
<br>  Определенные пользователем  преобразования рассматриваются только
в том случае, если без них вызов разрешить нельзя. Например:
<pre>
  class x { /* ... */ x(int); }
  overload h(double), h(x);
  h(1);
</pre>
<br>Вызов мог  бы быть проинтерпретирован или как h(double(1)), или как
h(x(1)), и  был бы  недопустим по правилу единственности. Но первая
интерпретация использует  только стандартное  преобразование и  она
будет выбрана по правилам, приведенным в <a HREF=gl4.htm#gl4.6.7>#4.6.7.</a>
Правила  преобразования   не  являются   ни  самыми   простыми  для
реализации и документации, ни наиболее общими из тех, которые можно
было   бы    разработать.   Возьмем    требование    единственности
преобразования.  Более   общий  подход   разрешил  бы   компилятору
применять любое  преобразование, которое  он  сможет  найти;  таким
образом,   не   нужно   было   бы   рассматривать   все   возможные
преобразования перед  тем, как  объявить  выражение  допустимым.  К
сожалению, это  означало бы,  что смысл  программы зависит от того,
какое преобразование  было найдено.  В результате  смысл  программы
неким образом  зависел бы  от    порядка  описания  преобразования.
Поскольку они  часто находятся в разных исходных файлах (написанных
разными  людьми),   смысл  программы   будет  зависеть  от  порядка
компоновки этих  частей вместе. Есть другой вариант - запретить все
неявные преобразования. Нет ничего проще, но такое правило приведет
либо к  неэлегантным пользовательским  интерфейсам, либо  к  бурному
росту перегруженных  функций, как  это было  в предыдущем разделе с
complex.
<br>  Самый общий подход учитывал бы всю имеющуюся информацию о типах и
рассматривал  бы   все  возможные  преобразования.  Например,  если
использовать предыдущее  описание,  то  можно  было  бы  обработать
aa=f(1), так  как тип  aa определяет единственность толкования. Если
aa является  x, то  единственное, дающее  в результате  x,  который
требуется присваиванием,   -  это f(x(1)),  а если  aa -  это y, то
вместо этого  будет  использоваться  f(y(1)).  Самый  общий  подход
справился бы  и с  g("asdf"), поскольку единственной интерпретацией
этого может  быть   g(z(x("asdf"))). Сложность этого подхода в том,
что он требует расширенного анализа всего выражения для того, чтобы
определить интерпретацию  каждой операции  и  вызова  функции.  Это
приведет к  замедлению компиляции,  а также к вызывающим удивление
интерпретациям и  сообщениям об ошибках, если компилятор рассмотрит
преобразования, определенные в библиотеках и т.п. При таком подходе
компилятор будет  принимать во  внимание  больше,  чем,  как  можно
ожидать, знает пишущий программу программист!
<a name=gl6.4>
<h2 ALIGN=CENTER>     6.4 Константы </h2>
<p>  Константы классового  типа определить  невозможно в том смысле, в
каком 1.2  и 12e3  являются константой  типа  double.  Вместо  них,
однако, часто  можно использовать константы основных типов, если их
реализация обеспечивается  с помощью  функций членов. Общий аппарат
для  этого  дают  конструкторы,  получающие  один  параметр.  Когда
конструкторы просты и подставляются inline, имеет смысл рассмотреть
в  качестве   константы  вызов   конструктора.  Если,  например,  в
  есть   описание  класса   comlpex,   то      выражение
zz1*3+zz2*comlpex(1,2) даст  два вызова  функций, а не пять. К двум
вызовам  функций   приведут  две   операции  *,   а  операция  +  и
конструктор,  к  которому  обращаются  для  создания  comlpex(3)  и
comlpex(1,2), будут расширены inline.
<a name=gl6.5>
<h2 ALIGN=CENTER>     6.5 Большие Объекты </h2>
<p>  При каждом  применении для  comlpex бинарных  операций, описанных
выше,  в   функцию,  которая   реализует  операцию,   как  параметр
передается копия  каждого операнда.  Расходы на копирование каждого
double заметны, но с ними вполне можно примириться. К сожалению, не
все классы  имеют небольшое и удобное представление. Чтобы избежать
ненужного копирования,  можно описать  функции таким образом, чтобы
они получали ссылочные параметры. Например:
<pre>
  class matrix {
      double m[4][4];
  public:
      matrix();
      friend matrix operator+(matrix&, matrix&);
      friend matrix operator*(matrix&, matrix&);
  };
</pre>
<br>  Ссылки  позволяют   использовать  выражения,  содержащие  обычные
арифметические  операции  над  большими  объектами,  без  ненужного
копирования. Указатели  применять нельзя, потому что невозможно для
применения к  указателю смысл  операции переопределить  невозможно.
Операцию плюс можно определить так:
<pre>
  matrix operator+(matrix&, matrix&);
  {
      matrix sum;
      for (int i=0; i<4; i++)
          for (int j=0; j<4; j++)
              sum.m[i][j] = arg1.m[i][j] + arg2.m[i][j];
      return sum;
  }
</pre>
<br>Эта  operator+()   обращается  к   операндам  +  через  ссылки,  но
возвращает значение  объекта. Возврат  ссылки может  оказаться более
эффективным:
<pre>
  class matrix {
      // ...
      friend matrix& operator+(matrix&, matrix&);
      friend matrix& operator*(matrix&, matrix&);
  };
</pre>
<br>Это является  допустимым, но  приводит  к  сложности  с  выделением
памяти. Поскольку ссылка на результат будет передаваться из функции
как  ссылка   на  возвращаемое   значение,  оно   не  может   быть
автоматической переменной.  Поскольку часто операция используется в
выражении больше одного раза, результат не может быть и статической
переменной. Как  правило, его  размещают в  свободной памяти. Часто
копирование возвращаемого  значения оказывается  дешевле (по времени
выполнения, объему кода и объему данных) и проще программируется.
<a name=gl6.6>
<h2 ALIGN=CENTER>     6.6 Присваивание и Инициализация </h2>
<p>  Рассмотрим очень простой класс строк string:
<pre>
  struct string {
      char* p;
      int size;    // размер вектора, на который указывает p

      string(int sz) { p = new char[size=sz]; }
      ~string() { delete p; }
  };
</pre>
<br>  Строка -  это структура  данных, состоящая  из вектора символов и
длины этого  вектора. Вектор создается конструктором и уничтожается
деструктором. Однако,  как показано  в #5.10,  это может привести к
неприятностям. Например:
<pre>
  void f()
  {
      string s1(10);
      string s2(20);
      s1 = s2;
  }
</pre>
<br>будет размещать  два вектора  символов, а  присваивание s1=s2 будет
портить указатель на один из них и дублировать другой. На выходе из
f() для s1 и s2 будет вызываться деструктор и уничтожать один и тот
же вектор  с непредсказуемо  разрушительными последствиями. Решение
этой  проблемы   состоит  в   том,  чтобы  соответствующим  образом
определить присваивание объектов типа string:
<pre>
  struct string {
      char* p;
      int size;    // размер вектора, на который указывает p

      string(int sz) { p = new char[size=sz]; }
      ~string() { delete p; }
      void operator=(string&)
  };

  void string::operator=(string& a)
  {
      if (this == &a) return;      // остерегаться s=s;
      delete p;
      p=new char[size=a.size];
      strcpy(p,a.p);
  }
</pre>
<br>  Это определение  string гарантирует, и что предыдущий пример будет
работать  как   предполагалось.  Однако   небольшое  изменение  f()
приведет к появлению той же проблемы в новом облике:
<pre>
  void f()
  {
      string s1(10);
      s2 = s1;
  }
</pre>
<br>Теперь  создается   только  одна  строка,  а  уничтожается  две.  К
неинициализированному объекту  определенная пользователем операция
присваивания не  применяется. Беглый  взгляд на string::operator=()
объясняет, почему  было неразумно  так делать:  указатель  p  будет
содержать неопределенное  и совершенно  случайное  значение.  Часто
операция  присваивания   полагается  на   то,  что   ее   аргументы
инициализированы. Для  такой инициализации,  как здесь, это не так
по определению. Следовательно, нужно определить похожую, но другую,
функцию, чтобы обрабатывать инициализацию:
<pre>
  struct string {
      char* p;
      int size;    // размер вектора, на который указывает p

      string(int sz) { p = new char[size=sz]; }
      ~string() { delete p; }
      void operator=(string&)
      string(string&);
  };

  void string::string(string& a)
  {
      p=new char[size=a.size];
      strcpy(p,a.p);
  }
</pre>
<br>  Для типа  X инициализацию тем же типом X обрабатывает конструктор
X(X&).  Нельзя   не  подчеркнуть   еще  раз,   что  присваивание  и
инициализация -  разные  действия.  Это  особенно  существенно  при
описании деструктора.  Если класс  X имеет конструктор, выполняющий
нетривиальную работу  вроде освобождения  памяти, то  скорее  всего
потребуется  полный  комплект  функций,  чтобы  полностью  избежать
побитового копирования объектов:
<pre>
  class X {
      // ...
      X(something);  // конструктор: создает объект
      X(&X);         // конструктор: копирует в инициализации
      operator=(X&); // присваивание: чистит и копирует
      ~X();          // деструктор: чистит
  };
</pre>
<br>  Есть еще  два  случая,  когда  объект  копируется:  как  параметр
функции и  как возвращаемое  значение. Когда  передается  параметр,
инициализируется  неинициализированная   до  этого   переменная   -
формальный параметр.  Семантика идентична  семантике инициализации.
То же  самое происходит  при возврате  из функции,  хотя это  менее
очевидно. В обоих случаях будет применен X(X&), если он определен:
<pre>
  string g(string arg)
  {
      return arg;
  }

  main()
  {
      string s = "asdf";
      s = g(s);
  }
</pre>
<br>Ясно,  что  после  вызова  g()  значение  s  обязано  быть  "asdf".
Копирование значения  s в  параметр arg  сложности не представляет:
для этого  надо взывать  string(string&). Для  взятия  копии  этого
значения из  g() требуется  еще один вызов string(string&); на этот
раз инициализируемой  является временная  переменная, которая затем
присваивается s.  Такие переменные,  естественно, уничтожаются  как
положено с помощью  string::~string() при первой возможности.
<a name=gl6.7>
<h2 ALIGN=CENTER>     6.7 Индексирование </h2>
<p>  Чтобы задать  смысл индексов  для  объектов  класса  используется
функция operator[].  Второй параметр  (индекс)  функции  operator[]
может быть  любого типа.  Это  позволяет  определять  ассоциативные
массивы и  т.п. В  качестве примера  давайте  перепишем  пример  из
<a HREF=gl2.htm#gl2.3.10>#2.3.10</a>, где  при написании  небольшой программы для подсчета числа вхождений  слов   в  файле  применялся  ассоциативный  массив.  Там
использовалась   функция.   Здесь   определяется   надлежащий   тип
ассоциативного массива:
<pre>
  struct pair {
      char* name;
      int val;
  };

  class assoc {
      pair* vec;
      int max;
      int free;
  public:
      assoc(int);
      int& operator[](char*);
      void print_all();
  };
</pre>
<br>В  assoc  хранится  вектор  пар  pair  длины  max.  Индекс  первого
неиспользованного элемента  вектора находится  в free.  Конструктор
выглядит так:
<pre>
  assoc::assoc(int s)
  {
      max = (s<16) ? s : 16;
      free = 0;
      vec = new pair[max];
  }
</pre>
<br>При реализации применяется все тот же простой и неэффективный метод
поиска, что использовался в <a HREF=gl2.htm#gl2.10>#2.3.10.</a> Однако при переполнении assoc увеличивается:
<pre>
  #include

  int assoc::operator[](char* p)
  /*
      работа с множеством пар "pair":
      поиск p,
      возврат ссылки на целую часть его "pair"
      делает новую "pair", если p не встречалось
  */
  {
      register pair* pp;

      for (pp=&vec[free-1]; vec<=pp; pp--)
          if (strcmp(p,pp->name)==0) return pp->val;

      if (free==max) {    // переполнение: вектор увеличивается
          pair* nvec = new pair[max*2];
          for ( int i=0; iname = new char[strlen(p)+1];
      strcpy(pp->name,p);
      pp->val = 0;     // начальное значение: 0
      return pp->val;
  }
</pre>
<br>Поскольку представление  assoc скрыто, нам нужен способ его печати.
В следующем  разделе  будет  показано,  как  определить  подходящий
итератор, а здесь мы используем простую функцию печати:
<pre>
  vouid assoc::print_all()
  {
      for (int i = 0; i>buf) vec[buf]++;
      vec.print_all();
  }
</pre>
<a name=gl6.8>
<h2 ALIGN=CENTER>     6.8 Вызов Функции </h2>
<p>  Вызов функции,  то есть запись выражение(список_выражений), можно
проинтерпретировать как  бинарную операцию, и операцию вызова можно
перегружать так  же,  как  и  другие  операции.  Список  параметров
функции operator()  вычисляется  и  проверяется  в  соответствие  с
обычными правилами передачи параметров. Перегружающая функция может
оказаться  полезной   главным  образом   для  определения  типов  с
единственной  операцией  и  для  типов,  у  которых  одна  операция
настолько преобладает,  что другие  в большинстве ситуаций можно не
принимать во внимание.
<br>  Для типа  ассоциативного массива assoc мы не определили итератор.
Это можно  сделать, определив класс assoc_iterator, работа которого
состоит в  том, чтобы в определенном порядке поставлять элементы из
assoc. Итератору  нужен доступ  к данным, которые хранятся в assoc,
поэтому он сделан другом:
<pre>
  class assoc {
  friend class assoc_iterator;
      pair* vec;
      int max;
      int free;
  public:
      assoc(int);
      int& operator[](char*);
  };
</pre>
<br>Итератор определяется как
<pre>
  class assoc_iterator{
      assoc* cs;  // текущий массив assoc
      int i;      // текущий индекс
  public:
      assoc_iterator(assoc& s) { cs = &s; i = 0; }
      pair* operator()()
          { return (ifree)? &cs->vec[i++] : 0; }
  };
</pre>
<br>Надо инициализировать  assoc_iterator для массива assoc, после чего
он будет  возвращать указатель на новую pair из этого массива всякий
раз, когда  его будут  активизировать операцией  (). По  достижении
конца массива он возвращает 0:
<pre>
  main()    // считает вхождения каждого слова во вводе
  {
      const MAX = 256;  // больше самого большого слова
      char buf[MAX];
      assoc vec(512);
      while (cin>>buf) vec[buf]++;
      assoc_iterator next(vec);
      pair* p;
      while ( p = next() )
          cout << p->name << ": " << p->val << "\n";
  }
</pre>
<br>Итераторный  тип  вроде  этого  имеет  преимущество  перед  набором
функций, которые  выполняют ту  же работу:  у него есть собственные
закрытые данные  для хранения  хода  итерации.  К  тому  же  обычно
существенно, чтобы  одновременно могли  работать  много  итераторов
этого типа.
<br>  Конечно, такое  применение объектов  для представления итераторов
никак особенно  с перегрузкой  операций не  связано.  Многие  любят
использовать итераторы  с такими  операциями, как first(), next() и
last() (первый, следующий и последний).
<a name=gl6.9>
<h2 ALIGN=CENTER>     6.9 Класс Строка </h2>
<p>  Вот  довольно   реалистичный  пример   класса   string.   В   нем
производится  учет   ссылок  на   строку  с   целью  минимизировать
копирование  и   в  качестве   констант   применяются   стандартные
символьные строки C++.
<pre>
  #include
  #include

  class string {
      struct srep {
          char* s;           // указатель на данные
          int   n;           // счетчик ссылок
  };
      srep *p;

  public:
      string(char *);        // string x = "abc"
      string();              // string x;
      string(string &);      // string x = string ...
      string& operator=(char *);
      string& operator=(string &);
      ~string();
      char& operator[](int i);

      friend ostream& operator<<(ostream&, string&);
      friend istream& operator>>(istream&, string&);

      friend int operator==(string& x, char* s)
          {return strcmp(x.p->s, s) == 0; }

      friend int operator==(string& x, string& y)
          {return strcmp(x.p->s, y.p->s) == 0; }

      friend int operator!=(string& x, char* s)
          {return strcmp(x.p->s, s) != 0; }

      friend int operator!=(string& x, string& y)
          {return strcmp(x.p->s, y.p->s) != 0; }

  };
</pre>
<br>Конструкторы и деструкторы просты (как обычно):
<pre>
  string::string()
  {
      p = new srep;
      p->s = 0;
      p->n = 1;
  }

  string::string(char* s)
  {
      p = new srep;
      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
  }

  string::string(string& x)
  {
      x.p->n++;
      p = x.p;
  }

  string::~string()
  {
      if (--p->n == 0) {
          delete p->s;
          delete p;
      }
  }
</pre>
<br>  Как обычно,  операции присваивания  очень похожи на конструкторы.
Они должны обрабатывать очистку своего первого (левого) операнда:
<pre>
  string& string::operator=(char* s)
  {
      if (p->n > 1) {    // разъединить себя
          p-n--;
          p = new srep;
      }
      else if (p->n == 1)
          delete p->s;

      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
      return *this;
  }
</pre>
<br>  Благоразумно обеспечить,  чтобы присваивание  объекта самому себе
работало правильно:
<pre>
  string& string::operator=(string& x)
  {
      x.p->n++;
      if (--p->n == 0) {
          delete p->s;
          delete p;
      }
      p = x.p;
      return *this;
  }
</pre>
<br>  Операция вывода задумана так, чтобы продемонстрировать применение
учета ссылок.  Она повторяет  каждую  вводимую  строку  (с  помощью
операции <<, которая определяется позднее):
<pre>
  ostream& operator<<(ostream& s, string& x)
  {
      return s << x.p->s << " [" << x.p->n << "]\n";
  }
</pre>
<br>  Операция ввода  использует стандартную  функцию ввода  символьной
строки (<a HREF=gl8.htm#gl8.4.1>#8.4.1</a>).
<pre>
  istream& operator>>(istream& s, string& x)
  {
      char buf[256];
      s >> buf;
      x = buf;
      cout << "echo: " << x << "\n";
      return s;
  }
</pre>
<br>  Для  доступа   к  отдельным   символам   предоставлена   операция
индексирования. Осуществляется проверка индекса:
<pre>
  void error(char* p)
  {
      cerr << p << "\n";
      exit(1);
  }

  char& string::operator[](int i)
  {
      if (i<0 || strlen(p->s)s[i];
  }
</pre>
<br>  Головная  программа   просто  немного   опробует  действия   над
строками. Она  читает слова  со ввода  в строки, а потом эти строки
печатает. Она  продолжает это делать до тех пор, пока не распознает
строку done,  которая завершает  сохранение слов  в строках, или не
встретит конец  файла. После  этого она  печатает строки в обратном
порядке и завершается.
<pre>
  main()
  {
      string x[100];
      int n;

      cout << "отсюда начнем\n";
      for (n = 0; cin>>x[n]; n++) {
          string y;
          if (n==100) error("слишком много строк");
          cout << (y = x[n]);
          if (y=="done") break;
      }
      cout << "отсюда мы пройдем обратно\n";
      for (int i=n-1; 0<=i; i--) cout << x[i];
  }
</pre>
<a name=gl6.10>
<h2 ALIGN=CENTER>     6.10 Друзья и Члены </h2>
<p>  Теперь, наконец,  можно обсудить,  в каких  случаях для доступа к
закрытой части определяемого пользователем типа использовать члены,
а в  каких  -  друзей.  Некоторые  операции  должны  быть  членами:
конструкторы, деструкторы  и  виртуальные  функции  (см. <a HREF=gl7.htm#gl7> следующую
главу</a>), но обычно это зависит от выбора.
<br>  Рассмотрим простой класс X:
<pre>
  class X {
      // ...
      X(int);
      int m();
      friend int f(X&);
  };
</pre>
<br>Внешне не  видно никаких причин делать f(X&) другом дополнительно к
члену X::m() (или наоборот), чтобы реализовать действия над классом
X.  Однако  член  X::m()  можно  вызывать  только  для  "настоящего
объекта", в  то время  как друг  f() может  вызываться для объекта,
созданного с помощью неявного преобразования типа. Например:
<pre>
  void g()
  {
      1.m();      // ошибка
      f(1);       // f(x(1));
  }
</pre>
<br>  Поэтому  операция,  изменяющее  состояние  объекта,  должно  быть
членом, а не другом. Для определяемых пользователем типов операции,
требующие в  случае фундаментальных типов операнд lvalue (=, *=, ++
и т.д.), наиболее естественно определяются как члены.
<br>  И наоборот,  если нужно  иметь неявное  преобразование  для  всех
операндов операции, то реализующая ее функция должна быть другом, а
не членом.  Это часто  имеет место  для функций,  которые  реализуют
операции, не  требующие  при  применении  к  фундаментальным  типам
lvalue в качестве операндов (+, -, || и т.д.).
<br>Если никакие  преобразования типа  не определены, то оказывается,
что нет  никаких существенных  оснований в  пользу члена, если есть
друг, который  получает ссылочный параметр, и наоборот. В некоторых
случаях  программист   может  предпочитать  один  синтаксис  вызова
другому. Например,  оказывается, что  большинство предпочитает  для
обращения  матрицы   m  запись   m.inv().   Конечно,   если   inv()
действительно обращает  матрицу m,  а не  просто  возвращает  новую
матрицу, обратную m, ей следует быть другом.
<br>  При прочих  равных условиях выбирайте, чтобы функция была членом:
никто  не  знает,  вдруг  когда-нибудь  кто-то  определит  операцию
преобразования.  Невозможно   предсказать,  потребуют   ли  будущие
изменения изменить  статус объекта.  Синтаксис вызова функции члена
ясно указывает  пользователю, что  объект можно изменить; ссылочный
параметр является  далеко не столь очевидным. Кроме того, выражения
в члене  могут быть  заметно короче  выражений в  друге. В  функции
друге надо  использовать явный  параметр, тогда  как в  члене можно
использовать неявный  this. Если  только не применяется перегрузка,
имена членов обычно короче имен друзей.
<a name=gl6.11>
<h2 ALIGN=CENTER>     6.11 Предостережение </h2>
<p>  Как и  большая  часть  возможностей  в  языках  программирования,
перегрузка  операций   может  применяться   как  правильно,  так  и
неправильно. В  частности, можно  так  воспользоваться  возможность
определять новые  значения старых  операций, что  они станут  почти
совсем непостижимы.  Представьте, например,  с  какими  сложностями
столкнется человек,  читающий программу,  в которой операция + была
переопределена для обозначения вычитания.
<br>  Данный аппарат  должен уберечь  программиста/читателя  от  худших
крайностей   применения    перегрузки,   потому   что   программист
предохранен от  изменения  значения  операций  для  основных  типов
данных вроде  int,  а  также  потому,  что  синтаксис  выражений  и
приоритеты операций сохраняются.
<br>  Может быть. разумно применять перегрузку операций главным образом
так, чтобы  подражать  общепринятому  применению  операций.  В  тех
случаях, когда  нет  общепринятой  операции  или  имеющееся  в  C++
множество  операций   не  подходит   для   имитации   общепринятого
применения, можно использовать запись вызова функции.
<a name=gl6.12>
<h2 ALIGN=CENTER>     6.12 Упражнения </h2>
<OL>
<LI> (*2)  Определите   итератор  для   класса  string.  Определите
     операцию конкатенации  + и  операцию "добавить  в  конец"  +=.
     Какие еще операции над string вы хотели бы осуществлять?
 <LI> (*1.5) Задайте  с помощью  перегрузки  ()  операцию  выделения
     подстроки для класса строк.
  <LI> (*3) Постройте  класс string  так,  чтобы  операция  выделения
     подстроки могла  использоваться в  левой  части  присваивания.
     Напишите сначала  версию, в которой строка может присваиваться
     подстроке той  же длины,  а потом  версию, где эти длины могут
     быть разными.
  <LI> (*2) Постройте  класс  string  так,  чтобы  для  присваивания,
     передачи параметров  и т.п.  он имел семантику по значению, то
есть в  тех случаях, когда копируется строковое представление,
     а не просто управляющая структура данных класса sring.
  <LI>(*3) Модифицируйте  класс string  из предыдущего примера таким
     образом,  чтобы   строка   копировалась   только   когда   это
     необходимо.   То    есть,   храните   совместно   используемое
     представление двух  строк, пока  одна из  этих строк  не будет
     изменена. Не  пытайтесь одновременно  с  этим  иметь  операцию
     выделения подстроки,  которая  может  использоваться  в  левой
     части.
 <LI> (*4) Разработайте  класс  string  с  семантикой  по  значению,
     копированием с  задержкой и операцией подстроки, которая может
     стоять в левой части.
 <LI> (*2) Какие  преобразования  используются  в  каждом  выражении
     следующей программы:
<pre>
       struct X {
          int i;
          X(int);
          operator+(int);
       };

       struct Y {
          int i;
          Y(X);
          operator+(X);
          operator int();
       };

       X operator* (X,Y);
       int f(X);

       X x = 1;
       Y y = x;
       int i = 2;

       main()
       {
          i + 10;
          y + 10;
          y + 10 * y;
          x + y + i;
          x * x + i;
          f(7);
          f(y);
          y + y;
          106 + y;
       }
</pre>
<br>     Определите X  и Y  так, чтобы  они  оба  были  целыми  типами.
     Измените программу так, чтобы она работала и печатала значения
     всех допустимых выражений.
<LI> (*2) Определите  класс INT,  который ведет себя в точности как
     int. Подсказка: определите INT::operator int().
 <LI> (*1) Определите  класс RINT, который ведет себя в точности как
     int за исключением того, что единственные возможные операции -
это +  (унарный и  бинарный), - (унарный и бинарный), *, /, %.
     Подсказка: не определяйте $ (R?)INT::operator int().
<LI> (*3)  Определите   класс  LINT,  ведущий  себя  как  RINT  за
     исключением того, что имеет точность не менее 64 бит.
<LI> (*4)  Определите   класс,  который   реализует  арифметику  с
     произвольной точностью.  Подсказка: вам надо управлять памятью
     аналогично тому, как это делалось для класса string.
<LI> (*2) Напишите  программу, доведенную до нечитаемого состояния
     с помощью макросов и перегрузки операций. Вот идея: определите
     для INT  + чтобы  он означал  - и  наоборот, а потом с помощью
     макроопределения определите int как INT. Переопределение часто
     употребляемых  функций,  использование  параметров  ссылочного
     типа и  несколько вводящих  в заблуждение комментариев помогут
     устроить полную неразбериху.
<LI> (*3) Поменяйтесь  со своим  другом программами, которые у вас
     получились в предыдущем упражнении. Не запуская ее попытайтесь
     понять, что  делает программа  вашего друга.  После выполнения
     этого упражнения вы будете знать, чего следует избегать.
<LI> (*2) Перепишите  примеры с  comlpex (<a HREF=#gl6.3.1>#6.3.1</a>), tiny (<a HREF=#gl6.3.2>#6.3.2</a>) и string (<a HREF=#gl6.9>#6.9</a>)  не используя friend функций. Используйте только функции члены.  Протестируйте каждую из новых версий. Сравните их с  версиями, в которых используются функции друзья. Еще раз
     посмотрите Упражнение <a HREF=gl5_2.htm#y5.3>5.3.</a>
<LI> (*2)  Определите  тип  vec4  как  вектор  их  четырех  float.
     Определите operator[]  для vec4.  Определите операции +, -, *,
     /, =,  +=, -=,  *=,  /=  для  сочетаний  векторов  и  чисел  с
     плавающей точкой.
 <LI> (*3) Определите  класс  mat4  как  вектор  из  четырех  vec4.
     Определите для  mat4 operator[], возвращающий vec4. Определите
     для этого  типа обычные  операции  над  матрицами.  Определите
     функцию, которая производит исключение Гаусса для mat4.
<LI> (*2) Определите  класс vector, аналогичный vec4, но с длиной,
     которая      задается      как      параметр      конструктора
     vector::vector(int).
<LI> (*3)  Определите   класс  matrix,   аналогичный  mat4,  но  с
     размерностью,      задаваемой      параметрами      конструктора
     matrix::matrix(int,int).
</ol>
<p><small>
<a name=*6.1>
*<sup>1</sup>  В   некоторых  системах   компоновщик  настолько  "умен",  что
ругается, даже  если не определена  неиспользуемая функция.  В таких
системах этим методом воспользоваться нельзя. (прим автора)
</small>
<p> <center> <font size="-1">
[<a href="gl5_2.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="gl7.htm">Вперед</a>]
</font>
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
