<html>
<head>





<title>Бьярн Страустрап. Введение в язык Си++, Описания и Константы</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<basefont size=3><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<h1 align=center>              Глава 2 </h1>
<a name=gl2>
<h2 align=center >       Описания и Константы </h2>
<center><p>                   Совершенство достигается только к моменту краха.
<br>                                           - С.Н. Паркинсон
</center>
<p>  В этой  главе описаны  основные типы  (char, int, float и т.д.) и
основные способы  построения из них новых типов (функций, векторов,
указателей и т.д.). Имя вводится в программе посредством описания,
которое задает  его  тип  и,  возможно,  начальное  значение.  Даны
понятия описания,  определения,  области  видимости  имен,  времени
жизни объектов  и типов. Описываются способы записи констант в C++,
а также  способы определения символических констант. Примеры просто
демонстрируют  характерные   черты  языка.   Более  развернутый   и
реалистичный пример  приводится в  следующей главе для знакомства с
выражениями  и  операторами  языка  C++.  Механизмы  задания  типов,
определяемых   пользователем,    с    присоединенными    операциями
представлены в Главах <a HREF=gl4.htm>4</a>,<a HREF=gl5_1.htm> 5 </a>и <a HREF=gl6.htm>6 </a>и здесь не упоминаются.
<a name=gl2.1>
<h2 align=center >     2.1 Описания </h2>
<table border=0>
<tr><td width=10></td><TD>  <a HREF=#gl2.1.1>2.1.1 Область Видимости      </a>                  
<tr><td width=10></td><TD>  <a HREF=#gl2.1.2>2.1.2 Объекты и Адреса (Lvalue) </a>                  
<tr><td width=10></td><TD>  <a HREF=#gl2.1.3>2.1.3 Время Жизни    </a>                             
</table>
<p>  Прежде чем  имя (идентификатор)  может быть  использовано в   C++
программе, он  должно быть описано. Это значит, что надо задать его
тип, чтобы  сообщить компилятору,  к какого вида объектам относится
имя. Вот несколько примеров, иллюстрирующих разнообразие описаний:
<pre>
  char ch;
  int count = 1;
  char* name = "Bjarne";
  struct complex { float re, im; };
  complex cvar;
  extern complex sqrt(complex);
  extern int error_number;
  typedef complex point;
  float real(complex* p) { return p->re; };
  const double pi = 3.1415926535897932385;
  struct user;
</pre>
<br>  Как можно  видеть из  этих примеров, описание может делать больше
чем  просто   ассоциировать  тип  с  именем.  Большинство  описаний
являются также  определениями; то  есть они  также  определяют  для
имени сущность,  к которой оно относится. Для ch, count и cvar этой
сущностью   является соответствующий  объем памяти,  который должен
использоваться как переменная - эта память будет выделена. Для real
это   заданная    функция.   Для    constant   pi    это   значение
3.1415926535897932385. Для  complex этой  сущностью является  новый
тип. Для  point это тип complex, поэтому point становится синонимом
complex. Только описания
<pre>
  extern complex sqrt(complex);
  extern int error_number;
  struct user;
</pre>
<br>не являются одновременно определениями. Это означает, что объект, к
которому они  относятся, должен  быть  определен  где-то  еще.  Код
(тело) функции  sqrt  должен  задаваться  неким  другим  описанием,
память для переменной error_number типа int должна выделяться неким
другим описанием,  и какое-то  другое  описание  типа  user  должно
определять, что  он из  себя представляет.  В C++  программе всегда
должно быть  только одно  определение каждого  имени,  но  описаний
может быть  много, и  все описания   должны согласовываться с типом
объекта, к  которому они  относятся, поэтому  в этом фрагменте есть
две ошибки:
<pre>
  int count;
  int count;               // ошибка: переопределение
  exnern int error_number;
  exnern int error_number; // ошибка: несоответствие типов
</pre>
<br>а в этом - ни одной (об использовании extern см. <a HREF=gl4.htm#gl4.2>#4.2</a>):
<pre>
  exnern int error_number;
  exnern int error_number;
</pre>
<br>  Некотрые описания  задают "значение"  для сущностей,  которые они
определяют:
<pre>
  struct complex { float re, im; };
  typedef complex point;
  float real(complex* p) { return  p->re };
  const double pi = 3.1415926535897932385;
</pre>
<br>  Для  типов,   функций  и   констант  "значение"   неизменно;   для
неконстантных типов  данных начальное  значение может  впоследствии
изменяться:
<pre>
  int count = 1;
  char* name = "Bjarne";
  //...
  count = 2;
  name = "Marian";
</pre>
<br>  Из всех определений только
<br>  char ch;
<br>не задает  значение. Всякое  описание, задающее  значение, является
определением.
<a name=gl2.1.1>
<h3 align=center >     2.1.1 Область Видимости </h3>
<p>  Описание вводит  имя в  области видимости;  то  есть,  имя  может
использоваться только  в определенной  части программы.  Для имени,
описанного в  функции (такое  имя часто  называют  локальным),  эта
область видимости  простирается от точки описания до конца блока, в
котором появилось  описание; для  имени не  в функции и не в классе
(называемого   часто    глобальным   именем)    область   видимости
простирается от  точки описания до конца файла, в котором появилось
описание. Описание  имени в блоке может скрывать (прятать) описание
во внутреннем  блоке или  глобальное имя.  Это  значит,  что  можно
переопределять имя  внутри блока для ссылки на другой объект. После
выхода из блока имя вновь обретает свое прежнее значение. Например:
<pre>
  int x;            // глобальное x

  f() {
      int x;        // локальное x прячет глобальное x
      x = 1;        // присвоить локальному x
      {
          int x;    // прячет первое локальное x
          x = 2;    // присвоить второму локальному x
      }
      x = 3;        // присвоить первому локальному x
  }

  int* p = &x;      // взять адрес глобального x
</pre>
<br>  Скрытие имен  неизбежно при  написании больших  программ.  Однако
читающий человек  легко  может  не  заметить,  что  имя  скрыто,  и
некоторые  ошибки,   возникающие  вследствие  этого,  очень  трудно
обнаружить, главным  образом потому, что они редкие. Значит скрытие
имен   следует   минимизировать.   Использование   для   глобальных
переменных имен вроде i или x напрашивается на неприятности.
<br>  С помощью  применения операции  разрешения области  видимости  ::
можно использовать скрытое глобальное имя. Например:
<pre>
  int x;

  f()
  {
      int x = 1;      // скрывает глобальное x
      ::x = 2;        // присваивает глобальному x
  }
</pre>
<br>  Но возможности использовать скрытое локальное имя нет.
<br>  Область  видимости   имени  начинается   в  точке  описания.  Это
означает,  что   имя  можно   использовать  даже  для  задания  его
собственного значения. Например:
<pre>
  int x;

  f()
  {
      int x = x;    // извращение
  }
</pre>
<br>  Это не  является недопустимым,  хотя и бессмысленно, и компилятор
предупредит, что  x "used  before set"  ("использовано до того, как
задано"), если  вы попробуете  так  сделать.  Можно,  напротив,  не
применяя операцию  ::, использовать  одно имя  для  ссылки  на  два
различных объекта в блоке. Например:
<pre>
  int x;

  f()             // извращение
  {
      int y = x;  // глобальное x
      int x = 22;
      y = x;      // локальное x
  }
</pre>
<br>  Переменная y  инициализируется значением  глобального  x,  11,  а
затем ему присваивается значение локальной переменной x, 22.
<br>  Имена параметров  функции считаются  описанными в  самом  внешнем
блоке функции, поэтому
<pre>
  f(int x)
  {
      int x;        // ошибка
  }
</pre>
<br>содержит ошибку,  так как  x определено  дважды в  одной и  той  же
области видимости.
<a name=gl2.1.2>
<h3 align=center >     2.1.2 Объекты и Адреса (Lvalue)</h3>
<p>  Можно назначать  и использовать  переменные, не  имеющие имен,  и
можно   осуществлять   присваивание   выражениям   странного   вида
(например, *p[a+10]=7).  Следовательно, есть  потребность  в  имени
"нечто  в   памяти".  Вот  соответствующая  цитата  из  справочного
руководства  по   C++: "Объект  есть  область  памяти;  lvalue  есть
выражение,   ссылающееся    на   объект"(<a HREF=ref1_7.htm#ref1_7.5>#с.5</a>).    Слово   "lvalue" первоначально было  придумано для значения "нечто, что может стоять
в  левой   части  присваивания".   Однако  не  всякий  адрес  можно
использовать в левой части присваивания; бывают адреса, ссылающиеся
на константу (см. <a HREF=#gl2.4>#2.4</a>).
<a name=gl2.1.3>
<h3 align=center >     2.1.3 Время Жизни </h3>
<p>  Если программист  не указал  иного, то  объект  создается,  когда
встречается его  описание, и уничтожается, когда его имя выходит из
области  видимости,  Объекты  с  глобальными  именами  создаются  и
инициализируются  один   раз  (только)   и  "живут"  до  завершения
программы.   Объекты,  определенные  описанием  с  ключевым  словом
static, ведут себя так же. Например <a HREF=#*2.1>*<sup>1</sup>:</a>
<pre>
  int a = 1;

  void f()
  {
      int b = 1;          // инициализируется при каждом вызове f()
      static int c = 1;   // инициализируется только один раз
      cout << " a = " << a++
           << " b = " << b++
           << " c = " << c++ << "\n";
  }

  main()
  {
      while (a < 4) f();
  }
</pre>
<br>производит вывод
<pre>
  a = 1 b = 1 c = 1
  a = 2 b = 1 c = 2
  a = 3 b = 1 c = 3
</pre>
<br>  Не инициализированная явно статическая (static) переменная неявно
инициализируется нулем.
<br>  С помощью операций new и delete программист может также создавать
объекты,  время  жизни  которых  управляется  непосредственно; см. <a HREF=gl3.htm#gl3.2.4>
#3.2.4</a>.
<a name=gl2.2>
<h2 ALIGN=CENTER>     2.2 Имена </h2>
<p>  Имя (идентификатор)  состоит из  последовательности букв  и цифр.
Первый символ  должен быть  буквой.  Символ  подчерка  _  считается
буквой. C++  не налагает  ограничений на число символов в имени, но
некоторые части реализации находятся вне ведения автора компилятора
(в частности,  загрузчик), и  они, к  сожалению, такие  ограничения
налагают.  Некоторые  среды  выполнения  также  делают  необходимым
расширить   или    ограничить   набор    символов,   допустимых   в
идентификаторе;  расширения   (например,  при  допущении  в  именах
символа $)  порождают непереносимые  программы. В качестве имени не
могут использоваться ключевые слова C++ (см. <a HREF=ref1_7.htm#ref1_7.2.3> #с.2.3</a>). Примеры имен:
<pre>
  hello    this_is_a_most_unusially_long_name
  DEFINED  foO    bAr     u_name    HorseSense
  var0     var1   CLASS   _class    ___
</pre>
<br>  Примеры   последовательностей    символов,   которые   не   могут
использоваться как идентификаторы:
<pre>
  012      a fool    $sys     class    3var
  pay.due  foo~bar   .name    if
</pre>
<br>  Буквы в  верхнем и нижнем регистрах считаются различными, поэтому
Count  и   count  -   различные  имена,   но  вводить  имена,  лишь
незначительно отличающиеся  друг  от  друга,  нежелательно.  Имена,
начинающиеся с  подчерка, по  традиции используются для специальных
средств  среды  выполнения,  поэтому  использовать  такие  имена  в
прикладных программах нежелательно.
<br>  Во время чтения программы компилятор всегда ищет наиболее длинную
строку, составляющую  имя, поэтому  var10 -  это одно имя, а не имя
var, за  которым следует  число 10;  и elseif  -  одно  имя,  а  не
ключевое слово else, после которого стоит ключевое слово if.
<a name=gl2.3>
<h2 align=center>     2.3 Типы </h2>
<table border=0>
<tr><td width=10></td><TD>     <a HREF=#gl2.3.1>2.3.1 Основные Типы   </a>                            
<tr><td width=10></td><TD>      <a HREF=#gl2.3.2>2.3.2 Неявное Преобразование Типа  </a>               
 <tr><td width=10></td><TD>    <a HREF=#gl2.3.3>2.3.3  Производные Типы    </a>                        
 <tr><td width=10></td><TD>    <a HREF=#gl2.3.4>2.3.4  Тип void                   </a>                 
<tr><td width=10></td><TD>     <a HREF=#gl2.3.5>2.3.5  Указатели                 </a>                  
<tr><td width=10></td><TD>     <a HREF=#gl2.3.6>2.3.6  Вектора                     </a>                
<tr><td width=10></td><TD>     <a HREF=#gl2.3.7>2.3.7  Указатели и Вектора    </a>                  
<tr><td width=10></td><TD>     <a HREF=#gl2.3.8>2.3.8  Структуры               </a>                    
<tr><td width=10></td><TD>     <a HREF=#gl2.3.9>2.3.9  Эквивалентность типов </a>                      
<tr><td width=10></td><TD>     <a HREF=#gl2.3.10>2.3.10 Ссылки                      </a>               
<tr><td width=10></td><TD>     <a HREF=#gl2.3.11>2.3.11 Регистры                   </a>                
</table>
<p>  Каждое имя  (идентификатор) в C++ программе имеет ассоциированный
с ним  тип. Этот  тип определяет, какие  операции можно применять к
имени (то  есть к  объекту, на  который оно  ссылается), и  как эти
операции интерпретируются. Например:
<pre>
  int error number;
  float real(complex* p);
</pre>
<br>  Поскольку error_number  описано как  int, его  можно присваивать,
использовать в  арифметических выражениях  и т.д. Тогда как функция
real может вызываться с адресом complex в качестве параметра. Можно
взять адрес  любого из  них. Некоторые  имена, вроде int и complex,
являются именами типов. Обычно имя типа используется в описании для
спецификации другого имени. Единственные отличные от этого действия
над именем  типа -  это sizeof  (для определения количества памяти,
которая требуется  для хранения объекта типа) и new (для размещения
объекта типа в свободной памяти). Например:
<pre>
  main()
  {
      int* p = new int;
      cout << "sizeof(int) = " << sizeof(int) "\n";
  }
</pre>
<br>  Имя  типа   можно   также   использовать   для   задания   явного
преобразования одного типа в другой, например:
<pre>
  float f;
  char* p;
  //...
  long ll = long(p);     // преобразует p в long
  int i = int(f);        // преобразует f в int
</pre>
<a name=gl2.3.1>
<h3 align=center>     2.3.1 Основные Типы </h3>
<p>  В C++  есть набор  основных типов, которые соответствуют наиболее
общим основным единицам памяти компьютера и наиболее общим основным
способам их использования:
<pre>
  char
  short int
  int
  long int
</pre>
<br>для представления целых различных размеров,
<pre>
  float
  double
</pre>
<br>для представления чисел с плавающей точкой,
<pre>
  unsigned char
  unsigned short int
  unsigned int
  unsigned long int
</pre>
<br>для представления  беззнаковых целых,  логических значений, битовых
массивов и  т.п. Для большей компактности записи можно опускать int
в комбинациях  из нескольких  слов, что не меняет смысла; так, long
означает long int, и unsigned означает unsigned int. В общем, когда
в описании опущен тип, он предполагается int. Например:
<pre>
  const a = 1;
  static x;
</pre>
<br>все определяют объект типа int.
<br>  Целый тип  char наиболее удобен для хранения и обработки символов
на данном  компьютере; обычно  это 8-битовый байт. Размеры объектов
C++ выражаются  в единицах  размера char,  поэтому  по  определению
sizeof(char)==1. В  зависимости  от  аппаратного  обеспечения  char
является  знаковым   или  беззнаковым  целым.  Тип  unsigned  char,
конечно, всегда  беззнаковый, и  при его  использовании  получаются
более переносимые  программы, но из-за применения его вместо просто
char могут возникать значительные потери в эффективности.
<br>  Причина того, что предоставляется более чем один целый тип, более
чем один беззнаковый тип и более чем один тип с плавающей точкой, в
том,   чтобы    дать   возможность   программисту   воспользоваться
характерными  особенностями   аппаратного  обеспечения.  На  многих
машинах между  различными разновидностями основных типов существуют
значительные различия  в потребностях  памяти, временах  доступа  к
памяти и  временах вычислений.  Зная машину обычно легко, например,
выбрать  подходящий   тип  для   конкретной  переменной.   Написать
действительно переносимую  программу нижнего  уровня  сложнее.  Вот
все, что гарантируется относительно размеров основных типов:
<pre>
     1==sizeof(char)<=sizeof(short)<= sizeof(int)<=sizeof(long)
     sizeof(float)<=sizeof(double)
</pre>
<br>Однако обычно  разумно предполагать,  что в  char  могут  храниться
целые числа  в диапазоне  0...127 (в  нем  всегда  могут  храниться
символы машинного  набора символов), что short и int имеют не менее
16 бит,  что int  имеет размер, соответствующий целой арифметике, и
что long  имеет по  меньшей мере  24  бита.  Предполагать  что-либо
помимо этого  рискованно, и даже эти эмпирические правила применимы
не  везде.   Таблицу  характеристик   аппаратного  обеспечения  для
некоторых машин можно найти в<a HREF=ref1_7.htm#ref1_7.2.6> #с.2.6.</a>
<br>  Беззнаковые  (unsigned)   целые  типы   идеально   подходят   для
применений, в  которых память  рассматривается  как  массив  битов.
Использование unsigned  вместо int  с тем,  чтобы получить еще один
бит  для   представления  положительных  целых,  почти  никогда  не
оказывается хорошей  идеей. Попытки гарантировать то, что некоторые
значения  положительны,   посредством   описания   переменных   как
unsigned, обычно  срываются из-за  правил неявного  преобразования.
Например:
<pre>
  unsigned surprise = -1;
</pre>
<br>допустимо (но компилятор обязательно сделает предупреждение).
<a name=gl2.3.2>
<h3 align=center >     2.3.2 Неявное Преобразование Типа </h3>
<p>  Основные  типы   можно  свободно   сочетать  в   присваиваниях  и
выражениях. Везде,  где это  возможно, значения  преобразуются так,
чтобы информация не терялась. Точные правила можно найти в<a HREF=ref1_7.htm#ref1_7.6> #с.6.6.</a>
<br>  Существуют  случаи,  в  которых  информация  может  теряться  или
искажаться. Присваивание  значения одного  типа переменной  другого
типа, представление  которого содержит меньшее число бит, неизбежно
является  источником   неприятностей.   Допустим,   например,   что
следующая  часть   программы  выполняется   на  машине  с  двоичным
дополнительным представлением целых и 8-битовыми символами:
<pre>
  int i1 = 256+255;
 char ch = i1        // ch == 255
 int i2 = ch;        // i2 == ?
</pre>
<br>В присваивании  ch=i1 теряется  один бит  (самый значимый!),  и  ch
будет содержать  двоичный код  "все-единицы" (т.е.  8 единиц);  при
присваивании i2  это никак не может превратиться в 511! Но каким же
может быть  значение i2? На DEC VAX, где char знаковые, ответ будет
-1; на AT&T 3B-20, где char беззнаковые, ответ будет 255. В C++ нет
динамического (т.е. действующего во время исполнения) механизма для
разрешения такого  рода проблем,  а выяснение на стадии компиляции
вообще очень сложно, поэтому программист должен быть внимателен.
<a name=gl2.3.3>
<h3 align=center >     2.3.3 Производные Типы </h3>
<p>  Другие  типы   модно  выводить   из  основных   типов  (и  типов,
определенных пользователем) посредством операций описания:
<table border=0>
<TR><TD>  *  </TD><TD>   указатель </TD>
<TR><TD>  &  </TD><TD>   ссылка </TD>
<TR><TD>  []  </TD><TD>  вектор </TD>
<TR><TD>  ()  </TD><TD>  функция </TD>
</table>
<br>и механизма определения структур. Например:
<pre>
  int* a;
  float v[10];
  char* p[20];    // вектор из 20 указателей на символ
  void f(int);
  struct str { short length; char* p; };
</pre>
<br>Правила  построения   типов  с   помощью  этих   операций  подробно
объясняются в  <a HREF=ref8.htm#ref8.3>#с.8.3-4.</a> Основная  идея состоит в том, что описание
производного типа отражает его использование. Например:
<pre>
  int v[10];     // описывает вектор
     i = v[3];      // использует элемент вектора

  int* p;        // описывает указатель
  i = *p;        // использует указываемый объект
</pre>
<br>  Вся сложность  понимания записи  производных типов проистекает из
того, что  операции * и & префиксные, а операции [] () постфиксные,
поэтому для  формулировки типов  в тех  случаях,  когда  приоритеты
операций создают  затруднения, надо  использовать скобки. Например,
поскольку приоритет у [] выше, чем у *, то
<pre>
  int* v[10];        // вектор указателей
  int (*p)[10];      // указатель на вектор
</pre>
<br>Большинство людей  просто помнят,  как  выглядят  наиболее  обычные
типы.
<br>  Описание каждого  имени, вводимого  в программе,  может оказаться
утомительным, особенно если их типы одинаковы. Но можно описывать в
одном описании  несколько имен.  В этом  случае  описание  содержит
вместо одного  имени список  имен, разделенных  запятыми. Например,
два имени можно описать так:
<pre>
  int x, y;    // int x; int y;
</pre>
<br>  При  описании  производных  типов  можно  указать,  что  операции
применяются только  к отдельным  именам (а  не  ко  всем  остальным
именам в этом описании). Например:
<pre>
  int* p, y;        // int* p; int y; НЕ int* y;
  int x, *p;        // int x; int* p;
  int v[10], *p;    // int v[10]; int* p;
</pre>
<br>Мнение автора  таково, что  подобные конструкции  делают  программу
менее удобочитаемой, и их следует избегать.
<a name=gl2.3.4>
<h3 align=center >     2.3.4 Тип void </h3>
<p>  Тип void  (пустой) синтаксически  ведет себя  как  основной  тип.
Однако использовать  его можно  только как часть производного типа,
объектов типа  void не  существует. Он используется для того, чтобы
указать, что  функция не  возвращает значения,  или как базовый тип
для указателей на объекты неизвестного типа.
<pre>
 void f()     // f не возвращает значение
 void* pv;    // указатель на объект неизвестного типа
</pre>
<br>  Переменной типа  void* можно присваивать указатель любого типа. На
первый взгляд  это может показаться не особенно полезным, поскольку
void* нельзя  разыменовать, но  именно это ограничение и делает тип
void*  полезным.  Главным  образом,  он  применяется  для  передачи
указателей функциям,  которые не  позволяют сделать предположение о
типе объекта,  и для возврата из функций нетипизированных объектов.
Чтобы  использовать   такой  объект,   необходимо  применить  явное
преобразование типа.  Подобные функции  обычно находятся  на  самом
нижнем уровне  системы, там,  где осуществляется работа с основными
аппаратными ресурсами. Например:
<pre>
  void* allocate(int size);    // выделить
  void deallocate(void*);      // освободить

  f() {
      int* pi = (int*)allocate(10*sizeof(int));
      char* pc = (char*)allocate(10);
  //...
  deallocate(pi);
  deallocate(pc);
  }
</pre>
<a name=gl2.3.5>
<h3 align=center >     2.3.5 Указатели </h3>
<p>  Для большинства  типов T  T* является  типом указатель  на T.  То
есть, в  переменной типа  T* может  храниться адрес объекта типа T.
Для указателей на вектора и указателей на функции вам, к сожалению,
придется пользоваться более сложной записью:
<pre>
  int* pi;
  char** cpp;             // указатель на указатель на char
  int (*vp)[10];          // указатель на вектор из 10 int'ов
  int (*fp)(char, char*); // указатель на функцию
                          // получающую параметры (char, char*)
                          // и возвращающую int
</pre>
<br> Основная операция над указателем - разыменование, то есть ссылка на
объект,  на   который  указывает   указатель.  Эта  операция  также
называется  косвенным  обращением.  Операция  разыменования  -  это
унарное * (префиксное). Например:
<pre>
 char c1 = 'a';
 char* p = &c1;    // в p хранится адрес c1
 char c2 = *p;    // c2 = 'a'
</pre>
<br>Переменная, на  которую указывает  p,- это  c1, а значение, которое
хранится в  c1, это  'a', поэтому присваиваемое c2 значение *p есть
'a'.
<br>  Над  указателями   можно  осуществлять  некоторые  арифметические
действия. Вот,  например, функция,  подсчитывающая число символов в
строке (не считая завершающего 0):
<pre>
  int strlen(char* p)
  {
      int i = 0;
      while (*p++) i++;
      return i;
  }
</pre>
<br>Другой способ  найти длину состоит в том, чтобы сначала найти конец
строки, а затем вычесть адрес начала строки из адреса ее конца:
<pre>
  int strlen(char* p)
  {
      char* q = p;
      while (*q++) ;
      return q-p-1;
  }
</pre>
<br>  Очень  полезными   могут  оказаться  указатели  на  функции;  они
обсуждаются в  <a HREF=gl4.htm#gl4.6.7>#4.6.7.</a>
<a name=gl2.3.6>
<h3 align=center >     2.3.6 Вектора </h3>
<p>  Для типа  T T[size] является типом "вектор из size элементов типа
T". Элементы индексируются (нумеруются) от 0 до size-1. Например:
<pre>
  float v[3];   // вектор из трех float: v[0], v[1], v[2]
  int a[2][5];  // два вектора из пяти int
  char* vpc;    // вектор из 32 указателей на символ
</pre>
<br>Цикл для  печати целых значений букв нижнего регистра можно было бы
написать так:
<pre>
  extern int strlen(char*);

  char alpha[] = "abcdefghijklmnoprstuvwxyz";

  main()
  {
      int sz = strlen(alpha);

      for (int i=0; i. 
</pre>
<br>Функция strlen() использовалась для подсчета  числа символов  в  alpha;  вместо  этого  можно  было использовать значение  размера  alpha (<a HREF=#gl2.4.4> #2.4.4</a>).  Если  применяется набор символов ASCII, то выдача выглядит так:
<pre>
  'a' = 97 = 0141 = 0x61
  'b' = 98 = 0142 = 0x62
  'c' = 99 = 0143 = 0x63
  ...
</pre>
<br>  Заметим,  что   задавать  размер   вектора  alpha  необязательно;
компилятор считает  число символов в символьной строке, указанной в
качестве инициализатора.  Использование строки  как  инициализатора
для вектора  символов -  удобное, но  к  сожалению  и  единственное
применение строк.  Аналогичное этому  присваивание  строки  вектору
отсутствует. Например:
<pre>
  char v[9];
  v = "строка";          // ошибка
</pre>
<br>ошибочно, поскольку присваивание не определено для векторов.
<br>  Конечно, для инициализации символьных массивов подходят не только
строки. Для  остальных типов  нужно применять более сложную запись.
Эту запись можно использовать и для символьных векторов. Например:
<pre>
  int  v1[] = { 1, 2, 3, 4 };
  int  v2[] = { 'a', 'b', 'c', 'd' };

  char v3[] = { 1, 2, 3, 4 };
  char v4[] = { 'a', 'b', 'c', 'd' };
</pre>
<br>  Заметьте, что  v4 - вектор из четырех (а не пяти) символов; он не
оканчивается нулем,  как того  требуют  соглашение  и  библиотечные
подпрограммы.  Обычно   применение  такой   записи   ограничивается
статическими объектами.
<br>  Многомерные  массивы   представляются  как  вектора  векторов,  и
применение записи  через запятую,  как  это  делается  в  некоторых
других языках,  дает ошибку  при компиляции,  так как  запятая  (,)
является операцией последования (см. <a HREF=gl3.htm#gl3.2.2>#3.2.2</a>). Попробуйте, например, сделать так:
<pre>
  int bad[5,2];    // ошибка
</pre>
<br>и так:
<pre>
  int v[5][2];
  int bad = v[4,1];      // ошибка
  int good = v[4][1];    // ошибка

  Описание

  char v[2][5];
</pre>
<br>описывает вектор  из двух  элементов, каждый  из  которых  является
вектором типа  char[5]. В следующем примере первый из этих векторов
инициализируется первыми  пятью буквами,  а второй  - первыми пятью
цифрами.
<pre>
  char v[2][5] = {
      'a', 'b', 'c', 'd', 'e',
      '0', '1', '2', '3', '4'
  }

  main() {
      for (int i = 0; i<2; i++) {
          for (int j = 0; j<5; j++)
              cout << "v[" << i << "][" << j
                   << "]=" << chr(v[i][j]) << "  ";
          cout << "\n";
      }
  }
</pre>
<br>это дает в результате
<pre>
  v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e
  v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4
</pre>
<a name=gl2.3.7>
<h3 align=center >     2.3.7 Указатели и Вектора </h3>
<p>  Указатели и  вектора в C++ связаны очень тесно. Имя вектора можно
использовать как  указатель на его первый элемент, поэтому пример с
алфавитом можно было написать так:
<pre>
  char alpha[] = "abcdefghijklmnopqrstuvwxyz";
  char* p = alpha;
  char ch;

  while (ch = *p++)
      cout << chr(ch) << " = " << ch
           << " = 0" << oct(ch) << "\n";
</pre>
<br>  Описание p можно было также записать как
<pre>
  char* p = &alpha[0];
</pre>
<br>  Эта эквивалентность  широко используется  в  вызовах  функций,  в
которых векторный  параметр  всегда  передается  как  указатель  на
первый элемент вектора; так, в примере
<pre>
  extern int strlen(char*);
  char v[] = "Annemarie";
  char* p = v;
  strlen(p);
  strlen(v);
</pre>
<br>функции strlen  в обоих  вызовах передается  одно и то же значение.
Вся штука  в  том,  что  этого  невозможно  избежать;  то  есть  не
существует способа  описать функцию  так, чтобы  вектор v  в вызове
функции копировался (<a HREF=gl4.htm#gl4.6.3> #4.6.3</a>).
<br>  Результат применения  к указателям  арифметических операций +, -,
++ или  -- зависит от типа объекта, на который они указывают. Когда
к  указателю   p  типа   T*  применяется  арифметическая  операция,
предполагается, что p указывает на элемент вектора объектов типа T;
p+1 означает  следующий элемент  этого вектора,  а p-1 - предыдущий
элемент. Отсюда следует, что значение p+1 будет на sizeof(T) больше
значения p. Например, выполнение
<pre>
  main()
  {
      char cv[10];
      int iv[10];

      char* pc = cv;
      int* pi = iv;

      cout << "char* " << long(pc+1)-long(pc) << "\n";
      cout << "int*  " << long(ic+1)-long(ic) << "\n";
  }
</pre>
<br>дает
<pre>
  char* 1
 int*  4
</pre>
<br>поскольку на моей машине каждый символ занимает один байт, а каждое
целое занимает  четыре байта.  Перед вычитанием значения указателей
преобразовывались к  типу long с помощью явного преобразования типа
(<a HREF=gl3.htm#gl3.2.5>#3.2.5</a>). Они  преобразовывались к  long, а  не к "очевидному" int, поскольку есть  машины, на  которых указатель  не влезет  в int (то
есть, sizeof(int)
<a name=gl2.3.8>
<h3 align=center > 2.3.8 Структуры </h3>
<p>  Вектор есть  совокупность элементов  одного типа; struct является
совокупностью элементов (практически) произвольных типов. Например:
<pre>
  struct address {        // почтовый адрес
  char* name;         // имя "Jim Dandy"
  long  number;       // номер дома 61
  char* street;       // улица "South Street"
  char* town;         // город "New Providence"
  char* state[2];     // штат 'N' 'J'
  int   zip;          // индекс 7974
 }
</pre>
<br>определяет новый тип, названный address (почтовый адрес), состоящий
из  пунктов,   требующихся  для  того,  чтобы  послать  кому-нибудь
корреспонденцию (вообще говоря, address не является достаточным для
работы  с   полным  почтовым   адресом,     но  в  качестве  примера
достаточен). Обратите внимание на точку с запятой в конце; это одно
из очень  немногих мест  в C++,  где  необходимо  ставить  точку  с
запятой после  фигурной скобки,  поэтому люди  склонны забывать  об
этом.
<br>  Переменные типа address могут описываться точно также, как другие
переменные, а  доступ  к  отдельным  членам  получается  с  помощью
операции . (точка). Например:
<pre>
  address jd;
  jd.name = "Jim Dandy";
  jd.number = 61;
</pre>
<br>  Запись, которая  использовалась для инициализации векторов, можно
применять и к переменным структурных типов. Например:
<pre>
  address jd = {
      "Jim Dandy",
      61, "South Street",
      "New Providence", {'N','J'}, 7974
  };
</pre>
<br>  Однако обычно  лучше использовать конструктор (<a HREF=gl5_1.htm#gl5_1.2.4>#5.2.4</a>). Заметьте, что нельзя  было бы  инициализировать jd.state строкой "NJ". Строки
оканчиваются символом  '\0', поэтому в "NJ" три символа, то есть на
один больше, чем влезет в jd.state.
<br>  К структурным  объектам часто  обращаются посредством  указателей
используя операцию ->. Например:
<pre>
  void print_addr(address* p)
  {
      cout << p->name << "\n"
          << p->number << " " << p->street << "\n"
          << p->town << "\n"
          << chr(p->state[0]) << chr(p->state[1])
          << " " << p->zip << "\n";
  }
</pre>
<br>  Объекты типа структур можно присваивать, передавать как параметры
функции и возвращать из функции в качестве результата. Например:
<pre>
  address current;

  address set_current(address next)
  {
      address prev = current;
      current = next;
      return prev;
  }
</pre>
<br>  Остальные осмысленные  операции, такие как сравнение (== и !=) не
определены. Однако  пользователь может определить эти операции; см.
<a HREF=gl6.htm>Главу 6.</a>
<br>  Размер объекта  структурного типа  нельзя  вычислить  просто  как
сумму его  членов. Причина  этого состоит  в том, что многие машины
требуют, чтобы  объекты определенных  типов выравнивались  в памяти
только по  некоторым зависящим  от архитектуры  границам  (типичный
пример: целое  должно быть  выравнено по  границе слова) или просто
гораздо более  эффективно  обрабатывают  такие  объекты,  если  они
выравнены в  машине. Это  приводит к "дырам" в структуре. Например,
(на моей  машине) sizeof (address) равен 24, а не 22, как можно было
ожидать.
<br>  Заметьте, что имя типа становится доступным сразу после того, как
оно встретилось,  а не только после того, как полностью просмотрено
все описание. Например:
<pre>
  struct link{
      link* previous;
      link* successor;
  }
</pre>
<br>Новые объекты  структурного типа не могут быть описываться, пока все
описание не просмотрено, поэтому
<pre>
  struct no_good {
      no_good member;
  };
</pre>
<br>является ошибочным (компилятор не может установить размер no_good).
Чтобы дать возможность двум (или более) структурным типам ссылаться
друг на  друга, можно просто описать имя как имя структурного типа.
Например:
<pre>
  struct list;        // должна быть определена позднее

  struct link {
      link* pre;
      link* suc;
      link* member_of;
  };

  struct list {
      link* head;
  }
</pre>
<br>Без первого описания list описание link вызвало бы к синтаксическую
ошибку.
<a name=gl2.3.9>
<h3 align=center >     2.3.9 Эквивалентность типов </h3>
<p>  Два структурных  типа являются  различными даже  когда они  имеют
одни и те же члены. Например:
<pre>
  struct s1 { int a; };
  struct s2 { int a; };
</pre>
<br>есть два разных типа, поэтому
<pre>
  s1 x;
  s2 y = x;    // ошибка: несоответствие типов
</pre>
<br>Структурные типы отличны также от основных типов, поэтому
<pre>
  s1 x;
  int i = x;    // ошибка: несоответствие типов
</pre>
<br>  Однако, существует  механизм для  описания нового  имени для типа
без введения нового типа. Описание с префиксом typedef описывает не
новую переменную данного типа, а новое имя этого типа. Например:
<pre>
  typedef char* Pchar;
  Pchar p1, p2;
  char* p3 = p1;
</pre>
<br>  Это может служить удобной сокращенной записью.
<a name=gl2.3.10>
<h3 align=center >     2.3.10 Ссылки </h3>
<p>  Ссылка является  другим именем объекта. Главное применение ссылок
состоит   в   спецификации   операций   для   типов,   определяемых
пользователем; они  обсуждаются в <a HREF=gl6.htm> Главе 6.</a>  Они могут  также  быть
полезны в качестве параметров функции. Запись x& означает ссылка на
x. Например:
<pre>
  int i = 1;
  int& r = i;    // r и i теперь ссылаются на один int
  int x = r      // x = 1
  r = 2;         // i = 2;
</pre>
<br>  Ссылка должна быть инициализирована (должно быть что-то, для чего
она является именем). Заметьте, что инициализация ссылки есть нечто
совершенно отличное от присваивания ей.
<br>  Вопреки  ожиданиям,  ни одна  операция  на  ссылку  не  действует.
Например,
<pre>
  int ii = 0;
  int& rr = ii;
  rr++;        // ii увеличивается на 1
</pre>
<br>допустимо,  но   rr++  не   увеличивает  ссылку;  вместо  этого  ++
применяется к  int, которым  оказывается ii.  Следовательно,  после
инициализации значение  ссылки не  может быть  изменено; она всегда
ссылается на объект, который ей было дано обозначать (денотировать)
при инициализации. Чтобы получить указатель на объект, денотируемый
ссылкой rr, можно написать &rr.
<br>  Очевидным  способом   реализации  ссылки   является   константный
указатель, который  разыменовывается при  каждом использовании. Это
делает    инициализацию  ссылки  тривиальной,  когда  инициализатор
является lvalue  (объектом, адрес  которого вы  можете  взять,  см.
<a HREF=ref1_7.htm#ref1_7.5>#с.5</a>).   Однако инициализатор  для &T  не обязательно  должен  быть lvalue, и даже не должен быть типа T. В таких случаях:
<br>  [1] Во-первых,  если необходимо,  применяются преобразование типа
     (<a HREF=ref1_7.htm#ref1_7.6.6>#с.6.6-8</a>, <a HREF=ref8.htm#ref8.5.6>#с.8.5.6</a>);
<br>  [2] Затем полученное значение помещается во временную переменную;
     и
<br>  [3]  Наконец,   ее  адрес   используется  в   качестве   значения
     инициализатора.
<br>Рассмотрим описание
<pre>
  double& dr = 1;
</pre>
<br>Это интерпретируется так:
<pre>
  double* drp;    // ссылка, представленная как указатель
  double temp;
  temp = double(1);
  drp = &temp;
</pre>
<br>  Ссылку можно  использовать для  реализации функции,  которая, как
предполагается, изменяет значение своего параметра.
<pre>
  int x = 1;
  void incr(int& aa) { aa++; }
  incr(x)                 // x = 2
</pre>
<br>  По определению  семантика передачи параметра та же, что семантика
инициализации, поэтому  параметр aa  функции incr становится другим
именем  для   x.  Однако,   чтобы  сделать  программу  читаемой,  в
большинстве случаев  лучше всего избегать функций, которые изменяют
значение своих  параметров. Часто  предпочтительно явно  возвращать
значение из функции или требовать в качестве параметра указатель:
<pre>
  int x = 1;
  int next(int p) { return p+1; }
  x = next(x);            // x = 2

  void inc(int* p) { (*p)++; }
  inc(&x);                // x = 3
</pre>
<br>  Ссылки также  можно применять  для определения  функций,  которые
могут использоваться  и в  левой, и  в правой  части  присваивания.
Опять,   большая    часть   наиболее   интересных   случаев   этого
обнаруживается   в    проектировании   нетривиальных   определяемых
пользователем  типов.   Для  примера   давайте  определим   простой
ассоциативный массив. Вначале мы определим структуру пары следующим
образом:
<pre>
  struct pair {
      char* name;
      int val;
  };
</pre>
<br>  Основная идея  состоит в  том, что строка имеет ассоциированное с
ней целое значение. Легко определить функцию поиска find(), которая
поддерживает структуру  данных, состоящую из одного pair для каждой
отличной от других  строки, которая была ей представлена.
Для  краткости   представления  используется   очень   простая   (и
неэффективная) реализация:
<pre>
  const large = 1024;
  static pair vec[large+1};

  pair* find(char* p)
  /*
      поддерживает множество пар "pair":
      ищет p, если находит, возвращает его "pair",
      иначе возвращает неиспользованную "pair"
  */
  {
      for (int i=0; vec[i].name; i++)
          if (strcmp(p,vec[i].name)==0) return &vec[i];

      if (i == large) return &vec[large-1];

      return &vec[i];
  }
</pre>
<br>  Эту  функцию  может  использовать  функция  value(),  реализующая
массив целых,  индексированный символьными строками (вместо обычного
способа):
<pre>
   int& value(char* p)
  {
      pair* res = find(p);
      if (res->name == 0) {       // до сих пор не встречалось:
               res->name = new char[strlen(p)+1];  // инициализировать
      strcpy(res->name,p);
      res->val = 0;             // начальное значение 0
      }
      return res->val;
  }
</pre>
<br>Для данной в качестве параметра строки value() находит целый объект
(а не  значение соответствующего целого); после чего она возвращает
ссылку на него. Ее можно использовать, например, так:
<pre>
  const MAX = 256;    // больше самого большого слова

  main()
  // подсчитывает число вхождений каждого слова во вводе
  {
      char buf[MAX];

      while (cin>>buf) value(buf)++;

      for (int i=0; vec[i].name; i++)
          cout << vec[i].name << ": " << vec [i].val << "\n";
  }
</pre>
<br>На каждом  проходе цикл  считывает одно слово из стандартной строки
ввода cin  в buf  (см. <a HREF=gl8.htm>Главу  8</a>), а затем обновляет связанный с ней
счетчик с помощью  find(). И, наконец, печатается полученная таблица
различных  слов   во  введенном   тексте,  каждое   с  числом   его
встречаемости. Например, если вводится
<pre>
  aa bb bb aa aa bb aa aa
</pre>
<br>то программа выдаст:
<pre>
  aa: 5
  bb: 3
</pre>
<br>  Легко   усовершенствовать   это   в   плане   собственного   типа
ассоциированного массива с помощью класса с перегруженной операцией
(<a HREF=gl6.htm#gl6.7>#6.7</a>) выбора [].
<a name=gl2.3.11>
<h3 align=center >     2.3.11 Регистры </h3>
<p>  Во многих  машинных архитектурах  можно обращаться  к (небольшим)
объектам заметно быстрее, когда они помещены в регистр. В идеальном
случае  компилятор   будет  сам  определять  оптимальную  стратегию
использования всех  регистров, доступных  на  машине,  для  которой
компилируется программа.  Однако это  нетривиальная задача, поэтому
иногда программисту  стоит дать подсказку компилятору. Это делается
с помощью описания объекта как register. Например:
<pre>
  register int i;
  register point cursor;
  register char* p;
</pre>
<br>Описание register  следует использовать только в тех случаях, когда
эффективность действительно  важна. Описание  каждой переменной как
register засорит  текст программы  и  может  даже  увеличить  время
выполнения  (обычно  воспринимаются  все  инструкции  по  помещению
объекта в регистр или удалению его оттуда).
<br>  Невозможно получить адрес имени, описанного как register, регистр
не может также быть глобальным.
<a name=gl2.4>
<h2 align=center >     2.4 Константы </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl2.4.1>2.4.1  Целые Константы        </a>                     
<tr><td width=10></td><TD>    <a HREF=#gl2.4.2>2.4.2  Константы с Плавающей Точкой </a>               
<tr><td width=10></td><TD>    <a HREF=#gl2.4.3>2.4.3  Символьные Константы </a>                      
<tr><td width=10></td><TD>    <a HREF=#gl2.4.4>2.4.4  Строки         </a>                             
<tr><td width=10></td><TD>    <a HREF=#gl2.4.5>2.4.5  Ноль            </a>                            
<tr><td width=10></td><TD>    <a HREF=#gl2.4.6>2.4.6  Const            </a>                           
<tr><td width=10></td><TD>    <a HREF=#gl2.4.7>2.4.7  Перечисления     </a>                           
</table>
<p>  C++ дает  возможность записи  значений основных типов: символьных
констант, целых констант и констант с плавающей точкой. Кроме того,
ноль (0)  может использоваться  как константа  любого указательного
типа, и  символьные строки  являются константами типа char[]. Можно
также задавать  символические константы.  Символическая константа -
это имя,  значение которого  не может  быть изменено  в его области
видимости. В  C++ имеется  три  вида  символических  констант:  (1)
любому значению  любого типа  можно дать имя и использовать его как
константу,  добавив  к  его  описанию  ключевое  слово  const;  (2)
множество целых  констант может быть определено как перечисление; и
(3) любое имя вектора или функции является константой.
<a name=gl2.4.1>
<h3 align=center >     2.4.1 Целые Константы </h3>
<p>  Целые  константы   предстают  в   четырех  обличьях:  десятичные,
восьмеричные, шестнадцатиричные  и символьные константы. Десятичные
используются чаще всего и выглядят так, как можно было бы ожидать:
<pre>
  0    1234    976    12345678901234567890
</pre>
<br>Десятичная константа  имеет тип int, при условии, что она влезает в
int,  в   противном  случае   ее  тип   long.   Компилятор   должен
предупреждать   о    константах,   которые   слишком   длинны   для
представления в машине.
<br>  Константа, которая  начинается нулем  за  которым  идет  x  (0x),
является шестнадцатиричным  числом (с  основанием 16), а константа,
которая     начинается  нулем   за  которым  идет  цифра,  является
восьмеричным числом  (с основанием  8).  Вот  примеры  восьмеричных
констант:
<pre>
  0        02        077        0123
</pre>
<br>их десятичные  эквиваленты -  это 0, 2, 63, 83. В шестнадцатиричной
записи эти константы выглядят так:
<pre>
  0x0      0x2       0x3f       0x53
</pre>
<br>Буквы a,  b, c,  d, e  и f,  или их эквиваленты в верхнем регистре,
используются для  представления чисел  10, 11.  12, 13,  14  и  15,
соответственно. Восьмеричная  и шестнадцатиричная  записи  наиболее
полезны для  записи  набора  битов;  применение  этих  записей  для
выражения обычных  чисел может привести к неожиданностям. Например,
на машине,  где  int  представляется  как  двоичное  дополнительное
шестнадцатеричное целое,  0xffff является  отрицательным десятичным
числом -1;  если бы для представления целого использовалось большее
число битов, то оно было бы числом 65535.
<a name=gl2.4.2>
 <h3 align=center >    2.4.2 Константы с Плавающей Точкой </h3>
<p>  Константы с плавающей точкой имеют тип double. Как и в предыдущем
случае, компилятор  должен предупреждать  о константах  с плавающей
точкой, которые  слишком велики,  чтобы их  можно было представить.
Вот некоторые константы с плавающей точкой:
<pre>
  1.23    .23      0.23     1.    1.0     1.2e10    1.23e-15
</pre>
<br>Заметьте, что  в середине  константы с  плавающей точкой  не  может
встречаться пробел.  Например, 65.43  e-21 является не константой с
плавающей точкой,  а  четырьмя  отдельными  лексическими  символами
(лексемами):
<pre>
  65.43    e    -    21
</pre>
<br>и вызовет синтаксическую ошибку.
<br>  Если вы  хотите иметь константу с плавающей точкой типа float, вы
можете определить ее так (<a HREF=#gl2.4.6>#2.4.6</a>):
<pre>
  const float pi = 3.14159265;
</pre>
<a name=gl2.4.3>
<h3 align=center >     2.4.3 Символьные Константы </h3>
<p>  Хотя в  C++ и  нет отдельного  символьного типа  данных,  точнее,
символ может  храниться в  целом типе,  в нем  для символов имеется
специальная и  удобная запись.  Символьная константа  - это символ,
заключенный в  одинарные кавычки;  например,  'a'  или  '0'.  Такие
символьные константы  в  действительности  являются  символическими
константами для  целого значения  символов в  наборе  символов  той
машины,  на   которой  будет   выполняться  программа  (который  не
обязательно  совпадает  с  набором  символов,  применяемом  на  том
компьютере,  где   программа  компилируется).   Поэтому,  если   вы
выполняетесь на  машине,  использующей  набор  символов  ASCII,  то
значением '0'  будет 48,  но если ваша машина использует EBCDIC, то
оно будет  240. Употребление  символьных констант вместо десятичной
записи делает программу более переносимой. Несколько символов также
имеют стандартные  имена,   в которых обратная косая \ используется
как escape-символ:
<table border=0>
<TR><TD>      '\b'  </TD><TD>  возврат назад </TD>
<TR><TD>      '\f'   </TD><TD>    перевод формата </TD>
<TR><TD>      '\n'   </TD><TD>    новая строка </TD>
<TR><TD>      '\r'    </TD><TD>   возврат каретки </TD>
<TR><TD>      '\t'    </TD><TD>   горизонтальная табуляция </TD>
<TR><TD>      '\v'   </TD><TD>    вертикальная табуляция </TD>
<TR><TD>      '\\'    </TD><TD>   обратная косая (обратный слэш) </TD>
<TR><TD>      '\''    </TD><TD>   одинарная кавычка </TD>
<TR><TD>      '\"'   </TD><TD>    двойная кавычка </TD>
<TR><TD>      '\0'   </TD><TD>    null, пустой символ, целое значение 0 </TD>
</table>
<br>  Вопреки их  внешнему виду  каждое является  одним символом. Можно
также представлять  символ одно-, дву- или трехзначным восьмеричным
числом (символ  \, за  которым идут восьмеричные цифры), или одно-,
дву- или  трехзначным шестнадцатиричным числом (\x, за которым идут
шестнадцатиричные цифры). Например:
<pre>
  '\6'      '\x6'        6        ASCII ack
  '\60'     '\x30'       48       ASCII '0'
  '\137'    '\x05f'      95       ASCII '_'
</pre>
<br>Это  позволяет  представлять  каждый  символ  из  машинного  набора
символов, и в частности вставлять такие символы в символьные строки
(см. следующий  раздел). Применение  числовой записи  для  символов
делает программу непереносимой между машинами с различными наборами
символов.
<a name=gl2.4.4>
<h3 align=center >     2.4.4 Строки </h3>
<p>  Строковая   константа    -   это   последовательность   символов,
заключенная в двойные кавычки:
<pre>
  "это строка"
</pre>
<br>Каждая строковая  константа содержит  на один  символ  больше,  чем
кажется; все они заканчиваются пустым символом '\0' со значением 0.
Например:
<pre>
  sizeof("asdf")==5;
</pre>
<br>  Строка имеет  тип "вектор  из соответствующего  числа  символов",
поэтому "asdf"  имеет тип char[5]. Пустая строка записывается "" (и
имеет  тип   char[1]).  Заметьте,   что   для   каждой   строки   s
strlen(s)==sizeof(s)-1, поскольку strlen() не учитывает завершающий
0.
<br>  Соглашение о  представлении  неграфических  символов  с  обратной
косой  можно   использовать  также   и  внутри   строки.  Это  дает
возможность представлять  в строке  двойные кавычки и escape-символ
\. Самым  обычным символом  этого рода является, безусловно, символ
новой строки '\n'. Например:
<pre>
  cout << "гудок в конце сообщения\007\n"
</pre>
<br>где 7 - значение ASKII символа bel (звонок).
<br>  В строке невозможно иметь "настоящую" новую строку:
<pre>
  "это не строка,
  а синтаксическая ошибка"
</pre>
<br>Однако в  строке может  стоять обратная  косая, сразу после которой
идет новая строка; и то, и другое будет проигнорировано. Например:
<pre>
  cout << "здесь все \
  ok"
</pre>
<br>напечатает
<pre>
  здесь все ok
</pre>
<br>Новая строка,  перед  которой  идет  escape  (обратная  косая),  не
приводит  к   появлению  в   строке  новой   строки,   это   просто
договоренность о записи.
<br>  В строке  можно иметь  пустой символ,  но большинство программ не
будет предполагать,  что есть символы после  него. Например, строка
"asdf\000hjkl" будет  рассматриваться стандартными функциями, вроде
strcpy() и strlen(), как "asdf".
<br>  Вставляя численную  константу в строку с помощью восьмеричной или
шестнадцатиричной записи благоразумно всегда использовать число из
трех цифр.  Читать запись  достаточно трудно  и  без  необходимости
беспокоиться о  том, является  ли символ после константы цифрой или
нет. Разберите эти примеры:
<pre>
  char v1[] = "a\x0fah\0129";    // 'a' '\xfa' 'h' '\12' '9'
  char v2[] = "a\xfah\129";      // 'a' '\xfa' 'h' '\12' '9'
  char v3[] = "a\xfad\127";      // 'a' '\xfad' '\127'
</pre>
<br>Имейте в виду, что двузначной шестнадцатиричной записи на машинах с
9-битовым байтом будет недостаточно.
<a name=gl2.4.5>
<h3 align=center >     2.4.5 Ноль </h3>
<p>  Ноль  (0)   можно  употреблять   как  константу   любого  целого,
плавающего или указательного типа. Никакой объект не размещается по
адресу  0.  Тип  нуля  определяется  контекстом.    Обычно  (но  не
обязательно)   он    представляется    набором    битов    все-нули
соответствующей длины.
<a name=gl2.4.6>
<h3 align=center >     2.4.6 Const </h3>
<p>  Ключевое слово  const  может добавляться к описанию объекта, чтобы
сделать этот объект константой, а не переменной. Например:
<pre>
  const int model = 145;
  const int v[] = { 1, 2, 3, 4 };
</pre>
<br>  Поскольку константе  ничего нельзя  присвоить,  она  должна  быть
инициализирована. Описание  чего-нибудь как  const гарантирует, что
его значение не изменится в области видимости:
<pre>
  model = 145;        // ошибка
  model++;            // ошибка
</pre>
<br>  Заметьте, что  const изменяет  тип, то  есть ограничивает  способ
использования  объекта,   вместо  того,   чтобы   задавать   способ
размещения константы.  Поэтому например  вполне разумно, а иногда и
полезно, описывать функцию как возвращающую const:
<pre>
  const char* peek(int i)
  {
      return private[i];
  }
</pre>
<br>Функцию вроде  этой можно  было бы  использовать  для  того,  чтобы
давать кому-нибудь читать строку, которая не может быть затерта или
переписана (этим кем-то).
<br>  С   другой   стороны,   компилятор   может   несколькими   путями
воспользоваться тем,  что объект  является константой  (конечно,  в
зависимости от того, насколько он сообразителен). Самое очевидное -
это то,  что для  константы не требуется выделять память, поскольку
компилятор знает  ее значение.  Кроме того, инициализатор константы
часто (но  не всегда)  является константным  выражением, то есть он
может быть  вычислен  на  стадии  компиляции.  Однако  для  вектора
констант обычно  приходится выделять память, поскольку компилятор в
общем случае  не может вычислить, на какие элементы вектора сделаны
ссылки в  выражениях. Однако  на многих  машинах даже в этом случае
может достигаться повышение эффективности путем размещения векторов
констант в память, доступную только для чтения.
<br>  Использование указателя  вовлекает два  объекта: сам  указатель и
указываемый объект.  Снабжение описания указателя "префиксом" const
делает объект, но не сам указатель, константой. Например:
<pre>
  const char* pc = "asdf";    // указатель на константу
  pc[3] = 'a';                // ошибка
  pc = "ghjk";                // ok
</pre>
<br>Чтобы  описать   сам  указатель,   а  не  указываемый  объект,  как
константный, используется операция const*. Например:
<pre>
  char *const cp = "asdf";    // константный указатель
  cp[3] = 'a';                // ok
  cp = "ghjk";                // ошибка
</pre>
<br>Чтобы сделать  константами оба объекта, их оба нужно описать const.
Например:
<pre>
  const char *const cpc = "asdf";    // const указатель на const
  cpc[3] = 'a';                      // ошибка
  cpc = "ghjk";                      // ошибка
</pre>
<br>  Объект, являющийся  константой при  доступе к  нему  через  один
указатель,  может  быть  переменной,  когда  доступ  осуществляется
другими путями.  Это в  частности полезно  для  параметров  функции.
Посредством  описания   параметра  указателя   как  const   функции
запрещается изменять объект, на который он указывает. Например:
<pre>
  char* strcpy(char* p, const char* q); // не может изменить q
</pre>
<br>  Указателю  на   константу  можно  присваивать  адрес  переменной,
поскольку никакого  вреда от  этого быть  не может.  Однако  нельзя
присвоить адрес  константы указателю,  на который  не было наложено
ограничение, поскольку  это позволило бы изменить значение объекта.
Например:
<pre>
  int a = 1;
  const c = 2;
  const* p1 = &c;    // ok
  const* p2 = &a;    // ok
  int* p3 = &c;      // ошибка
  *p3 = 7;           // меняет значение c
</pre>
<br>Как обычно, если тип в описании опущен, то он предполагается int.
<a name=gl2.4.7>
<h3 align=center >     2.4.7 Перечисления </h3>
<p>  Есть другой  метод определения  целых  констант,  который  иногда
более удобен, чем применение const. Например:
<pre>
  enum { ASM, AUTO, BREAK };
</pre>
<br>определяет  три   целых  константы,  называемы  перечислителями,  и
присваивает  им  значения.  Поскольку  значения  перечислителей  по
умолчанию присваиваются  начиная с  0 в  порядке  возрастания,  это
эквивалентно записи:
<pre>
  const ASM = 0;
  const AUTO = 1;
  const BREAK = 2;
</pre>
<br>Перечисление может быть именованным. Например:
<pre>
  enum keyword { ASM, AUTO, BREAK };
</pre>
<br>  Имя перечисления  становится синонимом  int, а  не  новым  типом.
Описание переменной  keyword, а  не  просто  int,  может  дать  как
программисту, так  и компилятору подсказку о том, что использование
преднамеренное. Например:
<pre>
  keyword key;

  switch (key) {
  case ASM:
      // что-то делает
      break;
  case BREAK:
      // что-то делает
      break;
  }
</pre>
<br>побуждает компилятор  выдать предупреждение,  поскольку только  два
значения keyword из трех используются.
<br>  Можно также задавать значения перечислителей явно. Например:
<pre>
  enum int16 {
      sign=0100000,               // знак
      most_significant=040000,    // самый значимый
      least_significant=1         // наименее значимый
  };
</pre>
<br>Такие значения не обязательно должны быть различными, возрастающими
или положительными.
<a name=gl2.5>
<h2 align=center >     2.5 Экономия Пространства </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl2.5.1>2.5.1  Поля                    </a>                    
<tr><td width=10></td><TD>    <a HREF=#gl2.5.2>2.5.2  Объединения       </a>                          
</table>
<p>  В  ходе   программирования  нетривиальных   разработок  неизбежно
наступает время,  когда хочется  иметь больше  пространства памяти,
чем  имеется   или  отпущено.  Есть  два  способа  выжать  побольше
пространства из того, что доступно:
<br>  [1] Помещение в байт более одного небольшого объекта; и
<br>  [2] Использование  одного и  того же  пространства  для  хранения
     разных объектов в разное время.
<br>  Первого можно  достичь с  помощью использования  полей, второго -
через использование  объединений.  Эти  конструкции  описываются  в
следующих разделах. Поскольку обычное их применение состоит чисто в
оптимизации программы,  и они  в большинстве  случаев непереносимы,
программисту следует  дважды подумать,  прежде чем использовать их.
Часто лучше  изменить способ  управления данными;  например, больше
полагаться на  динамически выделяемую  память (<a HREF=gl3.htm#gl3.2.6>#3.2.6</a>)  и меньше на заранее выделенную статическую память.
<a name=gl2.5.1>
<h3 align=center >     2.5.1 Поля </h3>
<p>  Использование  char   для  представления   двоичной   переменной,
например,  переключателя   включено/выключено,   может   показаться
экстравагантным,   но char  является наименьшим объектом, который в
C++ может   выделяться  независимо.  Можно,  однако,  сгруппировать
несколько таких  крошечных переменных  вместе в  виде полей struct.
Член определяется  как поле  путем указания  после его  имени числа
битов, которые  он занимает.  Допустимы неименованные  поля; они не
влияют на  смысл  именованных  полей,  но  неким  машинно-зависимым
образом могут улучшить размещение:
<pre>
  struct sreg {
      unsigned enable : 1;
      unsigned page : 3;
      unsigned : 1;        // неиспользуемое
      unsigned mode : 2;
      unsigned : 4:        // неиспользуемое
      unsigned access : 1;
      unsigned length : 1;
      unsigned non_resident : 1;
  }
</pre>
<br>Получилось  размещение   регистра  0   состояния  DEC   PDP11/45  (в
предположении, что  поля в  слове размещаются  слева направо). Этот
пример  также   иллюстрирует  другое   основное  применение  полей:
именовать части  внешне предписанного  размещения. Поле должно быть
целого типа  и используется  как другие целые, за исключением того,
что невозможно  взять адрес поля. В ядре операционной системы или в
отладчике тип sreg можно было бы использовать так:
<pre>
  sreg* sr0 = (sreg*)0777572;
  //...
  if (sr->access) {        // нарушение доступа
      // чистит массив
      sr->access = 0;
  }
</pre>
<br>  Однако применение полей для упаковки нескольких переменных в один
байт   не   обязательно   экономит   пространство.   Оно   экономит
пространство, занимаемое  данными, но  объем кода, необходимого для
манипуляции этими  переменными, на  большинстве  машин  возрастает.
Известны программы,  которые значительно  сжимались, когда двоичные
переменные преобразовывались  из полей  бит в  символы! Кроме того,
доступ к  char или  int обычно  намного быстрее, чем доступ к полю.
Поля  -   это  просто  удобная  и  краткая  запись  для  применения
логических операций  с целью  извлечения информации  из части слова
или введения информации в нее.
<a name=gl2.5.2>
<h3 align=center >     2.5.2 Объединения </h3>
<p>  Рассмотрим проектирование  символьной таблицы,  в которой  каждый
элемент содержит  имя  и  значение,  и  значение  может  быть  либо
строкой, либо целым:
<pre>
  struct entry {
      char* name;
      char  type;
      char* string_value;        // используется если type == 's'
      int   int_value;           // используется если type == 'i'
  };

  void print_entry(entry* p)
  {
      switch p->type {
      case 's':
          cout << p->string_value;
          break;
      case 'i':
          cout << p->int_value;
          break;
      default:
          cerr << "испорчен type\n";
          break;
      }
  }
</pre>
<br>  Поскольку   string_value    и   int_value    никогда   не   могут
использоваться  одновременно,   ясно,  что  пространство  пропадает
впустую. Это можно легко исправить, указав, что оба они должны быть
членами union (объединения); например, так:
<pre>
  struct entry {
      char* name;
      char  type;
      union {
          char* string_value;    // используется если type == 's'
          int   int_value;       // используется если type == 'i'
      };
  };
</pre>
<br>  Это  оставляет  всю  часть  программы,  использующую  entry,  без
изменений, но обеспечивает, что при размещении entry string_value и
int_value имеют  один и тот же адрес. Отсюда следует, что все члены
объединения вместе  занимают лишь  столько памяти, сколько занимает
наибольший член.
<br>  Использование  объединений   таким  образом,   чтобы  при  чтении
значения всегда  применялся тот  член, с  применением которого  оно
записывалось,  совершенно   оптимально.  Но  в  больших  программах
непросто гарантировать,  что объединения  используются только таким
образом,  и  из-за  неправильного  использования  могут  появляться
трудно уловимые  ошибки. Можно  капсулизировать  объединение  таким
образом, чтобы  соответствие между  полем типа и типами членов было
гарантированно правильным (<a HREF=gl5_2.htm#gl5_2.4.6>#5.4.6</a>).
<br>  Объединения иногда  используют  для  "преобразования  типов"  (это
делают главным  образом программисты,  воспитанные  на  языках,  не
обладающих  средствами   преобразования  типов,   где  жульничество
является необходимым).  Например, это  "преобразует" на VAX'е int в
int*, просто предполагая побитовую эквивалентность:
<pre>
  struct fudge {
      union {
          int  i;
          int* p;
      };
  };

  fudge a;
  a.i = 4096;
  int* p = a.p;    // плохое использование
</pre>
<br>  Но на  самом деле  это совсем  не  преобразование:  на  некоторых
машинах   int и  int* занимают неодинаковое количество памяти, а на
других  никакое   целое  не   может  иметь  нечетный  адрес.  Такое
применение объединений  непереносимо, а  есть явный  способ указать
преобразование типа (<a HREF=gl3.htm#gl3.2.5>#3.2.5</a>).
<br>  Изредка   объединения   умышленно   применяют,   чтобы   избежать
преобразования типов.  Можно, например,  использовать fudge,  чтобы
узнать представление указателя 0:
<pre>
  fudge.p = 0;
  int i = fudge.i;    // i не обязательно должно быть 0
</pre>
<br>  Можно  также   дать  объединению   имя,  то   есть  сделать   его
полноправным типом. Например, fudge можно было бы описать так:
<pre>
  union fudge {
          int  i;
          int* p;
  };
</pre>
<br>и использовать (неправильно) в точности как раньше. Имеются также и
оправданные применения именованных объединений; см. <a HREF=gl5_2.htm#gl5_2.4.6>#5.4.6</a>.
<a name=gl2.6>
<h2 align=center >     2.6 Упражнения </h2>
<ol>
<LI> (*1) Заставьте работать программу с "Hello, world" (1.1.1).
 <LI> (*1) Для  каждого описания  в <a HREF=#gl2.1> #2.1</a>  сделайте  следующее:    Если описание  не   является  определением,   напишите   для   него
     определение. Если описание является определением, напишите для
     него описание, которое при этом не является определением.
 <LI> (*1) Напишите описания для: указателя на символ; вектора из 10
     целых; ссылки  на вектор  из 10  целых; указателя на вектор из
символьных  строк;   указателя   на   указатель   на   символ;
     константного  целого;   указателя  на   константное  целое;  и
     константного   указателя    на   целое.    Каждый    из    них
     инициализируйте.
  <LI> (*1.5) Напишите программу, которая печатает размеры основных и
     указательных типов. Используйте операцию sizeof.
  <LI> (*1.5) Напишите  программу, которая печатает буквы 'a'...'z' и
     цифры '0'...'9'  и их  числовые значения.  Сделайте то  же для
     остальных печатаемых  символов. Сделайте  то же,  но используя
     шестнадцатиричную запись.
  <LI> (*1) Напечатайте набор битов, которым представляется указатель
     0 на вашей системе. Подсказка:<a HREF=#gl2.5.2> #2.5.2.</a>
  <LI> (*1.5)  Напишите   функцию,  печатающую   порядок  и  мантиссу
     параметра типа double.
 <LI> (*2)  Каковы   наибольшие  и  наименьшие  значения,  на  вашей
     системе, следующих  типов:  char,  short,  int,  long,  float,
     double,  unsigned,   char*,   int*   и   void*?   Имеются   ли
     дополнительные ограничения  на принимаемые ими значения? Может
     ли,  например,   int*   принимать   нечетное   значение?   Как
     выравниваются в памяти объекты этих типов? Может ли, например,
     int иметь нечетный адрес?
 <LI> (*1) Какое  самое длинное  локальное имя  можно использовать в
     C++ программе в вашей системе? Какое самое длинное внешнее имя
     можно использовать  в C++  программе в  вашей системе? Есть ли
     какие-нибудь ограничения на символы, которые можно употреблять
     в имени?
  <LI> (*2) Определите one следующим образом:
<pre>
       const one = 1;
</pre>
  <br>   Попытайтесь  поменять   значение  one  на  2.  Определите  num
     следующим образом:
<pre>
       const num[] = { 1, 2 };
</pre>
<br>     Попытайтесь поменять значение num[1] на 2.
  <LI> (*1) Напишите  функцию, переставляющую  два целых   (меняющую
     значения). Используйте в качесте типа параметра int*. Напишите
     другую переставляющую  функцию, использующую  в  качесте  типа
     параметра int&.
  <LI> (*1) Каков размер вектора str в следующем примере:
<pre>
       char str[] = "a short string";
</pre>
<br>     Какова длина строки "a short string"?
  <LI> (*1.5) Определите  таблицу названий месяцев года и числа дней
     в них.  Выведите ее. Сделайте это два раза: один раз используя
     вектор для  названий и  вектор для  числа  дней,  и  один  раз
     используя  вектор  структур,  в  каждой  из  которых  хранится
     название месяца и число дней в нем.
 <LI> (*1) С  помощью typedef  определите типы:  беззнаковый  char;
     константный беззнаковый char; указатель на целое; указатель на
     указатель на  char; указатель на вектора символов; вектор из 7
     целых указателей;   указатель на вектор из 7 целых указателей;
     и вектор из 8 векторов из 7 целых указателей.
</ol>
<p>
<a name=*2.1>
<small>
<br>*<sup>1</sup> Команда  #include   была выброшена  из примеров  в этой
главе для  экономии места.  Она необходима в примерах, производящих
ввывод, чтобы они были полными. (прим. автора)
</small>
<p> <center> 
<font size="-1">
[<a href="gl1.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="gl3.htm">Вперед</a>]
</font>
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
