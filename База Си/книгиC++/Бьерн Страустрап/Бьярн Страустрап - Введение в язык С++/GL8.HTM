<htm>
<head>





<title>Бьярн Страустрап. Введение в язык Си++, Потоки</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<basefont size="3"><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<h1 align=center>        Глава 8 </h1>
<a name=gl8>
<h2 align=center>       Потоки </h2>
<p>  Язык C++  не обеспечивает  средств для ввода/вывода. Ему это и не
нужно; такие  средства легко  и элегантно  можно создать  с помощью
самого языка.  Описанная здесь  стандартная  библиотека  потокового
ввода/вывода обеспечивает  гибкий и  эффективный с  гарантией  типа
метод обработки  символьного ввода  целых чисел,  чисел с плавающей
точкой и символьных строк, а также простую модель ее расширения для
обработки типов,  определяемых пользователем.  Ее  пользовательский
интерфейс находится  в .  В этой  главе описывается  сама
библиотека, некоторые  способы  ее  применения  и  методы,  которые
использовались при ее реализации.
<a name=gl8.1>
<h2 ALIGN=CENTER>     8.1 Введение </h2>
<p>  Разработка и  реализация  стандартных  средств  ввода/вывода  для
языка программирования  зарекомендовала  себя  как  заведомо  трудная
работа.   Традиционно    средства   ввода/вывода    разрабатывались
исключительно для  небольшого числа встроенных типов данных. Однако
в C++  программах обычно  используется  много  типов,  определенных
пользователем, и  нужно обрабатывать  ввод и вывод также и значений
этих типов.  Очевидно, средство  ввода/вывода должно  быть простым,
удобным, надежным в употреблении, эффективным и гибким, и ко всему
прочему полным. Ничье решение еще не смогло угодить всем, поэтому у
пользователя  должна   быть  возможность   задавать  альтернативные
средства ввода/вывода и расширять стандартные средства ввода/вывода
применительно к требованиям приложения.
<br>  C++  разработан   так,  чтобы  у  пользователя  была  возможность
определять новые  типы столь  же эффективные  и  удобные,  сколь  и
встроенные типы. Поэтому обоснованным является требование того, что
средства  ввода/вывода  для  C++  должны  обеспечиваться  в  C++  с
применением  только   тех   средств,   которые   доступны   каждому
программисту. Описываемые  здесь средства  ввода/вывода представляют
собой попытку ответить на этот вызов.
<br>  Средства  ввода/вывода      связаны   исключительно   с
обработкой    преобразования     типизированных     объектов     в
последовательности  символов   и  обратно.   Есть  и  другие  схемы
ввода/вывода, но  эта является  основополагающей в  системе UNIX, и
большая часть  видов бинарного  ввода/вывода  обрабатывается  через
рассмотрение  символа   просто  как   набор  бит,   при  этом   его
общепринятая связь с алфавитом игнорируется. Тогда для программиста
ключевая  проблема   заключается  в   задании  соответствия   между
типизированным объектом и принципиально не типизированной строкой.
<br>  Обработка  и   встроенных  и   определенных  пользователем  типов
однородным образом  и с гарантией типа достигается с помощью одного
перегруженного имени функции для набора функций вывода. Например:
<pre>
  put(cerr,"x = "); // cerr - поток вывода ошибок
  put(cerr,x);
  put(cerr,"\n");
</pre>
<br>Тип параметра  определяет то, какая из функций put будет вызываться
для каждого параметра. Это решение применялось в нескольких языках.
Однако ему недостает лаконичности. Перегрузка операции << значением
"поместить в"  дает более  хорошую запись  и позволяет программисту
выводить ряд объектов одним оператором. Например:
<pre>
  cerr << "x = " << x << "\n";
</pre>
<br>где cerr  -  стандартный  поток  вывода  ошибок.  Поэтому,  если  x
является int  со значением  123,  то  этот  оператор  напечатает  в
стандартный поток вывода ошибок
<pre>
  x = 123
</pre>
<br>и символ новой строки. Аналогично, если X принадлежит определенному
пользователем типу complex и имеет значение (1,2.4), то приведенный
выше оператор напечатает в cerr
<pre>
  x = 1,2.4)
</pre>
<br>  Этот  метод  можно  применять  всегда,  когда  для  x  определена
операция <<, и пользователь может определять операцию << для нового
типа.
<a name=gl8.2>
<h2 ALIGN=CENTER>     8.2 Вывод </h2>
<table border=0>
<tr><td width=10></td><TD>  <a HREF=#gl8.2.1>  8.2.1 Вывод Встроенных Типов    </a>                
<tr><td width=10></td><TD>  <a HREF=#gl8.2.2>   8.2.2 Некоторые Подробности Разработки    </a>      
<tr><td width=10></td><TD>  <a HREF=#gl8.2.3>  8.2.3 Форматированный Вывод     </a>               
<tr><td width=10></td><TD><a HREF=#gl8.2.4>8.2.4 Виртуальная Функция Вывода </a>               
</table>
<p>  В  этом   разделе  сначала   обсуждаются  средства  форматного  и
бесформатного вывода встроенных типов, потом приводится стандартный
способ спецификации  действий вывода для определяемых пользователем
типов.
<a name=gl8.2.1>
<h3 ALIGN=CENTER>     8.2.1 Вывод Встроенных Типов </h3>
<p>  Класс ostream  определяется вместе с операцией << ("поместить в")
для обработки вывода встроенных типов:
<pre>
  class ostream {
      // ...
  public:
      ostream& operator<<(char*);
      ostream& operator<<(int i) { return *this<
</pre>
<a name=gl8.2.2>
<h3 ALIGN=CENTER>8.2.2 Некоторые Подробности Разработки </h3>
<p>  Операция вывода  используется, чтобы избежать той многословности,
которую дало бы использование функции вывода. Но почему <<?
<br>  Возможности  изобрести   новый  лексический  символ  нет  (#6.2).
Операция присваивания  была кандидатом одновременно и на ввод, и на
вывод,  но   оказывается,  большинство  людей  предпочитают,  чтобы
операция ввода отличалась от операции вывода. Кроме того, = не в ту
сторону связывается  (ассоциируется),  то  есть  cout=a=b  означает
cout=(a=b).
<br>  Делались  попытки  использовать  операции  <  и  >,  но  значения
"меньше" и  "больше" настолько  прочно вросли в сознание людей, что
новые операции  ввода/вывода во  всех  реальных  случаях  оказались
нечитаемыми. Помимо  этого, "<"  находится на большинстве клавиатур
как раз на ",", и у людей получаются операторы вроде такого:
<pre>
  cout < x , y , z;
</pre>
<br>Для таких операторов непросто выдать хорошие сообщения об ошибках.
<br>  Операции <<  и >>  к  такого  рода  проблемам  не  приводят,  они
асимметричны в  том смысле,  что их  можно проассоциировать с "в" и
"из",  а  приоритет  <<  достаточно  низок,  чтобы  можно  было  не
использовать скобки  для арифметических выражений в роли операндов.
Например:
<pre>
  cout << "a*b+c=" << a*b+c << "\n";
</pre>
<br>Естественно, при  написании выражений,  которые содержат операции с
более низкими приоритетами, скобки использовать надо. Например:
<pre>
  cout << "a^b|c=" << (a^b|c) << "\n";
</pre>
<br>Операцию левого сдвига тоже можно применять в операторе вывода:
<pre>
  cout << "a<
</pre>
<a name=gl8.2.3>
<h3 ALIGN=CENTER> 8.2.3 Форматированный Вывод </h3>
<p>  Пока <<  применялась только  для неформатированного  вывода, и на
самом деле  в реальных  программах она  именно  для  этого  главным
образом и  применяется. Помимо  этого  существует  также  несколько
форматирующих функций,  создающих представление  своего параметра в
виде  строки,   которая  используется   для   вывода.   Их   второй
(необязательный) параметр  указывает,  сколько  символьных  позиций
должно использоваться.
<pre>
  char* oct(long, int =0);    // восьмеричное представление
  char* dec(long, int =0);    // десятичное представление
  char* hex(long, int =0);    // шестнадцатиричное представление
  char* chr(int, int =0);     // символ
  char* str(char*, int =0);   // строка
</pre>
<br>Если не  задано поле нулевой длины, то будет производиться усечение
или  дополнение;   иначе  будет   использоваться  столько  символов
(ровно), сколько нужно. Например:
<pre>
  cout << "dec(" << x
       << ") = oct(" << oct(x,6)
       << ") = hex(" << hex(x,4)
       << ")";
</pre>
<br>Если x==15, то в результате получится:
<pre>
  dec(15) = oct(    17) = hex(   f);
</pre>
<br>  Можно также использовать строку в общем формате:
<pre>
  char* form(char* format ...);
  cout<
</pre>
<a name=gl8.2.4>
<h3 ALIGN=CENTER>8.2.4 Виртуальная Функция Вывода </h3>
<p>  Иногда функция  вывода должна  быть  virtual.  Рассмотрим  пример
класса shape, который дает понятие фигуры (<a HREF=gl1.htm#gl1.18>#1.18</a>):
<pre>
  class shape {
      // ...
  public:
      // ...
      virtual void draw(ostream& s); // рисует "this" на "s"
  };

  class circle : public shape {
      int radius;
  public:
      // ...
      void draw(ostream&);
  };
</pre>
<br>  То есть,  круг имеет  все признаки  фигуры и может обрабатываться
как фигура,  но  имеет  также  и  некоторые  специальные  свойства,
которые должны учитываться при его обработке.
<br>  Чтобы  поддерживать   для  таких  классов  стандартную  парадигму
вывода, операция << определяется так:
<pre>
  ostream& operator<<(ostream& s, shape* p)
  {
      p->draw(s);
      return s;
  }
</pre>
<br> Если next  - итератор  типа определенного в <a HREF=gl7.htm#gl7.3.3>#7.3.3</a>, то список фигур распечатывается например так:
<pre>
  while ( p = next() ) cout << p;
</pre>
<a name=gl8.3>
<h2 ALIGN=CENTER>     8.3 Файлы и Потоки </h2>
<table border=0>
<tr><td width=10></td><TD><a HREF=#gl8.3.1> 8.3.1 Инициализация Потоков Вывода </a>             
<tr><td width=10></td><TD>    <a HREF=#gl8.3.2>   8.3.2 Закрытие Потоков Вывода </a>                  
<tr><td width=10></td><TD>     <a HREF=#gl8.3.3> 8.3.3 Открытие Файлов                </a>           
<tr><td width=10></td><TD>    <a HREF=#gl8.3.4>   8.3.4 Копирование Потоков        </a>                
</table>
<p>  Потоки обычно  связаны  с  файлами.  Библиотека  потоков  создает
стандартный поток  ввода cin,   стандартный  поток   вывода cout  и
стандартный поток  ошибок cerr.  Программист может открывать другие
файлы и создавать для них потоки.
<a name=gl8.3.1>
<h3 ALIGN=CENTER>     8.3.1 Инициализация Потоков Вывода </h3>
<p>  ostream имеет конструкторы:
<pre>
  class ostream {
      // ...
      ostream(streambuf* s);      // связывает с буфером потока
      ostream(int fd);            // связывание для файла
      ostream(int size, char* p); // связывет с вектором
  };
</pre>
<br>Главная работа  этих конструкторов  - связывать  с  потоком  буфер.
streambuf - класс, управляющий буферами; он описывается в <a HREF=#gl8.6>#8.6</a>, как и класс  filebuf, управляющий  streambuf для  файла.  Класс filebuf
является производным от класса streambuf.
<br>  Описание  стандартных   потоков  вывода   cout  и  cerr,  которое
находится  в   исходных  кодах   библиотеки  потоков  ввода/вывода,
выглядит так:
<pre>
      // описать подходящее пространство буфера
  char cout_buf[BUFSIZE]

      // сделать "filebuf" для управления этим пространством
      // связать его с UNIX'овским потоком вывода 1 (уже открытым)
  filebuf cout_file(1,cout_buf,BUFSIZE);

      // сделать ostream, обеспечивая пользовательский интерфейс
  ostream cout(&cout_file);

  char cerr_buf[1];

      // длина 0, то есть, небуферизованный
      // UNIX'овский поток вывода 2 (уже открытый)
  filebuf cerr_file()2,cerr_buf,0;

  ostream cerr(&cerr_file);
</pre>
<br>  Примеры двух  других конструкторов ostream можно найти в <a HREF=#gl8.3.3>#8.3.3</a> и <a HREF=#gl8.5>#8.5</a>.
<a name=gl8.3.2>
<h3 ALIGN=CENTER>     8.3.2 Закрытие Потоков Вывода </h3>
<p>  Деструктор для ostream сбрасывает буфер с помощью открытого члена
функции ostream::flush():
<pre>
  ostream::~ostream()
  {
      flush();       // сброс
  }
</pre>
<br>Сбросить буфер можно также и явно. Например:
<pre>
  cout.flush();
</pre>
<a name=gl8.3.3>
<h3 ALIGN=CENTER>     8.3.3 Открытие Файлов </h3>
<p>  Точные  детали   того,  как   открываются  и  закрываются  файлы,
различаются в  разных операционных  системах и  здесь  подробно  не
описываются.  Поскольку   после  включения     становятся
доступны cin,  cout и  cerr, во многих (если не во всех) программах
не нужно  держать код  для открытия файлов. Вот, однако, программа,
которая открывает  два  файла,  заданные  как  параметры  командной
строки, и копирует первый во второй:
<pre>
  #include

  void error(char* s, char* s2)
  {
      cerr << s << " " << s2 << "\n";
      exit(1);
  }

  main(int argc, char* argv[])
  {
      if (argc != 3) error("неверное число параметров","");

      filebuf f1;
      if (f1.open(argv[1],input) == 0)
          error("не могу открыть входной файл",argv[1]);
      istream from(&f1);

      filebuf f2;
      if (f2.open(argv[2],output) == 0)
          error("не могу создать выходной файл",argv[2]);
      ostream to(&f2);

      char ch;
      while (from.get(ch)) to.put(ch);

      if (!from.eof() !! to.bad())
          error("случилось нечто странное","");
  }
</pre>
<br>Последовательность действий при создании ostream для именованного
файла та  же, что используется для стандартных потоков: (1) сначала
создается буфер  (здесь это делается посредством описания filebuf);
(2)  затем   к  нему   подсоединяется  файл   (здесь  это  делается
посредством открытия  файла с  помощью функции filebuf::open()); и,
наконец, (3)  создается сам ostream с filebuf в качестве параметра.
Потоки ввода обрабатываются аналогично.
<br>  Файл может открываться в одной из двух мод:
<pre>
  enum open_mode { input, output };
</pre>
<br>Действие filebuf::open() возвращает 0, если не может открыть файл в
соответствие с  требованием.  Если  пользователь  пытается  открыть
файл, которого не существует для output, он будет создан.
<br>  Перед завершением  программа проверяет,  находятся  ли  потоки  в
приемлемом  состоянии   (см. <a HREF=#gl8.4.2> #8.4.2</a>).   При  завершении  программы открытые файлы неявно закрываются.
<br>  Файл можно  также открыть  одновременно для чтения и записи, но в
тех случаях,  когда это  оказывается необходимо,  парадигма потоков
редко оказывается  идеальной. Часто  лучше рассматривать такой файл
как вектор  (гигантских размеров).  Можно определить  тип,  который
позволяет программе обрабатывать файл как вектор; см. <a HREF=#y8>Упражнения 8-
10</a>.
<a name=gl8.3.4>
<h3 ALIGN=CENTER>     8.3.4 Копирование Потоков </h3>
<p>  Есть возможность копировать потоки. Например:
<pre>
  cout = cerr;
</pre>
<br>В результате этого получаются две переменные, ссылающиеся на один и
тот же  поток. Главным  образом это  бывает полезно  для того, чтобы
сделать стандартное  имя вроде  cin ссылающимся  на  что-то  другое
(пример этого см. в <a HREF=gl3.htm#gl3.1.6>#3.1.6</a>)
<a name=gl8.4>
<h2 ALIGN=CENTER>     8.4 Ввод </h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl8.4.1>   8.4.1 Ввод Встроенных Типов    </a>                 
<tr><td width=10></td><TD>   <a HREF=#gl8.4.2>    8.4.2 Состояния Потока               </a>           
<tr><td width=10></td><TD>   <a HREF=#gl8.4.3>       8.4.3 Ввод Типов, Определяемых Пользователем  </a>  
<tr><td width=10></td><TD> <a HREF=#gl8.4.4> 8.4.4 Инициализация Потоков Ввода </a>               
</table>
<p>  Ввод  аналогичен   выводу.   Имеется   класс   istream,   который
предоставляет операцию  >> ("взять  из") для  небольшого  множества
стандартных типов.  Функция operator>> может определяться для типа,
определяемого пользователем.
<a name=gl8.4.1>
<h3 ALIGN=CENTER>     8.4.1 Ввод Встроенных Типов </h3>
<p>  Класс istream определяется так:
<pre>
class istream {
      // ...
  public:
      istream& operator>>(char*);      // строка
      istream& operator>>(char&);      // символ
      istream& operator>>(short&);
      istream& operator>>(int&);
      istream& operator>>(long&);
      istream& operator>>(float&);
      istream& operator>>(double&);
      // ...
  };
</pre>
<br>  Функции ввода определяются в таком духе:
<pre>
  istream& istream::operator>>(char& c);
  {
          // пропускает пропуски
      int a;
          // неким образом читает символ в "a"
      c = a;
  }
</pre>
<br>  Пропуск определяется  как стандартный  пропуск в  C, через  вызов
isspase() в  том виде,  как она  определена  в    (пробел,
табуляция, символ новой строки, перевод формата и возврат каретки).
<br>  В качестве альтернативы можно использовать функции get():
<pre>
  class istream {
      // ...
      istream& get(char& c);                    // char
      istream& get(char* p, int n, int ='\n');  // строка
  };
</pre>
<br>Они обрабатывают  символы пропуска  так же,  как остальные символы.
Функция istream::get(char)  читает один  и тот  же  символ  в  свой
параметр; другая  istream::get читает  не более n символов в вектор
символов,  начинающийся   в  p.   Необязательный  третий   параметр
используется для  задания символа остановки (иначе, терминатора или
ограничителя), то  есть этот  символ читаться  не будет. Если будет
встречен  символ  ограничитель,  он  останется  как  первый  символ
потока. По  умолчанию вторая функция get будет читать самое большее
n  символов,   но  не   больше  чем   одну  строку,  '\n'  является
ограничителем по  умолчанию. Необязательный  третий параметр задает
символ, который читаться не будет. Например:
<pre>
  cin.get(buf,256,'\t');
</pre>
<br>будет читать  в buf  не  более  256  символов,  а  если  встретится
табуляция ('\t'),  то это приведет к возврату из get. В этом случае
следующим символом, который будет считан из cin, будет '\t'.
<br>  Стандартный  заголовочный  файл    определяет  несколько
функций, которые могут оказаться полезными при осуществлении ввода:
<pre>
  int isalpha(char)    // 'a'..'z' 'A'..'Z'
  int isupper(char)    // 'A'..'Z'
  int islower(char)    // 'a'..'z'
  int isdigit(char)    // '0'..'9'
  int isxdigit(char)   // '0'..'9' 'a'..'f' 'A'..'F'
  int isspase(char)    // ' ' '\t' возврат новая строка
                       // перевод формата
  int iscntrl(char)    // управляющий символ
                       // (ASCII 0..31 и 127)
  int ispunct(char)    // пунктуация: ниодин из вышеперечисленных
  int isalnum(char)    // isalpha() | isdigit()
  int isprint(char)    // печатаемый: ascii ' '..'-'
  int isgraph(char)    // isalpha() | isdigit() | ispunct()
  int isascii(char c)  { return 0<=c &&c<=127; }
</pre>
<br>Все кроме  isascii() реализуются  внешне одинаково,  с  применением
символа в  качестве индекса  в таблице  атрибутов символов. Поэтому
такие выражения, как
<pre>
  (('a'<=c && c<='z') || ('A'<=c && c<='Z')) // алфавитный
</pre>
<br>не только  утомительно пишутся  и чреваты  ошибками  (на  машине  с
набором символов  EBCDIC оно будет принимать неалфавитные символы),
они также и менее эффективны, чем применение стандартной функции:
<pre>
  isalpha(c)
</pre>
<a name=gl8.4.2>
<h3 ALIGN=CENTER>     8.4.2 Состояния Потока </h3>
<p>  Каждый поток  (istream или  ostream) имеет  ассоциированное с ним
состояние,   и    обработка   ошибок    и   нестандартных   условий
осуществляется с помощью соответствующей установки и проверки этого
состояния.
<br>  Поток может находиться в одном из следующих состояний:
<pre>
  enum stream_state { _good, _eof, _fail, _bad };
</pre>
<br>Если состояние  _good или  _eof, значит  последняя  операция  ввода
прошла успешно.  Если состояние  _good, то следующая операция ввода
может пройти  успешно, в  противном случае она закончится неудачей.
Другими словами,  применение операции  ввода к  потоку, который  не
находится  в  состоянии  _good,  является  пустой  операцией.  Если
делается попытка  читать в  переменную v,  и  операция  оканчивается
неудачей,  значение   v  должно   остаться  неизменным  (оно  будет
неизменным, если  v имеет один из тех типов, которые обрабатываются
функциями членами  istream или  ostream). Отличия между состояниями
_fail и  _bad очень  незначительно и представляет интерес только для
разработчиков операций ввода. В состоянии _fail предполагается, что
поток не  испорчен и  никакие символы не потеряны. В состоянии _bad
может быть все что угодно.
<br>  Состояние потока можно проверять например так:
<pre>
switch (cin.rdstate()) {
  case _good:
      // последняя операция над cin прошла успешно
      break;
  case _eof:
      // конец файла
      break;
  case _fail:
      // некоего рода ошибка форматирования
      // возможно, не слишком плохая
      break;
  case _bad:
      // возможно, символы cin потеряны
      break;
  }
</pre>
<br>  Для любой  переменной z типа, для которого определены операции <<
и >>, копирующий цикл можно написать так:
<pre>
  while (cin>>z) cout << z << "\n";
</pre>
<br>Например,  если   z  -  вектор  символов,  этот  цикл  будет  брать
стандартный ввод и помещать его в стандартный вывод по одному слову
(то есть, последовательности символов без пробела) на строку.
<br>  Когда в  качестве условия используется поток, происходит проверка
состояния потока    и  эта  проверка  проходит  успешно  (то  есть,
значение условия не ноль) только если состояние _good. В частности,
в  предыдущем   цикле  проверялось   состояние   istream,   которое
возвращает cin>>z.  Чтобы  обнаружить,  почему  цикл  или  проверка
закончились неудачно,  можно исследовать  состояние. Такая проверка
потока реализуется операцией преобразования (<a HREF=gl6.htm#gl6.3.2>#6.3.2</a>).
<br>  Делать проверку  на  наличие  ошибок  каждого  ввода  или  вывода
действительно не  очень удобно,  и обычно  источником ошибок служит
программист, не  сделавший этого  в том месте, где это существенно.
Например, операции  вывода обычно  не  проверяются,  но  они  могут
случайно не сработать. Парадигма потока ввода/вывода построена так,
чтобы когда в C++ появится (если это произойдет) механизм обработки
исключительных ситуаций  (как средство  языка или  как  стандартная
библиотека)   его   будет   легко   применить   для   упрощения   и
стандартизации обработки ошибок в потоках ввода/вывода.
<a name=gl8.4.3>
<h3 ALIGN=CENTER>     8.4.3 Ввод Типов, Определяемых Пользователем </h3>
<p>  Ввод для  пользовательского типа может определяться точно так же,
как вывод,  за тем исключением, что для операции ввода важно, чтобы
второй параметр был ссылочного типа. Например:
<pre>
  istream& operator>>(istream& s, complex& a)
  /*
      форматы ввода для complex; "f" обозначает float:
      f
      ( f )
      ( f , f )
  */
  {
      double re = 0, im = 0;
      char c = 0;

      s >> c;
      if (c == '(') {
          s >> re >> c;
          if (c == ',') s >> im >> c;
          if (c != ')') s.clear(_bad);    // установить state
      }
      else {
          s.putback(c);
          s >> re;
      }

      if (s) a = complex(re,im);
      return s;
  }
</pre>
<br>  Несмотря на  то, что  не хватает  кода обработки  ошибок, большую
часть видов  ошибок это на самом деле обрабатывать будет. Локальная
переменная c  инициализируется,  чтобы  ее  значение  не  оказалось
случайно  '('   после  того,   как  операция   окончится   неудачно.
Завершающая проверка  состояния потока  гарантирует,  что  значение
параметра a  будет изменяться  только в  том случае,  если все идет
хорошо.
<br>  Операция установки  состояния названа  clear() (очистить), потому
что она  чаще всего  используется  для  установки  состояния  потока
заново как _good. _good является значением параметра по умолчанию и
для istream::clear(), и для ostream::clear().
<br>  Над операциями  ввода надо  поработать еще. Было бы, в частности,
замечательно, если  бы можно  было задавать ввод в терминах шаблона
(как в  языках Снобол и Икон), а потом проверять, прошла ли успешна
вся  операция  ввода.  Такие  операции  должны  были  бы,  конечно,
обеспечивать некоторую  дополнительную буферизацию, чтобы они могли
восстанавливать поток ввода в его исходное состояние после неудачной
попытки распознавания.
<a name=gl8.4.4>
<h3 ALIGN=CENTER>     8.4.4 Инициализация Потоков Ввода </h3>
<p>  Естественно,  тип   istream,  так   же  как  и  ostream,  снабжен
конструктором:
<pre>
  class istream {
      // ...
      istream(streambuf* s, int sk =1, ostream* t =0);
      istream(int size, char* p, int sk =1);
      istream(int fd, int sk =1, ostream* t =0);
  };
</pre>
<br>Параметр sk  задает, должны пропускаться пропуски или нет. Параметр
t  (необязательный)   задает  указатель   на  ostream,  к  которому
прикреплен istream.  Например, cin  прикреплен к  cout; это значит,
что перед  тем, как  попытаться читать символы из своего файла, cin
выполняет
<pre>
  cout.flush(); // пишет буфер вывода
</pre>
<br>  С помощью функции istream::tie() можно прикрепить (или открепить,
с помощью tie(0)) любой ostream к любому istream. Например:
<pre>
  int y_or_n(ostream& to, istream& from)
  /*
       "to", получает отклик из "from"
  */
  {
      ostream* old = from.tie(&to);
      for (;;) {
          cout << "наберите Y или N: ";
          char ch = 0;
          if (!cin.get(ch)) return 0;

          if (ch != '\n') { // пропускает остаток строки
              char ch2 = 0;
              while (cin.get(ch2) && ch2 != '\n') ;
          }
          switch (ch) {
          case 'Y':
          case 'y':
          case '\n':
              from.tie(old);        // восстанавливает старый tie
              return 1;
          case 'N':
          case 'n':
              from.tie(old);        // восстанавливает старый tie
              return 0;
          default:
              cout << "извините, попробуйте еще раз: ";
          }
      }
  }
</pre>
<br>Когда используется  буферизованный  ввод  (как  это  происходит  по
умолчанию), пользователь  не может набрав только одну букву ожидать
отклика. Система  ждет появления  символа  новой  строки.  y_or_n()
смотрит на первый символ строки, а остальные игнорирует.
<br>  Символ   можно    вернуть   в    поток    с    помощью    функции
istream::putback(char).  Это   позволяет   программе   "заглядывать
вперед" в поток ввода.
<a name=gl8.5>
<h2 ALIGN=CENTER>     8.5 Работа со Строками </h2>
<p>  Можно   осуществлять   действия,   подобные   вводу/выводу,   над
символьным  вектором,   прикрепляя  к  нему  istream  или  ostream.
Например, если вектор содержит обычную строку, завершающуюся нулем,
для печати  слов из  этого вектора  можно использовать  приведенный
выше копирующий цикл:
<pre>
  void word_per_line(char v[], int sz)
  /*
      печатет "v" размера "sz" по одному слову на строке
  */
  {
      istream ist(sz,v); // сделать istream для v
      char b2[MAX];      // больше наибольшего слова
      while (ist>>b2) cout << b2 << "\n";
  }
</pre>
<br>Завершающий нулевой  символ  в  этом  случае  интерпретируется  как
символ конца файла.
 <br> В помощью  ostream можно  отформатировать сообщения,  которые  не
нужно печатать тотчас же:
<pre>
  char* p = new char[message_size];
  ostream ost(message_size,p);
  do_something(arguments,ost);
  display(p);
</pre>
<br>  Такая операция,  как do_something,  может  писать  в  поток  ost,
передавать ost  своим  подоперациям  и  т.д.  с помощью  стандартных
операций вывода. Нет необходимости делать проверку не переполнение,
поскольку ost  знает свою  длину и когда он будет переполняться, он
будет переходить  в состояние  _fail.  И,  наконец,  display  может
писать сообщения  в "настоящий"  поток  вывода.  Этот  метод  может
оказаться наиболее  полезным, чтобы  справляться  с  ситуациями,  в
которых окончательное  отображение данных  включает  в  себя  нечто
более сложное,  чем работу  с традиционным  построчным  устройством
вывода. Например,  текст из ost мог бы помещаться в располагающуюся
где-то на экране область фиксированного размера.
<a name=gl8.6>
<h2 ALIGN=CENTER>     8.6 Буферизация </h2>
<p>  При задании  операций ввода/вывода  мы никак  не  касались  типов
файлов, но  ведь не  все устройства можно рассматривать одинаково с
точки  зрения   стратегии  буферизации.   Например,  для   ostream,
подключенного к  символьной строке,  требуется буферизация  другого
вида, нежели  для ostream, подключенного к файлу. С этими проблемами
можно  справиться,  задавая  различные  буферные  типы  для  разных
потоков  в   момент  инициализации   (обратите  внимание   на   три
конструктора класса  ostream). Есть  только один набор операций над
этими буферными  типами, поэтому  в функциях  ostream нет  кода, их
различающего. Однако  функции,  которые  обрабатывают  переполнение
сверху и  снизу, виртуальные. Этого достаточно, чтобы справляться с
необходимой в данное время стратегией буферизации. Это также служит
хорошим примером  применения виртуальных  функций для  того,  чтобы
сделать  возможной  однородную  обработку  логически  эквивалентных
средств с различной реализацией. Описание буфера потока в
выглядит так:
<pre>
  struct streambuf {      // управление буфером потока

      char* base;         // начало буфера
      char* pptr;         // следующий свободный char
      char* qptr;         // следующий заполненный char
      char* eptr;         // один из концов буфера
      char  alloc;        // буфер, выделенный с помощью new

          // Опустошает буфер:
          // Возвращает EOF при ошибке и 0 в случае успеха
      virtual int overflow(int c =EOF);

          // Заполняет буфер
          // Возвращет EOF при ошибке или конце ввода,
          // иначе следующий char
      virtual int underflow();

      int snextc()        // берет следующий char
      {
          return (++qptr==pptr) ? underflow() : *qptr&0377;
      }

      // ...

      int allocate()      // выделяет некоторое пространство буфера

      streambuf() { /* ... */}
      streambuf(char* p, int l) { /* ... */}
      ~streambuf() { /* ... */}
  };
</pre>
<br>  Обратите внимание,  что здесь определяются указатели, необходимые
для работы  с буфером,  поэтому обычные посимвольные действия можно
определить (только один раз) в виде максимально эффективных inline-
функций. Для  каждой конкретной  стратегии  буферизации  необходимо
определять только  функции переполнения  overflow() и  underflow().
Например:
<pre>
  struct filebuf : public streambuf {

      int fd;              // дескриптор файла
      char opened;         // файл открыт

      int overflow(int c =EOF);
      int underflow();

      // ...

          // Открывает файл:
          // если не срабатывает, то возвращает 0,
          // в случае успеха возвращает "this"
      filebuf* open(char *name, open_mode om);
      int close() { /* ... */ }

      filebuf() { opened = 0; }
      filebuf(int nfd) { /* ... */ }
      filebuf(int nfd, char* p, int l) : (p,l) { /* ... */ }
      ~filebuf() { close(); }
  };

  int filebuf::underflow()         // заполняет буфер из fd
  {
      if (!opened || allocate()==EOF) return EOF;

      int count = read(fd, base, eptr-base);
      if (count < 1) return EOF;

      qptr = base;
      pptr = base + count;
      return *qptr & 0377;
  }
</pre>
<a name=gl8.7>
<h2 ALIGN=CENTER>     8.7 Эффективность </h2>
<p>  Можно было  бы ожидать, что раз ввод/вывод  определен с
помощью общедоступных средств языка, он будет менее эффективен, чем
встроенное средство.  На самом  деле это не так. Для действий вроде
"поместить   символ    в   поток"    используются   inline-функции,
единственные необходимые  на этом  уровне вызовы  функций возникают
из-за переполнения  сверху и  снизу. Для  простых объектов  (целое,
строка  и   т.п.)  требуется   по  одному  вызову  на  каждый.  Как
выясняется, это  не  отличается  от  прочих  средств  ввода/вывода,
работающих с объектами на этом уровне.
<a name=gl8.8>
<h2 ALIGN=CENTER>     8.8 Упражнения </h2>
<ol>
 <LI> (*1.5) Считайте  файл чисел  с плавающей  точкой, составьте из
     пар считанных  чисел комплексные  числа и выведите комплексные
     числа.
<LI> (*1.5)   Определите    тип   name_and_address   (имя_и_адрес).
     Определите  для  него  <<  и  >>.  Скопируйте  поток  объектов
     name_and_address.
 <LI> (*2)  Постройте   несколько  функций   для  запроса  и  чтения
     различного  вида   информации.  Простейший  пример  -  функция
     y_or_n() в  <a HREF=#gl8.4.4>#8.4.4.</a> Идеи: целое, число с плавающей точкой, имя файла, почтовый адрес, дата, личные данные и т.д. Постарайтесь
     сделать их защищенными от дурака.
  <LI> (*1.5) Напишите  программу, которая  печатает (1)  все буквы в
     нижнем регистре, (2) все буквы, (3) все буквы и цифры, (4) все
     символы, которые  могут встречаться  в идентификаторах  C++ на
     вашей системе,  (5) все символы пунктуации, (6) целые значения
     всех управляющих символов, (7) все символы пропуска, (8) целые
     значения всех символов пропуска, и (9) все печатаемые символы.
  <LI> (*4)  Реализуйте   стандартную   библиотеку   ввода/вывода   C
     () с  помощью стандартной библиотеки ввода/вывода C++
     ().
  <LI> (*4)  Реализуйте   стандартную  библиотеку   ввода/вывода  C++
     () с  помощью стандартной библиотеки ввода/вывода  C
     ().
  <LI> (*4) Реализуйте  стандартные библиотеки C и C++ так, чтобы они
     могли использоваться одновременно.
<a name=y8> 
 <LI> (*2)  Реализуйте   класс,  для  которого  []  перегружено  для
     реализации случайного чтения символов из файла.
  <LI> (*3) Как  Упражнение 8,  только сделайте,  чтобы [] работало и
     для чтения,  и  для  записи.  Подсказка:  сделайте,  чтобы  []
     возвращало  объект   "дескрипторного   типа",   для   которого
     присваивание означало  бы присвоить  файлу через дескриптор, а
     неявное преобразование  в char  означало бы  чтение  из  файла
     через дескриптор.
  <LI> (*2) Как  Упражнение 9,  только  разрешите  []  индексировать
     записи некоторого вида, а не символы.
  <LI> (*3) Сделайте  обобщенный  вариант  класса,  определенного  в
     Упражнении 10.
  <LI> (*3.5)  Разработайте   и   реализуйте   операцию   ввода   по
     сопоставлению с  образцом. Для спецификации образца используйте
     строки  формата   в  духе   printf.  Должна  быть  возможность
     попробовать  сопоставить  со  вводом  несколько  образцов  для
     нахождения фактического  формата. Можно  было бы вывести класс
     ввода по образцу из istream.
  <LI> (*4) Придумайте  (и реализуйте) вид образцов, которые намного
     лучше.
</ol>
<p> <center> <font size="-1">
[<a href="gl7.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="ref1_7.htm">Вперед</a>]
</font>
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
