<html>
<head>





<title>Бьярн Страустрап. Введение в язык Си++,Турне по С++</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<a name=gl1>
<basefont size=3><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<h1 align=center>       Глава 1 </h1>
<h2 align=center >           Турне по C++ </h2>
<center><p>       Единственный способ изучать новый язык программирования - писать на нем программы.
<br>                                                  - Брайэн Керниган
</center>
<p>  Эта глава  представляет собой  краткий обзор  основных черт языка
программирования C++.  Сначала приводится  программа на  C++, затем
показано, как ее откомпилировать и запустить, и как такая программа
может выводить  выходные данные и считывать входные. В первой трети
этой главы  после введения  описаны  наиболее  обычные  черты  C++:
основные типы,  описания, выражения, операторы, функции и структура
программы. Оставшаяся  часть главы  посвящена возможностям  C++  по
определению новых  типов, скрытию  данных, операциям,  определяемым
пользователем, и иерархии определяемых пользователем типов.
<a name=gl1.1>
<h2 align=center >     1.1 Введение</h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl1.1.1>1.1.1 Вывод  </a></td>
<tr><td width=10></td><TD>   <a HREF=#gl1.1.2>1.1.2 Компиляция  </a> </td>                                
<tr><td width=10></td><TD>   <a HREF=#gl1.1.3> 1.1.3 Ввод     </a></td>
</table>
<p>  Это турне  проведет вас  через ряд  программ и частей программ на
C++. К концу у вас должно сложиться общее представление об основных
особенностях C++,  и  будет  достаточно  информации,  чтобы  писать
простые  программы.  Для  точного  и  полного  объяснения  понятий,
затронутых   даже    в   самом   маленьком   законченном   примере,
потребовалось бы несколько страниц определений. Чтобы не превращать
эту главу  в описание  или  в  обсуждение  общих  понятий,  примеры
снабжены  только   самыми  короткими   определениями   используемых
терминов.  Термины   рассматриваются  позже,   когда  будет  больше
примеров, способствующих обсуждению.
<a name=gl1.1.1>
<h3 align=center >     1.1.1 Вывод </h3>
<p>      Прежде  всего, давайте  напишем программу,  выводящую  строку
выдачи:
<pre>
  #include

  main()
  {
      cout << "Hello, world\n";
  }
</pre>
<br>  Строка #include  сообщает компилятору, чтобы он включил
стандартные возможности  потока ввода и вывода, находящиеся в файле
stream.h. Без  этих описаний  выражение cout << "Hello, world\n" не
имело бы  смысла. Операция  << ("поместить  в"<a HREF=#*1.1>*<sup>1</sup></a>) пишет  свой первый аргумент во  второй (в  данном случае,  строку "Hello,  world\n"  в
стандартный поток  вывода cout).  Строка -  это  последовательность
символов, заключенная  в двойные  кавычки. В строке символ обратной
косой  \,   за  которым  следует  другой  символ,  обозначает  один
специальный символ;  в данном  случае, \n  является символом  новой
строки. Таким  образом выводимые  символы состоят из Hello, world и
перевода строки.
<br>  Остальная часть программы
<pre>
  main() { ... }
</pre>
<br>определяет  функцию,   названную  main.   Каждая  программа  должна
содержать функцию  с именем  main, и  работа программы начинается с
выполнения этой функции.
<a name=gl1.1.2>
<h3 align=center>     1.1.2 Компиляция</h3>
<p>  Откуда появились  выходной поток cout и код, реализующий операцию
вывода <<?  Для  получения  выполняемого  кода  написанная  на  C++
программа  должна   быть  скомпилирована;  по  своей  сути  процесс
компиляции такой  же, как  и для  С, и в нем участвует большая часть
входящих в  последний программ. Производится чтение и анализ текста
программы, и  если не обнаружены ошибки, то генерируется код. Затем
программа  проверяется   на  наличие   имен  и   операций,  которые
использовались, но  не были  определены (в  нашем случае это cout и
<<). Если  это возможно,  то программа  делается полной посредством
дополнения недостающих  определений из библиотеки (есть стандартные
библиотеки, и  пользователи могут  создавать свои  собственные).  В
нашем случае  cout и  << были  описаны в  stream.h, то  есть,  были
указаны их  типы, но не было дано никаких подробностей относительно
их реализации.  В стандартной  библиотеке  содержится  спецификация
пространства и инициализирующий код для cout и <<. На самом деле, в
этой библиотеке  содержится и  много других вещей, часть из которых
описана в  stream.h, однако  к скомпилированной  версии добавляется
только подмножество библиотеки, необходимое для того, чтобы сделать
нашу программу полной.
<br>  Команда компиляции  в C++  обычно называется CC. Она используется
так же,  как команда  cc для  программ на  C; подробности вы можете
найти в  вашем руководстве.  Предположим, что  программа с  "Hello,
world"        хранится        в        файле        с        именем
hello.c, тогда вы можете ее скомпилировать и запустить примерно так
($ - системное приглашение):
<pre>
  $ CC hello.c
  $ a.out
  Hello,world
  $
</pre>
<br>a.out -  это принимаемое  по умолчанию  имя исполняемого результата
компиляции. Если  вы  хотите  назвать  свою  программу,  вы  можете
сделать это с помощью опции -o:
<pre>
  $ CC hello.c -o hello
  $ hello
  Hello,world
  $
</pre>
<a name=gl1.1.3>
<h3 ALIGN=CENTER>     1.1.3 Ввод</h3>
<p>  Следующая (довольно многословная) программа предлагает вам ввести
число дюймов.  После того,  как вы  это  сделаете,  она  напечатает
соответствующее число сантиметров.
<pre>
  #include

  main()
  {
      int inch = 0;         // inch - дюйм
      cout << "inches";
      cin >> inch;
      cout << inch;
      cout << " in = ";
      cout << inch*2.54;
      cout << " cm\n";
  }
</pre>
<br>Первая строка  функции main()  описывает целую  переменную inch. Ее
значение  считывается  с  помощью  операции  >>  ("взять  из")  над
стандартным потоком  ввода cin.  Описания cin  и  >>,  конечно  же,
находятся  в  .  После  ее  запуска  ваш  терминал  может
выглядеть примерно так:
<pre>
  $ a.out
  inches=12
  12 in = 30.48 cm
  $
</pre>
<br> В этом  примере на  каждую команду вывода приходится один оператор;
это слишком  длинно.  Операцию  вывода  <<  можно  применять  к  ее
собственному результату,  так что  последние четыре  команды вывода
можно было записать одним оператором:
<pre>
  cout << inch << " in = " << inch*2.54 << " cm\n";
</pre>
<br>В последующих  разделах ввод  и вывод будут описаны гораздо более
подробно.  Вся  эта  глава  фактически  может  рассматриваться  как
объяснение того,  как можно написать предыдущие программы на языке,
который не  обеспечивает  операции  ввода-вывода.  На  самом  деле,
приведенные  выше   программы  написаны   на   C++,   "расширенном"
операциями  ввода-вывода   посредством  использования  библиотек  и
включения файлов  с помощью  #include. Другими  словами, язык C++ в
том  виде,  в  котором  он  описан  в  справочном  руководстве,  не
определяет  средств  ввода-вывода;  вместо  этого  исключительно  с
помощью средств, доступных любому программисту, определены операции
<< и >>.
<a name=gl1.2>
<h2 ALIGN=CENTER>     1.2 Комментарии</h2>
<p>  Часто  бывает   полезно  вставлять  в  программу  текст,  который
предназначается  в   качестве  комментария   только  для  читающего
программу человека  и игнорируется  компилятором в программе. В C++
это можно сделать одним из двух способов.
<br>  Символы /*  начинают комментарий,  заканчивающийся символами  */.
Вся эта  последовательность символов  эквивалентна символу пропуска
(например, символу пробела). Это наиболее полезно для многострочных
комментариев и  изъятия частей программы при редактировании, однако
следует помнить, что комментарии /* */ не могут быть вложенными.
<br>  Символы //  начинают комментарий,  который заканчивается  в конце
строки, на  которой они  появились. Опять,  вся  последовательность
символов эквивалентна  пропуску. Этот  способ наиболее  полезен для
коротких комментариев.  Символы //  можно  использовать  для  того,
чтобы закомментировать  символы /*  или */,  а символами  /*  можно
закомментировать //.
<a name=gl1.3>
<h2 ALIGN=CENTER>     1.3 Типы и Описания</h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl1.3.1>1.3.1 Основные Tипы    </a>                            
<tr><td width=10></td><TD>   <a HREF=#gl1.3.2>1.3.2  Производные Типы    </a>                         
</table>
<p>  Каждое имя  и каждое  выражение имеет тип, определяющий операции,
которые могут над ними производиться. Например, описание
<pre>
  int inch;
</pre>
<br>определяет, что  inch имеет  тип int, то есть,  inch является целой
переменной.
<br>  Описание - это оператор, который вводит имя в программе. Описание
задает тип  этого имени.  Тип определяет   правильное использование
имени или выражения. Для целых определены такие операции, как +, -,
* и /. После того, как включен файл stream.h, объект типа int может
также быть вторым операндом <<, когда первый операнд ostream.
<br>  Тип объекта  определяет не только то, какие операции могут к нему
применяться, но и смысл этих операций. Например, оператор
<pre>
  cout << inch << " in = " << inch*2.54 << " cm\n";
</pre>
<br>правильно обрабатывает  четыре входных  значения различным образом.
Строки печатаются  буквально, тогда  как целое  inch и  значение  с
плавающей  точкой   inch*2.54  преобразуются   из  их   внутреннего
представления в  подходящее  для  человеческого  глаза  символьное
представление.
<br>  В  C++   есть  несколько  основных  типов  и  несколько  способов
создавать новые.  Простейшие виды типов C++ описываются в следующих
разделах, а более интересные оставлены на потом.
<a name=gl1.3.1>
<h3 ALIGN=CENTER>     1.3.1 Основные Tипы</h3>
<p>  Основные  типы,  наиболее  непосредственно  отвечающие  средствам
аппаратного обеспечения, такие:
<pre>
  char  short  int  long  float  double
</pre>
<br>Первые четыре  типа используются для представления целых, последние
два -  для представления  чисел с плавающей точкой. Переменная типа
char имеет  размер, естественный  для хранения  символа  на  данной
машине  (обычно,   байт),  а  переменная  типа  int  имеет  размер,
соответствующий целой арифметике на  данной машине (обычно, слово).
Диапазон  целых  чисел,  которые  могут  быть  представлены  типом,
зависит от его размера. В C++ размеры измеряются в единицах размера
данных типа char, поэтому char по определению имеет размер единица.
Соотношение между основными типами можно записать так:
<pre>
  1 = sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long)
  sizeof(float) <= sizeof(double)
</pre>
<br>В целом,  предполагать что-либо  еще  относительно  основных  типов
неразумно. В  частности, то,  что  целое  достаточно  для  хранения
указателя, верно не для всех машин.
<br>  К основному  типу можно  применять прилагательное const. Это дает
тип, имеющий  те же  свойства, что  и исходный  тип, за исключением
того, что значение переменных типа const  не может изменяться после
инициализации.
<pre>
  const float pi = 3.14;
  const char plus = '+';
</pre>
<br>  Символ, заключенный  в  одинарные  кавычки,  является  символьной
константой.  Заметьте,  что  часто  константа,  определенная  таким
образом, не занимает память; просто там, где требуется, ее значение
может    использоваться     непосредственно.    Константа    должна
инициализироваться  при   описании.  Для  переменных  инициализация
необязательна,  но   настоятельно  рекомендуется.   Оснований   для
введения локальной переменной без ее инициализации очень немного.
<br>  К любой  комбинации этих  типов могут  применяться арифметические
операции:
<table border=0>
<TR><TD>  + </TD><TD>  (плюс, унарный и бинарный)</td>
<TR><TD>  - </TD><TD>  (минус, унарный и бинарный)</td>
<TR><TD>  * </TD><TD>  (умножение) </TD>
<TR><TD>  / </TD><TD>  (деление)</TD>
</table>
<br>А также операции сравнения:
<table border=0>
<TR><TD>    ==  </TD><TD>    (равно) </TD>
<TR><TD>    !=   </TD><TD>   (не равно) </TD>
<TR><TD>    <    </TD><TD>   (меньше) </TD>
<TR><TD>    >    </TD><TD>   (больше) </TD>
<TR><TD>    <=  </TD><TD>   (меньше или равно) </TD>
<TR><TD>    >=  </TD><TD>   (больше или равно) </TD>
</table>
<br>Заметьте, что  целое деление  дает целый результат: 7/2 есть 3. Над
целыми может выполняться операция % получения остатка: 7%2 равно 1.
<br>   При  присваивании и  арифметических операциях  C++ выполняет все
осмысленные преобразования  между основными типами, чтобы их можно
было сочетать без ограничений:
<pre>
  double d = 1;
  int i = 1;
  d = d + i;
  i = d + i;
</pre>
<a name=gl1.3.2>
<h3 align=center>     1.3.2 Производные Типы</h3>
<p>  Вот операции, создающие из основных типов новые типы:
<table>
<TR><TD>  *  </TD><TD>      указатель на </TD>
<TR><TD>    *const  </TD><TD> константный указатель на </TD>
<TR><TD>    &   </TD><TD>      ссылка на </TD>
<TR><TD>    []   </TD><TD>     вектор<a HREF=#*1.2>*<sup>2</sup></a> </TD>
<TR><TD>    ()   </TD><TD>    функция, возвращающая </TD>
</table>
<br>  Например:
<table border=0>
<TR><TD>  char* p     </TD><TD>        // указатель на символ  </TD>
<TR><TD>  char *const q   </TD><TD>    // константный указатель на символ  </TD>
<TR><TD>  char v[10]     </TD><TD>    // вектор из 10 символов  </TD>
</table>
<br>Все вектора в качестве нижней границы индекса имеют ноль, поэтому в
v десять  элементов: v[0] ...  v[9].  Функции  объясняются  в <a HREF=#gl1.5> #1.5</a>,
ссылки в  <a HREF=#gl1.9>#1.9</a>. Переменная  указатель может содержать адрес объекта соответствующего типа:
<pre>
  char c;
  // ...
  p = &c; // p указывает на c
</pre>
<br>Унарное & является операцией взятия адреса.
<a name=gl1.4>
<h2 ALIGN=CENTER>     1.4 Выражения и Операторы</h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl1.4.1>1.4.1 Выражения           </a>                         
<tr><td width=10></td><TD>   <a HREF=#gl1.4.2>1.4.2 Операторы Выражения     </a>                    
<tr><td width=10></td><TD>   <a HREF=#gl1.4.3>1.4.3 Пустой оператор            </a>                  
<tr><td width=10></td><TD>   <a HREF=#gl1.4.4>1.4.4 Блоки                              </a>         
<tr><td width=10></td><TD>   <a HREF=#gl1.4.5>1.4.5 Операторы if          </a>                               
<tr><td width=10></td><TD>   <a HREF=#gl1.4.6>1.4.6 Операторы switch    </a>                          
<tr><td width=10></td><TD>   <a HREF=#gl1.4.7>1.4.7 Оператор while          </a>                         
<tr><td width=10></td><TD>   <a HREF=#gl1.4.8>1.4.8 Оператор for             </a>                        
<tr><td width=10></td><TD>   <a HREF=#gl1.4.9>1.4.9 Описания                </a>                         
</table>
<p>  В C++  имеется  богатый  набор  операций,  с  помощью  которых  в
выражениях  образуются   новые  значения    и  изменяются  значения
переменных.  Поток   управления  в  программе  задается  с  помощью
операторов , а описания используются для введения  в программе имен
переменных,  констант   и  т.д.  Заметьте,  что  описания  являются
операторами,  поэтому  они  свободно  могут  сочетаться  с  другими
операторами.
<a name=gl1.4.1>
<h3 ALIGN=CENTER>     1.4.1 Выражения</h3>
<p>  В C++  имеется большое  число операций,  и они  будут объясняться
там, где (и если) это потребуется. Следует учесть, что операции
<table border=0>
<TR><TD>  ~  </TD><TD>  (дополнение) </TD>
<TR><TD>  & </TD><TD>   (И) </TD>
<TR><TD>  ^  </TD><TD>  (исключающее ИЛИ) </TD>
<TR><TD>  |  </TD><TD>  (включающее ИЛИ) </TD>
<TR><TD>  <<  </TD><TD> (логический сдвиг влево) </TD>
<TR><TD>  >> </TD><TD>  (логический сдвиг вправо)</TD>
</table>
<br>применяются  к   целым,  и  что  нет  отдельного  типа  данных  для
логических действий.
<br>  Смысл операции  зависит от  числа операндов;  унарное &  является
операцией взятия адреса, а бинарное & - это операция логического И.
Смысл операции  зависит также  от типа  ее операндов: + в выражении
a+b означает  сложение с  плавающей точкой, если операнды имеют тип
float, но  целое сложение,  если они  типа int. В <a HREF=#gl1.8>#1.8</a> объясняется,
как   можно    определить   операцию    для   типа,   определяемого
пользователем,  без   потери  ее  значения,  предопределенного  для
основных и производных типов.
<br>  В C++  есть операция  присваивания =, а не оператор присваивания,
как  в   некоторых  языках.   Таким  образом,   присваивание  может
встречаться в  неожиданном контексте;  например, x=sqrt(a=3*x). Это
бывает полезно.  a=b=c означает  присвоение c  объекту   b, а затем
объекту  a. Другим свойством операции присваивания является то, что
она может  совмещаться с  большинством бинарных операций. Например,
x[i+3]*=4 означает  x[i+3]=x[i+3]*4, за исключением того факта, что
выражение  x[i+3]   вычисляется   только   один   раз.   Это   дает
привлекательную степень эффективности без необходимости обращения к
оптимизирующим компиляторам. К тому же это более кратко.
<br>  В большинстве  программ  на  C++  широко  применяются  указатели.
Унарная операция  * разыменовывает<a HREF=#*1.3>*<sup>3</sup></a> указатель, т.е. *p есть объект, на который  указывает p.  Эта операция  также называется  косвенной
адресацией. Например,  если имеется  char* p, то *p есть символ, на
который указывает p.  Часто при работе с указателями бывают полезны
операция увеличения  ++ и  операция уменьшения  --. Предположим,  p
указывает на  элемент вектора  v, тогда p++ делает p указывающим на
следующий элемент.
<a name=gl1.4.2>
<h3 align=center>     1.4.2 Операторы Выражения</h3>
<p>  Самый обычный  вид оператора  - оператор выражение. Он состоит из
выражения, за которым следует точка с запятой. Например:
<pre>
  a = b*3+c;
  cout << "go go go";
  lseek(fd,0,2);
</pre>
<a name=gl1.4.3>
<h3 ALIGN=CENTER>     1.4.3 Пустой оператор</h3>
<p>  Простейшей формой оператора является пустой оператор:
<br>
 <br> ;
<p>Он не  делает ничего.  Однако он  может быть полезен в тех случаях,
когда синтаксис требует наличие оператора, а вам оператор не нужен.
<a name=gl1.4.4>
<h3 ALIGN=CENTER>     1.4.4 Блоки </h3>
<p>  Блок -  это возможно  пустой  список  операторов,  заключенный  в
фигурные скобки:
<pre>
  { a=b+2; b++; }
</pre>
<br>Блок позволяет рассматривать несколько операторов как один. Область
видимости имени,  описанного в  блоке, простирается до конца блока.
Имя можно  сделать невидимым  с помощью описаний такого же имени во
внутренних блоках.
<a name=1.4.5>
<h3 align=center>     1.4.5 Операторы if </h3>
<p>  Программа в  следующем примере осуществляет преобразование дюймов
в сантиметры  и сантиметров в дюймы; предполагается, что вы укажете
единицы измерения  вводимых данных,  добавляя i  для дюймов и c для
сантиметров:
<pre>
  #include

  main()
  {
      const float fac = 2.54;
      float x, in, cm;
      char ch = 0;

      cout << "введите длину: ";
      cin >> x >> ch;

      if (ch == 'i') {       // inch - дюймы
          in = x;
          cm = x*fac;
      }
      else if (ch == 'c')   //  cm - сантиметры
          in = x/fac;
          cm = x;
      }
      else
          in = cm = 0;

      cout << in << " in = " << cm << " cm\n";
  }
</pre>
<br>Заметьте, что  условие в  операторе  if  должно  быть  заключено  в
круглые скобки.
<a name=gl1.4.6>
<h3 ALIGN=CENTER>     1.4.6 Операторы switch </h3>
<p>  Оператор switch  производит сопоставление  значения с  множеством
констант. Проверки в предыдущем примере можно записать так:
<pre>
  switch (ch) {
  case 'i':
      in = x;
      cm = x*fac;
      break;
  case 'c':
      in = x/fac;
      cm = x;
      break;
  default:
      in = cm = 0;
      break;
  }
</pre>
<br>  Операторы break  применяются  для  выхода  из  оператора  switch.
Константы  в   вариантах  case   должны  быть  различными,  и  если
проверяемое  значение   не  совпадает   ни  с  одной  из  констант,
выбирается   вариант    default.   Программисту    не   обязательно
предусматривать default.
<a name=gl1.4.7>
<h3 align=center>     1.4.7 Оператор while </h3>
<p>  Рассмотрим копирование  строки, когда  заданы указатель  p на  ее
первый символ и указатель q на целевую строку. По соглашению строка
оканчивается символом с целым значением 0.
<pre>
  while (p != 0) {
      *q = *p;        // скопировать символ
      q = q+1;
      p = p+1;
  }
  *q = 0;             // завершающий символ 0 скопирован не был
</pre>
<br>Следующее после  while условие  должно  быть  заключено  в  круглые
скобки.  Условие   вычисляется,  и   если  его  значение  не  ноль,
выполняется  непосредственно   следующий  за   ним  оператор.   Это
повторяется до тех пор, пока вычисление условия не даст ноль.
<br>  Этот пример  слишком пространен.  Можно использовать  операцию ++
для непосредственного указания увеличения, и проверка упростится:
<pre>
  while (*p)  *q++ = *p++;
  *q = 0;
</pre>
<br>где конструкция  *p++ означает: "взять символ, на который указывает
p, затем увеличить  p."
<br>  Пример можно  еще упростить, так как указатель p разыменовывается
дважды за  каждый цикл.  Копирование символа можно делать тогда же,
когда производится проверка условия:
<pre>
  while (*q++ = *p++) ;
</pre>
<br>Здесь берется символ, на который указывает p, p увеличивается, этот
символ копируется  туда, куда  указывает q, и q увеличивается. Если
символ  ненулевой,   цикл   повторяется.   Поскольку   вся   работа
выполняется в  условии,  не  требуется  ни одного  оператора.  Чтобы
указать на  это,  используется  пустой  оператор.  C++  (как  и  C)
одновременно любят  и ненавидят  за возможность  такого чрезвычайно
краткого ориентированного на выразительность программирования <a HREF=#*1.4>*<sup>4</sup></a>.
<a name=gl1.4.8>
<h3 align=center>     1.4.8 Оператор for </h3>
<p>  Рассмотрим копирование десяти элементов  одного вектора в другой:
<pre>
  for (int i=0; i<10; i++) q[i]=p[i];
</pre>
<br>Это эквивалентно
<pre>
  int i = 0;
  while (i<10) {
      q[i] = p[i];
      i++;
  }
</pre>
<br>но  более   удобочитаемо,  поскольку  вся  информация,  управляющая
циклом,  локализована.   При  применении   операции  ++    к  целой
переменной к ней просто добавляется единица. Первая часть оператора
for не  обязательно должна  быть описанием,  она может  быть  любым
оператором. Например:
<pre>
  for (i=0; i<10; i++) q[i]=p[i];
</pre>
<br>тоже  эквивалентно   предыдущей   записи   при   условии,   что   i
соответствующим образом описано раньше.
<a name=gl1.4.9>
<h3 align=center>     1.4.9 Описания </h3>
<p>  Описание -  это оператор,  вводящий имя  в программе.  Оно  может
также инициализировать  объект с  этим именем.  Выполнение описания
означает,  что   когда  поток   управления  доходит   до  описания,
вычисляется   инициализирующее    выражение    (инициализатор)    и
производится инициализация. Например:
<pre>
  for (int i = 1; i
</pre>
<a name=gl1.5>
<h2> 1.5 Функции </h2>
<p>  Функция -  это  именованная  часть  программы,  к  которой  можно
обращаться  из   других  частей   программы  столько  раз,  сколько
потребуется. Рассмотрим программу, печатающую степени числа 2:
<pre>
  extern float pow(float, int); //pow() определена в другом месте

  main()
  {
      for (int i=0; i<10; i++) cout << pow(2,i) << "\n";
  }
</pre>
<br>Первая строка  функции -  описание, указывающее, что pow - функция,
получающая  параметры  типа  float  и  int  и  возвращающая  float.
Описание функции используется для того, чтобы сделать определенными
обращения к функции в других местах.
<br>  При  вызове   тип  каждого  параметра  функции  сопоставляется  с
ожидаемым типом  точно  так  же,  как  если  бы  инициализировалась
переменная описанного  типа. Это гарантирует надлежащую  проверку и
преобразование типов.  Например, обращение  pow(12.3,"abcd") вызовет
недовольство компилятора,  поскольку "abcd"  является строкой, а не
int. При вызове pow(2,i) компилятор преобразует 2 к типу float, как
того требует  функция. Функция  pow может  быть определена например
так:
<pre>
  float pow(float x, int n)
  {
   if (n < 0) error("извините, отрицательный показатель для pow()");

      switch (n) {
      case 0: return 1;
      case 1: return x;
      default:    return x*pow(x,n-1);
      }
  }
</pre>
<br>Первая  часть   определения  функции   задает  имя   функции,   тип
возвращаемого ею  значения (если таковое имеется) и типы и имена ее
параметров (если  они есть).  Значение возвращается  из  функции  с
помощью оператора return.
<br>  Разные  функции   обычно  имеют   разные  имена,   но   функциям,
выполняющим сходные  действия над объектами различных типов, иногда
лучше  дать  возможность  иметь  одинаковые  имена.  Если  типы  их
параметров различны,  то компилятор  всегда может  различить  их  и
выбрать для  вызова нужную  функцию. Может,  например, иметься одна
функция возведения  в степень  для целых  переменных и  другая  для
переменных с плавающей точкой:
<pre>
  overload pow;
  int pow(int, int);
  double pow(double, double);
  //...
  x=pow(2,10);
  y=pow(2.0,10.0);

  Описание

  overload pow;
</pre>
<br>сообщает компилятору,  что использование  имени pow  более чем  для
одной функции является умышленным.
<br>  Если функция  не возвращает  значения, то  ее следует описать как
void:
<pre>
  void swap(int* p, int* q)    // поменять местами
  {
      int t = *p;
      *p = *q;
      *q = t;
  }
</pre>
<a name=gl1.6>
<h2 align=center>     1.6 Структура программы </h2>
<p>  Программа на  C++  обычно  состоит  из  большого  числа  исходных
файлов,  каждый   из  которых  содержит  описания  типов,  функций,
переменных и  констант. Чтобы  имя можно было использовать в разных
исходных файлах  для ссылки  на один  и тот  же  объект, оно должно
быть описано как внешнее. Например:
<pre>
  extern double sqrt(double);
  extern instream cin;
</pre>
<br>Самый обычный  способ обеспечить  согласованность исходных файлов -
это  поместить   такие  описания   в  отдельные  файлы,  называемые
заголовочными (или  хэдер)  файлами,  а  затем  включить,  то  есть
скопировать, эти  заголовочные файлы  во все  файлы, где  нужны эти
описания. Например,  если описание  sqrt  хранится  в  заголовочном
файле для  стандартных математических  функций math.h,  и вы хотите
извлечь квадратный корень из 4, можно написать:
<pre>
  #include
  //...
  x = sqrt(4);
</pre>
<br>Поскольку обычные  заголовочные файлы включаются во многие исходные
файлы, они  не содержат  описаний, которые  не должны  повторяться.
Например,  тела  функций  даются  только  для  inline-подставляемых
функций  (<a HREF=#gl1.12>#1.12</a>)   и  инициализаторы  даются  только  для  констант (<a HREF=#gl1.3.1>#1.3.1</a>). За  исключением этих  случаев, заголовочный файл является хранилищем информации  о типах.  Он  обеспечивает  интерфейс  между
отдельно компилируемыми частями программы.
<br>  В команде  включения include  имя файла,  заключенное  в  угловые
скобки, например  , относится  к  файлу  с  этим  именем  в
стандартном  каталоге   (часто  это   /usr/include/CC);  на  файлы,
находящиеся в  каких-либо других  местах ссылаются  с помощью имен,
заключенных в двойные кавычки. Например:
<pre>
  #include "math1.h"
  #include "/usr/bs/math2.h"
</pre>
<br>включит math1.h  из текущего  пользовательского каталога, а math2.h
из каталога /usr/bs.
<br>  Здесь приводится  очень маленький законченный пример программы, в
котором строка определяется в одном файле, а ее печать производится
в другом. Файл header.h определяет необходимые типы:
<pre>
  // header.h

  extern char* prog_name;
  extern void f();
</pre>
<br>  В файле main.c находится главная программа:
<pre>
  // main.c

  #include "header.h"
  char* prog_name = "дурацкий, но полный";
  main()
  {
      f();
  }
</pre>
<br>а файл f.c  печатает строку:
<pre>
  // f.c

  #include
  #include "header.h"
  void f()
  {
      cout << prog_name << "\n";
  }
</pre>
<br>  Скомпилировать и запустить программу вы можете например так:
<pre>
  $ CC main.c f.c -o silly
  $ silly
  дурацкий, но полный
  $
</pre>
<a name=gl1.7>
<h2>     1.7 Классы </h2>
<p>  Давайте посмотрим,  как мы  могли бы определить тип потока вывода
ostream. Чтобы  упростить задачу,  предположим, что для буферизации
определен тип  streambuf. Тип  streambuf на  самом деле определен в
, где  также находится  и настоящее  определение ostream.
Пожалуйста, не  испытывайте примеры,  определяющие ostream в этом и
последующих  разделах;   пока  вы  не  сможете  полностью  избежать
использования  ,   компилятор  будет   возражать   против
переопределений.
<br>  Определение типа,  определяемого  пользователем  (который  в  C++
называется   class, т.е.  класс), специфицирует данные, необходимые
для представления  объекта этого  типа, и  множество  операций  для
работы с  этими объектами.  Определение имеет  две части:  закрытую
(private) часть,  содержащую информацию, которой может пользоваться
только его  разработчик, и  открытую (public) часть, представляющую
интерфейс типа с пользователем:
<pre>
  class ostream {
      streambuf* buf;
      int state;
  public:
      void put(char*);
      void put(long);
      void put(double);
  }
</pre>
<br>Описания после  метки public  задают интерфейс:  пользователь может
обращаться только  к трем  функциям put().  Описания  перед  меткой
public задают  представление объекта  класса ostream;  имена buf  и
state могут  использоваться только  функциями put(),  описанными  в
открытой части.
<br>  class  определяет   тип,  а   не  объект  данных,  поэтому  чтобы
использовать ostream,  мы должны один такой объект описать (так же,
как мы описываем переменные типа int):
<pre>
  ostream my_out;
</pre>
<br>Считая, что  my_out был  соответствующим образом проинициализирован
(как, объясняется в <a HREF=#gl1.10>#1.10</a>), его можно использовать например так:
<pre>
  my_out.put("Hello, world\n");
</pre>
<br>С помощью  операции точка    выбирается  член  класса  для  данного
объекта этого  класса. Здесь  для объекта  my_out  вызывается  член
функция put().
<br>  Функция может определяться так:
<pre>
  void ostream::put(char* p)
  {
      while (*p) buf.sputc(*p++);
  }
</pre>
<br>где   sputc() -  функция,  которая  помещает  символ  в  streambuf.
Префикс ostream необходим, чтобы отличить put() ostream'а от других
функций с именем put().
<br>  Для обращения к функции члену должен быть указан объект класса. В
функции члене  можно ссылаться  на  этот  объект  неявно,  как  это
делалось выше  в ostream::put():  в каждом  вызове buf  относится к
члену buf объекта, для которого функция вызвана.
<br>  Можно также ссылаться на этот объект явно посредством указателя с
именем   this. В  функции члене класса X this неявно описан как  X*
(указатель на  X) и  инициализирован указателем  на тот объект, для
которого эта  функция  вызвана.  Определение  ostream::put()  можно
также записать в виде:
<pre>
  void ostream::put(char* p)
  {
      while (*p) this->buf.sputc(*p++);
  }
</pre>
<br> Операция  ->   применяется  для  выбора  члена  объекта,  заданного
указателем.
<a name=gl1.8>
<h2 align=center>     1.8 Перегрузка операций </h2>
<p>  Настоящий класс  ostream определяет  операцию <<,  чтобы  сделать
удобным  вывод   нескольких  объектов   одним  оператором.  Давайте
посмотрим, как это сделано.
<br>  Чтобы определить  @, где  @ -  некоторая операция  языка C++, для
каждого определяемого  пользователем типа  вы определяете функцию с
именем operator@, которая получает параметры соответствующего типа.
Например:
<pre>
  class ostream {
      //...
      ostream operator<<(char*);
  };

  ostream ostream::operator<<(char* p)
  {
      while (*p) buf.sputc(*p++);
      return *this;
  }
</pre>
<br>определяет операцию  <<  как  член  класса  ostream,  поэтому  s<
");

<br>а если  применить операцию  взятия адреса,  то  вы  получите  адрес
объекта, на который ссылается ссылка:
<pre>
  &s1 == &my_out
</pre>
<br>  Первая очевидная польза от ссылок состоит в том, чтобы обеспечить
передачу адреса  объекта, а не самого объекта, в функцию вывода (в
некоторых языках это называется передачей параметра по ссылке):
<pre>
  ostream& operator<<(ostream& s, complex z) {
      return s << "(" << z.real << "," << z.imag << ")";
  }
</pre>
<br>Достаточно интересно,  что тело  функции осталось без изменений, но
если   вы   будете   осуществлять   присваивание   s,   то   будете
воздействовать на  сам объект,  а не  на его копию. В данном случае
то,  что   возвращается  ссылка,   также  повышает   эффективность,
поскольку очевидный  способ реализации  ссылки -  это указатель,  а
передача указателя  гораздо дешевле, чем передача большой структуры
данных.
<br>  Ссылки также  существенны для определения потока ввода, поскольку
операция  ввода   получает  в   качестве  операнда  переменную  для
считывания. Если  бы  ссылки  не  использовались,  то  пользователь
должен был бы явно передавать указатели в функции ввода.
<pre>
  class istream {
      //...
      int state;
  public:
      istream& operator>>(char&);
      istream& operator>>(char*);
      istream& operator>>(int&);
      istream& operator>>(long&);
      //...
  };
</pre>
<br>Заметьте, что  для чтения  long и  int используются разные функции,
тогда как для их печати требовалась только одна. Это вполне обычно,
и причина  в том,  что int  может  быть  преобразовано  в  long  по
стандартным правилам  неявного  преобразования  (<a HREF=ref1_7.htm#ref1_7.6.6>#с.6.6</a>),  избавляя таким образом  программиста от  беспокойства  по  поводу  написания
обеих функций ввода.
<a name=gl1.10>
<h2 align=center>     1.10 Конструкторы </h2>
<p>  Определение ostream  как класса  сделало члены  данные закрытыми.
Только функция  член имеет  доступ к  закрытым членам, поэтому надо
предусмотреть функцию  для инициализации.  Такая функция называется
конструктором и  отличается тем,  что имеет  то же  имя, что  и  ее
класс:
<pre>
  class ostream {
      //...
      ostream(streambuf*);
      ostream(int size, char* s);
  };
</pre>
<br>Здесь  задано   два  конструктора.   Один  получает  вышеупомянутый
streambuf для  реального вывода, другой получает размер и указатель
на символ  для форматирования  строки. В  описании необходимый  для
конструктора список  параметров присоединяется  к имени.  Теперь вы
можете, например, описать такие потоки:
<pre>
  ostream my_out(&some_stream_buffer);
  char xx[256];
  ostream xx_stream(256,xx);
</pre>
<br>Описание my_out  не  только  задает  соответствующий  объем  памяти
где-то   в   другом   месте,   оно   также   вызывает   конструктор
ostream::ostream(streambuf*), чтобы инициализировать его параметром
&some_stream_buffer,  предположительно   указателем  на  подходящий
объект класса  streambuf.  Описание  конструкторов  для  класса  не
только дает  способ инициализации  объектов, но  также обеспечивает
то, что  все объекты  этого класса  будут проинициализированы. Если
для  класса   были  описаны  конструкторы,  то  невозможно  описать
переменную этого  класса так, чтобы конструктор не был вызван. Если
класс  имеет   конструктор,  не   получающий  параметров,  то  этот
конструктор будет  вызываться в  том случае, если в описании нет ни
одного параметра.
<a name=gl1.11>
<h2 align=center>     1.11 Вектора </h2>
<p>  Встроенное в  C++ понятие  вектора  было  разработано  так,  чтобы
обеспечить максимальную  эффективность выполнения  при  минимальном
расходе памяти.  Оно также (особенно когда используется совместно с
указателями)  является   весьма  универсальным   инструментом   для
построения средств  более высокого  уровня. Вы  могли бы,  конечно,
возразить, что  размер вектора должен задаваться как константа, что
нет проверки  выхода за  границы вектора  и т.д.  Ответ на подобные
возражения таков:  "Вы можете  запрограммировать это сами." Давайте
посмотрим, действительно  ли оправдан такой ответ. Другими словами,
проверим средства абстракции языка C++, попытавшись реализовать эти
возможности для  векторных  типов,  которые  мы  создадим  сами,  и
посмотрим, какие  с  этим  связаны  трудности,  каких  это  требует
затрат, и насколько получившиеся векторные типы удобны в обращении.
<pre>
  class vector {
      int* v;
      int  sz;
  public:
          vector(int);      // конструктор
          ~vector();        // деструктор
      int size() { return sz; }
      void set_size(int);
      int& operator[](int);
      int& elem(int i) { return v[i]; }
  };
</pre>
<br> Функция size  возвращает число  элементов  вектора,  таким  образом
индексы должны  лежать в диапазоне 0 ... size()-1. Функция set_size
сделана для  изменения этого  размера, elem  обеспечивает доступ  к
элементам  без   проверки  индекса,  а  operator[]  дает  доступ  с
проверкой границ.
<br>  Идея состоит в том, чтобы класс сам был структурой фиксированного
размера, управляющей доступом к фактической памяти вектора, которая
выделяется конструктором вектора с помощью распределителя свободной
памяти new:
<pre>
  vector::vector(int s)
  {
      if (s<=0) error("плохой размер вектора");
      sz = s;
      v = new int[s];
  }
</pre>
<br>Теперь вы  можете описывать  вектора  типа  vector  почти  столь  же
элегантно, как и вектора, встроенные в сам язык:
<pre>
  vector v1(100);
  vector v2(nelem*2-4);
</pre>
<br>Операцию доступа можно определить как
<pre>
  int& vector::operator[](int i)
  {
      if(i<0 || sz<=i) error("индекс выходит за границы");
      return v[i];
  }
</pre>
<br>Операция ||  (ИЛИИЛИ) -  это логическая  операция  ИЛИ.  Ее  правый
операнд вычисляется  только тогда,  когда это  необходимо, то  есть
если вычисление  левого  операнда  дало  ноль.  Возвращение  ссылки
обеспечивает то, что запись [] может использоваться с любой стороны
операции присваивания:
<pre>
  v1[x] = v2[y];
</pre>
<br>  Функция со  странным именем  ~vector -  это деструктор,  то  есть
функция, описанная  для того,  чтобы она  неявно вызывалась,  когда
объект класса  выходит из  области видимости.  Деструктор класса  C
имеет имя ~C. Если его определить как
<pre>
  vector::~vector()
  {
      delete v;
  }
</pre>
<br>то он  будет, с  помощью операции delete, освобождать пространство,
выделенное конструктором,  поэтому когда  vector выходит из области
видимости, все  его пространство  возвращается обратно в память для
дальнейшего использования.
<a name=gl1.12>
<h2 align=center>     1.12 Inline-подстановка </h2>
<p>  Если часто повторяется обращение к очень маленькой функции, то вы
можете начать  беспокоиться о стоимости вызова функции. Обращение к
функции члену  не дороже  обращения к  функции не  члену с  тем  же
числом параметров (надо помнить, что функция член всегда имеет хотя
бы один  параметр), и  вызовы в  функций в  C++ примерно  столь  же
эффективны, сколь  и в  любом языке.  Однако для  слишком маленьких
функций может  встать вопрос  о накладных  расходах на обращение. В
этом случае  можно рассмотреть возможность спецификации функции как
inline-подставляемой.  Если   вы  поступите   таким   образом,   то
компилятор сгенерирует  для функции  соответствующий код в месте ее
вызова. Семантика вызова не изменяется. Если, например, size и elem
inline-подставляемые, то
<pre>
  vector s(100);
  //...
  i = s.size();
  x = elem(i-1);
</pre>
<br>порождает код, эквивалентный
<pre>
  //...
  i = 100;
  x = s.v[i-1];
</pre>
<br>C++  компилятор   обычно  достаточно  разумен,  чтобы  генерировать
настолько хороший  код, насколько  вы можете  получить в результате
прямого макрорасширения.  Разумеется,  компилятор  иногда  вынужден
использовать временные  переменные и другие уловки, чтобы сохранить
семантику.
<br>  Вы можете  указать, что  вы хотите,  чтобы функция  была  inline-
подставляемой, поставив  ключевое слово  inline, или,  для  функции
члена, просто  включив определение  функции в  описание класса, как
это сделано в предыдущем примере для size() и elem().
<br>  При хорошем  использовании inline-функции резко повышают скорость
выполнения и  уменьшают размер  объектного  кода.  Однако,  inline-
функции запутывают  описания и могут замедлить компиляцию, поэтому,
если они  не необходимы,  то их  желательно избегать. Чтобы inline-
функция  давала  существенный  выигрыш    по  сравнению  с  обычной
функцией, она должна быть очень маленькой.
<a name=1.13>
<h2 align=center>     1.13 Производные  классы </h2>
<p>  Теперь давайте  определим вектор, для которого пользователь может
задавать границы изменения индекса.
<pre>
  class vec: public vector {
      int low, high;
  public:
      vec(int,int);
      int& elem(int);
      int& operator[](int);
  };
</pre>
<br>Определение vec как
<pre>
  :public vector
</pre>
<br>означает, в  первую очередь,  что vec  это vector. То есть, тип vec
имеет (наследует) все свойства типа vector дополнительно к тем, что
описаны специально  для него.  Говорят, что  класс vector  является
базовым классом  для vec,  а о vec говорится, что он производный от
vector.
 <br> Класс vec  модифицирует класс  vector тем,  что  в  нем  задается
другой конструктор,  который требует  от пользователя указывать две
границы изменения  индекса, а  не длину, и имеются свои собственные
функции доступа  elem(int) и operator[](int). Функция elem() класса
vec легко выражается через elem() класса vector:
<pre>
  int& vec::elem(int i)
  {
      return vector::elem(i-low);
  }
</pre>
<br>Операция разрешения  области видимости  :: используется  для  того,
чтобы не  было бесконечной  рекурсии обращения к vec::elem() из нее
самой. с помощью унарной операции :: можно ссылаться на нелокальные
имена. Было  бы разумно  описать vec::elem() как inline, поскольку,
скорее  всего,   эффективность   существенна,   но   необязательно,
неразумно и  невозможно написать  ее так, чтобы она непосредственно
использовала закрытый  член v  класса vector.  Фунции  производного
класса не имеют специального доступа к закрытым членам его базового
класса.
<br>  Конструктор можно написать так:
<pre>
  vec::vec(int lb, int hb) : (hb-lb+1)
  {
      if (hb-lb<0) hb = lb;
      low = lb;
      high = hb;
  }
</pre>
<br>Запись :  (hb-lb+1) используется  для определения списка параметров
конструктора базового  класса  vector::vector().  Этот  конструктор
вызывается перед  телом vec::vec().  Вот небольшой  пример, который
можно  запустить,  если  скомпилировать  его  вместе  с  остальными
описаниями vector:
<pre>
  #include

  void error(char* p)
  {
      cerr << p << "n\"; // cerr - выходной поток сообщений об
  ошибках
      exit(1);
  }

  void vector::set_size(int) { /* пустышка */ }

  int& vec::operator[](int i)
  {
      if (i
</pre>
<a name=gl1.14>
<h2 align=center>1.14 Еще об операциях </h2>
<p>  Другое направление развития - снабдить вектора операциями:
<pre>
  class Vec : public vector {
  public:
      Vec(int s) : (s) {}
      Vec(Vec&);
      ~Vec() {}
      void operator=(Vec&);
      void operator*=(Vec&);
      void operator*=(int);
      //...
  };
</pre>
<br>Обратите внимание  на способ  определения конструктора производного
класса, Vec::Vec(),  когда он  передает свой  параметр конструктору
базового класса  vector::vector() и  больше не  делает ничего.  Это
полезная парадигма.  Операция присваивания  перегружена,  ее  можно
определить так:
<pre>
  void Vec::operator=(Vec& a)
  {
      int s = size();
      if (s!=a.size()) error("плохой размер вектора для =");
      for (int i = 0; i

  void error(char* p) {
      cerr << p << "\n";
      exit(1);
  }

  void vector::set_size(int) { /*...*/ }

  int& vec::operator[](int i) { /*...*/ }

  main()
  {
      Vec a(10);
      Vec b(10);
      for (int i=0; i
</pre>
<a name=1.15>
<h2 align=center>1.15 Друзья (friends) </h2>
<p>  Функция   operator+()    не   воздействует   непосредственно   на
представление вектора.  Действительно, она  не может  этого  делать,
поскольку  не   является  членом.  Однако  иногда  желательно  дать
функциям не  членам возможность  доступа к  закрытой части  класса.
Например,  если   бы  не   было  функции   "доступа  без  проверки"
vector::elem(), вам  пришлось бы проверять индекс i на соответствие
границам три  раза за  каждый проход  цикла. Здесь мы избежали этой
сложности, но  она довольно типична, поэтому у класса есть механизм
предоставления права  доступа к  своей закрытой  части функциям  не
членам. Просто в описание класса помещается описание функции, перед
которым стоит ключевое слово friend. Например, если имеется
<pre>
  class Vec;  // Vec - имя класса

  class vector {
      friend Vec operator+(Vec, Vec);
      //...
  };
</pre>
<br>То вы можете написать
<pre>
  Vec operator+(Vec a, Vec b)
  {
      int s = a.size();
      if (s != b.size()) error("плохой размер вектора для +");
      Vec& sum = *new Vec(s);
      int* sp = sum.v;
      int* ap = a.v;
      int* bp = b.v;
      while (s--) *sp++ = *ap++ + *bp++;
      return sum;
  }
</pre>
<br>Одним из  особенно полезных  аспектов механизма friend является то,
что функция  может быть  другом двух и более классов. Чтобы увидеть
это, рассмотрим  определение vector  и matrix,  а затем определение
функции умножения (см. <a HREF=ref8.htm#ref8.8>#с.8.8</a>).
<a name=gl1.16>
 <h2 align=center>    1.16 Обобщенные Вектора </h2>
<p>  "Пока все  хорошо," - можете сказать вы, - "но я хочу, чтобы один
из этих  векторов был типа matrix, который я только что определил."
К сожалению, в C++ не предусмотрены средства для определения класса
векторов с  типом элемента в качестве параметра. Один из способов -
продублировать описание  и класса,  и его  функций членов.  Это  не
идеальный способ, но зачастую вполне приемлемый.
<br>  Вы   можете    воспользоваться   препроцессором   (<a HREF=gl4.htm#gl4.7>#4.7</a>),   чтобы механизировать работу.  Например, класс vector - упрощенный вариант
класса, который   можно  найти в стандартном заголовочном файле. Вы
могли бы написать:
<pre>
  #include

  declare(vector,int);

  main()
  {
      vector(int) vv(10);
      vv[2] = 3;
      vv[10] = 4; // ошибка: выход за границы
  }
</pre>
<br>Файл  vector.h     таким   образом  определяет     макросы,   чтобы
declare(vector,int) после  расширения превращался в описание класса
vector, очень  похожий  на  тот,  который  был  определен  выше,  а
implement(vector,int)  расширялся   в  определение   функций  этого
класса. Поскольку  implement(vector,int)  в  результате  расширения
превращается  в  определение  функций,  его  можно  использовать  в
программе только  один раз,  в то  время как    declare(vector,int)
должно использоваться  по одному  разу в каждом файле, работающем с
этим типом целых векторов.
<pre>
  declare(vector,char);
  //...
  implement(vector,char);
</pre>
<br>даст  вам   отдельный  тип  "вектор  символов".  Пример  реализации
обобщенных классов с помощью макросов приведен в <a href=gl7.htm#gl7.3.5>#7.3.5</a>.
<a name=1.17>
<h2 align=center>     1.17 Полиморфные Вектора </h2>
<p>  У вас есть другая возможность - определить ваш векторный и другие
вмещающие классы через указатели на объекты некоторого класса:
<pre>
  class common {
      //...
  };
  class vector {
      common** v;
      //...
  public:
      cvector(int);
      common*& elem(int);
      common*& operator[](int);
      //...
  };
</pre>
<br>Заметьте, что  поскольку в  таких векторах хранятся указатели, а не
сами объекты,  объект может  быть  "в"  нескольких  таких  векторах
одновременно.  Это   очень  полезное  свойство  подобных  вмещающих
классов, таких,  как вектора,  связанные списки,  множества и  т.д.
Кроме  того,  можно  присваивать  указатель  на  производный  класс
указателю  на   его  базовый   класс,  поэтому  можно  использовать
приведенный выше  cvector для  хранения указателей  на объекты всех
производных от common классов. Например:
<pre>
  class apple : public common { /*...*/ }
  class orange : public common { /*...*/ }
  class apple_vector : public cvector {
  public:

  cvector fruitbowl(100);
  //...
  apple aa;
  orange oo;
  //...
  fruitbowl[0] = &aa;
  fruitbowl[1] = &oo;
  }
</pre>
<br>Однако, точный  тип объекта,  вошедшего в  такой  вмещающий  класс,
больше компилятору  не известен.  Например, в предыдущем примере вы
знаете, что  элемент вектора  является common, но является он apple
или  orange?   Обычно   точный   тип   должен   в последствие   быть
восстановлен, чтобы  обеспечить правильное  использование  объекта.
Для этого  нужно или  в какой-то  форме хранить информацию о типе в
самом объекте,  или обеспечить, чтобы во вмещающий класс помещались
только объекты  данного типа. Последнее легко достигается с помощью
производного  класса.   Вы  можете,   например,  создать     вектор
указателей на apple:
<pre>
  class apple_vector : public cvector {
  public:
      apple*& elem(int i)
          { return (apple*&) cvector::elem(i); }
      //...
  };
</pre>
<br>используя  запись   приведения  к   типу     (тип)выражение,  чтобы
преобразовать common*&  (ссылку на  указатель на  common),  которую
возвращает cvector::elem,  в apple*&.  Такое применение производных
классов создает альтернативу обобщенным классам. Писать его немного
труднее  (если   не  использовать   макросы  таким  образом,  чтобы
производные классы  фактически реализовывали обобщенные классы; см.
<a HREF=gl7.htm#gl7.3.5>#7.3.5</a>), но  оно имеет  то преимущество, что все производные классы совместно используют  единственную копию функции базового класса. В
случае обобщенных  классов, таких,  как vector(type),  для  каждого
нового   используемого   типа   должна   создаваться   (с   помощью
implement()) новая  копия таких  функций. Другой  способ,  хранение
идентификации  типа   в  каждом   объекте,  приводит  нас  к  стилю
программирования, который  часто  называют  объекто-основанным  или
объектно-ориентированным.
<a name=gl1.18>
<h2 align=center>     1.18 Виртуальные функции </h2>
<p>  Предположим, что  мы пишем  программу для  изображения  фигур  на
экране.  Общие   атрибуты  фигуры  представлены  классом  shape,  а
специальные атрибуты - специальными классами:
<pre>
  class shape {
      point center;
      color col;
      //...
  public:
      void move(point to) { center=to; draw(); }
      point where() { return center; }
      virual void draw();
      virtual void rotate(int);
      //...
  };
</pre>
<br>Функции, которые можно определить не зная точно определенной фигуры
(например, move  и where,  то есть,  "передвинуть" и  "где"), можно
описать как  обычно. Остальные  функции описываются  как virual, то
есть такие,  которые  должны  определяться  в  производном  классе.
Например:
<pre>
  class circle: public shape {
      int radius;
  public:
      void draw();
      void rotatte(int i) {}
      //...
  };
</pre>
<br>Теперь, если shape_vec - вектор фигур, то можно написать:
<pre>
  for (int i = 0; i
</pre>
<p><small>
<a name=*1.1>
*<sup>1</sup> Программирующим  на C  << известно  как операция сдвига влево для
целых. Такое  использование <<  не утеряно;  просто в дальнейшем <<
было определено  для  случая,  когда  его  левый  операнд  является
потоком вывода. Как это делается, описано в #1.8. (прим. автора)
<a name=*1.2>
<br>*<sup>2</sup>  одномерный   массив.  Это  принятый  термин  (например,  вектора
прерываний), и  мы сочли,  что стандартный перевод его как "массив"
затуманит изложение. (прим. перев.)
<a name=*1.3>
<br>*<sup>3</sup>  англ.  dereference  -  получить  значение  объекта,  на  который
указывает данный указатель. (прим. перев.)
<a name=*1.4>
<br>*<sup>4</sup> в  оригинале expression-oriented  (expression - выразительность и
выражение). (прим. перев.)

</small>
<p> <center> <font size="-1">
[<a href="apredis.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="gl2.htm">Вперед</a>]
</font> 
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
