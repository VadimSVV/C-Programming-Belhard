<htm>
<head>



<META NAME="Document-state" CONTENT=
"Static">

<title>Бьярн Страустрап. Введение в язык Си++, Классы</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<basefont size=3><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<a name=gl5_1>
<h1 align=center>               Глава 5 </h1>
<h2 align=center>        Классы </h2>
<p><center>      Эти типы не "абстрактны", они столь же реальны, как int и float.
                                                     - Дуг МакИлрой
</center>
<p>  В этой  главе описываются  возможности  определения новых типов в
C++, для  которых доступ  к данным  ограничен  заданным  множеством
функций доступа.  Объясняются способы  защиты структуры  данных, ее
инициализации, доступа  к ней  и, наконец,  ее уничтожения. Примеры
содержат простые  классы для  работы с  таблицей имен,  манипуляции
стеком, работу  с множеством  и  реализацию  дискриминирующего  (то
есть,  "надежного")   объединения.  Две  следующие  главы  дополнят
описание возможностей  определения новых  типов в  C++ и познакомят
читателя еще с некоторыми интересными примерами.
<a name=gl5_1.1>
<h2 ALIGN=CENTER>     5.1 Знакомство и краткий обзор </h2>
<p>  Предназначение понятия  класса,  которому  посвящены  эта  и  две
последующие главы,  состоит в  том, чтобы предоставить программисту
инструмент для  создания новых  типов, столь же удобных в обращении
сколь и  встроенные типы. В идеале тип, определяемый пользователем,
способом использования  не должен  отличаться от  встроенных типов,
только способом создания.
<br>  Тип есть  конкретное представление некоторой концепции (понятия).
Например, имеющийся в C++ тип float с его операциями +, -, * и т.д.
обеспечивает ограниченную,  но  конкретную  версию  математического
понятия действительного  числа. Новый тип создается для того, чтобы
дать   специальное и конкретное определение понятия, которому ничто
прямо и  очевидно среди  встроенных типов  не отвечает. Например, в
программе, которая  работает с телефоном, можно было бы создать тип
trunk_module (элемент линии), а в программе обработки текстов - тип
list_of_paragraphs (список  параграфов). Как  правило, программу, в
которой создаются  типы,  хорошо  отвечающие  понятиям  приложения,
понять легче,  чем программу,  в которой  это не  делается.  Хорошо
выбранные типы,  определяемые пользователем, делают программу более
четкой и  короткой. Это  также позволяет  компилятору  обнаруживать
недопустимые использования  объектов, которые  в  противном  случае
останутся необнаруженными до тестирования программы.
<br>  В определении нового типа основная идея - отделить несущественные
подробности   реализации    (например,   формат   данных,   которые
используются для  хранения объекта  типа) от  тех качеств,  которые
существенны для  его правильного  использования  (например,  полный
список функций,  которые имеют  доступ к  данным). Такое разделение
можно описать  так, что  работа со  структурой данных и внутренними
административными подпрограммами  осуществляется через  специальный
интерфейс (каналируется).
 <br> Эта глава состоит из четырех практически отдельных частей:
<OL type=I>
<LI> Классы и  Члены. Этот  раздел знакомит  с основным  понятием
     типа, определяемого  пользователем, который  называется  класс
     (class). Доступ к объектам класса может ограничиваться набором
     функций, которые описаны как часть этого класса. Такие функции
     называются  функциями  членами.  Объекты  класса  создаются  и
     инициализируются функциями  членами, специально  для этой цели
     описанными. Эти  функции  называются  конструкторами.  Функция
     член может  быть специальным  образом  описана  для  "очистки"
     каждого классового  объекта при его уничтожении. Такая функция
     называется деструктором.
  <LI> Интерфейсы и  Реализации.  В  этом  разделе  приводится  два
     примера  того,   как  класс   проектируется,   реализуется   и
     используется.
  <LI> Друзья  и  Объединения.  В  этом  разделе  приводится  много
     дополнительных  подробностей,   касающихся  классов.   В   нем
     показано, как  предоставить доступ  к  закрытой  части  класса
     функции,  которая  не  является  членом  этого  класса.  Такая
     функция называется  друг (friend).  В  этом  разделе  показано
     также, как определить дискриминирующее объединение.
  <LI> Конструкторы и  Деструкторы. Объект  может  создаваться  как
     автоматический, статический или как объект в свободной памяти.
     Объект может  также быть  членом некоторой  совокупности (типа
     вектора или  класса), которая в свою очередь может размещаться
     одним из  этих трех  способов.  Довольно  подробно  объясняется
     использование конструкторов и деструкторов.
</ol>
<a name=gl5_1.2>
<h2 ALIGN=CENTER>       5.2 Классы и Члены </H2>
<table border=0>
<tr><td width=10></td><TD>     <a HREF=#gl5_1.2.1>       5.2.1 Функции Члены      </a>                        
<tr><td width=10></td><TD>      <a HREF=#gl5_1.2.2>     5.2.2 Классы                      </a>               
<tr><td width=10></td><TD>     <a HREF=#gl5_1.2.3>    5.2.3 Ссылки на Себя         </a>                   
<tr><td width=10></td><TD>     <a HREF=#gl5_1.2.4>    5.2.4 Инициализация         </a>                     
<tr><td width=10></td><TD>      <a HREF=#gl5_1.2.5>      5.2.5 Очистка                 </a>                   
<tr><td width=10></td><TD>      <a HREF=#gl5_1.2.6>      5.2.6  Inline                      </a>               
</table>
<p>  Класс -  это определяемый пользователем тип. Этот раздел знакомит
с основными средствами определения класса, создания объекта класса,
работы с  такими объектами  и, наконец,  уничтожения таких объектов
после использования.
<a name=gl5_1.2.1>
<h3 ALIGN=CENTER>        5.2.1 Функции Члены </h3>
<p>  Рассмотрим реализацию  понятия даты  с использованием  struct для
того, чтобы  определить представление даты date и множества функций
для работы с переменными этого типа:
<pre>
  struct date { int month, day, year; };
      // дата:     месяц, день, год  }
  date today;
  void set_date(date*, int, int, int);
  void next_date(date*);
  void print_date(date*);
  // ...
</pre>
<br>  Никакой явной  связи между  функциями и  типом данных  нет. Такую
связь можно установить, описав функции как члены:
<pre>
  struct date {
      int month, day, year;

  void set(int, int, int);
  void get(int*, int*, int*);
  void next();
  void print();
  };
</pre>
<br>Функции, описанные  таким образом,  называются функциями  членами и
могут вызываться только для специальной переменной соответствующего
типа с  использованием стандартного синтаксиса для доступа к членам
структуры. Например:
<pre>
  date today;         // сегодня
  date my_burthday;   // мой день рождения

  void f()
  {
      my_burthday.set(30,12,1950);
      today.set(18,1,1985);

      my_burthday.print();
      today.next();
  }
</pre>
<br>  Поскольку  разные   структуры  могут   иметь  функции   члены   с
одинаковыми  именами,  при  определении  функции  члена  необходимо
указывать имя структуры:
<pre>
  void date::next()
  {
      if ( ++day > 28 ) {
          // делает сложную часть работы
      }
  }
</pre>
<br>В функции  члене имена членов могут использоваться без явной ссылки
на объект.  В этом  случае имя  относится к члену того объекта, для
которого функция была вызвана.
<a name=gl5_1.2.2>
<h3 ALIGN=CENTER>       5.2.2 Классы </h3>
<p>  Описание date  в предыдущем подразделе дает множество функций для
работы с  date, но  не  указывает,  что  эти  функции  должны  быть
единственными для  доступа к  объектам типа  date. Это  ограничение
можно наложить используя вместо struct class:
<pre>
  class date {
      int month, day, year;
  public:
      void set(int, int, int);
      void get(int*, int*, int*);
      void next();
      void print();
  };
</pre>
<br>  Метка public  делит тело  класса на  две части.  Имена в  первой,
закрытой части,  могут  использоваться  только  функциями  членами.
Вторая, открытая  часть, составляет  интерфейс  к  объекту  класса.
Struct -  это просто  class, у  которого все  члены общие,  поэтому
функции члены  определяются   и используются  точно так  же, как  в
предыдущем случае. Например:
<pre>
  void date::ptinr()        // печатает в записи, принятой в США
  {
      cout << month << "/" << day << "/" year;
  }
</pre>
<br>Однако функции не члены отгорожены от использования закрытых членов
класса date. Например:
<pre>
  void backdate()
  {
      today.day--;        // ошибка
  }
</pre>
<br>  В том,  что доступ  к структуре  данных ограничен  явно описанным
списком функций,  есть несколько преимуществ. Любая ошибка, которая
приводит  к   тому,  что   дата  принимает   недопустимое  значение
(например, Декабрь  36, 1985)  должна быть  вызвана  кодом  функции
члена, поэтому  первая стадия отладки, локализация, выполняется еще
до того,  как программа  будет запущена.  Это частный случай общего
утверждения, что  любое изменение  в поведении  типа date  может  и
должно вызываться  изменениями в  его членах. Другое преимущество -
это то,  что потенциальному  пользователю такого  типа нужно  будет
только  узнать  определение  функций  членов,  чтобы  научиться  им
пользоваться.
<br>  Защита закрытых  данных связана с ограничением использования имен
членов класса.  Это можно обойти с помощью манипуляции адресами, но
это уже, конечно, жульничество.
<a name=gl5_1.2.3>
<h3 ALIGN=CENTER>       5.2.3 Ссылки на Себя </h3>
<p>  В функции  члене на члены объекта, для которого она была вызвана,
можно ссылаться непосредственно. Например:
<pre>
class x {
      int m;
  public:
      int readm() { return m; }
  };

  x aa;
  x bb;

  void f()
  {
      int a = aa.readm();
      int b = bb.readm();
      // ...
  }
</pre>
<br>  В первом  вызове члена member() m относится к aa.m, а во втором -
к bb.m.
<br>  Указатель на  объект, для  которого вызвана функция член, является
скрытым  параметром   функции.  На   этот  неявный  параметр  можно
ссылаться явно  как на  this. В  каждой функции  класса x указатель
this неявно описан как
<pre>
  x* this;
</pre>
<br>и инициализирован  так, что  он указывает  на объект,  для которого
была вызвана  функция член. this не может быть описан явно, так как
это ключевое  слово. Класс  x можно  эквивалентным образом  описать
так:
<pre>
  class x {
      int m;
  public:
      int readm() { return this->m; }
  };
</pre>
<br>При ссылке  на члены  использование this  излишне. Главным  образом
this   используется   при   написании   функций   членов,   которые
манипулируют непосредственно  указателями. Типичный  пример этого -
функция, вставляющая звено в дважды связанный список:
<pre>
  class dlink {
      dlink* pre;    // предшествующий
      dlink* suc;    // следующий
  public:
      void append(dlink*);
      // ...
  };

  void dlink::append(dlink* p)
  {
      p->suc = suc;    // то есть, p->suc = this->suc
      p->pre = this;   // явное использование this
      suc->pre = p;    // то есть, this->suc->pre = p
      suc = p;         // то есть, this->suc = p
  }

  dlink* list_head;

  void f(dlink*a, dlink *b)
  {
      // ...
      list_head->append(a);
      list_head->append(b);
  }
</pre>
<br>    Цепочки  такой  общей  природы  являются  основой  для  списковых
классов, которые  описываются в <a HREF=gl7.htm#gl7>Главе 7.</a> Чтобы присоединить звено к списку необходимо  обновить объекты, на которые указывают указатели
this, pre  и suc  (текущий, предыдущий и последующий). Все они типа
dlink, поэтому  функция член  dlink::append() имеет  к ним  доступ.
Единицей защиты в C++ является class, а не отдельный объект класса.
<a name=gl5_1.2.4>
<h3 ALIGN=CENTER>      5.2.4 Инициализация </h3>
<p>  Использование  для   обеспечения  инициализации   объекта  класса
функций вроде  set_date() (установить  дату) неэлегантно  и чревато
ошибками. Поскольку  нигде не  утверждается, что объект должен быть
инициализирован, то  программист может забыть это сделать, или (что
приводит, как  правило, к  столь  же  разрушительным  последствиям)
сделать это  дважды. Есть  более хороший  подход: дать  возможность
программисту   описать    функцию,   явно    предназначенную    для
инициализации  объектов.   Поскольку  такая   функция  конструирует
значения данного  типа, она  называется конструктором.  Конструктор
распознается по  тому, что  имеет то  же  имя,  что  и  сам  класс.
Например:
<pre>
  class date {
      // ...
      date(int, int, int);
  };
</pre>
<br>  Когда класс  имеет конструктор,  все  объекты  этого  класса  будут
инициализироваться. Если  для  конструктора  нужны  параметры,  они
должны даваться:
<pre>
  date today = date(23,6,1983);
  date xmas(25,12,0);        // сокращенная форма
                          // (xmas - рождество)
  date my_burthday;        // недопустимо, опущена инициализация
</pre>
<br>    Часто бывает  хорошо обеспечить  несколько способов инициализации
объекта класса.  Это можно  сделать, задав несколько конструкторов.
Например:
<pre>
  class date {
      int month, day, year;
  public:
      // ...
      date(int, int, int);    // день месяц год
      date(char*);            // дата в строковом представлении
      date(int);                // день, месяц и год сегодняшние
      date();                    // дата по умолчанию: сегодня
  };
</pre>
<br>  Конструкторы  подчиняются  тем  же  правилам    относительно  типов
параметров, что  и перегруженные функции (<a HREF=gl4.htm#gl4.7>#4.6.7</a>). Если конструкторы существенно различаются по типам своих параметров, то компилятор при
каждом использовании может выбрать правильный:
<pre>
  date today(4);
  date july4("Июль 4, 1983");
  date guy("5 Ноя");
  date now;                    // инициализируется по умолчанию
</pre>
<br>    Заметьте, что  функции члены  могут быть  перегружены без  явного
использования ключевого  слова overload.  Поскольку  полный  список
функций членов  находится в описании класса и как правило короткий,
то нет  никакой серьезной  причины  требовать  использования  слова
overload для  предотвращения случайного    повторного  использования
имени.
<br>  Размножение  конструкторов   в  примере   с  date   типично.  При
разработке класса  всегда есть  соблазн обеспечить "все", поскольку
кажется проще  обеспечить какое-нибудь  средство просто  на случай,
что оно  кому-то понадобится  или потому,  что оно изящно выглядит,
чем решить,  что же  нужно на самом деле. Последнее требует больших
размышлений, но  обычно приводит  к программам,  которые меньше  по
размеру  и   более  понятны.   Один  из  способов  сократить  число
родственных функций - использовать параметры по умолчанию. В случае
date для  каждого параметра  можно задать  значение  по  умолчанию,
интерпретируемое как "по умолчанию принимать: today" (сегодня).
<pre>
  class date {
      int month, day, year;
  public:
      // ...
      date(int d =0, int m =0, int y =0);
      date(char*);            // дата в строковом представлении
  };

  date::date(int d, int m, int y)
  {
      day = d ? d : today.day;
      month = m ? m : today.month;
      year = y ? y : today.year;
      // проверка, что дата допустимая
      // ...
  }
</pre>
<br>    Когда используется  значение  параметра,  указывающее  "брать  по
умолчанию",  выбранное   значение  должно   лежать  вне   множества
возможных значений параметра. Для дня day и месяца mounth ясно, что
это так,  но для  года year  выбор нуля  неочевиден. К  счастью,  в
европейском календаре  нет нулевого года . Сразу после 1 г. до н.э.
(year==-1) идет  1 г. н.э. (year==1), но для реальной программы это
может оказаться слишком тонко.
<br>  Объект класса  без  конструкторов  можно  инициализировать  путем
присваивания ему  другого объекта  этого класса. Это можно делать и
тогда, когда конструкторы описаны. Например:
<pre>
  date  d = today;    // инициализация посредством присваивания
</pre>
<br>  По существу,  имеется конструктор  по умолчанию,  определенный  как
побитовая копия  объекта того  же класса.  Если для  класса X такой
конструктор по  умолчанию  нежелателен,  его  можно  переопределить
конструктором с именем X(X&). Это будет обсуждаться в <a HREF=gl6.htm#gl6.6>#6.6.</a>
<a name=gl5_1.2.5>
<h3 ALIGN=CENTER>         5.2.5 Очистка </h3>
<p>  Определяемый  пользователем   тип  чаще   имеет,  чем  не  имеет,
конструктор, который  обеспечивает  надлежащую  инициализацию.  Для
многих типов  также требуется  обратное действие, деструктор, чтобы
обеспечить  соответствующую   очистку  объектов   этого  типа.  Имя
деструктора для  класса X  есть ~X() ("дополнение конструктора"). В
частности,  многие   типы  используют  некоторый  объем  памяти  из
свободной памяти  (см. <a HREF=gl3.htm#gl3.2.6>#3.2.6</a>),  который выделяется конструктором и освобождается деструктором.  Вот, например,  традиционный  стековый
тип,  из  которого  для  краткости  полностью  выброшена  обработка
ошибок:
<pre>
  class char_stack {
      int size;
      char* top;
      char* s;
  public:
      char_stack(int sz) { top=s=new char[size=sz]; }
      ~char_stack()      { delete s; }    // деструктор
      void push(char c)  { *top++ = c; }
      char pop()         { return *--top;}
  }
</pre>
<br>  Когда  char_stack     выходит   из  области  видимости,  вызывается
деструктор:
<pre>
  void f()
  {
      char_stack s1(100);
      char_stack s2(200);
      s1.push('a');
      s2.push(s1.pop());
      char ch = s2.pop();
      cout << chr(ch) << "\n";
  }
</pre>
<br>  Когда вызывается  f(), конструктор  char_stack вызывается  для  s1,
чтобы выделить  вектор из  100 символов,  и для  s2, чтобы выделить
вектор из  200 символов.  При возврате из f() эти два вектора будут
освобождены.
<a name=gl5_1.2.6>
<h3 ALIGN=CENTER>        5.2.6  Inline </h3>
<p>  При  программировании   с  использованием   классов  очень  часто
используется  много  маленьких  функций.  По  сути,  везде,  где  в
программе традиционной  структуры  стояло  бы  просто  какое-нибудь
обычное использование  структуры данных,  дается функция.  То,  что
было соглашением,  стало стандартом, который распознает компилятор.
Это может  страшно понизить  эффективность,  потому  что  стоимость
вызова функции  (хотя и  вовсе не  высокая по  сравнению с  другими
языками) все  равно  намного  выше,  чем  пара  ссылок  по  памяти,
необходимая для тела функции.
<br>  Чтобы справиться с этой проблемой, был разработан аппарат inline-
функций. Функция  член, определенная  (а  не  просто  описанная)  в
описании класса,  считается inline.  Это значит,  например,  что  в
функциях,  которые  используют  приведенные  выше  char_stack,  нет
никаких вызовов  функций  кроме  тех,  которые  используются    для
реализации операций  вывода! Другими  словами, нет  никаких  затрат
времени  выполнения,   которые  стоит  принимать  во  внимание  при
разработке класса.  Любое, даже  самое  маленькое  действие,  можно
задать эффективно.  Это утверждение  снимает аргумент, который чаще
всего приводят чаще всего в пользу открытых членов данных.
<br>  Функцию член  можно также описать как inline вне описания класса.
Например:
<pre>
  char char_stack {
      int size;
      char* top;
      char* s;
  public:
      char pop();
      // ...
  };

  inline char char_stack::pop()
  {
      return *--top;
  }
</pre>
<a name=gl5_1.3>
<h2 ALIGN=CENTER>       5.3 Интерфейсы и Реализации </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl5_1.3.1>        5.3.1 Альтернативные Реализации            </a>       
<tr><td width=10></td><TD>      <a HREF=#gl5_1.3.2> 5.3.2 Законченный Класс     </a>                      
</table>
<p>  Что представляет  собой хороший класс? Нечто, имеющее небольшое и
хорошо  определенное   множество   действий.   Нечто,   что   можно
рассматривать  как   "черный  ящик",  которым  манипулируют  только
посредством  этого   множества  действий.  Нечто,  чье  фактическое
представление можно любым мыслимым способом изменить, не повлияв на
способ использования  множества действий.  Нечто, чего можно хотеть
иметь больше одного.
<br>  Для всех видов контейнеров существуют очевидные примеры: таблицы,
множества, списки,  вектора,  словари  и  т.д.  Такой  класс  имеет
операцию "вставить",  обычно он  также имеет  операции для проверки
того, был ли вставлен данный элемент. В нем могут быть действия для
осуществления проверки  всех элементов  в определенном  порядке,  и
кроме всего  прочего, в  нем может  иметься операция  для  удаления
элемента. Обычно  контейнерные (то  есть, вмещающие)  классы  имеют
конструкторы и деструкторы.
<br>  Скрытие данных  и  продуманный  интерфейс  может  дать  концепция
модуля (см.  например  <a HREF=gl4.htm#gl4.4>#4.4</a>:  файлы  как  модули).  Класс,  однако,
является типом.  Чтобы использовать его, необходимо создать объекты
этого класса,  и таких  объектов можно  создавать столько,  сколько
нужно. Модуль же сам является объектом. Чтобы использовать его, его
надо только инициализировать, и таких объектов ровно один.
<a name=gl5_1.3.1>
<h3 ALIGN=CENTER>        5.3.1 Альтернативные Реализации </h3>
<p>  Пока описание  открытой части  класса и  описание функций  членов
остаются неизменными,  реализацию класса  можно  модифицировать  не
влияя на  ее пользователей.  Как пример  этого  рассмотрим  таблицу
имен, которая  использовалась в  настольном калькуляторе в <a HREF=gl3.htm#gl3>Главе 3</a>.
Это таблица имен:
<pre>
  struct name {
      char* string;
      char* next;
      double value;
  };
</pre>
<br>  Вот вариант класса table:
<pre>
  // файл table.h

  class table {
      name* tbl;
  public:
      table() { tbl = 0; }

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };
</pre>
<br>    Эта таблица  отличается от той, которая определена в <a HREF=gl3.htm#gl3>Главе 3</a> тем, что это  настоящий тип.  Можно описать  более чем одну table, можно
иметь указатель на table и т.д. Например:
<pre>
  #include "table.h"

  table globals;
  table keywords;
  table* locals;

  main() {
      locals = new table;
      // ...
  }
</pre>
<br>    Вот реализация  table::look(), которая  использует линейный поиск в
связанном списке имен name в таблице:
<pre>
  #include

  name* table::look(char* p, int ins)
  {
      for (name* n = tbl; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl;
      tbl = nn;
      return nn;
  }
</pre>
<br>    Теперь рассмотрим  класс table,  усовершенствованный таким образом,
чтобы  использовать  хэшированный  просмотр,  как  это  делалось  в
примере с  настольным калькулятором. Сделать это труднее из-за того
ограничения, что уже написанные программы, в которых использовалась
только что  определенная версия  класса  table,  должны  оставаться
верными без изменений:
<pre>
  class table {
      name** tbl;
      int size;
  public:
      table(int sz = 15);
      ~table();

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };
</pre>
<br>      В структуру  данных и  конструктор внесены  изменения, отражающие
необходимость  того,  что  при  использовании  хэширования  таблица
должна иметь определенный размер. Задание конструктора с параметром
по умолчанию  обеспечивает, что  старая  программа,  в  которой  не
указывался  размер  таблицы,  останется  правильной.  Параметры  по
умолчанию   очень полезны в ситуации, когда нужно изменить класс не
повлияв  на  старые  программы.  Теперь  конструктор  и  деструктор
создают и уничтожают хэш-таблицы:
<pre>
  table::table(int sz)
  {
      if (sz < 0) error("отрицательный размер таблицы");
      tbl = new name*[size=sz];
      for (int i = 0; inext) {
              delete n->string;
              delete n;
          }
          delete tbl;
  }
</pre>
<br>    Описав деструктор  для класса  name можно  получить более простой и
ясный  вариант   table::~table().  Функция   просмотра  практически
идентична  той,   которая  использовалась   в  примере  настольного
калькулятора (<a HREF=gl3.htm#gl3.1.3>#3.1.3</a>):
<pre>
  #include

  name* table::look(char* p, int ins)
  {
      int ii = 0;
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= size;

      for (name* n=tbl[ii]; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl[ii];
      tbl[ii] = nn;
      return nn;

  }
</pre>
<br>    Очевидно, что  функции члены  класса должны  заново компилироваться
всегда, когда  вносится какое-либо  изменение в  описание класса. В
идеале такое  изменение никак не должно отражаться на пользователях
класса.  К   сожалению,  это  не  так.  Для  размещения  переменной
классового типа компилятор должен знать размер объекта класса. Если
размер  этих   объектов  меняется,   то  файлы,   в  которых  класс
используется, нужно  компилировать  заново.  Можно  написать  такую
программу  (и  она  уже  написана),  которая  определяет  множество
(минимальное) файлов, которое необходимо компилировать заново после
изменения описания класса, но пока что широкого распространения она
не получила.
<br>  Почему,  можете  вы  спросить,  C++  разработан  так,  что  после
изменения закрытой  части необходима новая компиляция пользователей
класса? И  действительно, почему  вообще закрытая часть должна быть
представлена в  описании класса? Другими словами, раз пользователям
класса не  разрешается обращаться  к  закрытым  членам,  почему  их
описания должны  приводиться в  заголовочных файлах,  которые,  как
предполагается, пользователь  читает?  Ответ  -  эффективность.  Во
многих  системах   и  процесс   компиляции,  и   последовательность
операций,  реализующих   вызов   функции,   проще,   когда   размер
автоматических  объектов  (объектов  в  стеке)  известен  во  время
компиляции.
<br>  Этой сложности  можно избежать,  представив каждый  объект класса
как указатель  на "настоящий"  объект. Так  как все  эти  указатели
будут иметь  одинаковый размер,  а размещение  "настоящих" объектов
можно определить в файле, где доступна закрытая часть, то это может
решить проблему. Однако решение подразумевает дополнительные ссылки
по памяти  при обращении  к членам  класса, а  также, что еще хуже,
каждый вызов  функции с  автоматическим объектом класса включает по
меньшей мере один вызов программ выделения и освобождения свободной
памяти. Это  сделало бы также невозможным реализацию inline-функций
членов, которые  обращаются к  данным закрытой  части. Более  того,
такое изменение  сделает невозможным  совместную компоновку C и C++
программ (поскольку  C компилятор  обрабатывает struct  не так, как
это  будет  делать  C++  компилятор).  Для  C++  это  было  сочтено
неприемлемым.
<a name=gl5_1.3.2>
<h3 ALIGN=CENTER>          5.3.2 Законченный Класс </h3>
<p>  Программирование без  скрытия  данных  (с  применением  структур)
требует меньшей  продуманности, чем  программирование  со  скрытием
данных (с  использованием классов).  Структуру можно  определить не
слишком задумываясь  о том,  как ее  предполагается использовать. А
когда  определяется   класс,  все   внимание  сосредотачивается  на
обеспечении нового  типа полным  множеством  операций;  это  важное
смещение акцента.  Время, потраченное  на разработку  нового  типа,
обычно  многократно   окупается  при   разработке  и   тестировании
программы.
<br>  Вот пример  законченного типа  intset, который  реализует понятие
"множество целых":
<pre>
  class intset {
      int cursize, maxsize;
      int *x;
  public:
      intset(int m, int n);    // самое большее, m int'ов в 1..n
      ~intset();

      int member(int t);       // является ли t элементом?
      void insert(int t);      // добавить "t" в множество

      void iterate(int& i)     { i = 0; }
      int ok(int& i)           { return i

  void error(char* s)
  {
      cerr << "set: " << s << "\n";
      exit(1);
  }
</pre>
<br>      Класс intset  используется в  main(),  которая  предполагает  два
целых параметра.  Первый параметр  задает  число  случайных  чисел,
которые нужно  сгенерировать. Второй параметр указывает диапазон, в
котором должны лежать случайные целые:
<pre>
  main(int argc, char* argv[])
  {
      if (argc != 3) error("ожидается два параметра");
      int count = 0;
      int m = atoi(argv[1]);        // число элементов множества
      int n = atoi(argv[2]);        // в диапазоне 1..n
      intset s(m,n);

      while (count maxsize) error("слищком много элементов");
      int i = cursize-1;
      x[i] = t;

      while (i>0 && x[i-1]>x[i]) {
          int t = x[i];                // переставить x[i] и [i-1]
          x[i] = x[i-1];
          x[i-1] = t;
          i--;
      }
  }
</pre>
<br>    Для нахождения членов используется просто двоичный поиск:
<pre>
  int intset::member(int t)        // двоичный поиск
  {
      int l = 0;
      int u = cursize-1;

      while (l <= u) {
          int m = (l+u)/2;
          if (t < x[m])
              u = m-1;
          else if (t > x[m])
              l = m+1;
          else
              return 1;            // найдено
      }
      return 0;                    // не найдено
  }
</pre>
<br>      И,  наконец,  нам  нужно  обеспечить  множество  операций,  чтобы
пользователь  мог   осуществлять  цикл  по  множеству  в  некотором
порядке, поскольку  представление intset  от  пользователя  скрыто.
Множество внутренней  упорядоченности не имеет, поэтому мы не можем
просто дать  возможность обращаться  к вектору (завтра я, наверное,
реализую intset по-другому, в виде связанного списка).
<br>  Дается три  функции: iterate()  для инициализации  итерации, ok()
для проверки,  есть ли  следующий элемент, и next() для того, чтобы
взять следующий элемент:
<pre>
  class intset {
      // ...
      void iterate(int& i)        { i = 0; }
      int ok(int& i)              { return iiterate(var);
      while (set->ok(var)) cout << set->next(var) << "\n";
  }
</pre>
<br>    Другой способ задать итератор приводится в <a HREF=gl6.htm#gl6.8>#6.8.</a>
<p> <center> <font size="-1">
[<a href="gl4.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="gl5_2.htm">Вперед</a>]
</font> 
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
