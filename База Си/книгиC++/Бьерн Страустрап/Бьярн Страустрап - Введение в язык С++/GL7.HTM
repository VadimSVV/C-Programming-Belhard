<htm>
<head>





<title>Бьярн Страустрап. Введение в язык Си++, Производные Классы</title>
</head>
<body bgcolor=fff5ee link=ff0000 alink=ff0000 vlink=a52a2a >
<basefont size="3"><center>
<table width=100%>
<tr><td><a href="cit.htm#2" onMouseOver="status='Server for Information Technologies (Main)' ;return true" onMouseOut="status='' ;return true"><img height=50 src="pictures/logo.gif" alt="Server for Information Technologies" border=0></a></td>
<th><font color=navy><a href="cit.htm#2">Сервер Информационных Технологий</a><br>
содержит море(!) аналитической информации</font>
</th><td><p align=right><font size="-2">
Сервер поддерживается<br>
<a href="cit.htm#1">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM Local Copy'">info@citforum.ru</a></font></p></td>
</tr>
</table>
</center>
<hr noshade width=90%>

<a name=gl7>
<h1 ALIGN=CENTER> Глава 7</h1>
<h2 ALIGN=CENTER>    Производные Классы </h2>
<p><center>                       Не надо размножать объекты без необходимости
                                                         - У. Оккам
</center>
<p>  В этой  главе описывается  понятие  производного  класса  в  C++.
Производные классы  дают  простой,  гибкий  и  эффективный  аппарат
задания для  класса альтернативного интерфейса и определения класса
посредством добавления  возможностей к  уже имеющемуся  классу  без
перепрограммирования  или  перекомпиляции.  С  помощью  производных
классов можно  также  обеспечить  общий  интерфейс  для  нескольких
различных классов  так, чтобы другие части программы могли работать
с объектами  этих классов  одинаковым образом.  При этом  обычно  в
каждый объект помещается информация о типе, чтобы эти объекты могли
обрабатываться соответствующим  образом в  ситуациях, когда  их тип
нельзя узнать  во время  компиляции.  Для  элегантной  и  надежной
обработки таких  динамических зависимостей  типов  имеется  понятие
виртуальной функции.  По своей  сути производные  классы существуют
для того, чтобы облегчить программисту формулировку общности.
<a name=gl7.1>
<h2 ALIGN=CENTER>     7.1 Введение </h2>
<p>  Представим себе  процесс  написания  некоторого  средства  общего
назначения  (например,  тип  связанный  список,  таблица  имен  или
планировщик для  системы моделирования),  которое  предназначается
для   использования    многими   разными    людьми    в    различных
обстоятельствах. Очевидно,  что в  кандидатах на роль таких средств
недостатка нет,  и выгоды  от их  стандартизации огромны.  Кажется,
любой опытный  программист написал  (и  отладил)  дюжину  вариантов
типов множества,  таблицы имен,  сортирующей  функции  и  т.п.,  но
оказывается, что  таблиц имен каждый программист и каждая программа
используют свою  версию этих  понятий, из-за чего программы слишком
трудно читать,  тяжело отлаживать  и сложно  модифицировать.  Более
того,  в  большой  программе  вполне  может  быть  несколько  копий
идентичных (почти) частей кода для работы с такими фундаментальными
понятиями.
<br>  Причина этого хаоса частично состоит в том, что представить такие
общие понятия в языке программирования сложно с концептуальной точки
зрения, а  частично в  том, что  средства,  обладающие  достаточной
общностью, налагают  дополнительные  расходы  по  памяти  и/или  по
времени, что  делает их  неудобными для  самых простых  и  наиболее
напряженно используемых средств (связанные списки, вектора и т.п.),
где они  были бы  наиболее полезны.  Понятие производного  класса в
C++, описываемое  в <a HREF=#gl7.2>#7.2</a>,  не обеспечивают общего решения всех этих проблем, но оно дает способ справляться с довольно небольшим числом
важных  случаев.   Будет,  например,   показано,   как   определить
эффективный класс общего связанного списка таким образом, чтобы все
его версии использовали код совместно.
<br>  Написание  общецелевых   средств  -  задача  непростая,  и  часто
основной акцент в их разработке другой, чем при разработке программ
специального  назначения.   Конечно,  нет   четкой  границы   между
средствами общего и специального назначения, и к методам и языковым
средствам, которые  описываются в этой главе, можно относиться так,
что они  становятся все  более полезны  с ростом объема и сложности
создаваемых программ.
<a name=gl7.2>
<h2 ALIGN=CENTER> 7.2 Производные Классы </h2>
<table border=0>
<tr><td width=10></td><TD>  <a HREF=#gl7.2.1>         7.2.1 Построение Производного Класса           </a> 
<tr><td width=10></td><TD>  <a HREF=#gl7.2.2>         7.2.2 Функции Члены   </a>                          
<tr><td width=10></td><TD>  <a HREF=#gl7.2.3>         7.2.3 Видимость             </a>                    
<tr><td width=10></td><TD>  <a HREF=#gl7.2.4>         7.2.4 Указатели               </a>                   
<tr><td width=10></td><TD>  <a HREF=#gl7.2.5>         7.2.5 Иерархия Типов     </a>                       
<tr><td width=10></td><TD>  <a HREF=#gl7.2.6>         7.2.6 Конструкторы и Деструкторы   </a>              
<tr><td width=10></td><TD>  <a HREF=#gl7.2.7>         7.2.7 Поля Типа   </a>                              
<tr><td width=10></td><TD>  <a HREF=#gl7.2.8>         7.2.8 Виртуальные Функции  </a>                      
</table>
<p>  Чтобы разделить  задачи понимания  аппарата языка  и методов  его
применения, знакомство  с понятием  производных классов  делается в
три этапа.  Вначале с  помощью небольших  примеров, которые не надо
воспринимать как  реалистичные, будут  описаны сами  средства языка
(запись  и   семантика).  После   этого  демонстрируются   некоторые
неочевидные применения  производных классов, и, наконец, приводится
законченная программа.
<a name=gl7.2.1>
<h3 ALIGN=CENTER>     7.2.1 Построение Производного Класса </h3>
<p>  Рассмотрим построение  программы, которая  имеет дело  с  людьми,
служащими в  некоторой фирме.  Структура данных  в  этой  программе
может быть например такой:
<pre>
  struct employee {          // служащий
      char*    name;        // имя
      short    age;         // возраст
      short    department;  // подразделение
      int      salary;      //
      employee* next;
      // ...
  };
</pre>
<br>Список аналогичных  служащих  будет  связываться  через  поле  next.
Теперь давайте определим менеджера:
<pre>
  struct manager {           // менеджер
      employee emp;          // запись о менеджере как о служащем
      employee* group;       // подчиненные люди
      // ...
  };
</pre>
<br>Менеджер также  является служащим; относящиеся к служащему employee
данные хранятся  в члене  emp объекта  manager. Для  читающего  это
человека это,  может быть, очевидно, но нет ничего выделяющего член
emp для  компилятора. Указатель на менеджера (manager*) не является
указателем на  служащего (employee*),  поэтому просто  использовать
один  там,  где  требуется  другой,  нельзя.  В  частности,  нельзя
поместить  менеджера  в  список  служащих,  не  написав  для  этого
специальную  программу.  Можно  либо  применить  к  manager*  явное
преобразование типа,  либо поместить  в список служащих адрес члена
emp, но  и то и другое мало элегантно и довольно неясно. Корректный
подход состоит  в том,  чтобы  установить,  что  менеджер  является
служащим с некоторой добавочной информацией:
<pre>
  struct manager : employee {
      employee* group;
      // ...
  };
</pre>
<br>manager является  производным от employee и, обратно, employee есть
базовый класс  для manager.  Класс manager  дополнительно  к  члену
group имеет члены класса employee (name, age и т.д.).
<br>  Имея определения  employee и  manager  мы  можем  теперь  создать
список  служащих,   некоторые  из   которых  являются  менеджерами.
Например:
<pre>
  void f()
  {
      manager m1, m2;
      employee e1, e2;
      employee* elist;
      elist = &m1;     // поместить m1, e1, m2 и e2 в elist
      m1.next = &e1;
      e1.next = &m2;
      m2.next = &e2;
      e2.next = 0;
  }
</pre>
<br>Поскольку менеджер является служащим, manager* может использоваться
как employee*.  Однако служащий  необязательно является менеджером,
поэтому использовать employee* как manager* нельзя.
<a name=gl7.2.2>
<h3 ALIGN=CENTER>    7.2.2 Функции Члены </h3>
<p>  Просто структуры данных вроде employee и manager на самом деле не
столь интересны  и часто  не особенно  полезны, поэтому рассмотрим,
как добавить к ним функции. Например:
<pre>
  class employee {
      char* name;
      // ...
  public:
      employee* next;
      void print();
      // ...
  };

  class manager : public employee {
      // ...
  public:
      void print();
      // ...
  };
</pre>
<br>Надо  ответить   на  некоторые  вопросы.  Как  может  функция  член
производного класса  manager использовать члены его базового класса
employee? Как  члены базового  класса employee  могут  использовать
функции члены  производного класса  manager? Какие  члены  базового
класса employee  может использовать функция не член на объекте типа
manager? Каким  образом программист может повлиять на ответы на эти
вопросы, чтобы удовлетворить требованиям приложения?
<br>  Рассмотрим:
<pre>
  void manager::print()
  {
      cout << " имя " << name << "\n";
      // ...
  }
</pre>
<br>Член производного  класса может использовать открытое имя из своего
базового  класса   так  же,  как  это  могут  делать  другие  члены
последнего, то  есть без  указания объекта.  Предполагается, что на
объект указывает  this, поэтому  (корректной) ссылкой  на имя  name
является this->name.  Однако функция manager::print компилироваться
не будет,  член производного класса не имеет никакого особого права
доступа к закрытым членам его базового класса, поэтому для нее name
недоступно.
<br>  Это многим  покажется удивительным,  но представьте  себе  другой
вариант: что  функция член  могла бы  обращаться к  закрытым членам
своего  базового   класса.  Возможность,  позволяющая  программисту
получать доступ  к закрытой части класса просто с помощью вывода из
него другого  класса, лишила  бы понятие  закрытого  члена  всякого
смысла.  Более  того,  нельзя  было  бы  узнать  все  использования
закрытого имени  посмотрев на функции, описанные как члены и друзья
этого класса.  Пришлось бы  проверять каждый  исходный файл во всей
программе на  наличие в  нем производных классов, потом исследовать
каждую функцию  этих классов,  потом искать все классы, производные
от этих  классов, и  т.д. Это  по меньшей мере утомительно и скорее
всего нереально.
<br>  С другой  стороны, можно ведь использовать механизм friend, чтобы
предоставить такой доступ или отдельным функциям, или всем функциям
отдельного класса (как описывается в #5.3). Например:
<pre>
  class employee {
      friend void manager::print();
      // ...
  };
</pre>
<br>решило бы проблему с manager::print(), и
<pre>
  class employee {
  friend class manager;
      // ...
  };
</pre>
<br>сделало бы  доступным каждый  член employee для всех функций класса
manager.   В    частности,   это   сделает   name   доступным   для
manager::print().
<br>  Другое, иногда более прозрачное решение для производного класса, -
использовать только открытые члены его базового класса. Например:
<pre>
  void manager::print()
  {
      employee::print();    // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }
</pre>
<br>Заметьте, что  надо использовать  ::,  потому  что    print()  была
переопределена  в   manager.  Такое  повторное  использование  имен
типично. Неосторожный мог бы написать так:
<pre>
  void manager::print()
  {
      print();              // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }
</pre>
<br>и  обнаружить,   что  программа   после   вызова   manager::print()
неожиданно попадает в последовательность рекурсивных вызовов.
<a name=gl7.2.3>
<h3 ALIGN=CENTER>   7.2.3 Видимость </h3>
<p>  Класс employee  стал открытым  (public)  базовым  классом  класса
manager в результате описания:
<pre>
  class manager : public employee {
      // ...
  };
</pre>
<br>Это означает,  что открытый  член класса  employee является также и
открытым членом класса manager. Например:
<pre>
  void clear(manager* p)
  {
      p->next = 0;
  }
</pre>
<br>будет компилироваться,  так как  next -  открытый член и employee и
manager'а.  Альтернатива  -  можно  определить  закрытый  (private)
класс, просто опустив в описании класса слово public:
<pre>
  class manager : employee {
      // ...
  };
</pre>
<br>Это означает,  что открытый  член класса employee является закрытым
членом класса  manager. То есть, функции члены класса manager могут
как и  раньше использовать  открытые члены  класса employee, но для
пользователей класса manager эти члены недоступны. В частности, при
таком описании  класса manager  функция clear()  компилироваться не
будет. Друзья  производного класса  имеют к  членам базового класса
такой же доступ, как и функции члены.
<br>  Поскольку, как  оказывается, описание  открытых  базовых  классов
встречается чаще  описания закрытых,  жалко, что описание открытого
базового класса длиннее описания закрытого. Это, кроме того, служит
источником запутывающих ошибок у начинающих.
<br>Когда  описывается   производная  struct,  ее  базовый  класс  по
умолчанию является public базовым классом. То есть,
<pre>
  struct D : B { ...
</pre>
<br>означает
<pre>
  class D : public B { public: ...
</pre>
<br>Отсюда следует,  что если  вы не  сочли полезным то скрытие данных,
которое  дают   class,  public   и  friend,  вы  можете  просто  не
использовать эти  ключевые слова  и  придерживаться  struct.  Такие
средства  языка,  как  функции  члены,  конструкторы  и  перегрузка
операций, не зависят от механизма скрытия данных.
<br>  Можно также  объявить некоторые,  но не  все,  открытые  $  члены
базового класса открытыми членами производного класса. Например:
<pre>
  class manager : employee {
      // ...
  public:
      // ...
      employee::name;
      employee::department;
  };
</pre>
<br>Запись
<pre>
  имя_класса :: имя_члена ;
</pre>
<br>не вводит новый член, а просто делает открытый член базового класса
открытым для  производного класса.  Теперь name  и department могут
использоваться для  manager'а, а  salary и  age - нет. Естественно,
сделать сделать  закрытый  член  базового  класса  открытым  членом
производного класса  невозможно. Невозможно  с помощью  этой записи
также сделать открытыми перегруженные имена.
<br>  Подытоживая, можно  сказать, что вместе с предоставлением средств
дополнительно к  имеющимся в базовом классе, производный класс можно
использовать для  того, чтобы сделать средства (имена) недоступными
для пользователя.  Другими словами,  с помощью  производного класса
можно обеспечивать прозрачный, полупрозрачный и непрозрачный доступ
к его базовому классу.
<a name=gl7.2.4>
<h3 ALIGN=CENTER>   7.2.4 Указатели </h3>
<p>  Если производный класс derived имеет открытый базовый класс base,
то указатель на derived можно присваивать переменной типа указатель
на  base   не  используя   явное  преобразование   типа.   Обратное
преобразование, указателя  на base  в указатель  на derived, должно
быть явным. Например:
<pre>
  class base { /* ... */ };
  class derived : public base { /* ... */ };

  derived m;
  base* pb = &m;     // неявное преобразование
  derived* pd = pb;  // ошибка: base* не является derived*
  pd = (derived*)pb; // явное преобразование
</pre>
<br>Иначе говоря,  объект производного  класса при  работе с  ним через
указатель и можно  рассматривать  как  объект  его  базового  класса.
Обратное неверно.
<br>  Будь  base  закрытым  базовым  классом  класса  derived,  неявное
преобразование  derived*   в  base*   не   делалось   бы.   Неявное
преобразование не  может в этом случае быть выполнено, потому что к
открытому члкну  класса base  можно обращаться  через указатель  на
base, но нельзя через указатель на derived:
<pre>
  class base {
      int m1;
  public:
      int m2;     // m2 - открытый член base
  };

  class derived : base {
      // m2 НЕ открытый член derived
  };

  derived d;
  d.m2 = 2;       // ошибка: m2 из закрытой части класса
  base* pb = &d;  // ошибка: (закрытый base)
  pb->m2 = 2;     // ok
  pb = (base*)&d; // ok: явное преобразование
  pb->m2 = 2;     // ok
</pre>
<br>Помимо всего  прочего, этот  пример показывает, что используя явное
приведение к типу можно сломать правила защиты. Ясно, делать это не
рекомендуется, и  это приносит программисту заслуженную "награду". К
несчастью , недисциплинированное использование явного преобразования
может  создать   адские  условия   для  невинных   жертв,   которые
эксплуатируют программу,  где это  делается.  Но,  к  счастью,  нет
способа  воспользоваться   приведением  для   получения  доступа  к
закрытому имени  m1.  Закрытый  член  класса  может  использоваться
только членами и друзьями этого класса.
<a name=gl7.2.5>
<h3 ALIGN=CENTER>     7.2.5 Иерархия Типов </h3>
<p>  Производный класс сам может быть базовым классом. Например:
<pre>
  class employee { ... };
  class secretary : employee { ... };
  class manager : employee { ... };
  class temporary : employee { ... };
  class consultant : temporary { ... };
  class director : manager { ... };
  class vice_president : manager { ... };
  class president : vice_president { ... };
</pre>
<br>Такое множество  родственных  классов  принято  называть  иерархией
классов. Поскольку  можно выводить  класс только из одного базового
класса, такая  иерархия является  деревом и  не может  быть  графом
более общей структуры. Например:
<pre>
  class temporary { ... };
  class employee { ... };
  class secretary : employee { ... };

  // не C++:
  class temporary_secretary : temporary : secretary { ... };
  class consultant : temporary : employee { ... };
</pre>
<br>И  этот   факт  вызывает   сожаление,   потому   что   направленный
ациклический граф  производных классов  был бы очень полезен. Такие
структуры описать  нельзя, но  можно смоделировать с помощью членов
соответствующий типов. Например:
<pre>
  class temporary { ... };
  class employee { ... };
  class secretary : employee { ... };

  // Альтернатива:
  class temporary_secretary : secretary
  { temporary temp; ... };
  class consultant : employee
  { temporary temp; ... };
</pre>
<br>Это выглядит  неэлегантно и  страдает как  раз от  тех проблем, для
преодоления которых  были изобретены  производные классы. Например,
поскольку  consultant   не  является   производным  от   temporary,
consultant'а нельзя помещать с список временных служащих (temporary
employee), не  написав  специальной  программы.  Однако  во  многих
полезных программах этот метод успешно используется.
<a name=gl7.2.6>
<h3 ALIGN=CENTER>   7.2.6 Конструкторы и Деструкторы </h3>
<p>  Для некоторых  производных классов  нужны  конструкторы.  Если  у
базового класса  есть конструктор, он должен вызываться, и если для
этого конструктора нужны параметры, их надо предоставить. Например:
<pre>
  class base {
      // ...
  public:
      base(char* n, short t);
      ~base();
  };

  class derived : public base {
      base m;
  public:
      derived(char* n);
      ~derived();
  };
</pre>
<br>Параметры   конструктора    базового   класса   специфицируются   в
определении конструктора производного класса. В этом смысле базовый
класс работает  точно также,  как неименованный  член  производного
класса (см. <a HREF=gl5_2.htm#gl5_2.5.4>#5.5.4</a>). Например:
<pre>
  derived::derived(char* n) : (n,10), m("member",123)
  {
      // ...
  }
</pre>
<br>Объекты класса  конструируются снизу  вверх: сначала базовый, потом
члены, а  потом сам  производный класс. Уничтожаются они в обратном
порядке:  сначала  сам  производный  класс,  потом  члены  а  потом
базовый.
<a name=gl7.2.7>
<h3 ALIGN=CENTER>   7.2.7 Поля Типа </h3>
<p>  Чтобы использовать  производные  классы  не  просто  как  удобную
сокращенную запись  в описаниях, надо разрешить следующую проблему:
Если  задан  указатель  типа  base*,  какому  производному  типу  в
действительности принадлежит  указываемый объект? Есть три основных
способа решения этой проблемы:
<br>  [1] Обеспечить, чтобы  всегда указывались  только объекты  одного
     типа (<a HREF=#gl7.3.3>#7.3.3</a>);
<br>  [2] Поместить  в   базовый  класс   поле  типа,   которое  смогут
     просматривать функции; и
 <br> [3] Использовать виртуальные функции (<a HREF=#gl7.2.8>#7.2.8</a>).
  Обыкновенно  указатели   на  базовые   классы  используются   при
разработке контейнерных (или вмещающих) классов: множество, вектор,
список и  т.п. В  этом случае  решение 1 дает однородные списки, то
есть списки  объектов одного типа. Решения 2 и 3 можно использовать
для построения  неоднородных  списков,  то  есть  списков  объектов
(указателей на объекты) нескольких различных типов. Решение 3 - это
специальный вариант решения 2, безопасный относительно типа.
<br>  Давайте сначала исследуем простое решение с помощью поля типа, то
есть решение  2. Пример  со служащими  и менеджерами  можно было бы
переопределить так:
<pre>
  enum empl_type { M, E };

  struct employee {
      empl_type type;
      employee* next;
      char*     name;
      short     department;
      // ...
  };

  struct manager : employee {
      employee* group;
      short     level;        // уровень
  };
</pre>
<br>Имея это,  мы  можем  теперь  написать  функцию,  которая  печатает
информацию о каждом служащем:
<pre>
  void print_employee(employee* e)
  {
      switch (e->type) {
      case E:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          break;
      case M:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
          break;
      }
  }
</pre>
<br>и воспользоваться ею для того, чтобы напечатать список служащих:
<pre>
  void f()
  {
      for (; ll; ll=ll->next) print_employee(ll);
  }
</pre>
<br>  Это прекрасно работает, особенно в небольшой программе, написанной
одним  человеком,   но   имеет   тот   коренной   недостаток,   что
неконтролируемым  компилятором   образом  зависит   от  того,   как
программист работает  с типами.  В больших  программах  это  обычно
приводит к  ошибкам двух  видов. Первый - это невыполнение проверки
поля  типа,  второй  -  когда  не  все  случаи  case  помещаются  в
переключатель  switch   как  в  предыдущем  примере.  Оба  избежать
достаточно легко  , когда  программу сначала  пишут на бумаге $, но
при модификации нетривиальной программы, особенно написанной другим
человеком, очень  трудно избежать  и того, и другого. Часто от этих
сложностей становится  труднее уберечься   из-за  того, что функции
вроде print()  часто бывают  организованы  так,  чтобы  пользоваться
общность классов, с которыми они работают. Например:
<pre>
  void print_employee(employee* e)
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
      if (e->type == M)  {
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
      }
  }
</pre>
<br>Отыскание всех таких операторов if, скрытых внутри большой функции,
которая  работает   с  большим   числом  производных  классов,  может
оказаться сложной  задачей, и  даже когда  все они  найдены, бывает
нелегко понять, что же в них делается.
<a name=gl7.2.8>
<h3 ALIGN=CENTER>    7.2.8 Виртуальные Функции </h3>
<p>  Виртуальные функции  преодолевают  сложности  решения  с  помощью
полей  типа,  позволяя  программисту  описывать  в  базовом  классе
функции, которые  можно переопределять  в любом производном классе.
Компилятор и  загрузчик обеспечивают  правильное соответствие между
объектами и применяемыми к ним функциями.  Например:
<pre>
  struct employee {
      employee* next;
      char*     name;
      short     department;
      // ...
      virtual void print();
  };
</pre>
<br>Ключевое слово virtual указывает, что могут быть различные варианты
функции print()  для разных  производных классов, и что поиск среди
них  подходящей   для  каждого   вызова  print()   является   задачей
компилятора. Тип  функции описывается  в базовом  классе и не может
переписываться в  производном классе.  Виртуальная функция  должна
быть  определена   для  класса,  в  котором  она  описана  впервые.
Например:
<pre>
  void employee::print()
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
  }
</pre>
<br>Виртуальная функция может, таким образом, использоваться даже в том
случае, когда нет производных классов от ее класса, и в производном
классе, в котором не нужен специальный вариант виртуальной функции,
ее   задавать    не   обязательно.   Просто   при   выводе   класса
соответствующая функция  задается в  том случае,  если  она  нужна.
Например:
<pre>
  struct manager : employee {
      employee* group;
      short     level;
      // ...
      void print();
  };

  void manager::print()
  {
      employee::print();
      cout << "\tуровень" << level << "\n";
      // ...
  }
</pre>
<br>Функция print_employee() теперь не нужна, поскольку ее место заняли
функции члены  print(), и теперь со списком служащих можно работать
так:
<pre>
  void f(employee* ll)
  {
      for (; ll; ll=ll->next) ll->print();
  }
</pre>
<br>Каждый служащий  будет  печататься  в  соответствии  с  его  типом.
Например:
<pre>
  main()
  {
      employee e;
          e.name = "Дж.Браун";
          e.department = 1234;
          e.next = 0;
      manager m;
          m.name = "Дж.Смит";
          e.department = 1234;
          m.level = 2;
          m.next = &e;
      f(&m);
  }
</pre>
<br>выдаст
<pre>
  Дж.Смит 1234
          уровень 2
  Дж.Браун 1234
</pre>
<br>  Заметьте, что это будет работать даже в том случае, если f() была
написана и  откомпилирована еще  до  того,  как  производный  класс
manager был  задуман!  Очевидно,  при  реализации  этого  в  каждом
объекте класса  employee сохраняется  некоторая информация  о типе.
Занимаемого для  этого пространства  (в текущей реализации) как раз
хватает для  хранения указателя. Это пространство занимается только
в объектах  классов с виртуальными функциями, а не во всех объектах
классов и  даже не во всех объектах производных классов. Вы платите
эту пошлину  только за  те классы,  для которых описали виртуальные
функции.
<br>Вызов функции с помощью операции разрешения области видимости ::,
как это  делается в  manager::print(),  гарантирует,  что  механизм
виртуальных функций  применяться не  будет. Иначе  manager::print()
подвергалось бы  бесконечной рекурсии. Применение уточненного имени
имеет еще  один эффект,  который  может  оказаться  полезным:  если
описанная как  virtual функция  описана еще  и как  inline  (в  чем
ничего необычного  нет), то  там, где в вызове применяется :: может
применяться inline-подстановка.  Это дает  программисту эффективный
способ справляться с теми важными специальными случаями, когда одна
виртуальная функция  вызывает другую для того же объекта. Поскольку
тип объекта  был определен  при вызове  первой виртуальной функции,
обычно его  не надо  снова динамически определять другом вызове для
того же объекта.
<a name=gl7.3>
<h2 ALIGN=CENTER>   7.3 Альтернативные Интерфейсы </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl7.3.1>       7.3.1 Интерфейс                    </a>              
<tr><td width=10></td><TD>   <a HREF=#gl7.3.2>        7.3.2 Реализация                   </a>              
<tr><td width=10></td><TD>    <a HREF=#gl7.3.3>       7.3.3 Как Этим Пользоваться  </a>                    
<tr><td width=10></td><TD>   <a HREF=#gl7.3.4>      7.3.4 Обработка Ошибок          </a>                
<tr><td width=10></td><TD>    <a HREF=#gl7.3.5>       7.3.5 Обобщенные Классы      </a>                   
<tr><td width=10></td><TD>  <a HREF=#gl7.3.6>  7.3.6 Ограниченные Интерфейсы </a>                  
</table>
<p>  После того,  как описаны  средства  языка,  которые  относятся  к
производным классам,  обсуждение снова  может вернуться  к  стоящим
задачам.  В   классах,  которые   описываются   в   этом   разделе,
основополагающая идея  состоит в  том, что  они однажды написаны, а
потом их  используют программисты,  которые не  могут  изменить  их
определение.  Физически   классы  состоят   из  одного   или  более
заголовочных файлов,  определяющих интерфейс,  и одного  или  более
файлов, определяющих  реализацию. Заголовочные файлы будут помещены
куда-то туда,  откуда пользователь  может взять  их копии с помощью
директивы  #include.   Файлы,   определяющие   реализацию,   обычно
компилируют и помещают в библиотеку.
<a name=gl7.3.1>
<h3 ALIGN=CENTER>  7.3.1 Интерфейс </h3>
<p>  Рассмотрим такое  написание класса slist для однократно связанного
списка, с  помощью которого  можно создавать  как однородные, так и
неоднородные списки  объектов тех  типов, которые  еще должны  быть
определены. Сначала мы определим тип ent:
<pre>
  typedef void* ent;
</pre>
<br>Точная сущность  типа ent  несущественна, но нужно, чтобы в нем мог
храниться указатель. Тогда мы определим тип slink:
<pre>
  class slink {
  friend class slist;
  friend class slist_iterator;
      slink* next;
      ent e;
      slink(ent a, slink* p) { e=a; next=p;}
  };
</pre>
<br>В  одном   звене  может  храниться  один  ent,  и  с  помощью  него
реализуется класс slist:
<pre>
  class slist {
  friend class slist_iterator;
      slink* last;        // last->next - голова списка
  public:
      int insert(ent a);  // добавить в голову списка
      int append(ent a);  // добавить в хвост списка
      ent get();          // вернуться и убрать голову списка
      void clear();       // убрать все звенья

      slist()      { last=0; }
      slist(ent a) { last=new slink(a,0); last->next=last; }
      ~slist()     { clear(); }
  };
</pre>
<br>Хотя список  очевидным образом  реализуется как  связанный список,
реализацию  можно  изменить  так,  чтобы  использовался  вектор  из
ent'ов, не  повлияв при  этом на пользователей. То есть, применение
slink'ов никак  не видно  в описаниях  открытых функций slist'ов, а
видно только в закрытой части и определениях функций.
<a name=gl7.3.2>
<h3 ALIGN=CENTER>    7.3.2 Реализация </h3>
<p> Реализующие  slist   функции  в   основном  просты.  Единственная
настоящая сложность  - что  делать в случае ошибки, если, например,
пользователь попытается  get() что-нибудь  из  пустого  списка.  Мы
обсудим это  в <a HREF=#gl7.3.4>#7.3.4.</a>  Здесь приводятся  определения членов slist. Обратите внимание,  как хранение  указателя  на  последний  элемент
кругового списка  дает возможность  просто реализовать оба действия
append() и insert():
<pre>
  int slist::insert(ent a)
  {
      if (last)
          last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  int slist::append(ent a)
  {
      if (last)
          last = last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  ent slist::get()
  {
      if (last == 0) slist_handler("get fromempty list");
                                 // взять из пустого списка
      slink* f = last->next;
      ent r  f->e;
      if (f == last)
          last = 0;
      else
          last->next = f->next;
      delete  f;
      return f;
  }
</pre>
<br>Обратите внимание, как вызывается slist_handler (его описание можно
найти в  <a HREF=#gl7.3.4>#7.3.4</a>). Этот  указатель на имя функции используется точно так же,  как если  бы он  был именем  функции. Это является краткой
формой более явной записи вызова:
<pre>
  (*slist_handler)("get fromempty list");

И slist::clear(), наконец, удаляет из списка все элементы:

  void slist::clear()
  {
      slink* l = last;
      if (l == 0) return;
      do {
          slink* ll = l;
          l = l->next;
          delete ll;
      } while (l!=last);
  }
</pre>
<br>Класс slist не обеспечивает способа заглянуть в список, но только
средства для  вставления и удаления элементов. Однако оба класса, и
slist, и  slink, описывают  класс slist_iterator как друга, поэтому
мы можем  описать подходящий  итератор. Вот один, написанный в духе
<a HREF=gl6.htm#gl6.8>#6.8</a>:
<pre>
  class slist_iterator {
      slink* ce;
      slist* cs;
  public:
      slist_iterator(slist& s) { cs = &s; ce = cs->last; }

      ent operator()() {
          // для индикации конца итерации возвращает 0
          // для всех типов не идеален, хорош для указателей
          ent ret = ce ? (ce=ce->next)->e : 0;
          if (ce == cs->last) ce= 0;
          return ret;
      }
  };
</pre>
<a name=gl7.3.3>
<h3 ALIGN=CENTER>      7.3.3 Как Этим Пользоваться </h3>
<p>  Фактически класс  slist в  написанном виде бесполезен. В конечном
счете, зачем  можно использовать  список указателей  void*? Штука в
том, чтобы  вывести класс  из slist и получить список тех объектов,
которые представляют  интерес в  конкретной  программе.  Представим
компилятор языка  вроде C++.  В  нем  широко  будут  использоваться
списки имен; имя - это нечто вроде
<pre>
  struct name {
      char* string;
      // ...
  };
</pre>
<br>В список  будут помещаться  указатели на  имена, а  не сами объекты
имена. Это  позволяет использовать  небольшое информационное поле e
slist'а, и дает возможность имени находиться одновременно более чем
в одном  списке. Вот определение класса nlist, который очень просто
выводится из класса slist:
<pre>
  #include "slist.h"
  #include "name.h"

  struct nlist : slist {
      void insert(name* a) { slist::insert(a); }
      void append(name* a) { slist::append(a); }
      name* get()          {}
      nlist(name* a) : (a) {}
  };
</pre>
<br>Функции нового класса или наследуются от slist непосредственно, или
ничего не  делают кроме  преобразования типа.   Класс  nlist -  это
ничто иное,  как альтернативный  интерфейс класса slist. Так как на
самом  деле   тип  ent   есть   void*,   нет   необходимости   явно
преобразовывать указатели  name*, которые  используются в  качестве
фактических параметров (<a HREF=gl2.htm#gl2.3.4>#2.3.4</a>).
<br>  Списки имен  можно использовать  в классе,  который  представляет
определение класса:
<pre>
  struct classdef {
      nlist friends;
      nlist constructors;
      nlist destructors;
      nlist members;
      nlist operators;
      nlist virtuals;
      // ...
      void add_name(name*);
      classdef();
      ~classdef();
  };
</pre>
<br>и имена могут добавляться к этим спискам приблизительно так:
<pre>
  void classdef::add_name(name* n)
  {
      if (n->is_friend()) {
          if (find(&friends,n))
              error("friend redeclared");
          else if (find(&members,n))
              error("friend redeclared as member");
          else
              friends.append(n);
      }
      if (n->is_operator()) operators.append(n);
      // ...
  }
</pre>
<br>где is_iterator()  и is_friend()  являются функциями членами класса
name. Фукнцию find() можно написать так:
<pre>
  int find(nlist* ll, name* n)
  {
      slist_iterator ff(*(slist*)ll);
      ent p;
      while ( p=ff() ) if (p==n) return 1;
      return 0;
  }
</pre>
<br>Здесь  применяется   явное  преобразование  типа,  чтобы  применить
slist_iterator к  nlist. Более  хорошее решение, -  сделать итератор
для nlist'ов,  приведено в  #7.3.5. Печатать nlist может, например,
такая функция:
<pre>
  void print_list(nlist* ll, char* list_name)
  {
      slist_iterator count(*(slist*)ll);
      name* p;
      int n = 0;
      while ( count() ) n++;
      cout << list_name << "\n" << n << "members\n";
      slist_iterator print(*(slist*)ll);
      while ( p=(name*)print() ) cout << p->string << "\n";
  }
</pre>
<a name=gl7.3.4>
<h3 ALIGN=CENTER>    7.3.4 Обработка Ошибок </h3>
<p>  Есть четыре  подхода к  проблеме, что  же делать,  когда во время
выполнения общецелевое  средство вроде slist сталкивается с ошибкой
(в C++ нет никаких специальных средств языка для обработке ошибок):
<br>  [1] Возвращать недопустимое значение и позволить пользователю его
     проверять;
<br>  [2] Возвращать  дополнительное  значение  состояния  и  разрешить
     пользователю проверять его;
<br>  [3] Вызывать функцию ошибок, заданную как часть класса slist; или
<br>  [4]   Вызывать    функцию   ошибок,    которую   предположительно
     предоставляет пользователь.
<br>  Для   небольшой    программы,    написанной    ее    единственным
пользователем, нет  фактически никаких особенных причин предпочесть
одно  из  этих  решений  другим.  Для  средства  общего  назначения
ситуация совершенно иная.
<br>  Первый подход,  возвращать недопустимое  значение,  неосуществим.
Нет совершенно  никакого способа  узнать, что  некоторое конкретное
значение будет недопустимым во всех применениях slist.
<br>  Второй подход,  возвращать значение состояния, можно использовать
в некоторых  классах (один  из вариантов  этого плана применяется в
стандартных  потоках   ввода/вывода  istream   и  ostream;   как  -
объясняется в  <a HREF=gl8.htm#gl8.4.2>#8.4.2</a>). Здесь,  однако, имеется серьезная проблема, вдруг пользователь  не позаботится  проверить  значение  состояния,
если средство не слишком часто подводит. Кроме того, средство может
использоваться в  сотнях или  даже тысячах мест программы. Проверка
значения в каждом месте сильно затруднит чтение программы.
<br>  Третьему  подходу,   предоставлять  функцию   ошибок,   недостает
гибкости. Тот, кто реализует общецелевое средство, не может узнать,
как пользователи  захотят, чтобы  обрабатывались ошибки.  Например,
пользователь  может   предпочитать   сообщения   на   датском   или
венгерском.
<br>  Четвертый подход, позволить пользователю задавать функцию ошибок,
имеет некоторую  привлекательность  при  условии,  что  разработчик
предоставляет класс  в виде библиотеки (<a HREF=gl4.htm#gl4.5>#4.5</a>), в которой содержатся стандартные функции обработки ошибок.  Решения  3   и  4   можно  сделать   более  гибкими  (и  по  сути эквивалентными), задав указатель на функцию, а не саму функцию. Это
позволит разработчику  такого  средства,  как  slist,  предоставить
функцию ошибок, действующую по умолчанию, и при этом программистам,
которые  будут   использовать  списки,   будет  легко  задать  свои
собственные  функции   ошибок,  если   нужно,  и  там,  где  нужно.
Например:
<pre>
  typedef void (*PFC)(char*); // указатель на тип функция
  extern PFC slist_handler;
  extern PFC set_slist_handler(PFC);
</pre>
<br>Функция   set_slist_hanlder()   позволяет   пользователю   заменить
стандартную   функцию.    Общепринятая   реализация   предоставляет
действующую по  умолчанию функцию обработки ошибок, которая сначала
пишет сообщение  об ошибке в cerr, после чего завершает программу с
помощью exit():
<pre>
  #include "slist.h"
  #include

  void default_error(char* s)
  {
      cerr << s << "\n";
      exit(1);
  }
</pre>
<br>Она описывает  также указатель  на функцию  ошибок и,  для  удобства
записи, функцию для ее установки:
<pre>
  PFC slist_handler = default_error;

  PFC set_slist_handler(PFC handler);
  {
      PFC rr = slist_handler;
      slist_handler = handler;
      return rr;
  }
</pre>
<br>Обратите внимание,  как set_slist_hanlder()  возвращает  предыдущий
slist_hanlder().  Это  делает  удобным  установку  и  переустановку
обработчиков ошибок  на манер  стека. Это  может  быть  в  основном
полезным в больших программах, в которых slist может использоваться
в нескольких  разных ситуациях,  в каждой  из которых  могут, таким
образом, задаваться свои собственные подпрограммы обработки ошибок.
Например:
<pre>
  {
  PFC old = set_slist_handler(my_handler);

      // код, в котором в случае ошибок в slist
      // будет использоваться мой обработчик my_handler

      set_slist_handler(old); // восстановление
  }
</pre>
<br>  Чтобы сделать управление более изящным, slist_hanlder мог бы быть
сделан членом  класса slist,  что позволило  бы  различным  спискам
иметь одновременно разные обработчики.
<a name=gl7.3.5>
<h3 ALIGN=CENTER>   7.3.5 Обобщенные Классы </h3>
<p>  Очевидно,  можно   было  бы   определить  списки   других   типов
(classdef*, int,  char* и  т.д.) точно  так же,  как был  определен
класс nlist:  простым выводом  из класса slist. Процесс определения
таких новых  типов утомителен  (и  потому  чреват  ошибками),  но  с
помощью макросов  его можно  "механизировать".  К  сожалению,  если
пользоваться стандартным  C препроцессором  (<a HREF=gl4.htm#gl4.7>#4.7</a> и  #с.11.1),  это тоже может  оказаться тягостным.  Однако полученными  в  результате
макросами пользоваться довольно просто.
<br>  Вот пример  того, как обобщенный (generic) класс slist, названный
gslist, может  быть задан  как макрос. Сначала для написания такого
рода макросов включаются некоторые инструменты из :
<pre>
  #include "slist.h"

  #ifndef GENERICH
  #include
  #endif
</pre>
<br>  Обратите  внимание  на  использование  #ifndef  для  того,  чтобы
гарантировать, что   в одной компиляции не будет включен
дважды. GENERICH определен в .
<br>  После  этого  с  помощью  name2(),  макроса  из    для
конкатенации имен, определяются имена новых обобщенных классов:
<pre>
  #define gslist(type) name2(type,gslist)
  #define gslist_iterator(type) name2(type,gslist_iterator)
</pre>
<br>  И,  наконец,    можно    написать    классы    gslist(тип)    и
gslist_iterator(тип):
<pre>
  #define gslistdeclare(type)                              \
  struct gslist(type) : slist {                            \
      int insert(type a)                                   \
          { return slist::insert( ent(a) ); }              \
      int append(type a)                                   \
          { return slist::append( ent(a) ); }              \
      type get() { return type( slist::get() ); }          \
      gslist(type)() { }                                   \
      gslist(type)(type a) : (ent(a)) { }                  \
      ~gslist(type)() { clear(); }                         \
  };                                                       \
                                                           \
  struct gslist_iterator(type) : slist_iterator {          \
      gslist_iterator(type)(gslist(type)& a)               \
          : ( (slist&)s ) {}                               \
      type operator()()                                    \
          { return type( slist_iterator::operator()() ); } \
  }
</pre>
<br>  \ на конце строк указывает , что следующая строка является частью
определяемого макроса.
<br>  С помощью  этого макроса  список указателей  на имя,  аналогичный
использованному раньше классу nlist, можно определить так:
<pre>
  #include "name.h"

  typedef name* Pname;
  declare(gslist,Pname); // описать класс gslist(Pname)

  gslist(Pname) nl;      // описать один gslist(Pname)
</pre>
<br>Макрос declare  (описать) определен в . Он конкатенирует
свои параметры  и вызывает  макрос с  этим именем,  в данном случае
gslistdeclare, описанный выше. Параметр имя типа для declare должен
быть простым  именем. Используемый  метод макроопределения не может
обрабатывать имена типов вроде name*, поэтому применяется typedef.
<br>  Использования вывода  класса гарантирует,  что все частные случаи
обобщенного класса разделяют код. Этот метод можно применять только
для создания  классов объектов  того же  размера  или  меньше,  чем
базовый класс, который используется в макросе. gslist применяется в
<a HREF=#gl7.6.2>#7.6.2.</a>
<a name=gl7.3.6>
<h3 ALIGN=CENTER>   7.3.6 Ограниченные Интерфейсы </h3>
<p>  Класс slist - довольно общего характера. Иногда подобная общность
не требуется  или даже  нежелательна.  Ограниченные  виды  списков,
такие как  стеки и  очереди, даже  более обычны, чем сам обобщенный
список. Такие  структуры данных  можно задать,  не  описав  базовый
класс как открытый. Например, очередь целых можно определить так:
<pre>
  #include "slist.h"

  class iqueue : slist {
                 //предполагается sizeof(int)<=sizeof(void*)
  public:
      void put(int a) { slist::append((void*)a); }
      int det()       { return int(slist::get()); }
      iqueue()        {}
  };
</pre>
<br>При таком выводе осуществляются два логически разделенных действия:
понятие списка ограничивается понятием очереди (сводится к нему), и
задается тип  int, чтобы  свести  понятие  очереди  к  типу  данных
очередь  целых,   iqueue.  Эти   два  действия  можно  выполнять  и
раздельно. Здесь  первая часть  - это список, ограниченный так, что
он может использоваться только как стек:
<pre>
  #include "slist.h"

  class stack : slist {
  public:
      slist::insert;
      slist::get;
      stack() {}
      stack(ent a) : (a) {}
  };
</pre>
<br>который потом  используется для  создания типа  "стек указателей на
символы":
<pre>
  #include "stack.h"

  class cp : stack {
  public:
      void push(char* a) { slist::insert(a); }
      char* pop() { return (char*)slist::get(); }
      nlist() {}
  };
</pre>
<a name=gl7.4>
<h2 ALIGN=CENTER>   7.4 Добавление к Классу </h2>
<p>  В предыдущих  примерах производный  класс ничего  не  добавлял  к
базовому  классу.  Для  производного  класса  функции  определялись
только чтобы  обеспечить преобразование  типа.  Каждый  производный
класс просто  задавал альтернативный  интерфейс к  общему множеству
программ.  Этот  специальный  случай  важен,  но  наиболее  обычная
причина определения новых классов как производных классов в том, что
кто-то хочет  иметь то,  что предоставляет  базовый класс, плюс еще
чуть-чуть.
<br>  Для  производного   класса  можно  определить  данные  и  функции
дополнительно к  тем, которые  наследуются из  его базового класса.
Это дает  альтернативную стратегию  обеспечить средства  связанного
списка. Заметьте,  когда в  тот slist,  который  определялся  выше,
помещается элемент,  то создается  slink, содержащий два указателя.
На их  создание тратится  время, а  ведь без  одного из  указателей
можно обойтись,  при условии,  что нужно  только чтобы  объект  мог
находиться в  одном списке.  Так что  указатель next  на  следующий
можно поместить  в сам  объект, вместо  того, чтобы  помещать его в
отдельный объект  slink. Идея  состоит в  том, чтобы  создать класс
olink с  единственным полем  next, и  класс  olist,  который  может
обрабатывать указателями  на такие звенья olink. Тогда olist сможет
манипулировать объектами  любого  класса,  производного  от  olink.
Буква "o"  в названиях  стоит для  того, чтобы  напоминать вам, что
объект может находиться одновременно только в одном списке olist:
<pre>
  struct olink {
      olink* next;
  };
</pre>
<br>Класс olist  очень напоминает  класс slist.  Отличие состоит в том,
что пользователь  класса olist  манипулирует объектами класса olink
непосредственно:
<pre>
  class olist {
      olink* last;
  public:
      void insert(olink* p);
      void append(olink* p);
      olink* get();
      // ...
  };
</pre>
<br>Мы можем вывести из класса olink класс name:
<pre>
  class name : public olink {
      // ...
  };
</pre>
<br>  Теперь легко  сделать  список,  который  можно  использовать  без
накладных расходов времени на размещение или памяти.
<br>  Объекты, помещаемы  в olist,  теряют свой  тип. Это означает, что
компилятор знает  только то,  что они olink'и. Правильный тип можно
восстановить с помощью явного преобразования типа объектов, вынутых
из olist. Например:
<PRE>
  void f()
  {
      olist ll;
      name nn;
      ll.insert(&nn);              // тип &nn потерян
      name* pn = (name*)ll.get();  // и восстановлен
  }
</pre>
<br>Другой способ:  тип можно  восстановить, выведя  еще один  класс из
olist для обработки преобразования типа:
<pre>
  class olist : public olist {
      // ...
      name* get() { return (name*)olist::get(); }
  };
</pre>
<br>  Имя name  может одновременно находиться только в одном olist. Для
имен это  может быть  и не подходит,  но в  классах, для которых это
подойдет полностью,  недостатка нет.  Например, класс  фигур  shape
использует для  поддержки списка  всех  фигур  именно  этот  метод.
Обратите  внимание,   что  можно   было  бы  определить  slist  как
производный от  olist, объединяя  таким образом оба понятия. Однако
использование   базовых    и   производных    классов   на    таком
микроскопическом уровне может очень сильно исказить код.
<a name=gl7.5>
<h2 ALIGN=CENTER>     7.5 Неоднородные Списки </h2>
<p>  Предыдущие списки  были однородными. То есть, в список помещались
только  объекты   одного   типа.   Это   обеспечивалось   аппаратом
производных   классов.    Списки   не   обязательно   должны   быть
однородными. Список,  заданный в  виде указателей на класс, может
содержать объекты  любого класса,  производного от этого класса. То
есть, список  может быть  неоднородным. Вероятно,  это единственный
наиболее важный  и полезный аспект производных классов, и он весьма
существенно  используется   в   стиле   программирования,   который
демонстрируется   приведенным    выше    примером.    Этот    стиль
программирования    часто    называют    объектно-основанным    или
объектно-ориентированным. Он  опирается на  то,  что  действия  над
объектами  неоднородных  списков  выполняются  одинаковым  образом.
Смысл  этих   действий  зависит   от  фактического  типа  объектов,
находящихся в  списке (что  становится известно  только  на  стадии
выполнения),  а   не  просто  от  типа  элементов  списка  (который
компилятору известен).
<a name=gl7.6>
<h2 ALIGN=CENTER>   7.6 Законченная Программа </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl7.6.1>      7.6.1 Администратор Экрана   </a>                   
<tr><td width=10></td><TD>   <a HREF=#gl7.6.2>        7.6.2 Библиотека Фигур           </a>                
<tr><td width=10></td><TD>  <a HREF=#gl7.6.3>        7.6.3 Прикладная Программа   </a>                   
</table>
<p>  Разберем процесс  написания программы  для  рисования  на  экране
геометрических фигур.  Она естественным  образом разделяется  на три
части:
<br>  [1] Администратор экрана: подпрограммы низкого уровня и структуры
     данных, определяющие экран; он ведает только точками и прямыми
     линиями;
<br>  [2] Библиотека  фигур: набор  определений основных  фигур  вроде
     прямоугольника и  круга и  стандартные программы  для работы с
     ними; и
<br>  [3]     Прикладная      программа:     множество     определений,
     специализированных для  данного приложения,  и код,  в котором
     они используются.
<br>  Эти три  части скорее  всего будут  писать разные  люди (в разных
организациях и  в разное  время). При этом части будут скорее всего
писать   именно    в   указанном    порядке   с   тем   осложняющим
обстоятельством,  что  у  разработчиков  нижнего  уровня  не  будет
точного представления,  для чего  их код  в  конечном  счете  будет
использоваться. Это отражено в приводимом примере. Чтобы пример был
короче,  графическая   библиотека   предоставляет   только   весьма
ограниченный сервис,  а сама  прикладная  программа  очень  проста.
Чтобы читатель смог испытать программу, даже если у него нет совсем
никаких  графических   средств,  используется  чрезвычайно  простая
концепция экрана.  Не должно  составить труда заменить эту экранную
часть программы  чем-нибудь подходящим,  не изменяя  код библиотеки
фигур и прикладной программы.
<a name=gl7.6.1>
<h3 ALIGN=CENTER>   7.6.1 Администратор Экрана </h3>
<p>  Вначале было намерение написать администратор экрана на C (а не на
C++),  чтобы   подчеркнуть  разделение   уровней  реализации.   Это
оказалось  слишком   утомительным,  поэтому   пришлось   пойти   на
компромисс: используется  стиль C  (нет функций членов, виртуальных
функций,  определяемых   пользователем  операций  и  т.п.),  однако
применяются  конструкторы,   надлежащим   образом   описываются   и
проверяются параметры  функций  и  т.д.  Оглядываясь  назад,  можно
сказать, что  администратор экрана  очень  похож  на  C  программу,
которую потом  модифицировали, чтобы воспользоваться средствами C++
не переписывая все полностью.
<br>  Экран представляется  как двумерный  массив  символов,  работу  с
которым осуществляют функции put_point() и put_line(), использующие
при ссылке на экран структуру point:
<pre>
  // файл screen.h

  const XMAX=40, YMAX=24;

  struct point {
      int x,y;
      point() {}
      point(int a, int b) { x=a; y=b; }
  };

  overload put_point;
  extern void put_point(int a, int b);
  inline void put_point(point p) { put_point(p.x,p.y); }

  overload put_line;
  extern void put_line(int, int, int, int);
  inline void put_line(point a, point b)
      { put_line(a.x,a.y,b.x,b.y); }

  extern void screen_init();
  extern void screen_refresh();
  extern void screen_clear();

  #include
</pre>
<br>  Перед   первым    использованием   функции    put   экран    надо
инициализировать с  помощью screen_init(),  а изменения в структуре
данных  экрана   отображаются  на   экране  только   после   вызова
screen_refresh().  Как   увидит  пользователь,   это   "обновление"
("refresh") осуществляется  просто посредством  печати новой  копии
экрана под  его предыдущим  вариантом. Вот  функции  и  определения
данных для экрана:
<pre>
  #include "screen.h"
  #include

  enum color { black='*', white=' ' };

  char screen[XMAX][YNAX];

  void screen_init()
  {
      for (int y=0; y=a || a<=b) y0 += dy, eps -= two_a;
      }
  }
</pre>
<br>Предоставляются функции для очистки экрана и его обновления:
<pre>
  void screen_clear() { screen_init(); }  // очистка

  void screen_refresh()                   // обновление
  {
      for (int y=YMAX-1; 0<=y; y--) {     // сверху вниз
          for (int x=0; x
</pre>
<a name=gl7.6.2>
<h3 ALIGN=CENTER> 7.6.2 Библиотека Фигур </h3>
<p>  Нам нужно  определить общее  понятие  фигуры  (shape).  Это  надо
сделать таким образом, чтобы оно использовалось (как базовый класс)
всеми конкретными фигурами (например, кругами и квадратами), и так,
чтобы любой  фигурой можно  было манипулировать исключительно через
интерфейс, предоставляемый классом shape:
<pre>
  struct shape {
      shape() { shape_list.append(this); }

      virtual point north() { return point(0,0); } // север
      virtual point south() { return point(0,0); } // юг
      virtual point east() { return point(0,0); }  // восток
      virtual point neast() { return point(0,0); } // северо-восток
      virtual point seast() { return point(0,0); } // юго-восток

      virtual void draw() {};                      // нарисовать
      virtual void move(int, int) {};              // переместить
  };
</pre>
<br>  Идея состоит  в том,  что расположение  фигуры задается с помощью
move(), и фигура помещается на экран с помощью draw(). Фигуры можно
располагать  относительно   друг  друга,  используя  понятие  точки
соприкосновения, и  эти точки  перечисляются после точек на компасе
(сторон света). Каждая конкретная фигура определяет свой смысл этих
точек, и  каждая  определяет  способ,  которым  она  рисуется.  Для
экономии места  здесь на самом деле определяются только необходимые
в этом  примере стороны света. Конструктор shape::shape() добавляет
фигуру в  список фигур  shape_list. Этот список является gslist, то
есть,  одним   из  вариантов   обобщенного  односвязанного  списка,
определенного в  <a HREF=#gl7.3.5>#7.3.5.</a> Он и соответствующий итератор были сделаны так:
<pre>
  typedef shape* sp;
  declare(gslist,sp);

  typedef gslist(sp) shape_lst;
  typedef gslist_iterator(sp) sp_iterator;
</pre>
<br>поэтому shape_list можно описать так:
<pre>
  shape_lst shape_list;
</pre>
<br>Линию можно  построить либо по двум точкам, либо по точке и целому.
В последнем  случае создается  горизонтальная линия,  длину которой
определяет целое.  Знак целого  указывает,  каким  концом  является
точка: левым или правым. Вот определение:
<pre>
  class line : public shape {
  /*
      линия из 'w' в 'e'
      north() определяется как ``выше центра
      и на север как до самой северной точки''
  */
      point w,e;
  public:
      point north()
          { return point((w.x+e.x)/2,e.ydraw();
      screen_refresh();
  }
</pre>
<br>И вот,  наконец, настоящая  сервисная функция (утилита). Она кладет
одну фигуру  на верх другой, задавая, что south() одной должен быть
сразу над north() другой:
<pre>
  void stack(shape* q, shape* p)   // ставит p на верх q
  {
      point n = p->north();
      point s = q->south();
      q->move(n.x-s.x,n.y-s.y+1);
  }
</pre>
<br>  Теперь   представим    себе,   что   эта   библиотека   считается
собственностью  некоей   компании,  которая   продает   программное
обеспечение, и  что  они  продают  вам  только  заголовочный  файл,
содержащий   определения   фигур,   и   откомпилированный   вариант
определений  функций.  И  у  вас  все  равно  остается  возможность
определять новые  фигуры и использовать для ваших собственных фигур
сервисные функции.
<a name=gl7.6.3>
<h3 ALIGN=CENTER>   7.6.3 Прикладная Программа </h3>
<p>  Прикладная  программа   чрезвычайно  проста.  Определяется  новая
фигура my_shape  (на печати  она немного похожа на рожицу), а потом
пишется главная  программа, которая  надевает на нее шляпу. Вначале
описание my_shape:
<pre>
  #include "shape.h"

  class myshape : public rectangle {
      line* l_eye;                   // левый глаз
      line* r_eye;                   // правый глаз
      line* mouth;                   // рот
  public:
      myshape(point, point);
      void draw();
      void move(int, int);
  };
</pre>
<br>  Глаза и  рот -  отдельные и  независимые объекты, которые создает
конструктор my_shape:
<pre>
  myshape::myshape(point a, point b) : (a,b)
  {
      int ll = neast().x-swest().x+1;
      int hh = neast().y-swest().y+1;
      l_eye = new line(
          point(swest().x+2,swest().y+hh*3/4),2);
      r_eye = new line(
          point(swest().x+ll-4,swest().y+hh*3/4),2);
      mouth = new line(
          point(swest().x+2,swest().y+hh/4),ll-4);
  }
</pre>
<br>  Объекты  глаза   и   рот   порознь   рисуются   заново   функцией
shape_refresh(), и  в принципе  могут обрабатываться  независимо из
объекта  my_shape,   которому  они  принадлежат.  Это  один  способ
определять средства  для иерархически  построенных  объектов  вроде
my_shape. Другой  способ демонстрируется  на примере  носа. Никакой
нос не  определяется,  его  просто  добавляет  к  картинке  функция
draw():
<pre>
  void myshape::draw()
  {
      rectangle::draw();
      put_point(point(
          (swest().x+neast().x)/2,(swest().y+neast().y)/2));
  }
</pre>
<br>my_shape    передвигается    посредством    перемещения    базового
прямоугольника rectangle  и вторичных объектов l_eye, r_eye и mouth
(левого глаза, правого глаза и рта):
<pre>
  void myshape::move()
  {
      rectangle::move();
      l_eye->move(a,b);
      r_eye->move(a,b);
      mouth->move(a,b);
  }
</pre>
<br>Мы  можем,   наконец,  построить   несколько  фигур  и  немного  их
подвигать:
<pre>
  main()
  {
      shape* p1 = new rectangle(point(0,0),point(10,10));
      shape* p2 = new line(point(0,15),17);
      shape* p3 = new myshape(point(15,10),point(27,18));
      shape_refresh();
      p3->move(-10,-10);
      stack(p2,p3);
      stack(p1,p2);
      shape_refresh();
      return 0;
  }
</pre>
<br>  Еще раз  обратите внимание,  как функции  вроде shape_refresh() и
stack() манипулируют  объектами типов,  определяемых гораздо позже,
чем  были  написаны  (и,  может  быть,  откомпилированы)  сами  эти
функции.
<br>Результатом работы программы будет: 
<p><font size=1>
<table border=1 align=center>
<TR><TD>
<pre>
     ***********
     *         *
     *         *
     *         *
     *         *
     *         *
     *         *
     *         *
     *         *
     *         *
     ***********
  *****************
    *************
    *           *
    * **     ** *
    *           *
    *     *     *
    *           *
    * ********* *
    *           *
    *************
</table></font></pre>
<a name=gl7.7>
<h2 ALIGN=CENTER>    7.7 Свободная Память </h2>
<p>  Если вы  пользовались классом slist, вы могли обнаружить, что ваша
программа тратит  на заметное  время на  размещение и  освобождение
объектов класса  slink.  Класс  slink  -  это  превосходный  пример
класса, который может значительно выиграть от того, что программист
возьмет под  контроль управление  свободной памятью. Для этого вида
объектов идеально  подходит оптимизирующий  метод, который описан в
<a HREF=gl5_2.htm#gl5_2.5.6>#5.5.6.</a>  Поскольку   каждый  slink   создается  с   помощью  new  и уничтожается с  помощью delete  членами класса slist, другой способ
выделения памяти не представляет никаких проблем.
<br>  Если производный  класс осуществляет присваивание указателю this,
то конструктор  его базового  класса будет  вызываться только после
этого  присваивания,  и  значение  указателя  this  в  конструкторе
базового  класса   будет  тем,   которое  присвоено   конструктором
производного класса. Если базовый класс присваивает указателю this,
то будет  присвоено то  значение,  которое  использует  конструктор
производного класса. Например:
<pre>
  #include

  struct base { base(); };

  struct derived : base { derived(); }

  base::base()
  {
      cout << "\tbase 1: this=" << int(this) << "\n";
      if (this == 0) this = (base*)27;
      cout << "\tbase 2: this=" << int(this) << "\n";
  }

  derived::derived()
  {
      cout << "\tderived 1: this=" << int(this) << "\n";
      this = (this == 0) ? (derived*)43 : this;
      cout << "\tderived 2: this=" << int(this) << "\n";
  }

  main()
  {
  cout << "base b;\n";
  base b;
  cout << "new base b;\n";
  new base;
  cout << "derived d;\n";
  derived d;
  cout << "new derived d;\n";
  new derived;
  cout << "at the end\n";

  }
</pre>
<br>порождает вывод
<pre>
  base b;
          base 1: this=2147478307
          base 2: this=2147478307
  new base;
          base 1: this=0
          base 2: this=27
  derived d;
          derived 1: this=2147478306
          base 1: this=2147478306
          base 2: this=2147478306
          derived 1: this=2147478306
  new derived;
          derived 1: this=0
          base 1: this=43
          base 2: this=43
          derived 1: this=43
  at the end
</pre>
<br>  Если деструктор  производного  класса  осуществляет  присваивание
указателю this,  то будет  присвоено то  значение, которое  встретил
деструктор  его   базового  класса.   Когда   кто-либо   делает   в
конструкторе присваивание указателю this, важно, чтобы присваивание
указателю this встречалось на всех путях в конструкторе<a HREF=#*7.1>*<sup>1</sup></a>.
<a name=gl7.8>
<h2 ALIGN=CENTER>    7.8 Упражнения </h2>
<ol>
  <LI> (*1) Определите
<pre>
       class base {
       public:
          virtual void iam() { cout << "base\n"; }
       };
</pre>
<br>     Выведите из base два класса и для каждого определите iam() ("я
     есть"), которая выводит имя класса на печать. Создайте объекты
     этих классов  и  вызовите  для  них  iam().  Присвойте  адреса
     объектов производных классов указателям base* и вызовите iam()
     через эти указатели.
  <LI> (*2) Реализуйте примитивы экрана (<a HREF=#gl7.6.1>#7.6.1</a>) подходящим для вашей системы образом.
  <LI> (*2) Определите  класс triangle  (треугольник) и  класс circle
     (круг).
  <LI> (*2) Определите функцию, которая рисует линию, соединяющую две
     фигуры, отыскивая  две  ближайшие  "точки  соприкосновения"  и
     соединяя их.
  <LI> (*2) Модифицируйте  пример с  фигурами так,  чтобы  line  была
     rectangle и наоборот.
  <LI> (*2) Придумайте  и реализуйте дважды связанный список, который
     можно использовать без итератора.
  <LI> (*2) Придумайте  и реализуйте дважды связанный список, которым
     можно  пользоваться  только  посредством  итератора.  Итератор
     должен иметь  действия для  движения вперед  и назад, действия
     для вставления и удаления элементов списка, и способ доступа к
     текущему элементу.
  <li> (*2) Постройте обобщенный вариант дважды связанного списка.
 <LI> (*4) Сделайте  список, в  котором вставляются и удаляются сами
     объекты (а не просто указатели на объекты). Проделайте это для
     класса  X,   для   которого   определены   X::X(X&),   X::~X()
     X::operator=(X&).
  <LI> (*5)  Придумайте   и  реализуйте   библиотеку  для  написания
     моделей, управляемых прерываниями. Подсказка: . Только
     это -  старая программа,  а вы могли бы написать лучше. Должен
     быть класс  task (-  задача). Объект  класса task  должен мочь
     сохранять свое  состояние и  восстанавливаться в это состояние
     (вы можете  определить task::save()  и task::restore()), чтобы
     он мог  действовать как  сопрограмма. Отдельные  задачи  можно
     определять как  объекты классов,  производных от  класса task.
     Программа, которую  должна исполнять  задача, модет задаваться
     как виртуальная  функция. Должна  быть возможность  передавать
     новой задаче  ее параметры  как параметры ее конструктора(ов).
     Там   должен    быть   планировщик,    реализующий   концепцию
     виртуального    времени.     Обеспечьте    функцию    задержки
     task::delay(), которая  "тратит" виртуальное  время. Будет  ли
     планировщик отдельным  или частью  класса task  - это  один из
     основных вопросов,  которые надо  решить  при  проектировании.
     Задача должна  передавать данные. Для этого разработайте класс
     queue (очередь). Придумайте способ, чтобы задача ожидала ввода
     из нескольких очередей. Ошибки в ходе выполнения обрабатывайте
     единообразно. Как  бы вы  отлаживали программы,  написанные  с
     помощью такой библиотеки?
</ol>
<p><small>
<a name=*7.1>
*<sup>1</sup> К  сожалению, об  этом присваивании  легко забыть.  Например, в
первом издании  этой книги  (английском  -  перев.)  вторая  строка
конструктор derived::derived() читалась так:
<big><pre>
  if (this == 0) this = (derived*)43;
</pre></big>
И следовательно,  для d конструктор базового класса base::base() не
вызывался. Программа  была допустимой  и корректно  выполнялась, но
очевидно делала не то, что подразумевал автор. (прим. автора)
</small>
<p> <center> <font size="-1">
[<a href="gl6.htm">Назад</a>]
[<a href="aglav.htm">Содержание</a>]
[<a href="gl8.htm">Вперед</a>]
</font> 
<p>
<center><font size=1>
Copyright &copy <a href="cit.htm#1">CIT</a>
</font></center>
</body></html>
