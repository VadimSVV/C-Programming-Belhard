Мюррэй Хилл, Нью Джерси
Бьярн Страустрап

Язык C++

Содержание                                         1

Предисловие                                        8
Благодарности                                      8
Заметки для читателя                              10
Структура этой книги                              10
Замечания по реализации                           11
Упражнения                                        11
Замечания по проекту языка                        11
Исторические замечания                            12
Эффективность и структура                         13
Философские замечания                             15
Размышления о программировании на C++             15
Правила правой руки                               17
Замечания для программистов на C                  17
Глава 1
Турне по C++                                      18
1.1 Введение                                      18
1.1.1 Вывод                                       18
1.1.2 Компиляция                                  19
1.1.3 Ввод                                        20
1.2 Комментарии                                   21
1.3 Типы и Описания                               21
1.3.1 Основные Tипы                               21
1.3.2 Производные Типы                            23
1.4 Выражения и Операторы                         23
1.4.1 Выражения                                   23
1.4.2 Операторы Выражения                         24
1.4.3 Пустой оператор                             24
1.4.4 Блоки                                       24
1.4.5 Операторы if                                25
1.4.6 Операторы switch                            25
1.4.7 Оператор while                              26
1.4.8 Оператор for                                26
1.4.9 Описания                                    27
1.5 Функции                                       27
1.6 Структура программы                           28
1.7 Классы                                        30
1.8 Перегрузка операций                           31
1.9 Ссылки                                        32
1.10 Конструкторы                                 33
1.11 Вектора                                      34
1.12 Inline-подстановка                           35
1.13 Производные  классы                          36
1.14 Еще об операциях                             37
1.15 Друзья (friend)                              39
1.16 Обобщенные Вектора                           40
1.17 Полиморфные Вектора                          40
1.18 Виртуальные функции                          42
Глава 2
Описания и Константы                              43
2.1 Описания                                      43
2.1.1 Область Видимости                           44
2.1.2 Объекты и Адреса (Lvalue)                   46
2.1.3 Время Жизни                                 46
2.2 Имена                                         47
2.3 Типы                                          47
2.3.1 Основные Типы                               48
2.3.2 Неявное Преобразование Типа                 49
2.3.3 Производные Типы                            50
2.3.4 Тип void                                    51
2.3.5 Указатели                                   51
2.3.6 Вектора                                     52
2.3.7 Указатели и Вектора                         54
2.3.8 Структуры                                   55
2.3.9 Эквивалентность типов                       57
2.3.10 Ссылки                                     58
2.3.11 Регистры                                   60
2.4 Константы                                     61
2.4.1 Целые Константы                             61
2.4.2 Константы с Плавающей Точкой                62
2.4.3 Символьные Константы                        62
2.4.4 Строки                                      63
2.4.5 Ноль                                        64
2.4.6 Const                                       64
2.4.7 Перечисления                                65
2.5 Экономия Пространства                         66
2.5.1 Поля                                        66
2.5.2 Объединения                                 67
2.6 Упражнения                                    69
Глава 3
Выражения и операторы                             71
3.1 Настольный калькулятор                        71
3.1.1 Программа синтаксического разбора           71
3.1.2 Функция ввода                               76
3.1.3 Таблица имен                                78
3.1.4 Обработка ошибок                            80
3.1.5 Драйвер                                     81
3.1.6 Параметры командной строки                  82
3.2 Краткая сводка операций                       83
3.2.1 Круглые скобки                              85
3.2.2 Порядок вычисления                          85
3.2.2 Увеличение и уменьшение*                    86
3.2.4 Побитовые логические операции               87
3.2.5 Преобразование типа                         88
3.2.6 Свободная память                            89
3.3 Сводка операторов                             92
3.3.1 Проверки                                    93
3.3.2 Goto                                        95
3.4 Комментарии и Выравнивание                    96
3.5 Упражнения                                    97
Глава 4
Функции и Файлы                                  100
4.1 Введение                                     100
4.2 Компоновка                                   101
4.3 Заголовочные Файлы                           102
4.3.1 Один Заголовочный Файл                     104
4.3.2 Множественные Заголовочные Файлы           107
4.3.3 Скрытие Данных                             109
4.4 Файлы как Модули                             110
4.5 Как Создать Библиотеку                       111
4.6 Функции                                      112
4.6.1 Описания Функций                           112
4.6.2 Определения Функций                        112
4.6.3 Передача Параметров                        113
4.6.4 Возврат Значения                           114
4.6.5 Векторные Параметры                        115
4.6.6 Параметры по Умолчанию                     116
4.6.7 Перегрузка Имен Функций                    117
4.6.8 Незаданное Число Параметров                119
4.6.9 Указатель на Функцию                       120
4.7 Макросы                                      124
4.8 Упражнения                                   125
Глава 5
Классы                                           128
5.1 Знакомство и краткий обзор                   128
5.2 Классы и Члены                               129
5.2.1 Функции Члены                              129
5.2.2 Классы                                     130
5.2.3 Ссылки на Себя                             131
5.2.4 Инициализация                              132
5.2.5 Очистка                                    134
5.2.6  Inline                                    135
5.3 Интерфейсы и Реализации                      135
5.3.1 Альтернативные Реализации                  136
5.3.2 Законченный Класс                          139
5.4 Друзья и Объединения                         142
5.4.1 Друзья                                     142
5.4.2 Уточнение* Имени Члена                     144
5.4.3 Вложенные Классы                           144
5.4.4 Статические Члены                          145
5.4.5 Указатели на Члены                         146
5.4.6 Структуры и Объединения                    147
5.5 Конструкторы и Деструкторы                   149
5.5.1 Предостережение                            150
5.5.2 Статическая Память                         150
5.5.3 Свободная Память                           152
5.5.4 Объекты Класса и Члены                     152
5.5.5 Вектора Объектов Класса                    154
5.5.6 Небольшие Объекты                          155
5.5.7 Предостережение                            156
5.5.8 Объекты Переменного Размера                157
5.6 Упражнения                                   158
Глава 6
Перегрузка Операций                              160
6.1 Введение                                     160
6.2 Функции Операции                             161
6.2.1 Бинарные и Унарные Онерации                161
6.2.2 Предопределенные Значения Операций         162
6.2.3 Операции и Определяемые Пользователем Типы 162
6.3 Определяемое Преобразование Типа             163
6.3.1 Конструкторы                               164
6.3.2 Операции Преобразования                    164
6.3.3 Неоднозначности                            166
6.4 Константы                                    167
6.5 Большие Объеты                               167
6.6 Присваивание и Инициализация                 168
6.7 Индексирование                               170
6.8 Вызов Функции                                172
6.9 Класс Строка                                 173
6.10 Друзья и Члены                              177
6.11 Предостережение                             177
6.12 Упражнения                                  178
Глава 7
Производные Классы                               181
7.1 Введение                                     181
7.2 Производные Классы                           182
7.2.1 Построение Производного Класса             182
7.2.2 Функции Члены                              183
7.2.3 Видимость                                  184
7.2.4 Указатели                                  186
7.2.5 Иерархия Типов                             187
7.2.6 Конструкторы и Деструкторы                 187
7.2.7 Поля Типа                                  188
7.2.8 Виртуальные Функции                        190
7.3 Альтернативные Интерфейсы                    192
7.3.1 Интерфейс                                  192
7.3.2 Реализация                                 193
7.3.3 Как Этим Пользоваться                      194
7.3.4 Обработка Ошибок                           196
7.3.5 Обобщенные Классы                          197
7.3.6 Ограниченные Интерфейсы                    199
7.4 Добавление к Классу                          199
7.5 Неоднородные Списки                          201
7.6 Законченна Программа                         201
7.6.1 Администратор Экрана                       201
7.6.2 Библиотека Фигур                           203
7.6.3 Прикладная Программа                       207
7.7 Свободная Память                             209
7.8 Упражнения                                   210
Глава 8
Потоки                                           212
8.1 Введение                                     212
8.2 Вывод                                        213
8.2.1 Вывод Встроенных Типов                     213
8.2.2 Вывод Типов, Определяемых Пользователем    214
8.2.3 Некоторые Подробности Разработки           214
8.2.4 Форматированный Вывод                      216
8.2.5 Виртуальная Функция Вывода                 218
8.3 Файлы и Потоки                               219
8.3.1 Инициализация Потоков Вывода               219
8.3.2 Закрытие Потоков Вывода                    220
8.3.3 Открытие Файлов                            220
8.3.4 Копирование Потоков                        221
8.4 Ввод                                         221
8.4.1 Ввод Встроенных Типов                      221
8.4.2 Состояния Потока                           223
8.4.3 Ввод Типов, Определяемых Пользователем     224
8.4.4 Инициализация Потоков Ввода                225
8.5 Работа со Строками                           226
8.6 Буферизация                                  226
8.7 Эффективность                                228
8.8 Упражнения                                   228
1. ВВЕДЕНИЕ                                      230
2. ДОГОВОРЕННОСТИ О ЛЕКСИКЕ                      230
2.1 Комментарии                                  230
2.2 Идентификаторы (имена)                       230
2.3 Ключевые слова                               230
2.4 Константы                                    231
2.4.1 Целые константы                            231
2.4.2 Явно заданные длинные константы            231
2.4.3 Символьные константы                       231
2.4.4 Константы с плавающей точкой               232
2.4.5 Перечислимые константы                     232
2.4.6 Описанные константы                        232
2.5 Строки                                       232
2.6 Харктеристики аппаратного обеспечения        232
3. ЗАПИСЬ СИНТАКСИСА                             233
4. ИМЕНА И ТИПЫ                                  233
4.1 Область видимости                            234
4.2 Определения                                  234
4.3 Компоновка                                   234
4.4  Классы памяти                               235
4.5 Основные типы                                236
4.4 Производные типы                             236
5.  ОБЪЕКТЫ И LVALUE(АДРЕСА)                     237
6.  ПРЕОБРАЗОВАНИЯ                               237
6.1 Символы и целые                              237
6.2 Float и double                               237
6.3 Плавающие и целые                            237
6.4 Указатели и целые                            238
6.5 Unsigned                                     238
6.6 Арифметические преобразования                238
6.7 Преобразования указателей                    239
6.8 Преобразования ссылок                        239
7. ВЫРАЖЕНИЯ                                     239
7.1 Основные выражения                           240
7.2 Унарные операции                             241
7.2.1 Увеличение и Уменьшение                    242
7.2.2 Sizeof                                     242
7.2.3 Явное Преобразование Типа                  243
7.2.4 Свободная Память                           243
7.3 Мультипликативные операции                   244
7.4 Аддитивные операции                          244
7.5 Операции сдвига                              245
7.6 Операции отношения                           245
7.7 Операции равенства                           246
7.8 Операция побитовое И                         246
7.9 Операция побитовое исключающее ИЛИ           246
7.10 Операция побитовое включающее ИЛИ           246
7.11 Операция логическое И                       246
7.12 Операция логическое ИЛИ                     246
7.13 Условная операция                           247
7.14 Операции присваивания                       247
7.15 Операция запятая                            247
7.16 Перегруженные операции                      248
7.16.1 Унарные операции                          248
7.16.2 Бинарные операции                         248
7.16.3 Особые операции                           248
8. ОПИСАНИЯ                                      249
8.1 Спецификаторы класса памяти                  249
8.2 Спецификаторы Типа                           250
8.3 Описатели                                    251
8.4 Смысл описателей                             252
8.4.1 Примеры                                    254
8.5 Описания классов                             256
8.5.1 Статические члены                          257
8.5.2 Функции члены                              257
8.5.3 Производные классы                         259
8.5.4 Виртуальные функции                        259
8.5.5 Конструкторы                               260
8.5.6 Преобразования                             261
8.5.7 Деструкторы                                261
8.5.8 Видимость имен членов                      261
8.5.9 Друзья (friends)                           262
8.5.10 Функция операция                          263
8.5.11 Структуры                                 263
8.5.12 Объединения                               263
8.5.13 Поля бит                                  263
8.5.14 Вложенные классы                          264
8.6 Инициализация                                264
8.6.1 Список инициализаторов                     265
8.6.2 Классовые объекты                          266
8.6.3 Ссылки                                     266
8.6.4 Массивы символов                           267
8.7 Имена типов                                  267
8.8 Определение типа typedef                     268
8.9 Перегруженные имена функций                  269
8.10 Описание перечисления                       270
8.11 Описание Asm                                270
9. ОПЕРАТОРЫ                                     271
9.1 Оператор выражение                           271
9.2 Составной оператор, или блок                 271
9.3 Условный оператор                            271
9.4 Оператор while                               271
9.5 Оператор do                                  272
9.6 Оператор for                                 272
9.7 Оператор switch                              273
9.8 Оператор break                               273
9.9 Оператор continue                            274
9.10 Оператор return                             274
9.11 Оператор goto                               274
9.12 Помеченные операторы                        274
9.13 Пустой оператор                             274
9.14 Оператор delete                             275
9.15 Оператор asm                                275
10. ВНЕШНИЕ ОПРЕДЕЛЕНИЯ                          275
10.1  Определения функций                        275
10.2 Определения внешних данных                  276
11. ПРАВИЛА ОБЛАСТИ ВИДИМОСТИ                    276
12. КОМАНДНЫЕ СТРОКИ КОМПИЛЯТОРА                 276
12.1 Замена идентификаторов                      277
12.2 Включение файлов                            277
12.3 Условная компиляция                         277
12.4 Управление строкой                          278
13. НЕЯВНЫЕ ОПИСАНИЯ                             278
14. ОБЗОР ТИПОВ                                  278
14.1 Классы                                      278
14.2 Функции                                     278
14.3 Массивы, указатели и индексирование         279
14.4 Явные преобразования указателей             279
15. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ                        280
16. СООБРАЖЕНИЯ МОБИЛЬНОСТИ                      281
17. СВОБОДНАЯ ПАМЯТЬ                             281
18. КРАТКОЕ ИЗЛОЖЕНИЕ СИНТАКСИСА                 282
18.1 Выражения                                   282
18.2 Описания                                    283
18.3 Операторы                                   285
18.4 Внешние определения                         286
18.5 Препроцессор                                286
19. ОТЛИЧИЯ ОТ "СТАРОГО C"                       286
19.1 Расширения                                  286

Предисловие

Язык формирует наш способ мышления
и определяет, о чем мы можем мыслить.

Б.Л. Ворф

	C++ - универсальный язык программирования, задуманный так, чтобы сделать программирование более приятным для серьезного программиста. За исключением второстепенных деталей C++ является надмножеством языка программирования C. Помимо возможностей, которые дает C, C++ предоставляет гибкие  и эффективные средства определения новых  типов. Используя  определения новых типов, точно отвечающих концепциям приложения, программист может разделять разрабатываемую программу на легко поддающиеся контролю части.Такой метод построения программ часто называют абстракцией данных.Информация о типах содержится в некоторых объектах типов,определенных пользователем. Таки  объекты просты и надежны в использовании в тех ситуациях, когда их тип нельзя установить на стадии компиляции. Программирование с применением таких объектов часто называют объектно-ориентированным. При правильном использовании этот метод дает более короткие, проще понимаемые и легче контролируемые программы.
	Ключевым понятием C++ является класс. Класс - это тип, определяемый пользователем.  Классы  обеспечивают  скрытие  данных,
гарантированную инициализацию  данных, неявное преобразование типов
для типов,  определенных пользователем,  динамическое задание типа,
контролируемое  пользователем   управление  памятью   и   механизмы
перегрузки операций.  C++ предоставляет  гораздо лучшие,  чем в  C,
средства выражнения модульности программы и проверки типов. В языке
есть  также  усовершенствования,  не  связанные  непосредственно  с
классами,  включающие   в  себя  символические  константы,  inline-
подстановку функций,  параметры функции по умолчанию, перегруженные
имена функций,  операции управления  свободной памятью  и ссылочный
тип. В  C++ сохранены  возможности языка  C по  работе с  основными
объектами аппаратного  обеспечения (биты,  байты, слова,  адреса  и
т.п.).  Это   позволяет  весьма   эффективно  реализовывать   типы,
определяемые пользователем.
  C++  и  его  стандартные  библиотеки  спроектированы  так,  чтобы
обеспечивать переносимость.  Имеющаяся на текущий момент реализация
языка будет  идти в  большинстве систем,  поддерживающих C.  Из C++
программ  можно   использовать  C   библиотеки,  и   с  C++   можно
использовать большую часть инструментальных средств, поддерживающих
программирование на C.
  Эта книга  предназначена главным  образом для  того, чтобы помочь
серьезным  программистам   изучить   язык   и   применять   его   в
нетривиальных проектах.  В ней  дано  полное  описание  C++,  много
примеров и еще больше фрагментов программ.

     Благодарности

  C++  никогда   бы   не   созрел  без  постоянного  использования,
предложений и  конструктивной критики  со стороны  многих друзей  и
                              - стр 9 -

коллег. Том  Карджил, Джим Коплин, Сту Фельдман, Сэнди Фрэзер, Стив
Джонсон, Брайэн Керниган, Барт Локанти, Дуг МакИлрой, Дэннис Риччи,
Лэрри Рослер, Джерри Шварц и Джон Шопиро подали важные для развития
языка идеи.  Дэйв Пресотто  написал текущую  реализацию  библиотеки
потоков ввода/вывода.
  Кроме того, в развитие C++ внесли свой вклад сотни людей, которые
присылали   мне   предложения   по   усовершенствованию,   описания
трудностей, с  которыми они  сталкивались,  и  ошибки  компилятора.
Здесь я  могу упомянуть  лишь немногих  из них:  Гэри Бишоп,  Эндрю
Хьюм, Том Карцес, Виктор Миленкович, Роб Мюррэй, Леони Росс, Брайэн
Шмальт и Гарри Уокер.

  В издании этой книги мне помогли многие люди, в частности, Джон
Бентли, Лаура Ивс, Брайэн Керниган, Тэд Ковальски, Стив Махани,
Джон Шопиро и участники семинара по C++, который проводился в Bell
Labs, Колумбия, Огайо, 26-27 июня 1985 года.

                      Мюррэй Хилл, Нью Джерси      Бьярн Страустрап

                       Заметки для читателя

                                   "О многом,"-молвил Морж,-"Пришла
                                                  пора поговорить."

                                                          Л. Кэррол

  В этой  главе содержится  обзор книги,  список  библиографических
ссылок и  некоторые замечания  по C++  вспомогательного  характера.
Замечания  касаются   истории  C++,   идей,  оказавших  влияние  на
разработку C++,  и мыслей  по поводу  программирования на  C++. Эта
глава  не   является  введением:  замечания  не    обязательны  для
понимания последующих  глав, и некоторые из них предполагают знание
C++.

     Структура этой книги

  Глава 1  - это  короткое  турне  по  основным  особенностям  C++,
предназначенное для  того, чтобы  дать читателю почувствовать язык.
Программисты на  C первую  половину  главы  могут  прочитать  очень
быстро; она охватывает главным образом черты, общие для C и C++. Во
второй главе  описаны  средства  определения  новых  типов  в  C++;
начинающие могут  отложить более  подробное изучение этого до того,
как прочтут Главы 2, 3 и 4.
  В Главах  2, 3  и 4  описываются средства  C++, не  включенные  в
определение новых  типов:  основные  типы,  выражения  и  структуры
управления в  C++ программах.  Другими словами,  в них  описывается
подмножество  C++,   которое  по   существу  является   языком   C.
Рассмотрение  в   них  проводится   гораздо  подробнее,  но  полную
информацию можно найти только в справочном руководстве.
  В Главах  5, 6  и 7  описываются средства  C++ по  описанию новых
типов, особенности  языка, не  имеющие эквивалента  в C.  В Главе 5
приводится понятие  базового  класса,  и  показывается,  как  можно
инициализировать   объекты   типа,   определенного   пользователем,
обращаться к ним и, наконец, убирать их. В Главе 6 объясняется, как
для определенного  пользователем типа определять унарные и бинарные
операции, как  задавать преобразования  между типами, определенными
пользователем,  и   как  как  задавать  то,  каким  образом  должно
обрабатываться каждое  создание, уничтожение и копирование значения
определенного  пользователем  типа.  Глава  7  описывает  концепцию
производных классов,  которая позволяет  программисту строить более
сложные  классы   из  более  простых,  обеспечивать  альтернативные
интерфейсы класса  и работать с объектами безопасным и не требующим
беспокоиться о  типе способом  в тех ситуациях, когда типы объектов
не могут быть известны на стадии компиляции.
  В Главе  8 представлены классы ostream и istream, предоставляемые
стандартной библиотекой  для осуществления  ввода-вывода. Эта глава
имеет двоякую  цель: в  ней  представлены  полезные  средства,  что
одновременно является реальным примером использования C++.
  И, наконец, в книгу включено справочное руководство по C++.
  Ссылки на различные части этой книги даются в форме #2.3.4 (Глава
2 подраздел  3.4). Глава  с - это справочное руководство; например,
#с.8.5.5.
                             - стр 11 -

     Замечания по реализации

  Во время  написания этой  книги все  реализации C++  использовали
версии единственного интерфейсного компилятора#. Он используется на
многих   архитектурах,    включая   действующие    версии   системы
операционной системы  UNIX на AT&T 3B, DEC VAX, IBM 370 и Motorolla
68000. Фрагменты  программ, которые  приводятся в этой книге, взяты
непосредственно  из  исходных файлов, которые компилировались на 3B
в UNIX  System V  версии 2  [15], VAX11/750 под 8-ой Редакцией UNIX
[16] и  CCI Power 6/32 под BSD4.2 UNIX [17]. Язык, описанный в этой
книге,  -   это  "чистый  C++",  но  имеющиеся  на  текущий  момент
компиляторы реализуют  большое число  "анахронизмов"  (описанных  в
#с.15.3), которые должны способствовать переходу от C к C++.

     Упражнения

  Упражнения находятся в конце глав. Все упражнения главным образом
типа напишите-программу. Для решения всегда пишите такую прогармму,
которая  будет  компилироваться  и  работать  по  меньшей  мере  на
нескольких тестовых  случаях. Упражнения  различаются в основном по
сложности, поэтому  они помечены  оценкой степени  сложности. Шкала
экспоненциальная, так  что если на упражение (*1) вам потребовалось
пять минут,  то упражнение  (*2) вам может  потребоваться час, а на
(*3) -  день. Время,  которое требуется  на то,  чтобы  написать  и
оттестировать программу,  зависит больше  от опыта читателя, нежели
от самого  упражения. Упражнение  (*1) может  отнять день, если для
того, чтобы запустить ее,  читателю сначала  придется знакомиться с
новой вычислительной  системой. С  другой стороны,  тот, у кого под
рукой окажется нужный набор программ, может сделать упражнение (*5)
за  час.  В  качестве  источника  упражнений  к  Главам  2-4  можно
использовать любую  книгу по  C. У  Ахо и др. [1] приведено большое
количество общих структур данных и алгоритмов втерминах абстрактных
типов данных. Эту книгу также может служить источником упражнений к
Главам 5-7.  Однако языку,  который  в  этой  книге  использовался,
недостает как  функций членов,  так и  производных классов. Поэтому
определенные  пользователем  типы часто  можно выражать в C++ более
элегантно.

     Замечания по проекту языка

  Существенным критерием  при разработке  языка была простота; там,
где возникал  выбор между  упрощением руководства по языку и другой
документации и  упрощением компилятора, выбиралось первое. Огромное
значение также  придавалось совместимости с C; это помешало удалить
синтаксис C.
  В C++  нет типов  данных высокого уровня и нет первичных операций
высокого уровня.  В нем  нет, например, матричного типа с операцией
обращения  или   типа  строка   с  операцией   конкатенации.   Если
пользователю понадобятся подобные типы, их можно определить в самом
____________________
# C++  можно купить  в AT&T,  Software Sales  and Marketing, PO Box
25000, Greensboro, NC 27420, USA (телефон 800-828-UNIX) или в ваших
местных организациях,  осуществляющих продажу  Системы UNIX. (прим.
автора)

                             - стр 12 -

языке. По  сути дела,  основное, чем занимается программирование на
C++, - это определение универсальных и специально-прикладных типов.
Хорошо разработанный тип, определенный пользователем, отличается от
встроенного  типа  только  способом  определения,  но  не  способом
использования.
  Исключались те  черты, которые  могли бы  повлечь  дополнительные
расходы памяти или времени выполнения. Например, мысли о том, чтобы
сделать  необходимым   храние  в   каждом  объекте  "хозяйственной"
информации, были отвергнуты; если пользователь описывает структуру,
состоящую из двух 16-битовых величин, то структура поместится в 32-
битовый регистр.
  C++ проектировался  для  использования  в  довольно  традиционной
среде компиляции  и  выполнения,  среде  программирования  на  C  в
системе UNIX.  Средства обработки  особых ситуаций  и параллельного
программирования, требующие  нетривиальной загрузки  и поддержки  в
процессе выполнения,  не были  включены  в  C++.  Вследствие  этого
реализация C++ очень легко переносима. Однако есть полные основания
использовать C++  в среде,  где имеется  гораздо более существенная
поддержка. Такие  средства, как  динамическая  загрузка,  пошаговая
трансляция  и   база  данных  определений  типов  могут  с  пользой
применяться без воздействия на язык.
  Типы и  средства скрытия  данных в C++ опираются на проводимый во
время компиляции  анализ программ с целью предотвращения случайного
искажения данных.  Они не  обеспечивают секретности  или защиты  от
умышленного  нарушения   правил.  Однако     эти   средства   можно
использовать без  ограничений, что  не  приводит  к  дополнительным
расходам времени на выполнение или пространства памяти.

     Исторические замечания

  Безусловно, C++ восходит главным образом к C [7]. C сохранено как
подможество, поэтому  сделанного в  C акцента  на средствах низкого
уровня достаточно,  чтобы справляться  с самыми  насущными задачами
системного программирования.  C, в  свою  очередь,  многим  обязано
своему предшественнику  BCPL [9];  на самом  деле,  комментарии  //
(заново) введены  в C++  из  BCPL.  Если  вы  знаете  BCPL,  то  вы
заметите,  что  в  C++  по-прежнему  нет  VALOF  блока.  Еще  одним
источником вдохновения  послужил язык  Simula67 [2,3]; из него была
позаимствована концепция  класса (вместе  с производными классами и
функциями  членами).   Это  было   сделано,  чтобы   способствовать
модульности через  использование виртуальных  функций.  Возможности
C++ по перегрузке операций и свобода в расположении описаний везде,
где может встречаться оператор, похожи на Алгол68 [14].
  Название C++  - изобретение совсем недавнее (лета 1983его). Более
ранние  версии  языка  использовались  начиная  с  1980ого  и  были
известны как  "C  с  Классами".  Первоначально  язык  был  придуман
потому, что  автор хотел написать модели, управляемые прерываниями,
для чего  был бы  идеален Simula67,  если не  принимать во внимание
эффективность. "C  с Классами" использовался  для  крупных проектов
моделирования,  в   которых    строго   тестировались   возможности
написания программ,  требующих минимального  (только)  пространства
памяти и  времени на  выполнение.  В  "C  с  Классами"  не  хватало
перегрузки операций,  ссылок, виртуальных функций и многих деталей.
C++ был впервые введен за пределами исследовательской группы автора

                             - стр 13 -

в июле  1983его; однако  тогда многие  особенности C++  были еще не
придуманы.
  Название  C++   выдумал  Рик   Масситти.  Название  указывает  на
эволюционную природу  перехода к  нему от  C. "++"  - это  операция
приращения в  C. Чуть более короткое имя C+ является синтаксической
ошибкой; кроме  того, оно  уже было использовано как совсем другого
языка. Знатоки семантики C находят, что C++ хуже, чем ++C. Названия
D язык  не получил,  поскольку он является расширением C и в нем не
делается  попыток   исцеляться  от   проблем   путем   выбрасывания
различных особенностей.  Еще одну  интерпретацию названия C++ можно
найти в приложении к Оруэллу [8].
  Изначально C++  был разработан,  чтобы автору  и его  друзьям  не
приходилось программировать на ассемблере, C или других современных
языках высокого  уровня. Основным  его предназначением было сделать
написание хороших  программ более простым и приятным для отдельного
программиста. Плана  разработки C++  на  бумаге  никогда  не  было;
проект,   документация   и   реализация   двигались   одновременно.
Разумется, внешний  интерфейс C++  был написан  на C++.  Никогда не
существовало "Проекта  C++" и "Комитета по разработке C++". Поэтому
C++ развивался  и продолжает развиваться во всех направлениях чтобы
справляться со сложностями, с которыми сталкиваются пользователи, а
также в процессе дискуссий автора с его друзьями и коллегами.
  В качестве базового языка для C++ был выбран C, потому что он (1)
многоцелевой,  лаконичный   и  относительно   низкого  уровня;  (2)
отвечает большинству  задач системного  программирования; (3)  идет
везде и  на всем; и (4) пригоден в среде программирования UNIX. В C
есть свои  сложности, но  в наспех спроектированном языке тоже были
бы свои,  а сложности  C нам  известны. Самое  главное, работа  с C
позволила  "C   с  Классами"   быть  полезным  (правда,  неудобным)
инструментом в  ходе первых  месяцев  раздумий  о  добавлении  к  C
Simula-образных классов.
  C++ стал  использоваться шире,  и по  мере того, как возможности,
предоставляемые им  помимо возможностей  C, становились  все  более
существенными, вновь  и вновь поднимался вопрос о том, сохранять ли
совместимость с  C. Ясно,  что отказавшись  от  определенной  части
наследия C  можно было  бы избежать  ряда проблем   (см., например,
Сэти [12]). Это не было сделано, потому что (1) есть миллионы строк
на C, которые могли бы принести пользу в C++ при условии, что их не
нужно было  бы полностью  переписывать с  C на  C++; (2) есть сотни
тысяч строк  библиотечных функций  и сервисных программ, написанных
на C, которые можно было бы использовать из или на C++ при условии,
что C++  полностью совместим  с C по загрузке и синтаксически очень
похож на  C; (3) есть десятки тысяч программистов, которые знают C,
и которым,  поэтому,  нужно  только  научиться  использовать  новые
особенности C++,  а не  заново изучать его основы; и (4), поскольку
C++ и  C будут  использоваться на  одних и тех же системах одними и
теми же людьми, отличия должны быть либо очень большими, либо очень
маленькими, чтобы свести к минимуму ошибки и недоразумения. Позднее
была проведена  проверка определения  C++, чтобы  удостовериться  в
том,  что   любая  конструкциия,   допустимая  и   в  C  и  в  C++,
действительно означает в обоих языках одно и то же.
  Язык C  сам эволюционировал  за последние несколько лет, частично
под влиянием  развития  C++  (см.  Ростлер  [11]).  Предварительный
грубый ANSI  стандарт C  [10] содержит  синтаксис описаний функций,
заимствованный из  "C с  Классами". Заимствование  идей идет  в обе
стороны; например,  указатель void*  был  придуман  для  ANSI  C  и

                             - стр 14 -

впервые реализован  в C++. Когда ANSI стандарт разовьется несколько
дальше, придет время пересмотреть C++, чтобы удалить необоснованную
несовместимость.  Будет,   например,  модернизирован   препроцессор
(#с.11),  и   нужно   будет,   вероятно,   отрегулировать   правила
осуществления  плавающей   арифметики.  Это   не  должно  оказаться
болезненным, и  C и  ANSI C   очень  близки  к  тому,  чтобы  стать
подмножествами C++ (см. #с.11).

     Эффективность и структура

  C++ был  развит из  языка программирования C и за очень немногими
исключениями  сохраняет   C  как   подмножество.  Базовый  язык,  C
подмножество C++,  спроектирован так,  что  имеется  очень  близкое
соответствие  между   его  типами,   операциями  и   операторами  и
компьютерными  объектами,  с  которыми  непосредственно  приходится
иметь дело:  числами, символами и адресами. За исключением операций
свободной памяти  new и delete, отдельные выражения и операторы C++
обычно не  нуждаются в  скрытой поддержке  во время  выполнения или
подпрограммах.
  В C++  используются те же последовательности вызова и возврата из
функций, что  и в  C. В  тех  случаях,  когда  даже  этот  довольно
эффективный механизм  является слишком  дорогим, C++  функция может
быть подставлена  inline, удовлетворяя, таким образом, соглашению о
записи функций без дополнительных расходов времени выполнения.
  Одним из  первоначальных предназначений  C  было  применение  его
вместо программирования  на ассемблере  в  самых  насущных  задачах
системного программирования. Когда проектировался C++, были приняты
меры, чтобы  не ставить  под угрозу успехи в этой области. Различие
между C  и  C++  состоит  в  первую  очередь  в  степени  внимания,
уделяемого типам  и структурам.  C выразителен и снисходителен. C++
еще более  выразителен,  но  чтобы  достичь  этой  выразительности,
программист должен  уделить больше  внимания типам  объектов. Когда
известны типы  объектов, компилятор  может  правильно  обрабатывать
выражения, тогда  как в  противном случае  программисту пришлось бы
задавать  действия   с  мучительными  подробностями.  Знание  типов
объектов также позволяет компилятору обнаруживать ошибки, которые в
противном  случае   остались  бы  до  тестирования.  Заметьте,  что
использование системы  типов  для  того,  чтобы  получить  проверку
параметров функций, защитить данные от случайного искажения, задать
новые операции  и т.д.,  само по  себе не  увеличивает расходов  по
времени выполнения и памяти.
  Особое  внимание,   уделенное  при   разработке  C++   структуре,
отразилось на  возрастании масштаба программ, написанных со времени
разработки C.  Маленькую программу  (меньше 1000  строк) вы  можете
заставить работать  с помощью грубой силы, даже нарушая все правила
хорошего стиля.  Для программ  больших размеров  это не совсем так.
Если программа  в  10 000  строк  имеет  плохую  структуру,  то  вы
обнаружите,  что   новые  ошибки  появляются  так  же  быстро,  как
удаляются старые.  C++ был  разработан так,  чтобы дать возможность
разумным образом  структурировать большие  программы таким образом,
чтобы  для   одного  человека  не  было  непомерным  справляться  с
программами в  25 000 строк.  Существуют программы  гораздо больших
размеров, однако  те, которые  работают, в  целом, как оказывается,
состоят из  большого числа  почти  независимых  частей,  каждая  из
которых намного  ниже указанных  пределов.  Естественно,  сложность

                             - стр 15 -

написания и  поддержки программы зависит от сложности разработки, а
не просто  от числа строк текста программы, так что точные цифры, с
помощью которых  были выражены  предыдущие соображения,  не следует
воспринимать слишком серьезно.
  Не  каждая   часть   программы,   однако,   может   быть   хорошо
структурирована,  независима   от  аппаратного  обеспечения,  легко
читаема и  т.п. C++  обладает  возможностями,  предназначенные  для
того, чтобы  непосредственно и  эффективно работать  с  аппаратными
средствами, не беспокоясь о безопасности или простоте понимания. Он
также имеет  возможности, позволяющие  скрывать такие  программы за
элегантными и надежными интерфейсами.
  В  этой  книге  особый  акцент  делается    на  методах  создания
универсальных  средств,   полезных  типов,  библиотек  и  т.д.  Эти
средства пригодятся  как тем программистам, которые пишут небольшие
программы, так  и тем, которые пишут большие. Кроме того, поскольку
все   нетривиальные    программы   состоят    из   большого   числа
полунезависимых частей,  методы написания таких частей пригодятся и
системным, и прикладным программистам.
  У кого-то  может появиться подозрение, что спецификация программы
с помощью  более подробной  системы  типов  приведет  к  увеличению
исходных текстов  программы. В  C++  это  не  так;  C++  программа,
описывающая типы  параметров функций,  использующая классы  и т.д.,
обычно немного  короче эквивалентной  C программы,  в  которой  эти
средства не используются.

     Философские замечания

  Язык программирования служит двум связанным между собой целям: он
дает программисту аппарат для задания действий, которые должны быть
выполнены, и  формирует концепции, которыми пользуется программист,
размышляя о  том, что  делать. Первой  цели идеально отвечает язык,
который настолько  "близок к машине", что всеми основными машинными
аспектами можно легко и просто оперировать достаточно очевидным для
программиста образом.  С таким умыслом первоначально задумывался C.
Второй цели  идеально отвечает  язык, который  настолько "близок  к
решаемой задаче",  чтобы концепции  ее решения  можно было выражать
прямо  и  коротко.  С  таким  умыслом  предварительно  задумывались
средства, добавленные к C для создания C++.
  Связь  между   языком,  на  котором  мы  думаем/программируем,  и
задачами  и  решениями,  которые  мы  можем  представлять  в  своем
воображении, очень  близка. По  этой причине  ограничивать свойства
языка только  целями исключения ошибок программиста в лучшем случае
опасно. Как  и в  случае с  естественными  языками,  есть  огромная
польза  быть   по  крайней   мере  двуязычным.  Язык  предоставляет
программисту  набор   концептуальных  инструментов;   если  они  не
отвечают задаче,  то  их  просто  игнорируют.  Например,  серьезные
ограничения концепции  указателя заставляют  программиста применять
вектора и  целую арифметику, чтобы реализовать структуры, указатели
и  т.п.   Хорошее  проектирование  и  отсутствие  ошибок  не  может
гарантироваться чисто за счет языковых средств.
  Система  типов  должна  быть  особенно  полезна  в  нетривиальных
задачах. Действительно,  концепция  классов  в  C++  показала  себя
мощным концептуальным средством.

                             - стр 16 -

     Размышления о программировании на C++

  В идеальном  случае подход  к разработке программы делится на три
части: вначале  получить ясное  понимание  задачи,  потом  выделить
ключевые идеи,  входящие в ее решение, и наконец выразить решение в
виде программы.  Однако подробности  задачи и  идеи решения   часто
становятся ясны  только в   результате  попытки выразить  их в виде
программы -  именно  в  этом  случае  имеет  значение  выбор  языка
программирования.
  В  большинстве   разработок  имеются   понятия,  которые   трудно
представить в  программе в  виде одного  из основных  типов или как
функцию без  ассоциированных с ней статических данных. Если имеется
подобное понятие,  опишите класс,  представляющий его  в программе.
Класс -  это тип;  это значит, что он задает поведение объектов его
класса: как  они создаются, как может осуществляться работа с ними,
и как  они уничтожаются.  Класс также  задает способ  представления
объектов; но на ранних стадиях разработки программы это не является
(не должно  являться) главной  заботой. Ключом  к написанию хорошей
программы является  разработка таких  классов, чтобы  каждый из них
представлял  одно   основное  понятие.  Обычно  это  означает,  что
программист  должен  сосредоточиться  на  вопросах:  Как  создаются
объекты этого  класса? Могут  ли  эти  объекты  копироваться  и/или
уничтожаться? Какие действия можно производить над этими объектами?
Если на такие вопросы нет удовлетворительных ответов, то во-первых,
скорее всего,   понятие  не было  "ясно", и  может быть неплохо еще
немного подумать  над задачей  и предлагаемым решением вместо того,
чтобы сразу начинать "программировать вокруг" сложностей.
  Проще  всего   иметь  дело  с  такими  понятиями,  которые  имеют
традиционную математическую  форму: числа  всех  видов,  множества,
геометрические фигуры  и т.п.  На самом  деле, следовало  бы  иметь
стандартные библиотеки  классов, представляющих такие понятия, но к
моменту написания  это  не  имело  места.  C++  еще  молод,  и  его
библиотеки не развились еще до той же степени, что и сам язык.
  Понятие не  существует в  пустоте, всегда  есть группы  связанных
между собой понятий. Организовать в программе взаимоотношения между
классами, то  есть определить  точную взаимосвязь  между различными
понятиями,  часто   труднее,  чем  сначала  спланировать  отдельные
классы. Лучше, чтобы  не получилось неразберихи, когда каждый класс
(понятие) зависит  от всех остальных. Рассмотрим два класса, A и B.
Взаимосвязи вроде  "A вызывает функции из B", "A создает объекты B"
и "A имеет члены B" редко вызывают большие сложности, а взаимосвязь
вроде "A  использует данные из B" обычно можно исключить (просто не
используйте  открытые   данные-члены).  Неприятными,  как  правило,
являются взаимосвязи,  которые по своей природе имеют вид "A есть B
и ...".
  Одним из  наиболее мощных  интеллектуальных средств,  позволяющих
справляться со  сложностью, является иерархическое упорядочение, то
есть  организация  связанных  между  собой  понятий  в  древовидную
структуру с  самым общим  понятием в  корне. В  C++ такие структуры
представляются  производными  классами.  Часто  можно  организавать
программу как  множество  деревьев  (лес?).  То  есть,  программист
задает  набор   базовых  классов,  каждый  из  которых  имеет  свое
собственное множество  производных классов.  Для определения набора
действий для  самой общей  интерпретации понятия  (базового класса)
часто   можно    использовать   виртуальные    функции    (#7.2.8).
Интерпретацию  этих   действий  можно,   в  случае   необходимости,

                             - стр 17 -

усовершенствовать для  отдельных специальных  классов  (производных
классов).
  Естественно,  такая   организация  имеет   свои  ограничения.   В
частности, множество  понятий  иногда  лучше  организуется  в  виде
ациклического  графа,   в  котором  понятие  может  непосредственно
зависеть от более чем одного другого понятия; например, "A есть B и
C и  ...". В  C++ нет непосредственной поддержки этого, но подобные
связи можно  представить, немного  потеряв в  элегантности и сделав
малость дополнительной работы (#7.2.5).
  Иногда для  организации понятий  некоторой программы  оказывается
непригоден даже  ациклический граф;  некоторые понятия  оказываются
взаимозависимыми по  своей природе.  Если множество взаимозависимых
классов  настолько   мало,  что  его  легко  себе  представить,  то
циклические  зависимости   не  должны   вызвать   сложностей.   Для
представления  множеств   взаимозависимых  классов   с  C++   можно
использовать идею friend классов (#5.4.1).
  Если вы можете организовать понятия программы только в виде обще-
го графа (не дерева или ациклического направленного графа), и  если
вы  не можете локализовать взаимные зависимости, то вы, по всей ви-
димости, попали в затруднительное положение, из которого вас не вы-
ручит ни один язык программирования. Если вы не можете  представить
какой-либо просто формулируемой зависимости между основными поняти-
ями, то скорее всего справиться с программой не удастся.
  Напомню,  что   большую  часть  программирования  можно  легко  и
очевидно  выполнять,   используя  только  простые  типы,  структуры
данных, обычные  функции и  небольшое число  классов из стандартной
библиотеки. Весь  аппарат, входящий  в определение  новых типов, не
следует  использовать   за  исключением   тех  случаев,   когда  он
действительно нужен.
  Вопрос "Как пишут хорошие программы на C++" очень похож на вопрос
"Как пишут  хорошую  английскую  прозу?"  Есть  два  вида  ответов:
"Знайте,  что  вы  хотите  сказать"  и  "Практикуйтесь.  Подражайте
хорошему языку."  Оба совета оказываются подходящими к C++ в той же
мере, сколь и для английского - и им столь же трудно следовать.

     Правила Правой Руки (*)

  Здесь  приводится   набор   правил,   которых   вам   хорошо   бы
придерживаться изучая C++. Когда вы станете более опытны, вы можете
превратить  их   в  то,   что  будет   подходить  для  вашего  рода
деятельности и вашего стиля программирования. Они умышленно сделаны
очень простыми, поэтому подробности в них опущены. Не воспринимайте
их чересчур  буквально. Написание  хороших  программ  требует  ума,
вкуса и терпения. Вы не собираетесь как следует понять это с самого
начала; поэкспериментируйте!
  [1]     Когда   вы   программируете,   вы   создаете   конкретное
     представление идей  вашего  решения  некоторой  задачи.  Пусть
     структура отражает  эти идеи  настолько  явно,  насколько  это
     возможно:
     [a]  Если вы  считате  "это"  отдельным понятием, сделайте его
          классом.

____________________
 (*)  Некоторые  легко запоминаемые эмпирические правила, "Правила-
помошники." (прим. перев.)

                             - стр 18 -

     [b]  Если вы  считате  "это"  отдельным объектом, сделайте его
          объектом некоторого класса.
     [c]  Если два  класса имеют общим нечто существенное, сделайте
          его базовым  классом. Почти  все классы в вашей программе
          будут иметь  нечто общее;  заведите (почти) универсальный
          базовый класс, и разработайте его наиболее тщательно.
  [2]     Когда  вы   определяете  класс,   который  не   реализует
     некоторый   математический    объект,   вроде    матрицы   или
     комплексного числа,  или тип  низкого уровня, вроде связанного
     списка, то:
     [a]  Не используйте глобальные данные.
     [b]  Не используйте глобальные функции (не члены).
     [c]  Не используйте открытые данные-члены.
     [d]  Не используйте  друзей, кроме как чтобы избежать [a], [b]
          или [c].
     [e]  Не  обращайтесь   к  данным-членам  или  другим  объектам
          непосредственно.
     [f]  Не помещайте в класс "поле типа"; используйте виртуальные
          функции.
     [g]  Не  используйте   inline-функции,  кроме   как   средство
          существенной оптимизации.

     Замечания для программистов на C

  Чем лучше  кто-нибудь знает  C,  тем  труднее  окажется  избежать
писания на  C++ в  стиле C,  теряя, тем  самым, некоторые возможные
выгоды C++. Поэтому проглядите, пожалуйста, раздел "Отличия от C" в
справочном руководстве  (#с.15).  Там  указывается  на  области,  в
которых C++ позволяет делать что-то лучше, чем C. Макросы (#define)
в  C++   почти  никогда  не  бывают  необходимы;  чтобы  определять
провозглашаемые константы,  используйте  const  (#2.4.6)  или  enum
(#2.4.7), и  inline (#1.12)  - чтобы  избежать лишних  расходов  на
вызов  функции.  Старайтесь  описывать  все  функции  и  типы  всех
параметров -  есть  очень  мало  веских  причин  этого  не  делать.
Аналогично, практически  нет причин  описывать локальную переменную
не инициализируя ее, поскольку описание может появляться везде, где
может стоять  оператор, - не описывайте переменную, пока она вам не
нужна. Не используйте malloc() - операция new (#3.2.6) делает ту же
работу лучше. Многие объединения не нуждаются в имени - используйте
безымянные объединения (#2.5.2).


                           Глава 1

                           Турне по C++

                             Единственный способ изучать новый язык
                        программирования - писать на нем программы.
                                                  - Брайэн Керниган

  Эта глава  представляет собой  краткий обзор  основных черт языка
программирования C++.  Сначала приводится  программа на  C++, затем
показано, как ее откомпилировать и запустить, и как такая программа
может выводить  выходные данные и считывать входные. В первой трети
этой главы  после введения  описаны  наиболее  обычные  черты  C++:
основные типы,  описания, выражения, операторы, функции и структура
программы. Оставшаяся  часть главы  посвящена возможностям  C++  по
определению новых  типов, скрытию  данных, операциям,  определяемым
пользователем, и иерархии определяемых пользователем типов.

     1.1 Введение

  Это турне  проведет вас  через ряд  программ и частей программ на
C++. К концу у вас должно сложиться общее представление об основных
особенностях C++,  и  будет  достаточно  информации,  чтобы  писать
простые  программы.  Для  точного  и  полного  объяснения  понятий,
затронутых   даже    в   самом   маленьком   законченном   примере,
потребовалось бы несколько страниц определений. Чтобы не превращать
эту главу  в описание  или  в  обсуждение  общих  понятий,  примеры
снабжены  только   самыми  короткими   определениями   используемых
терминов.  Термины   рассматриваются  позже,   когда  будет  больше
примеров, способствующих обсуждению.

     1.1.1 Вывод

      Прежде  всего, давайте  напишем программу,  выводящую  строку
выдачи:

  #include

  main()
  {
      cout << "Hello, world\n";
  }

  Строка #include  сообщает компилятору, чтобы он включил
стандартные возможности  потока ввода и вывода, находящиеся в файле
stream.h. Без  этих описаний  выражеине cout << "Hello, world\n" не
имело бы  смысла. Операция  << ("поместить  в"*) пишет  свой первый
аргумент во  второй (в  данном случае,  строку "Hello,  world\n"  в
____________________
* Программирующим  на C  << известно  как операция сдвига влево для
целых. Такое  использование <<  не утеряно;  просто в дальнейшем <<
было определено  для  случая,  когда  его  левый  операнд  является
потоком вывода. Как это делается, описано в #1.8. (прим. автора)

                             - стр 20 -

стандартный поток  вывода cout).  Строка -  это  последовательность
символов, заключенная  в двойные  кавычки. В строке символ обратной
косой  \,   за  которым  следует  другой  символ,  обозначает  один
специальный символ;  в данном  случае, \n  является символом  новой
строки. Таким  образом выводимые  символы состоят из Hello, world и
перевода строки.
  Остальная часть программы

  main() { ... }

определяет  функцию,   названную  main.   Каждая  программа  должна
содержать функцию  с именем  main, и  работа программы начинается с
выполнения этой функции.

     1.1.2 Компиляция

  Откуда появились  выходной поток cout и код, реализующий операцию
вывода <<?  Для  получения  выполняемого  кода  написанная  на  C++
программа  должна   быть  скомпилирована;  по  своей  сути  процесс
компляции такой  же, как  и для  С, и в нем участвует большая часть
входящих в  последний программ. Производится чтение и анализ текста
программы, и  если не обнаружены ошибки, то генерируется код. Затем
программа  проверяется   на  наличие   имен  и   операций,  которые
использовались, но  не были  определены (в  нашем случае это cout и
<<). Если  это возможно,  то программа  делается полной посредством
дополнения недостающих  определений из библиотеки (есть стандартные
библиотеки, и  пользователи могут  создавать свои  собственные).  В
нашем случае  cout и  << были  описаны в  stream.h, то  есть,  были
указаны их  типы, но не было дано никаких подробностей относительно
их реализации.  В стандартной  библиотеке  содержится  спецификация
пространства и инициализирующий код для cout и <<. На самом деле, в
этой библиотеке  содержится и  много других вещей, часть из которых
описана в  stream.h, однако  к скомпилированной  версии добавляется
только подмножество библиотеки, необходимое для того, чтобы сделать
нашу программу полной.
  Команда компиляции  в C++  обычно называется CC. Она используется
так же,  как команда  cc для  программ на  C; подробности вы можете
найти в  вашем руководстве.  Предположим, что  программа с  "Hello,
world"        хранится        в        файле        с        именем

                             - стр 21 -

hello.c, тогда вы можете ее скомпилировать и запустить примерно так
($ - системное приглашение):

  $ CC hello.c
  $ a.out
  Hello,world
  $

a.out -  это принимаемое  по умолчанию  имя исполняемого результата
компиляции. Если  вы  хотите  назвать  свою  программу,  вы  можете
сделать это с помощью опции -o:

  $ CC hello.c -o hello
  $ hello
  Hello,world
  $

     1.1.3 Ввод

  Следующая (довольно многословная) программа предлагает вам ввести
число дюймов.  После того,  как вы  это  сделаете,  она  напечатает
соответствующее число сантиметров.

  #include

  main()
  {
      int inch = 0;         // inch - дюйм
      cout << "inches";
      cin >> inch;
      cout << inch;
      cout << " in = ";
      cout << inch*2.54;
      cout << " cm\n";
  }

Первая строка  функции main()  описывает целую  переменную inch. Ее
значение  считывается  с  помощью  операции  >>  ("взять  из")  над
стандартным потоком  ввода cin.  Описания cin  и  >>,  конечно  же,
находятся  в  .  После  ее  запуска  ваш  терминал  может
выглядеть примерно так:

  $ a.out
  inches=12
  12 in = 30.48 cm
  $

В этом  примере на  каждую команду вывода приходится один оператор;
это слишком  длинно.  Операцию  вывода  <<  можно  применять  к  ее
собственному результату,  так что  последние четыре  команды вывода
можно было записать одним оператором:

  cout << inch << " in = " << inch*2.54 << " cm\n";

                             - стр 22 -

  В последующих  разделах ввод  и вывод будут описаны гораздо более
подробно.  Вся  эта  глава  фактически  может  рассматриваться  как
объяснение того,  как можно написать предыдущие программы на языке,
который не  обеспечивает  операции  ввода-вывода.  На  самом  деле,
приведенные  выше   программы  написаны   на   C++,   "расширенном"
операциями  ввода-вывода   посредством  использования  библиотек  и
включения файлов  с помощью  #include. Другими  словами, язык C++ в
том  виде,  в  котором  он  описан  в  справочном  руководстве,  не
определяет  средств  ввода-вывода;  вместо  этого  исключительно  с
помощью средств, доступных любому программисту, определены операции
<< и >>.

     1.2 Комментарии

  Часто  бывает   полезно  вставлять  в  программу  текст,  который
предназначается  в   качестве  комментария   только  для  читающего
программу человека  и игнорируется  компилятором в программе. В C++
это можно сделать одним из двух способов.
  Символы /*  начинают комментарий,  заканчивающийся символами  */.
Вся эта  последовательность символов  эквивалентна символу пропуска
(например, символу пробела). Это наиболее полезно для многострочных
комментариев и  изъятия частей программы при редактировании, однако
следует помнить, что комментарии /* */ не могут быть вложенными.
  Символы //  начинают комментарий,  который заканчивается  в конце
строки, на  которой они  появились. Опять,  вся  последовательность
символов эквивалентна  пропуску. Этот  способ наиболее  полезен для
коротких комментариев.  Символы //  можно  использовать  для  того,
чтобы закомментировать  символы /*  или */,  а символами  /*  можно
закомментировать //.

     1.3 Типы и Описания

  Каждое имя  и каждое  выражение имеет тип, определяющий операции,
которые могут над ними производиться. Например, описание

  int inch;

определяет, что  inch имеет  тип int, то есть,  inch является целой
переменной.
  Описание - это оператор, который вводит имя в программе. Описание
задает тип  этого имени.  Тип определяет   правильное использование
имени или выражения. Для целых определены такие операции, как +, -,
* и /. После того, как включен файл stream.h, объект типа int может
также быть вторым операндом <<, когда первый операнд ostream.
  Тип объекта  определяет не только то, какие операции могут к нему
применяться, но и смысл этих операций. Например, оператор

  cout << inch << " in = " << inch*2.54 << " cm\n";

правильно обрабатывает  четыре входных  значения различным образом.
Строки печатаются  буквально, тогда  как целое  inch и  значение  с
плавающей  точкой   inch*2.54  преобразуются   из  их   внутреннего
представлениия в  подходящее  для  человеческого  глаза  символьное
представление.

                             - стр 23 -

  В  C++   есть  несколько  основных  типов  и  несколько  способов
создавать новые.  Простейшие виды типов C++ описываются в следующих
разделах, а более интересные оставлены на потом.

     1.3.1 Основные Tипы

  Основные  типы,  наиболее  непосредственно  отвечающие  средствам
аппаратного обеспечения, такие:

  char  short  int  long  float  double

Первые четыре  типа используются для представления целых, последние
два -  для представления  чисел с плавающей точкой. Переменная типа
char имеет  размер, естественный  для хранения  символа  на  данной
машине  (обычно,   байт),  а  переменная  типа  int  имеет  размер,
соответствующий целой арифметике на  данной машине (обычно, слово).
Диапазон  целых  чисел,  которые  могут  быть  представлены  типом,
зависит от его размера. В C++ размеры измеряются в единицах размера
данных типа char, поэтому char по определению имеет размер единица.
Соотношение между основными типами можно записать так:

  1 = sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long)
  sizeof(float) <= sizeof(double)

В целом,  предполагать что-либо  еще  относительно  основных  типов
неразумно. В  частности, то,  что  целое  достаточно  для  хранения
указателя, верно не для всех машин.
  К основному  типу можно  применять прилагательное const. Это дает
тип, имеющий  те же  свойства, что  и исходный  тип, за исключением
того, что значение переменных типа const  не может изменяться после
инициалиизации.

  const float pi = 3.14;
  const char plus = '+';

  Символ, заключенный  в  одинарные  кавычки,  является  символьной
константой.  Заметьте,  что  часто  константа,  определенная  таким
образом, не занимает память; просто там, где требуется, ее значение
может    использоваться     непосредственно.    Константа    должна
инициализироваться  при   описании.  Для  переменных  инициализация
необязательна,  но   настоятельно  рекомендуется.   Оснований   для
введения локальнной переменной без ее инициализации очень немного.
  К любой  комбинации этих  типов могут  применяться арифметические
операции:

  +   (плюс, унарный и бинарный)
  -   (минус, унарный и бинарный)
  *   (умножение)
  /   (деление)

А также операции сравнения:

                             - стр 24 -

  ==  (равно)
  !=  (не равно)
  <   (меньше)
  >   (больше)
  <=  (меньше или равно)
  >=  (больше или равно)

Заметьте, что  целое деление  дает целый результат: 7/2 есть 3. Над
целыми может выполняться операция % получения остатка: 7%2 равно 1.
   При  присваивании и  арифметических операциях  C++ выполняет все
осмысленнные преобразования  между основными типами, чтобы их можно
было сочетать без ограничений:

  double d = 1;
  int i = 1;
  d = d + i;
  i = d + i;

     1.3.2 Производные Типы

  Вот операции, создающие из основных типов новые типы:

  *        указатель на
  *const   константный указатель на
  &        ссылка на
  []       вектор*
  ()       функция, возвращающая

  Например:

  char* p        // указатель на символ
  char *const q  // константный указатель на символ
  char v[10]     // вектор из 10 символов

Все вектора в качестве нижней границы индекса имеют ноль, поэтому в
v десять  элементов:v[0] ...  v[9].  Функции  объясняются  в  #1.5,
ссылки в  #1.9. Переменная  указатель может содержать адрес объекта
соответствующего типа:

  char c;
  // ...
  p = &c; // p указывает на c

Унарное & является операцией взятия адреса.

     1.4 Выражения и Операторы

  В C++  имеется  богатый  набор  операций,  с  помощью  которых  в
выражениях  образуются   новые  значения    и  изменяются  значения
____________________
*  одномерный   массив.  Это  принятый  термин  (например,  вектора
прерываний), и  мы сочли,  что стандартный перевод его как "массив"
затуманит изложение. (прим. перев.)

                             - стр 25 -

переменных.  Поток   управления  в  программе  задается  с  помощью
операторов , а описания используются для введения  в программе имен
переменных,  констант   и  т.д.  Заметьте,  что  описания  являются
операторами,  поэтому  они  свободно  могут  сочетаться  с  другими
операторами.

     1.4.1 Выражения

  В C++  имеется большое  число операций,  и они  будут объясняться
там, где (и если) это потребуется. Следует учесть, что операции

  ~    (дополнение)
  &    (И)
  ^    (исключающее ИЛИ)
  |    (включающее ИЛИ)
  <<   (логический сдвиг влево)
  >>   (логический сдвиг вправо)

применяются  к   целым,  и  что  нет  отдельного  типа  данных  для
логических действий.
  Смысл операции  зависит от  числа операндов;  унарное &  является
операцией взятия адреса, а бинарное & - это операция логического И.
Смысл операции  зависит также  от типа  ее операндов: + в выражении
a+b означает  сложение с  плавающей точкой, если операнды имеют тип
float, но  целое сложение,  если они  типа int. В #1.8 объясняется,
как   можно    определить   операцию    для   типа,   определяемого
пользователем,  без   потери  ее  значения,  предопределенного  для
основных и производных типов.
  В C++  есть операция  присваивания =, а не оператор присваивания,
как  в   некоторых  языках.   Таким  образом,   присваивание  может
встречаться в  неожиданном контексте;  например, x=sqrt(a=3*x). Это
бывает полезно.  a=b=c означает  присвоение c  объекту   b, а затем
объекту  a. Другим свойством операции присваивания является то, что
она может  совмещаться с  большинством бинарных операций. Например,
x[i+3]*=4 означает  x[i+3]=x[i+3]*4, за исключением того факта, что
выражение  x[i+3]   вычисляется   только   один   раз.   Это   дает
привлекательную степень эффективности без необходимости обращения к
оптимизирующим компиляторам. К тому же это более кратко.
  В большинстве  программ  на  C++  широко  применяются  указатели.
Унарная операция  * разыменовывает* указатель, т.е. *p есть объект,
на который  указывает p.  Эта операция  также называется  косвенной
адресацией. Например,  если имеется  char* p, то *p есть символ, на
который указывает p.  Часто при работе с указателями бывают полезны
операция увеличения  ++ и  операция уменьшения  --. Предположим,  p
указывает на  элемент вектора  v, тогда p++ делает p указывающим на
следующий элемент.

     1.4.2 Операторы Выражения

  Самый обычный  вид оператора  - оператор выражение. Он состоит из
выражения, за которым следует точка с запятой. Например:
____________________
*  англ.  dereference  -  получить  значение  объекта,  на  который
указывает данный указатель. (прим. перев.)

                             - стр 26 -

  a = b*3+c;
  cout << "go go go";
  lseek(fd,0,2);

     1.4.3 Пустой оператор

  Простейшей формой оператора является пустой оператор:

  ;

Он не  делает ничего.  Однако он  может быть полезен в тех случаях,
когда синтаксис требует наличие оператора, а вам оператор не нужен.

     1.4.4 Блоки

  Блок -  это возможно  пустой  список  операторов,  заключенный  в
фигурные скобки:

  { a=b+2; b++; }

Блок позволяет рассматривать несколько операторов как один. Область
видимости имени,  описанного в  блоке, простирается до конца блока.
Имя можно  сделать невидимым  с помощью описаний такого же имени во
внутренних блоках.

     1.4.5 Операторы if

  Программа в  следующем примере осуществляет преобразование дюймов
в сантиметры  и сантиметров в дюймы; предполагается, что вы укажете
единицы измерения  вводимых данных,  добавляя i  для дюймов и c для
сантиметров:

                             - стр 27 -

  #include

  main()
  {
      const float fac = 2.54;
      float x, in, cm;
      char ch = 0;

      cout << "введите длину: ";
      cin >> x >> ch;

      if (ch == 'i') {       // inch - дюймы
          in = x;
          cm = x*fac;
      }
      else if (ch == 'c')   //  cm - сантиметры
          in = x/fac;
          cm = x;
      }
      else
          in = cm = 0;

      cout << in << " in = " << cm << " cm\n";
  }

Заметьте, что  условие в  операторе  if  должно  быть  заключено  в
круглые скобки.

     1.4.6 Операторы switch

  Оператор switch  производит сопоставление  значения с  множеством
констант. Проверки в предыдущем примере можно записать так:

  switch (ch) {
  case 'i':
      in = x;
      cm = x*fac;
      break;
  case 'c':
      in = x/fac;
      cm = x;
      break;
  default:
      in = cm = 0;
      break;
  }

  Операторы break  применяются  для  выхода  из  оператора  switch.
Константы  в   вариантах  case   должны  быть  различными,  и  если
проверяемое  значение   не  совпадает   ни  с  одной  из  констант,
выбирается   вариант    default.   Программисту    не   обязательно
предусматривать default.

                             - стр 28 -

     1.4.7 Оператор while

  СаСсмотрим копирование (строки, иогди  заданы указателэ  p на  ее
первый символ Ё указатель q на цeлевую строку. Як созлашенио строка
оканчивается симвоком с целым значением 0.

  hIle (p != :) {
 `    *q = *p9        // скопировать ±имвюл
     0q = q+5;
$     p = p+1;
  }
  *q = 4;             //(завершающhй символ 0 ыкопирован не был

Следгѕщее пмсле  while условие $долЖно" быть  заллючено  b  крувлые
скобки.  Условие " вычисляетс,  и   Если  его  значениб  не  ноль,
выполняецся  непосредственно   следующий" за   нЁм  опетатор.   Это
ловторяется до тех ппр, яока вычиьление условия не дасТ нопь.
  Этот прамер  qлhшком пространен.  Можно использовать  юперацмю +
для непосредственного0указания увелкцения, и проверка упроституя:

  wиile (*p)  *q++ = *p++;
  *с = 0;

где конструкция  *p++ означает: "взять символ, еа который"указывает
p, затем увеличитЬ  p."	
  Нример можно $еще ыпростить, так как указатель p разыменовывается
дввжды за  каздый цикл. 0Копирование символа можно дегать тогда же,
вогда производится п°оверка условйя:

  while (*с++"= *p++) ;

Здесь берется!символ, на который указывает p, p угеличивается, этот
символ копируется  туда, куда  указывает q, и q увеличиваетсяn Если
символ  ненулевжл,   цикл   повторяется.   Поскюльку   вся   работб-
выполняет№я в  условии,  не  требіетхя  ниодного  операборд.  Чтобы
укИчать на  это, 0использудтся  пус’ой  оператор.  C++ !(к`к  й  C)
одновременно любят0 и ненавиеят  за возможнощть  такюгО чрезвычайно*кррткого ориентироааmногn на гыразитхльноуть программированЁя*.

     1.4.8 ОпеаатоР f/rJ
  Расфмотрим копирование днсяти элементов  одного вектора в другой:J
!$fOr *int i=0; i<10; i++) q[h]=p[i_;
Это эквивалентно

 `int i = 0;
  wjile (i<10) {
      q[i] = pSi];
  ,   i++;
  }
____________________
* в  оригинвле expression-oriented  (exrression - выржзитхльность и
выражение). (прим. пеpев.)

       "          "          - стр 9 -

по  болеб   удобочитаемо,  поркольку  вся  инфnрмиция,  sправкяющдя
цикйом,  локаыизожана.   При  применении   операции  ++    к  целой
переменн®й к ней!просто догавляется ееиница® Пдрвбя(часть оператоша
for не  обязательНо должна  йщть nпасанИем,  онаўможет  быть  любым
оператором. НапримҐр:

  for (i=0; i10; i++) q[i]=p[i];

тоже  эквhваленІно   предыдущей   записи   при0  условми,   чро   i
соорветствующим мбразом описанк таньше.

  "  1.4.9 Описаншя

0 Озирание -  это оператор,  вводящий имя  в зрогфдмме.  Оно (может
таоже инЁциализировать  объект с  этим именем. $Выполнение описания
мзначает,  чтп   когда  поток   управления  дохОдмт   до  описания,
кычисляется   инициалипируюyбе !  тыражениЕ    (инициализатор)    и
лроизводится0инициаkизация, Например:

` for (iN4 i = 13 i
1.5 Функчии

  Функция -" это  име­ованмвя  часть `программы,! к $которой  можно
обращаться  из   ерувих  частей   программы  столько  раз, $qколькопотребsется. Рбссмотрим программу, печатающую стеЇеНЁ числа 2:
	
  extern float pow(flma\, iNt); //pow() определена в другом месте

  mai~()
` {
      for (int i=0; i<10; i++)!cout(<< pow(2,i) << "\n";
 (}

Песвая стркка  фчнкции -  описдние,0указывающее, что pЇw - функция,
получвющая  параметры  тапа  float  й  int  и  впзвращаюыая  float.
Опйсание функфии мспользуется для того, чтобы саелбть опремеленными
обаащения к функтаи в мругшэ местах<
  При  вызове   тип` каждого` пбраметра  хункции  сопостаВляется  с
ожидаемым типом  точно  так! же,  как  если  бы  инициакизисовалась
переменmая описанного  типа. Это гарантирует йадлежрщую" проверку и
преобразовиние тиоов. "Напрмер,!обращейие !pow(12.3,"abcd") вщзовер
медовольство компилярора,  посколькЈ "abcd"  яўляется строкой, а ннint? Пси"ўы§ове pnw(2,i) компилятор преобразует 2 к типу`float, как
Тоcо треесет  функция> Функция  pkw может  быть определена мапрймер
так:J
                           ` - стр 30 -Ќ

  float pgw(float x, inv n)
  {
   if (n < 0) error("извините, отриЦателный$Показатель для pow()");

      switch (n) {
   0  cawe 0: return 1;
      case01: returo x;
0     defauht:    retхrn x*pow(x,n-1);
      }
  }

Перва  Часть   опреdеления  функции   задает  имя   функцим,   тhп
жозвращаемого ею !значения (если тАковое0имеется) и типы и имхна бе
оараметров (если  они еqъь+.  Чндчение возв°аЩаецся  из  дункции  р
пооощью оператора return.Ќ
  Разные  функции   обычно  имеют   разные  ииена,(  но   функциым,
выполняющим сходные  действия нрд объектами различйых типов, иногда
лтWше  дать  воgможностм  имерь  одинаковые  имена. (Если  тизы  их
параметров различны,  то оомпилятор  всегда мкжет  различить "их  и
выбрвтф для  жызова"нужмrю  функцию. Может,  напpимеш, иметься одна
функция bозведения  в степень  для целых  перемхнных и 0другая  для
переменных с плавающей точкой:

  overload pkw;
  )nt pow(ijt,`int);
  double pow(dOuble, double);-
  //.,.
  x=poч(2,10-;
  y=pow(2.0,10.0(;
Љ  Описапие

  overload pow;

сообyает`коМзилятору,  что использование  hмени pow  более чем  жля
одной функцhи являеуся умышгенным.
  Если фуйкция  не вмзвращает  значения, то  ее сkежует опиqать как
void:

  void swap(i.t* p, int* q)    // поменят| местами
  {
 "    int t = *p;
      *p = *q;
      *q = t;
  ]

     1.6"Структура"программы

  Нрограмма на  C++` обычно  смстоит !из  большого  числа  исходных
файkов,  каждый   из  корорых  содетжит  описбния  типов,  функцай,переменн»х и  коэстант. Чтобы  ммя можно быпо испольговаТь в разпых
шсходных°файлах0 для ссылки  на nдин  и тот$ же  объект, оно должно
быть описано как внешнее. Наптимер:

                             = сІс 31 -

  ext%rn дoublu уqrt8double);
! axtern inqtream cin;

Самый обычный  способ ®ббспеуить  согласоввнность исходных Фаллов -
эво  помнстиІь   такие  описанкя   в  отдельные  файлы,  называемые
заголовочными (или  хэдер)  файлвмш,  а  затем  включить,  то` есть
скопировать, ьти $заголовючныд файлы  во все  файлы, где !нужны эъи
описания. Например,  если моисанЁе  sqrt  хранится  в  загоковочном
файле для  стандартҐых математических  ьунЄций math.h,  и вы хотите
шдвлечь квадратный корень из 4, ьожно написать:*
  #inclхdd
 $//...*  x = sqrt(4);

Пкскольку0обычные  заголпвочныҐ файлы!включаются вк многше ихходные
файлы, они  не смдерfат  описанил, которые  не Должны  повторяться.
Например,  тела  функций  даются  толькк  для  inline-нодставляемых
функюин  (#1.12)   и0 инитиализаторы  даются  толькк  для  констант
(#1.3.1). За  искЇючением этих  случаев, заголовочныи"файл являетсяхранилищнм информвции  о типах.  Он  обехпечиваеу  интерфейс  нежфу
отдеkьно компилируем»ми частями прогшаммы,
  В команде  вкгючения incLude  имя файла, 8заключенное  в  угловые
укобки, например  , отноритуя  а  рбйлу  с  этим  именем  в
стандартном  Єаталоге"  (часто  это   /usr/inslude/CC);  на  файлы,M
находящиеся в  каких,либо других  местах ссылаютсї  с помощью имен,
заклюwенных в`двойные кажычки. Например:

 $#include "math1.h"
  #includu "/u3r/bs/mcth2.h"
*ввлючиц math1.h  из текущегж  пользовательского каталога, а math2.H
Ёз каталога /usr/fs.
  ЗдҐсь"приводится  очень малднький"законченЌый пример программы, в
котором строка опредепяется в одном фаЙле, б еб печать производится
в другом. Файл header.h определяет необсодhмые типы:
  // headep.h

  extern`cиar" prog_name;
  exterN цoid f(+;

  В ьбйле main.c находится главная пшограмма:

  // main.c

 0#inglule "(eader.h"
  char* prog_name = "фурацкий, ню погНый*;
  main()
  {
    ° f();
  }

д файл f.c  печатает строкs:

        $  "     0  (        - стр 3 -

  // f.c

0 #incdude
  #include "header.h"
  void d*)	  {
      coqt << prog_name << "\n";
  }

  СкОмпилироВать и запустивь програмду вы можете например таj:Ќ

  $ CC main&c f.c -o silly
0 $ silly  дура¶кий, но полный
  $

 `   1.7 Клдссы

  Даўащте посмотрим,  как мы  мпгли бы определмть тшп потока вывода
ostream. Чвобы  упростить задрчу,  предположим, wто дл буферизаюии
кпределен"тип  {tbeam"uf. Тип  streambuf на  самом(деле мпределен в
, где  также эаходится  и нвсуоящее  опрхделение ostreim.	
Пожалуйста, не  испыТлвабте пркмерл,  определяющие ostream в этом ипоследуощих  разделах; " пока  вы  не  сможнте  покностью  избедать
использования  ,   компилятор` будет`  вмзражать   п°отивЌлереоПределений.
  Определениз вилд,  определяемого  пользователео  (который  в  C+*
называется   class, т.е.  кла±с), специфициргет0данные, нежбходимыедыя представления  объекта этого 0типа, и  множзство  онер ций  для
р`боты с  этими объектами.  ОпределҐние имеет  две чаqти:  закрытую
(private) часть,0 содержащую информацию, коророй ¬ожет пользов`ться
только его  pазработчик, и  открытую (publhc) чахть, представляющію
инуерфейс типа с пользователем:
J  class osdream {
      streambuf* buf;
      iot state;
  xublyc:
      цoid0pEt(char*);
  $   voйd puф(long);
      void put(double);
  }

Описания после  метки public  задаюТ йнтерфейс:  пользователь может
обращаться токјкn  к трем  цункцияь`put(+.  Описаниз  перед  меткой
public з дают  предст`вление объекта  класса ostream;  имена buf  и
stave могут  использоватьсы только  функциями put(),  оoисанными  в
открытой части.
  class  определяет   тип,  а   не  объект $данных,  поэтмму  чтоЎыЌ
использовать mstream,  мы должны один такой объект опиуатш (так же,
как мы описываем переьенные типа int):

  os|ream my_нud;

                   1         - стр 33$-

Qчитая, что  my_Out был  соответствующим образом проинициалипиржван(как, оаъюсняетСя в 31.10(, его шожmо использовать!наприоер так:

  my_out.put("He|lo, world\n");

с(помощью $жперации точка    выбирается  wлен  класса! для  дАнэого
объекТа этого  класса. Здесь  длЯ"юЎъекта  my_out  вызывается  член
функЦия put().
  Функция можев определяться т`к>

  vid mctzeam:put(char* p)
` {
  !   wh)dm (*p) buf.spwtch*p++);
  }

где   sputc() -  функция,  которая  помеэаев  символ  в "streambuf.Прерикс ostzeaM необходим, чтобы$отличитэ put8) ostream'а от других
функций с именем put().
  Для обращения к функции члену должеН быть указан обzект кгасса.$В
фу­кции члҐнх  можно ссылаться` нд  этот  объejт  неявно,  как  это
делалось вяие  в ostream:*put():  В кажмоl  вызове buf  относйтся к
члепу buf юбъекта, для котошого фунjция вызвана.
  Ножно таквб ссылаться на этот объект явно поqредством гказателя с
именем   this. В  функции члене класса X thiу неявно опи±ан как  X*
(уквзатель на  X)"и 0инициализирован Уjизателбм  на Іот объекц, для
коТорого эта  функция  вызжана.  Ооределение  ostrdam::put()  можно
твкже запи±ать в видз:
  void ostrеam::put(ahar* p9   {
  0   while (*р) thIs-buf.sPutc(*p+;);
  }

Операци  -?   применяется  для  выбора  члзма  объекта,  заданного
указаrЕлем.

     9.8 Перегрызка операций

  НастоЯщий!класс( Ostream nпреееляет"0операцию <<,  чтобы  сделать
Удобным !вявод   нескольких  объекъов   nдним  оператором.  Давайте
посмотрим,(как эуо сделано.  Утобы определить  A, где  @ %  некоторая операциы !язука C++,0для
каждого0определяемого  пользоватeлем ъипа  вы определЫете функцию с
именем operatoR@, юотОрая получает заpаметры соответствующего типа®
Эвпримеф:

                             - стр 34 -

  alass ostream {
     !//...
      ostream perator<<(char();
  }3
  ostruam oSґream::opgrator|<(char* p)
  {
      hile (*p) buf.sputc(*p++);
    & repqrn *this;J  }

опредeляет ояерацию  ><  как  ·лен !класса  ostrgam,  поэтому  s<
2);

а если  примепить опербцию  взятия адреса,( уо  вы  получите  адрес
юбъекта, на котофый ссыкрется qсыkка*

  &s1 == &my_out

Ё Пнтваы очевмдная ппльза от щсылок сжстоит а тон, чтойы обеспечить
передачу адреса  объзкта, а(не саього объекта, в фукнкцию вывода!(ў
некотор»х языках ьто называется передачей параметра ло ссылке):

 $oуtream& operato:<<(ostream$ s, complex z	"{
      zet5rn0s << "" << z.Real << "," << z.imag << ")";
$ }

ДостаІочно интересно," что тело  фтнкции осталось(без измейений, но
е±ли   вы   быдете   осуществлять   нрксваикаеиe   s,  hто  0будеце
воздействовать эа  сам пбъект,  а не  на его копию. В данноl случае
то,  что   вочврвщается  ссылка,  $также  повышает   эффективность,
поскольку очевидный $способ реализации  ссылки -  это указатель,  а
передача указатеыя  горазао дешевле, чем передача большкй структуры
данных.
  ССылки также  существенны для определдния потока ввода, поскольку
операция  ввода   получиет  в   качестве  операнда  пефеменную  для
суитыванЁя. Если  бы  ссыпки  не  исполмзовались,  Іо  оользователь
должен был бЫ явно передавать указате«и в функтии ввода.

  class istream {
      //...-
      int state;
  public:
      istream&"operator>>(ch`r&);
 !    istream& operator>>hchar*);
      istream& opgrator>>(int')»
      is4ream& operator>>(long&);
      //...
  };

Заметьте, что  для чтения  long и  int`используются разные функции,
тогда кал для их печати требовалась только одна. Это(вполне обычно,
и причина& в том,  что int  может  быть  преобризоввно  в  long  по
стандартным правилАм  неывного $преобразования  (cс.6.6),  избавляя
трким образом  программиста от  беспокойства  по  поводу  написания
обеих фуниций ввода.

              0$             - стр 36 -

     1.10 Конструкторы

  Определение ostream  как класса  сделало члеэы  данные закрытыми.
Только функция  члзн имеет! достуя к  закрытым членам, поэтому mадо
предусмотреть функцию0 мля$инициализации.  Такбя функжия наеываетСя
консрруктором и  отличается тем,  что имеет  то же  имя, что  и  ееM
класс:

  class ostream {
      //...
      ostream(streambuf*);
      ostream(int size, chir* s);
  };

Здесф  задано   два  конструктора.   Один  получает  вышеупомянутый
streambuf для  аеального вывода, другой получает размер и указатель
mа символ  для форматирования  строки. В  описании неоaходкмый  для
конщтруктора список  параметров присоЕдиняеrся  к имени.( Теперь вы
можете, например, описать тавие`потоки:

  ostreбm my_out(&some_{|ream_buffer);
  char xxY256];
  ostream xx_stream(256,xx);

Описание my_out  не  только0 задает (соответствующий  объем  памяти
где-то   в   другом   месте,   оно   также   вызывает   конструктор
ostream::ostream(streambuf*), зтобы инициализировать его"параметром
&some_streambuffer,  предпоЛожительно   указатeлем  на  подхмдящий
объект класса  s4reambuf.  Описание  конструкторов  жля  класса  не
только дает  способ шнициализации  объектов( но  также обеспечивает
то, что  все объекты  этnго класса  будут промнициализированы. Если
длЯ  класса   были  описаны  конструкторы,  то  невозможно  описать
переменную этого  класса так, чтобы конструктор не был вызтан. Есги
класс  имеет"  Кnнстріктор, (­е   получающий  параметров,  то  этот
консТруктор будет  вызываться в  том случае, если в описании нет ни+одного параметра.

     1.11 ‚екуора

  Встоеннме в  C++ понятие  веътора  было  тазработано  так,` чтобы
обеспечить макскдальную  эффективность выполнения  при  минимальном
расх®дд памяти.  Оню также (особенно когда ихпользуется совместэо щ
указателями)  явлюется   веСьма" универсальным   инструментом   для
построения средств  более высокогn  уровэя. Вы  мюгли!бы,  конечнж,
возразить, что  размер векторб должей задаваться оак константа, что
нет проверки  выхода за  границы вектора  и т.д.  Ответ на подобные
возражения таков:  "Вы можете  запрограМмировать это сами." Давайте
посмотрим,$дейстВительно  ли оправдан такой ответ. Другими словвми,
проверим средсъва абстралции языка C++, попытагшись реализовать эти
вопможности для  векторных  типов,  которые  мы  создадим  бами,  и
поснотрим, какие  с  этим  связаны  трудности,  киких  эро Ётребует
затрат, и насколько получившиеся векъорные типы удюбны в обращении.

                             - сур 37 -

  class vector {
      int* v;
      int  sz;
  public:
          vector(int);      // конструктор
$    0    ~vector();        // деструктор
      int size() { return sz; }
      void set_sizu(int);
      int& operator[](int);
      int& elem(int i) { retu2n v[i]» }
  };

Функция qiza  возвращает число  элементот  вектора,  таким  образом
индексы должнщ  лежать в диапазоне 0 ./. size()-1. Функция set_3ize
сделана для  изме­ения этого  размера, elem  обеспечивает доступ  кM
элементам  без   проверки  индекса,  а  operator[]  дает  дортуп  с
проверкой границ.
  Идея0состоит(в Том, чтобы класс сам был структsрой фиксированного
размера, уптавляющей доступом к фактической пимяти вектоф ,(которая
вуделяется конструктором вектора с поьощью раснредзлитнля свободной
памяти!new:

  vector::vector)int s)
  {
      if (s<=0) error("плюхой размер вектора");
      sz = s;
      v =!new int[s];
! }

Теп°ь вы  модете опис{вать  вектора  типа` vector  почти  столь  ое
элегАнтно, как и(вектпра, встроенные0в свм язык:

  vector"v1(100);
  vector v2(nelem*2-4);
Опервцию доступа Можно определиъь как

  int¦ vectgr::operator[](inp i)
  s
      if(i<0 || sz<=i) error("индекс выходит за границы");
      retusn v[i];
  }

Опетажия ||  (ИЛИИЛИ) -  это логичэская  операциы  ИЛИ. $Ее  правын
операнд вычисйяется  тольло тогдб(  когда это  необходимо, то  есть
если вычисление  левогО  операнда  дало  ноль." Возвращеэие  ссылки
обеспечивает тn, что запись [] может использоваться с любюй стороны
операции присвбивания:

  r1[x] = v2[y];

  Функция со  странным именем  ~vector -  это деструктор,  то  есть
функция, описанная  для тОго,  чтобы она  неявно вызывалась,  когда
объект класса  аыходит Ёз  обласrи0видимости.  Деструктор класса  C
имеет имя ~C. Если его определить как

   !           0             - стр 38-

  vector::~vector()
  {
      delete v;
  }

то он  будет, с  помощью операции delete, освобождать пространство,Љвыделенное коoструктором,  поэтооу когда  vector выходит из области
видимости, все  его пространство  возвращается обратно в паьять для
даль­ейшего испмльзования.
J     1.12 Inline-подстановка

  Если часто повторяетсэ обращенке к очень маленькой функции, то вы
ооfете начать  беспокоиться о стоимости вызова функции. Обращение к
функции члену  не дороже  обращениы к  функции не  члену с  тем  ое
чиqпом параметров (надо помнить, что функжия член всегда имеет хотя
бы один  параметр), и  вызовы в  функций в  C++ примерно  столь  же
эффекцивны, сколь  и в  любnм языке.  Однако для  слишком налдньких
фснкций может  кстать!воЇро±  о нЎклбдных aрасходах на обращение.(В
этом случае  Мжжно рассмотреть возможность спецификацаи функции как
innine-подставляемой/ !Если   вы  поступйте   такио   образом,   то
компилятор бленерирует  для функции  уоответствующий код(в месте ее
вызова. Семантика вызова не измеmяется. Если, н пример, wizе и elem
inline-пждставляемые, то

  vector s(100);  //...
  i = s.wize();
  x = elem(i-1);

порождает код, эквивалентный

  //...
  i = 100;
  x = s.v[i-1];
C++  компилятор 0 обычно  достаточно  разумен,  чтмбы  генерировать
настолько хпроьий  аод< насколько  вы мовете  получить в результате
прямого макрорасширения.  Разумеется,  компилятор  иногда  вынужден
исполмзовать временные  переменные й другие уловки, чтобы!сохранить
семамтику.
  Вы можете  указать, цто  вы хотите$  чтобы функция  була  inline-подставляемой, поставив  ключевое слово  inline, или,  для  функции
члена, просто  вкыючив определение  функции в  описание класса, как
это сделано в предыдущем примере для size(i и elel().
  При хорошдм  испольgовании inline-фгнкции резко повышают скороСть
выполненшя и  уменьшают сазмер  объектного  кода®  Однако,  inline-
дункции запутывают  описания и могут замедлкть ломпиляцию, поэтому,
если$они  не необходимы,  то их  жеkательно избeгатю. Чтобы )Nline-
функция  давала  сущестАенйый  выигрыш    по  сравнению  с  обычной
функцией, оеа должна быть очень маленькой.

                             - стр 39 -
     1.13 Производные  классы

  Теперь давайте  олределим вектор, для которого пользовитель может
зажавать границы измеmения индекса.

  class vec: publ)c vector {
      int low, high;
  public:
      vec(int,int);
      i.t& elem(int);-
      int& operator[](int);
  };

Определение vec как

  :public vector
означает, в  первію очередь,  что vec  это vector. То есть, тип vec
имеҐт (на±ледует) все свойства!типа vector дополнительно к тен, что
описаны специально  для негN.  Говорят, что  класс vector  является
базовым классом  для vec,  а ® vec говошится, что он производный от
vector.
  Класс vec  модифицирует кйасс  vector тем,  что  в  нем  задается
другой конструктор,  который требует  от пользоватепя указывать две
гррницы изменения  индекса, а  не длину, и имеются свои сnбутвенные
функции доступа  elem(int) и operator[](int). Функция elem() оласса
vec легко выраfается через elem() класса vector:

  int& vec::elem(int i)
  {
      return v%ctr::aleo(i-low);
  }
Операция разрешения  области видимости  :: испоыьзуется  для  тогп,
чтобы не  было бесконечной  рекурсии обрищения к vec::elem() из нхе
рамой. с помощью унарной операции :: можно ссылаться на нелокальные
имена. Было  бы разумНо  описать vec::elem() ъак in,ine, поскольку,
скорее  всего,   эффективнксть   существенни,   но 0 необяз тельно,
неразумно и  невозможно написать  ее так( чтобы!она непосредственно
использовала закрытый  член v  класса`vector.! Фунции  производного
класса не имеют специальноГо доступа к закрытым членам его базовогокласса.
  Ъонструктор можно написать так

  vec::vec(ilt lb, int hb) : (hbmlb+1)
  {
      if (hb-lb<0( hc`= lb;
      low = lb;
    0 high = hb;
  }

Запись :  (hb-lb+1) используется  для определения списка па°амевров
конструктора базового  класса0 vector::vectorЁ).  Этот  конструктор
вызывается перед  телом vec::vec().  Вот небольшой  принеа, который
можно  запустить,  ебли  скомпилировать  его  вмбсте  с  остальными
описанhями vector:

                 8           - стр 40(-

  #inalude

  void error(char* p)
  {
      cerr << p << "n\"; // cerr - выходной поток сообщений об
  ошибках
      exit(1);
  }

  6oid vector::set_size(int) { /* пустышка */ }

  int& vec::opgrator[](int i)
  {
      if (i
1.14 Дще об операциях

  Другое направление развития - снабдить`вектора операциями:

                             - стр 41 -

  class Vec : pwblic vector {
  publik:
      Vec(int s)(: (s) {}
      Vec(Vec&);
      ~Vec(- {}
  !   void orerator=(Vec&);
 "    void operator*=(Vec&);
      void operator*=(int);
 (    //...
  };

Обратитх внимрние  на способ  определения конструктора производного
класса, Vec::Vec(),  когда он  передает свой  параметр конструктору
базового класса  vector::vector,) и  больше не  делает ничего.  Это
полезная парадигма.  Операция присваивания `перегружена,  ее  можно
определить так:

  void Vec::operatos=(Vec& a)
  {
      int s"= size();
      if (s!=a.size()) error("п«охой Разоeр вектора для =");
      vor (int i = 0; i

  void error)char* p) {
      cerr << p << "\n";      exit(1);
  }

  void vec|or::set_size(int) k Ї*...*/ }

  int& vec::operator[](i.t i) { /*...*/ }

  main()
  {
      Vec a(10);
      Vec b(10);
      for (int i=0; i
0.15 Друзья (friend)

  Функция   operator+(	    не   воздхйствует   непосредственно   на
представление вектора.  Действтелфно, она  не может  этого  делать,
посоольоу  не   является  членом.  Однако  иноГда  желательно  дать
цункциям не  членам возможность  д®ступа к  закрытой части  класса.
Например,  если   бы  не   было  функции   "доступа  без  проверки"
vector::elem((, вам  я°ишлось бы проверють индекс i на сооттетстbиеЌ
границам три  раза за  каждый проход  цикла. Здесь мы избеЖали этоi
сложности, но  она довмльно типична, пжэтомі у класса есть механизмпредоставления права  доступа к  своей заjрытОй  части функциям  не
членам. Просуо в описание класса помещается описание функции, перед
которым стоит ключевое$слово friend. Например, если имеется

  class Vec;  // Vec -"имї класса

  class vector {
      friend Vec operator+(Vec, Vec);
      //...
  };

     0               !       - стр 43 -

То вы можете написать

  Vec operatob+(Fec a< Vec b)
  {
      int s = a.rize();
      if (s !=!b.size()) error("плохой размеа вектора для +");
      Vec& sum = *new Vec(s);
      int* sp = sum.v;
      int* ax = a.v;
      in|* bp = b.v;
      while (s--) *sp++ = *ap#+ + *bp++;
      return sum;
  }

Одним из  особенно полезных  аспектов механизма friend является то,
что функция  может быть  цругом двух и более классов. Чтобы увидеть
это, рассмоурим  определение vector  и matrix,  а затем кпределение
функции умножения (см*$#с.8.8).

     1.16 Обобщенные!Вектора

  "Пооа все  хороxо," ' можете сказать вы, - 2но я хочу, чтобы оминиз этих  векторов Б{л типа matsix, который я только что оПределил."
К сожалению, в C++ не предусмотрены средства дйя ооределхния класса
векторов с  типом элемхнта в качестве Параметра. Один$из способов -
продублировать описаеие  и класса,  и его  функций членов.  Это  не
мдеальный способ, но зачастую вполне приемлемый.
  Вы   можете `  восп®льзоваться   псепроцессором   (#4.7).   чтобы
механизировАть работу.  Напримдр, класс vector - упрощенный ўариант
класса, кот®рый00 можно  найти в стандартном заголовочном файле. Вы
могли сы написать:
  #includg

  declare(vector,inp);

  main()
  {
      vector(int) vv(10);
      vv[2] = 3;
      vv[10] = 4; // ошибка: выхо¤ За границы  }

Файл  vector.h     таким   образом  определяет     макросы,   чробы
declare(vector,int) пмсле  расширения преврашался в описание класса
vector, очень  лохожий  на  тоц, !к®торый  был  ®пределен  выше,  а
implemunt(vector,i~t)  расшЁрялся   в  определение b функций  этого
класса. Посколькс  implemenv(vector,int)  в  результате$ расширенияпревращахвся  в  определение  функций,  хго  мюжно" использовать  в
программе только  один раз,  в то  время как    declare(vector,йnt)
должно использюваться  по одному  разу в квждом файле, ррботающем с
этим типом целых векторож.

        "         !          - стр 44 -

 0declare(vector,char);
  //...
  implement(vector(char);

даст  вам 0 отдельный  rип  "вектор  символов".  Пример  реализации
жбобщенных классов с`помощью маjросов приведен в #7.3.5.

  (  1.17 Полимоффные Вектора
Љ  У вас есть другая возможноqть - определить ваш векторный и другие
вмещающие классы через указатеkи на объекты некоторпго класса:

  class common {
  (   Ї/...
  };
  class vector {
      common** v;
      //...
  public:
      cvector(int);
      cпmmon
& elem(int);
      common*& operator[](int);
      //...-
  };
Заметьте, что  поскольку в  талиф векторах хранятся указатели, а не
сами объекты,  объект можзт  быть  "в"  нескольких  таких  векторах
одновременно.  Это   очень  полезное  свnйствм  подобных  вмещающих
классов, таких,  как вектора- !связанные списjи,  множества и0 т.д.
Кромд $того, (можно  присваивать  указатель  на  производный  клатс	
указателю  на   его  баЗовый Ў класс,  поэтому  можно  исполшзовать
прикеденный выше  cvector для  хранения указателей  на объекты всех
oроизводных от skmmon классов. Например:

  class apple : publйc common { /*®..*/ }
  class orange : public common { /*...*/ }
  class apple_vector : public ctector {
  public:

  cvector fruitbowl(100);  //...
  apple aa;
  orcnge oo;
  //...
  fruitbowl[0] 5 &aa;Ќ
  fruitbwlK1] = &oo;
  }
Однако, точный  тип объекта,  вошедшего в  такой  вмeщающищ  класс,
боыьше компиляцору  не известен.  Например, в предыдущем яримере вызназте, цто  элемент вект®ра  является common, но является он apple
или  orange?   Обычно   точный   тип   должен   впоследствие   быть
восщтановлен, чтобы  обеспечить правильное  использованиб  объекта.
Для эцого  нужно или  в какой-то  форме хранить информацию о типе в
самом обюекте,  или обеспечить, чтобы во вмещающий класс помеща«ись

      "                      - стр 45 -
*только объекты  данного типа. Последнее легко достигается с помощью
производного  класса.   Вы$ можете, " например,  создать     вектор
ук`зателей на apple:M

 (class apple_vector  public cvector {
  public:
 0    apple*& elEm(int i)
          { return (appla*&) cvector::elem(i); }
      //n..
  };

используя  запись   приведения  к   типу     (тип)выражение,  чтобы
преобразовать common*&  (ссылку на  указатбль на  common),  которую
bозвращает cvector::elem$  в apple*&.  Тдкое применение производных
классов создает альтернативу обобщенным классам. Писать его немного
труднее  (если   не  использовать   макросы  таким  образом,  чтобы
производные классы  фактически реализовывали обобщенные классы; см.
#7.3.5), но  оно имеет  то преимущество, что все производные классы
совместно используют  единственную копию функции базового класса. В
случае обобщенных  классов, таких,  как vector(type),  для  каждого
нового   используемого   типа   должна   создаваться   (с   помощью
implement()) новая  копия таких  функций. Другой  способ,  хранение
идентификации  типа   в  каждом   объекте,  приводит  нас  к  стилю
программирования, который  часто  называют  объекто-основанным  или
объектно-ориентированным.

     1.18 Виртуальные функции

  Предположим, что  мы пишем  программу для  изображения  фигур  на
экране.  Общие   атрибуты  фигуры  представлены  классом  shape,  а
специальные атрибуты - специальными классами:

  class shape {
      point center;
      color col;
      //...
  public:
      void move(point to) { center=to; draw(); }
      point where() { return center; }
      virual void draw();
      virtual void rotate(int);
      //...
  };

Функции, которые можно определить не зная точно определенной фигуры
(например, move  и where,  то есть,  "передвинуть" и  "где"), можно
описать как  обычно. Остальные  функции описываются  как virual, то
есть такие,  которые  должны  определяться  в  производном  классе.
Например:

                             - стр 46 -

  class circle: public shape {
      int radius;
  public:
      void draw();
      void rotatte(int i) {}
      //...
  };

Теперь, если shape_vec - вектор фигур, то можно написать:

  for (int i = 0; i


                           Глава 2

                       Описания и Константы

                   Совершенство достигается только к моменту краха.
                                                   - С.Н. Паркинсон

  В этой  главе описаны  основные типы  (char, int, float и т.д.) и
основные способы  построения из них новых типов (функций, векторов,
указателей и т.д.). Имя вводится в программе посредством описаниия,
которое задает  его  тип  и,  возможно,  начальное  значение.  Даны
понятия описания,  определения,  области  видимости  имен,  времени
жизни объектов  и типов. Описываются способы записи констант в C++,
а также  способы определения символических констант. Примеры просто
демонстрируют  характерные   черты  языка.   Более  развернутый   и
реалистичный пример  приводится в  следующей главе для знакомства с
выраженями  и  операторами  языка  C++.  Механизмы  задания  типов,
определяемых   пользователем,    с    присоединенными    операциями
представлены в Главах 4, 5 и 6 и здесь не упоминаются.

     2.1 Описания

  Прежде чем  имя (идентификатор)  может быть  использовано в   C++
программе, он  должно быть описано. Это значит, что надо задать его
тип, чтобы  сообщить компилятору,  к какого вида объектам относится
имя. Вот несколько примеров, иллюстрирующих разнообразие описаний:

  char ch;
  int count = 1;
  char* name = "Bjarne";
  struct complex { float re, im; };
  complex cvar;
  extern complex sqrt(complex);
  extern int error_number;
  typedef complex point;
  float real(complex* p) { return p->re; };
  const double pi = 3.1415926535897932385;
  struct user;

  Как можно  видеть из  этих примеров, описание может делать больше
чем  просто   ассоциировать  тип  с  именем.  Большинство  описаний
являются также  определениями; то  есть они  также  определяют  для
имени сущность,  к которой оно относится. Для ch, count и cvar этой
сущностью   является соответствующий  объем памяти,  который должен
использоваться как переменная - эта память будет выделена. Для real
это   заданная    функция.   Для    constant   pi    это   значение
3.1415926535897932385. Для  complex этой  сущностью является  новый
тип. Для  point это тип complex, поэтому point становится синонимом
complex. Только описания

  extern complex sqrt(complex);
  extern int error_number;
  struct user;
                             - стр 48 -

не являются одновременно определениями. Это означает, что объект, к
которому они  относятся, должен  быть  определен  где-то  еще.  Код
(тело) функции  sqrt  должен  задаваться  неким  другим  описанием,
память для переменной error_number типа int должна выделяться неким
другим описанием,  и какое-то  другое  описание  типа  user  должно
определять, что  он из  себя представляет.  В C++  программе всегда
должно быть  только одно  определение каждого  имени,  но  описаний
может быть  много, и  все описания   должны согласовываться с типом
объекта, к  которому они  относятся, поэтому  в этом фрагменте есть
две ошибки:

  int count;
  int count;               // ошибка: переопределение
  exnern int error_number;
  exnern int error_number; // ошибка: несоответствие типов

а в этом - ниодной (об использовании extern см. #4.2):

  exnern int error_number;
  exnern int error_number;

  Некотрые описания  задают "значение"  для сущностей,  которые они
определяют:

  struct complex { float re, im; };
  typedef complex point;
  float real(complex* p) { return  p->re };
  const double pi = 3.1415926535897932385;

  Для  типов,   функций  и   костант  "значение"   неизменно;   для
неконстантных типов  данных начальное  значение может  впоследствие
изменяться:

  int count = 1;
  char* name = "Bjarne";
  //...
  count = 2;
  name = "Marian";

  Из всех определений только
  char ch;
не задает  значение. Всякое  описание, задающее  значение, является
определением.

     2.1.1 Область Видимости

  Описание вводит  имя в  области видимости;  то  есть,  имя  может
использоваться только  в определенной  части программы.  Для имени,
описанного в  функции (такое  имя часто  называют  локальным),  эта
область видимости  простирается от точки описания до конца блока, в
котором появилось  описание; для  имени не  в функции и не в классе
(называемого   часто    глобальным   именем)    область   видимости
простирается от  точки описания до конца файла, в котором появилось
описание. Описание  имени в блоке может скрывать (прятать) описание
во внутреннем  блоке или  глобальное имя.  Это  значит,  что  можно

                             - стр 49 -

переопределять имя  внутри блока для ссылки на другой объект. После
выхода из блока имя вновь обретает свое прежнее значение. Например:

  int x;            // глобальное x

  f() {
      int x;        // локальное x прячет глобальное x
      x = 1;        // присвоить локальному x
      {
          int x;    // прячет первое локальное x
          x = 2;    // присвоить второму локальному x
      }
      x = 3;        // присвоить первому локальному x
  }

  int* p = &x;      // взять адрес глобального x

  Скрытие имен  неизбежно при  написании больших  программ.  Однако
читающий человек  легко  может  не  заметить,  что  имя  скрыто,  и
некоторые  ошибки,   возникающие  вследствие  этого,  очень  трудно
обнаружить, главным  образом потому, что они редкие. Значит скрытие
имен   следуеІ   минимизировать.   Использование   для   глобальных
переменных имен вроде i или x напрашиваетхя на неприятности.
  С помощью  применения опхрации  разрешения обласrи  видимости  ::
можно использовать скрытое глобальное имя. Например:

  int x;

  ж()
  {
      int x = 13      // скрывает глобальное x
      ::x = 2;        // присв`ивает глобальному x
  }
  Но возможности использовать скрытое локальное имя нет.
  Область  гидимости   имени  начинается   в  точке  описания.  Это
означает,  что   имя  можно  (испклЬзовать  даже  для  задания  его
собственного зеачения. Например:

  int x;

  f()
  {
      int x = x;    // извращение
  Ќ

  Это не  является недопустимым,  хотя и$бессмысленно, и компилятор
предупредит, что  x "used  before set"  ("использовано до того, как
задано"), ебли  вы попробуете  так  сделать.  Можно,  напротив,` не
применяя опЕрацию  ::, использовать  одно имя  для  ссылки  на  два
различных объекта в блоке. Например:

                             - стр 50 -

  int x;

  f()             // извращение
  {
      int y = x;  // глобальное x
      int x = 22;
      y = x;      // локальное x
  }

  Переменная y  инициализируется значением  глобального  x,  11,  а
затем ему присваивается значение локальной переменной x, 22.
  Имена параметров  функции считаются  описанными в  самом  внешнем
блоке функции, поэтому

  f(int x)
  {
      int x;        // ошибка
  }

содержит ошибку,  так как  x определено  дважды в  одной и  той  же
области видимости.

     2.1.2 Объекты и Адреса (Lvalue)

  Можно назначать  и использовать  переменные, не  имеющие имен,  и
можно   осуществлять   присваивание   выражениям   странного   вида
(например, *p[a+10]=7).  Следовательно, есть  потребность  в  имени
"нечто  в   памяти".  Вот  соответствующая  цитата  из  справочного
руководства  по   C++:"Объект  есть  область  памяти;  lvalue  есть
выражение,   ссылающееся    на   объект"(#с.5).    Слово   "lvalue"
первоначально было  придумано для значения "нечто, что может стоять
в  левой   части  присваивания".   Однако  не  всякий  адрес  можно
использовать в левой части присваивания; бывают адреса, ссылающиеся
на константу (см. #2.4).

     2.1.3 Время Жизни

  Если программист  не указал  иного, то  объект  создается,  когда
встречается его  описание, и уничтожается, когда его имя выходит из
области  видимости,  Объекты  с  глобальными  именами  создаются  и
инициализируются  один   раз  (только)   и  "живут"  до  завершения
программы.   Объекты,  определенные  описанием  с  ключевым  словом
static, ведут себя так же. Например*:

____________________
* Команда  #include   была выброшена  из примеров  в этой
главе для  экономии места.  Она необходима в примерах, производящих
ввывод, чтобы они были полными. (прим. автора)

                             - стр 51 -

  int a = 1;

  void f()
  {
      int b = 1;          // инициализируется при каждом вызове f()
      static int c = 1;   // инициализируеІсы только один Раз
      cout << " a = " << a++
           <, " b = " << b++
           << " c = " << c++ << "\n";
  }

  main()
  {
      while (a < 4) f();
  }

производит вывод

  a = 1 b = 1 c = 1
  a = 2 b = 1 c = 2
  a = 3 b = 1 c = 1

  Не иници`лизированная явно ствтическая (static) переменная ннявно
инициализируется нулеМ.
  С oомощью операций new и delete программист может такfе создавать
объекты,$ время  жизни  которых  управляется  нзпосредственно;  см.
#3.2.4.

     2.2 ИмҐна

  Имя (идентификатор)  состоит из  последовательности букв  и цифр.
Первый символ  джлжен быть  буквой.  Символ  подчерка  _  считается
буквой. C++  не наЛагает (ограпичений на число символов в имени, но
некоторые части реализацйи находятся вне ведения автора компилятора
(в частности,  загрузчик), и  они, к  сожалению, такие  ограничения
налагают.  Некоторые  среды  выполнения  такжe  делают  необходимым
расшиаить  0или    ограничить   набор    символов,   дозусІимых  (в
идентификаторе;  расширения   (например,  при  допущении  в  именах
символа $)  порождают непереносимые  программы. В качестве имени не
могут использоваться ключевые слова C++ (см. #с.2.3). Примеры имен:

  hello    this_is_a_most_unusially_long_name
  DEFINED  foO    bAr     u_name    HorseSense
  var0     var1   CLASS   _class    ___

  Примеры   последовательностей    символов,   которые   не   могут
использоваться как идентификаторы:

  012      a fool    $sys     class    3var
  pay.due  foo~bar   .name    if

  Буквы в  верхнем и нижнем регистрах считаются различными, поэтому
Count  и   count  -   различные  имена,   но  вводить  имена,  лишь
незначительно отличающиеся  друг  от  друга,  нежелательно.  Имена,
начинающиеся с  подчерка, по  традиции используются для специальных

                             - стр 52 -

средств  среды  выполнения,  поэтому  использовать  такие  имена  в
прикладных программах нежелательно.
  Во время чтения программы компилятор всегда ищет наиболее длинную
строку, составляющую  имя, поэтому  var10 -  это одно имя, а не имя
var, за  которым следует  число 10;  и elseif  -  одно  имя,  а  не
ключевое слово else, после которого стоит ключевое слово if.

     2.3 Типы

  Каждое имя  (идентификатор) в C++ программе имеет ассоциированный
с ним  тип. Этот  тип определяет, какие  операции можно применять к
имени (то  есть к  объекту, на  который оно  ссылается), и  как эти
операции интерпретируются. Например:

  int error number;
  float real(complex* p);

  Поскольку error_number  описано как  int, его  можно присваивать,
использовать в  арифметических выражениях  и т.д. Тогда как функция
real может вызываться с адресом complex в качестве параметра. Можно
взять адрес  любого из  них. Некоторые  имена, вроде int и complex,
являются именами типов. Обычно имя типа используется в описании для
спецификации другого имени. Единственные отличные от этого действия
над именем  типа -  это sizeof  (для определения количества памяти,
которая требуется  для хранения объекта типа) и new (для размещения
объекта типа в свободной памяти). Например:

  main()
  {
      int* p = new int;
      cout << "sizeof(int) = " << sizeof(int) "\n";
  }

  Имя  типа   можно   также   использовать   для   задания   явного
преобразования одного типа в другой, например:

  float f;
  char* p;
  //...
  long ll = long(p);     // преобразует p в long
  int i = int(f);        // преобразует f в int

     2.3.1 Основные Типы

  В C++  есть набор  основных типов, которые соответствуют наиболее
общим основным единицам памяти компьютера и наиболее общим основным
способам их использования:

  char
  short int
  int
  long int

                             - стр 53 -

для представления целых различных размеров,

  float
  double

для представления чисел с плавающей точкой,

  unsigned char
  unsigned short int
  unsigned int
  unsigned long int

для представления  беззнаковых целых,  логических значений, битовых
массивов и  т.п. Для большей компактности записи можно опускать int
в комбинациях  из нескольких  слов, что не меняет смысла; так, long
означает long int, и unsigned означает unsigned int. В общем, когда
в описании опущен тип, он предполагается int. Например:

  const a = 1;
  static x;

все определяют объект типа int.
  Целый тип  char наиболее удобен для хранения и обработки символов
на данном  компьютере; обычно  это 8-битовый байт. Размеры объектов
C++ выражаются  в единицах  размера char,  поэтому  по  определению
sizeof(char)==1. В  зависимости  от  аппаратного  обеспечения  char
является  знаковым   или  беззнаковым  целым.  Тип  unsigned  char,
конечно, всегда  беззнаковый, и  при его  использовании  получаются
более переносимые  программы, но из-за применения его вместо просто
char могут возникать значительные потери в эффективности.
  Причина того, что предоставляется более чем один целый тип, более
чем один беззнаковый тип и более чем один тип с плавающей точкой, в
том,   чтобы    дать   возможность   программисту   воспользоваться
характерными  особенностями   аппаратного  обеспечения.  На  многих
машинах между  различными разновидностями основных типов существуют
значительные различия  в потребностях  памяти, временах  доступа  к
памяти и  временах вычислений.  Зная машину обычно легко, например,
выбрать  подходящий   тип  для   конкретной  переменной.   Написать
действительно переносимую  программу нижнего  уровня  сложнее.  Вот
все, что гарантируется относительно размеров основных типов:
     1==sizeof(char)<=sizeof(short)<= sizeof(int)<=sizeof(long)
     sizeof(float)<=sizeof(double)
Однако обычно  разумно предполагать,  что в  char  могут  храниться
целые числа  в диапазоне  0...127 (в  нем  всегда  могут  храниться
символы машинного  набора символов), что short и int имеют не менее
16 бит,  что int  имеет размер, соответствующий целой арифметике, и
что long  имеет по  меньшей мере  24  бита.  Предполагать  что-либо
помимо этого  рискованно, и даже эти эмпирические правила применимы
не  везде.   Таблицу  характеристик   аппаратного  обеспечения  для
некоторых машин можно найти в #с.2.6.
  Беззнаковые  (unsigned)   целые  типы   идеально   подходят   для
применений, в  которых память  рассматривается  как  массив  битов.
Использование unsigned  вместо int  с тем,  чтобы получить еще один
бит  для   представления  положительных  целых,  почти  никогда  не
оказывается хорошей  идеей. Попытки гарантировать то, что некоторые
значения  положительны,   посредством   описания   переменных   как

                             - стр 54 -

unsigned, обычно  срываются из-за  правил неявного  преобразования.
Например:

  unsigned surprise = -1;

допустимо (но компилятор обязательно сделает предупреждение).

     2.3.2 Неявное Преобразование Типа

  Основные  типы   можно  свободно   сочетать  в   присваиваниях  и
выражениях. Везде,  где это  возможно, значения  преобразуются так,
чтобы информация не терялась. Точные правила можно найти в #с.6.6.
  Существуют  случаи,  в  которых  информация  может  теряться  или
искажаться. Присваивание  значения одного  типа переменной  другого
типа, представление  которого содержит меньшее число бит, неизбежно
является  источником   неприятностей.   Допустим,   например,   что
следующая  часть   программы  выполняется   на  машине  с  двоичным
дополнительным предсталением целых и 8-битовыми символами:

  int i1 = 256+255;
  char ch = i1        // ch == 255
  int i2 = ch;        // i2 == ?

В присваивании  ch=i1 теряется  один бит  (самый значимый!),  и  ch
будет содержать  двоичный код  "все-единицы" (т.е.  8 единиц);  при
присваивании i2  это никак не может превратиться в 511! Но каким же
может быть  значение i2? На DEC VAX, где char знаковые, ответ будет
-1; на AT&T 3B-20, где char беззнаковые, ответ будет 255. В C++ нет
динамического (т.е. действующего во время исполнения) механизма для
разрешения такого  рода проблемм,  а выяснение на стадии компиляции
вообще очень сложно, поэтому программист должен быть внимателен.

     2.3.3 Производные Типы

  Другие  типы   модно  выводить   из  основных   типов  (и  типов,
определенных пользователем) посредством операций описания:

  *     указатель
  &     ссылка
  []    вектор
  ()    функция

и механизма определения структур. Например:

  int* a;
  float v[10];
  char* p[20];    // вектор из 20 указателей на символ
  void f(int);
  struct str { short length; char* p; };

Правила  построения   типов  с   помощью  этих   операций  подробно
объясняются в  #с.8.3-4. Основная  идея состоит в том, что описание
производного типа отражает его использование. Например:

                             - стр 55 -

  int v[10];     // описывает вектор
  i = v[3];      // использует элемент вектора

  int* p;        // описывает указатель
  i = *p;        // использует указываемый объект

  Вся сложность  понимания записи  производных типов проистекает из
того, что  операции * и & префиксные, а операции [] () постфиксные,
поэтому для  формулировки типов  в тех  случаях,  когда  приоритеты
операций создают  затруднения, надо  использовать скобки. Например,
поскольку приоритет у [] выше, чем у *, то

  int* v[10];        // вектор указателей
  int (*p)[10];      // указатель на вектор

Большинство людей  просто помнят,  как  выглядят  наиболее  обычные
типы.
  Описание каждого  имени, вводимого  в программе,  может оказаться
утомительным, особенно если их типы одинаковы. Но можно описывать в
одном описании  несколько имен.  В этом  случае  описание  содержит
вместо одного  имени список  имен, разделенных  запятыми. Например,
два имени можно описать так:

  int x, y;    // int x; int y;

  При  описании  производных  типов  можно  указать,  что  операции
применяются только  к отдельным  именам (а  не  ко  всем  остальным
именам в этом описании). Например:

  int* p, y;        // int* p; int y; НЕ int* y;
  int x, *p;        // int x; int* p;
  int v[10], *p;    // int v[10]; int* p;

Мнение автора  таково, что  подобные конструкции  делают  программу
менее удобочитаемой, и их следует избегать.

     2.3.4 Тип void

  Тип void  (пустой) синтаксически  ведет себя  как  основной  тип.
Однако использовать  его можно  только как часть производного типа,
объектов типа  void не  существует. Он используется для того, чтобы
указать, что  функция не  возвращает значения,  или как базовый тип
для указателей на объекты неизвестного типа.

  void f()     // f не возвращает значение
  void* pv;    // указатель на объект неизвестного типа

  Переменной тиа  void* можно присваивать указатель любого типа. На
первый взгляд  это может показаться не особенно полезным, поскольку
void* нельзя  разыменовать, но  именно это ограничение и делает тип
void*  полезным.  Главным  образом,  он  применяется  для  передачи
указателей функциям,  которые не  позволяют сделать предположение о
типе объекта,  и для возврата из функций нетипизированных объектов.
Чтобы  использовать   такой  объект,   необходимо  применить  явное

                             - стр 56 -

преобразование типа.  Подобные функции  обычно находятся  на  самом
нижнем уровне  системы, там,  где осуществляется работа с основными
аппаратными ресурсами. Например:

  void* allocate(int size);    // выделить
  void deallocate(void*);      // освободить

  f() {
      int* pi = (int*)allocate(10*sizeof(int));
      char* pc = (char*)allocate(10);
  //...
  deallocate(pi);
  deallocate(pc);
  }

     2.3.5 Указатели

  Для большинства  типов T  T* является  типом указатель  на T.  То
есть, в  переменной типа  T* может  храниться адрес объекта типа T.
Для указателей на вектора и указателей на функции вам, к сожалению,
придется пользоваться более сложной записью:

  int* pi;
  char** cpp;             // указатель на указатель на char
  int (*vp)[10];          // указатель на вектор из 10 int'ов
  int (*fp)(char, char*); // указатель на функцию
                          // получающую параметры (char, char*)
                          // и возвращающую int

Основная операция над указателем - разыменование, то есть ссылка на
объект,  на   который  указывает   указатель.  Эта  операция  также
называется  косвенным  обращением.  Операция  разыменования  -  это
унарное * (префиксное). Например:

  char c1 = 'a';
  char* p = &c1;    // в p хранится адрес c1
  char c2 = *p;    // c2 = 'a'

Переменная, на  которую указывает  p,- это  c1, а значение, которое
хранится в  c1, это  'a', поэтому присваиваемое c2 значение *p есть
'a'.
  Над  указателями   можно  осуществлять  некоторые  арифметические
действия. Вот,  например, функция,  подсчитывающая число символов в
строке (не считая завершающего 0):

  int strlen(char* p)
  {
      int i = 0;
      while (*p++) i++;
      return i;
  }

Другой способ  найти длину состоит в том, чтобы сначала найти конец
строки, а затем вычесть адрес начала строки из адреса ее конца:

                             - стр 57 -

  int strlen(char* p)
  {
      char* q = p;
      while (*q++) ;
      return q-p-1;
  }

  Очень  полезными   могут  оказаться  указатели  на  функции;  они
обсуждаются в  #4.6.7.

     2.3.6 Вектора

  Для типа  T T[size] является типом "вектор из size элементов типа
T". Элементы индексируются (нумеруются) от 0 до size-1. Например:

  float v[3];   // вектор из трех float: v[0], v[1], v[2]
  int a[2][5];  // два вектора из пяти int
  char* vpc;    // вектор из 32 указателей на символ

Цикл для  печати целых значений букв нижнего регистра можно было бы
написать так:

  extern int strlen(char*);

  char alpha[] = "abcdefghijklmnoprstuvwxyz";

  main()
  {
      int sz = strlen(alpha);

      for (int i=0; i. Функция strlen() использовалась
для подсчета  числа символов  в  alpha;  вместо  этого  можно  было
использовать значение  размера  alpha  (#2.4.4).  Если  применяется
набор символов ASCII, то выдача выглядит так:

  'a' = 97 = 0141 = 0x61
  'b' = 98 = 0142 = 0x62
  'c' = 99 = 0143 = 0x63
  ...

                             - стр 58 -

  Заметим,  что   задавать  размер   вектора  alpha  необязательно;
компилятор считает  число символов в символьной строке, указанной в
качестве инициализатора.  Использование строки  как  инициализатора
для вектора  символов -  удобное, но  к  сожалению  и  единственное
применение строк.  Аналогичное этому  присваивание  строки  вектору
отсутствует. Например:

  char v[9];
  v = "строка";          // ошибка

ошибочно, поскольку присваивание не определено для векторов.
  Конечно, для инициализации символьных массивов подходят не только
строки. Для  остальных типов  нужно применять более сложную запись.
Эту запись можно использовать и для символьных векторов. Например:

  int  v1[] = { 1, 2, 3, 4 };
  int  v2[] = { 'a', 'b', 'c', 'd' };

  char v3[] = { 1, 2, 3, 4 };
  char v4[] = { 'a', 'b', 'c', 'd' };

  Заметьте, что  v4 - вектор из четырех (а не пяти) символов; он не
оканчивается нулем,  как того  требуют  соглашение  и  библиотечные
подпрограммы.  Обычно   применение  такой   записи   ограничивается
статическими объектами.
  Многомерные  массивы   представляются  как  вектора  векторов,  и
применение записи  через запятую,  как  это  делается  в  некоторых
других языках,  дает ошибку  при компиляции,  так как  запятая  (,)
является операцией последования (см. #3.2.2). Попробуйте, например,
сделать так:

  int bad[5,2];    // ошибка

и так:

  int v[5][2];
  int bad = v[4,1];      // ошибка
  int good = v[4][1];    // ошибка

  Описание

  char v[2][5];

описывает вектор  из двух  элементов, каждый  из  которых  является
вектором типа  char[5]. В следующем примере первый из этих векторов
инициализируется первыми  пятью буквами,  а второй  - первыми пятью
цифрами.

                             - стр 59 -

  char v[2][5] = {
      'a', 'b', 'c', 'd', 'e',
      '0', '1', '2', '3', '4'
  }

  main() {
      for (int i = 0; i<2; i++) {
          for (int j = 0; j<5; j++)
              cout << "v[" << i << "][" << j
                   << "]=" << chr(v[i][j]) << "  ";
          cout << "\n";
      }
  }

это дает в результате

  v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e
  v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4

     2.3.7 Указатели и Вектора

  Указатели и  вектора в C++ связаны очень тесно. Имя вектора можно
использовать как  указатель на его первый элемент, поэтому пример с
алфавитом можно было написать так:

  char alpha[] = "abcdefghijklmnopqrstuvwxyz";
  char* p = alpha;
  char ch;

  while (ch = *p++)
      cout << chr(ch) << " = " << ch
           << " = 0" << oct(ch) << "\n";

  Описание p можно было также записать как

  char* p = &alpha[0];

  Эта эквивалентность  широко используется  в  вызовах  функций,  в
которых векторный  параметр  всегда  передается  как  указатель  на
первый элемент вектора; так, в примере

  extern int strlen(char*);
  char v[] = "Annemarie";
  char* p = v;
  strlen(p);
  strlen(v);

функции strlen  в обоих  вызовах передается  одно и то же значение.
Вся штука  в  том,  что  этого  невозможно  избежать;  то  есть  не
существует способа  описать функцию  так, чтобы  вектор v  в вызове
функции копировался (#4.6.3).
  Результат применения  к указателям  арифметических операций +, -,
++ или  -- зависит от типа объекта, на который они указывают. Когда
к  указателю   p  типа   T*  применяется  арифметическая  операция,

                             - стр 60 -

предполагается, что p указывает на элемент вектора объектов типа T;
p+1 означает  следующий элемент  этого вектора,  а p-1 - предыдущий
элемент. Отсюда следует, что значение p+1 будет на sizeof(T) больше
значения p. Например, выполнение

  main()
  {
      char cv[10];
      int iv[10];

      char* pc = cv;
      int* pi = iv;

      cout << "char* " << long(pc+1)-long(pc) << "\n";
      cout << "int*  " << long(ic+1)-long(ic) << "\n";
  }

дает

  char* 1
  int*  4

поскольку на моей машине каждый символ занимает один байт, а каждое
целое занимает  четыре байта.  Перед вычитанием значения указателей
преобразовывались к  типу long с помощью явного преобразования типа
(#3.2.5). Они  преобразовывались к  long, а  не к "очевидному" int,
поскольку есть  машины, на  которых указатель  не влезет  в int (то
есть, sizeof(int)
2.3.8 Структуры

  Вектор есть  совокупность элементов  одного типа; struct является
совокупностью элементов (практически) произвольных типов. Например:

                             - стр 61 -

  struct address {        // почтовый адрес
      char* name;         // имя "Jim Dandy"
      long  number;       // номер дома 61
      char* street;       // улица "South Street"
      char* town;         // город "New Providence"
      char* state[2];     // штат 'N' 'J'
      int   zip;          // индекс 7974
  }

определяет новый тип, названный address (почтовый адрес), состоящий
из  пунктов,   требующихся  для  того,  чтобы  послать  кому-нибудь
корреспонденцию (вообще говоря, address не является достаточным для
работы  с   полным  почтовым   адресом,     но  в  качетве  примера
достаточен). Обратите внимание на точку с запятой в конце; это одно
из очень  немногих мест  в C++,  где  необходимо  ставить  точку  с
запятой после  фигурной скобки,  поэтому люди  склонны забывать  об
этом.
  Переменные типа address могут описываться точно также, как другие
переменные, а  доступ  к  отдельным  членам  получается  с  помощью
операции . (точка). Например:

  address jd;
  jd.name = "Jim Dandy";
  jd.number = 61;

  Запись, которая  использовалась для инициализации векторов, можно
применять и к переменным структурных типов. Например:

  address jd = {
      "Jim Dandy",
      61, "South Street",
      "New Providence", {'N','J'}, 7974
  };

  Однако обычно  лучше использовать конструктор (#5.2.4). Заметьте,
что нельзя  было бы  инициализировать jd.state строкой "NJ". Строки
оканчиваются символом  '\0', поэтому в "NJ" три символа, то есть на
один больше, чем влезет в jd.state.
  К структурным  объектам часто  обращаются посредством  указателей
используя операцию ->. Например:

  void print_addr(address* p)
  {
      cout << p->name << "\n"
          << p->number << " " << p->street << "\n"
          << p->town << "\n"
          << chr(p->state[0]) << chr(p->state[1])
          << " " << p->zip << "\n";
  }

  Объекты типа структур можно присваивать, передавать как параметры
функции и возвращать из функции в качестве результата. Например:

                             - стр 62 -

  address current;

  address set_current(address next)
  {
      address prev = current;
      current = next;
      return prev;
  }

  Остальные осмысленные  операции, такие как сравнение (== и !=) не
определены. Однако  пользователь может определить эти операции; см.
Главу 6.
  Размер объекта  структурного типа  нельзя  вычислить  просто  как
сумму его  членов. Причина  этого состоит  в том, что многие машины
требуют, чтобы  объекты определенных  типов выравнивались  в памяти
только по  некоторым зависящим  от архитектуры  границам  (типичный
пример: целое  должно быть  выравнено по  границе слова) или просто
гораздо более  эффективно  обрабатывают  такие  объекты,  если  они
выравнены в  машине. Это  приводит к "дырам" в структуре. Например,
(на моей  машине) sizeof(address) равен 24, а не 22, как можно было
ожидать.
  Заметьте, что имя типа становится доступным сразу после того, как
оно встретилось,  а не только после того, как полностью просмотрено
все описание. Например:

  struct link{
      link* previous;
      link* successor;
  }

Новые объекы  структурного типа не могут быть описываться, пока все
описание не просмотрено, поэтому

  struct no_good {
      no_good member;
  };

является ошибочным (компилятор не может установить размер no_good).
Чтобы дать возможность двум (или более) структурным типам ссылаться
друг на  друга, можно просто описать имя как имя структурного типа.
Например:

  struct list;        // должна быть определена позднее

  struct link {
      link* pre;
      link* suc;
      link* member_of;
  };

  struct list {
      link* head;
  }

Без первОгк описания list опйсапие link вызвало бы к синтаксическую
ошибку.

                !            - ст° 63 -

   , 2.s.9 Эквивалеетность типоb

  Два структурных  тшпа являются  разпичнъмЄ даже  когда они  имеют
однЁ и те же члены, Наприме°>

  rtruct s1 { int a; };
 !struct s2`{ int0a; };
бсть два разных типа, пмэтому
  sq x;
  s2 y = x;    // ошибка: несоответствие типпв

Структурные тиoы отличны тдкже от основных"типов, поэтпму

  s1 z;
  inv i < x;p   // ошибка: несоответствие тиожв
  Однало, сущеутвует( механизь$для  описания нового  именh длч типаЉбез введеmия нового типа. Описание с префиксом typedef описывает не	
новую переменную!даепого0тhпт, а новое имя эІого типа. Наяример:
  typedef`char* Pchar;
  Pchar p1, p2;
  char: p3 = p1;

  Это может служить(удобной сокращенной записью.

  $  2.3.10 Ссылки
Ќ
  Ссылка пгляется  дсугим(именем кбъекта. Главное!ПрименеНие ±сылок
состоит   в   спецификации   опбраций   для   тизnв,!  определяемых*пользователем; онй  оссуждаются в  Главе 6.  Оеи могут  также$ быть
оолезны в качестве параметров функции. Записю x& означаеr ссылка на
x. Например:

  int i = 1;
  int& r = i;  ! // r и y теперш(ссылаются нб$одим int
  int x = r     `// x"= 1
  r = 2;  !   `  // i = 2;

  СсылЄа должна!быть инициализ€роbана (¤олжнN быть что-то, для чего
она являетбя именем). Заметьте< чrо инициализация(ссылки есть нечто
совершенно отличное от(присваиванмя ей.
  Вопреки0 ожиданиям,  нкодна  мперация  на  ссылкт  не  действует.
Например$
  int )I = 0;  int. rr =(ii;
` rr++;        ,/ ii увеличиваеТся на 1

допусти¬о,  ео   rz++  не   увеличивает  ссылку;  вместо  этого "++
применяетщя(к  int которым  оказыванТсп ii.  Следовательно,  пОсле
инициализации зничение 0Ссылки не $может быть  измҐнено; она в±егда
сСылрется на"объект, котОрый ей было ¤ано кбозначдть Ёденотйровать)

  !                  $(      - стр 44 ­
Љпри иниvиализацйм. Чтобы получить укаЗатель на жбъект, денотируемый
ссылкой rr, можно написать 6rr.
  Очевианым  способом   реализации  ссщлки   является   конртантный
указатель, китnрыи  pрзыменовываеrщя при  каждом использовании. Щто
делаҐт    инициализацию  ссылки  тривиальной$  когдв  инициализатор
являЕтся lvanue  (обюектом, адрес  которого вы !можбте  цзяsь,  см.
#с.5).   Однако инициакизацмр  для &P  не ОбязАтеkьно  должен  быть
lvalue, и даже ее дол¦ен быть випб T. В таких случаяхє
  [1] Во/первых  еСли нeогхоеимо,  применяются преобрапование0типа
     (#с.6.6-8,#с.8.5.6);
  [2] затем получейное значение помешдетуя во временную переменную;
     и
 $[3]  НакоMец,  `ееd адрес 0 исполюзгецся  в   качестве   значения
     инициализатора
Р ссмотрим описание
 doublе& dr ="1;

Это инъерпретаруевся таК2

  touble" drp;    // ссыбка, представйенная ъак уоазбтель
  double temp;L
( temp = double(1);  drp!= &temp;

  Ссылку ¬овно  использовать жля0 реализации функции, !которая, Как
предполагается, измЕняет значение своего парамзтра.

  int x = 1;
  void incr(йnt& aa) { aa++; }
  iоcr(x)"    "  !        // x = 2

  По определению" семантика перЕеачи параметра та же$ что семайтика
шнициалшздции, поэт®му  параlетр aa  функцииincr становится дтугим
именем  для   x.  Однако,   чтобы  сделать  программу  читаемой," в
бокьшинсТве случаев  лучше всево избегать функций, оотпрые изменяят
значениб сўоих  парамeтров. Ч`сто  предпочритхлјно явно  возвращать
чначение из фуниции ийи Требnвать b качестже$парамеъра указатель8

! int x(= q;
 $int next(int p9 { return p+1; }
  y = oe|t(x);      0     // x"= 2

  void inc(int* p) { (*p)++; 
  inc(&x);         (      // x = 3

  Хсылки тАкже  можно применять  для опрежелдния  фуекцийl  которые
могут использоватшся  и в  леpой, и  в правой  чахти  присваивания.
Ппятю,$  большая    часть   наиболеe   интересныU  `слічаев   этого
обнаружмваетСя   в    проектировании   нетшивиальных  $определяемых
пользоватЕлем  типов.   Дл  примера   давайте  опРеделим   простnй
ассотиативный массив. Вначале мы определйм структушу пдры следующим
образом:
                   !         - стР 65 -

  strtct pair {
      char* fame3
   $  int val;  };

  Осповная идея  смстоит в  том, что строка имеет ассоциисовАнное с
ней целон!значениб.(Кегко юпределить функцию яомска find(), кото°ая
поддерживАет стргктуру  данных, состоыщую из одного pcir для иаждой
жтлиуной отличной  ов дрчгих  свроки, которая"была ей лредставлена.
Для  краткОсти0  представления  испоkьзуетря   оченм   простая  "(и
mеэффективная) реализация:Љ
  const large = 1024;
  static pair vec[lasge+1};

  paiт* find(char* p)
  /*
     !поддерживаеІ множество`пар "pairў:
   b  йщет p, если находит, вогвращает его "pair",
  (   иначе козвращает неиспользованную!"pcir"  */
 ${
      for (iot i=0; vec[i].name; i++)
          if ,strcmp(p,vec[i].nme)==0) rmtu2n fvgc[i];

 "    if (i == large) veturn "vec[lqrge)1];

      reфurn &vec[i;
  }

  Эту  функцию  может` испnльеовать  tснкция $value(), 0реализующая
масбив целых, $индеисированыщ сиэвольными стровими (вместо осычного
±посоав):

  int& valu%(char: p)
  {
      pair* res = find(p);      iv (res->namе == 0)({       //`до`сих пор не встрхчалось:
      ( rus->name = new char{surlen(p)+1];  // инициапЁ§ировать
        strcpy(res->nalе,p);
 `      res->val = 0;    !     0  // начальmое зНачение 0
      }
      zeturn res->val;  }

Дкя дайной(в качестве параlетра строои value() находит целый мбъект
(в нҐ  значхние соответству~щегю целого); пюсле чего она возвращает
ссылку на него. Ее можно использовать, мапример. таи:

                          "  - хтр 66 -

  const MAX = %6; "  o/(боыьше с`мого большого слова
  mamn()
  /? подсчитывает чисйо вхождений каждог® слова во вводе
  {
      char buf[M@X];

     0while (cin>>buf) ~alue(buf)++;

      for!(inT i=0; fec[i].name; i++)
          cout << wec[i].name << ": " ґ< vec [i].val <<  \n";
  }

На каждкм  прnходе`цикл  считывает одно словв и§!стаmдартной строки
ввода cin !в buf  (см. Глажу  8), а затeм обновляет0свчзанный с нeй
счетчик спомощью" find(). И,0наконец, пе·атается полученнря таблица
различных  слоў   ўо  введеннОм   Тексте,  каждое   у  числон   згю
вртречаемости. Нап°имер, ебли bводится

 "aa bb0bb aa aa bb aa aa	

то программи выдаст:

  ia: 5
  jb: 3	

  Легко   усовеpшенствоварь   это   в   п«ане   собственногю   типа
ассоциировбнного массива с помощью кл рса щ перегружҐнной опешацкел
(#6.7( выбора []/

    `2.3.11 Регистры
  Вю`многих  машинных арэитектурах  можйо обращаться` к )пебольшим)
объзктам заметно"быстрее, когаа они помещены л аегистр. В кдеальнош
случае$ компилятор   будет  сам( юпредепять $олтимальщую  стратегию
исппльзования всех  рзгистров, доступпых  на  машИне,  для0 которой
компилируется программа.  Однако это  нетривиальная зрдача, поэтому
шногда программиqту  стоит дать подсказку компилятошу. Это феЛается
с помощью!описания объекта как register. НапрммерєЌ
J  regmster ilt y;
 `rEgister point cursor;
  6egister bhar* p;

Озисанае register  следУет йспользовать только в вес слууаях, когда
эффекривность действительнж  важн`. Опищание  каfдоЙ лбременнкй как
regiqter засорит  текст программы  ш  мкжет  дбже  увеличить  время
выпопнения  (обычэ®  воспсинимдютсы( все  инструкциа  по  помещенияЌ
объелтб в реГистр или удалению"его оттуда).
  Невоз¬ожно получить ад°ес имени, опшсанного как regicter, регистр
не может также быть гoоЎалшмым.

       $      $ $           "- ст° 67 -

     2.4 ъойстанты

  C+) дрет  возмпжнюсть запибш" значений основных тйпов: симкольйых
констант,0цеыых констант и констант с плавающей точоой. Кроме тогм,
ноль (0)  может использоватюся  крк констднта! любnго указательнозо
типа, И  символьные строки  являются конщуантами типа char[].!Можно
также задавать  сммволшческие константы. `Симвюлическдя константа -
это имя,  зmачение котоpог®  не может !бытш игМененм"`b его области
видимости. В "C++ имеется  три  вида  симвопических0 лонстант:  (1)
любомг зЭачению  любого тИпа! можно дать имя и использовауь его как
константу,  аобавив  к "его  описания  клѕчевое  блюво  cknst;  (2)
множество целые  констант может быть определено как перечи±ление; и
(3) любое амп вектора или функцаи является конст`нтой.
 `   2*4.1 Целые$КонстАнты
" Цхлые  конст`нты   предстают  в ! четырех( обличьях:  десятичные,
восьмерйяные, шестнадцатиричмые  и щимвольнще консуанты. Десятичпые
используются чаще всего и в{гкядят таъ,(как можнк было2бя ожидать:

  0    1:34    972    1234567890123t567<90
Днсятичная кместанта  hмеер тип int, при усыовии, ·то онд влезает в
int,!`в   противном (случах   ее $тип 0 long>   КюмпиляТор   должен
предупреждать   о    копстантах.   которые   слишком   длиmны   длп
представления в машине.
  Константа, которая  начинается нулем  зА  которым  иДет  x  (0x!,
является шестнадцаткричным  числом (с  основанием 16), а констанrа,
коІорая     нахинается  нулем   за  которым "идет0 цифра,  является
вос|меричным часлжl  (с основанием  ).  Впт  примҐры  bосьмеричных
констант>

! 0        02        077        0123

их десятичные  нквиваленты )  эт®$0, 2, 6,`83. В шестнадцатиричной
залиси эти константы выглядят так:

  0x0      0x2  !    0x3f   (   0x53

Буквы a  b, c, ad, e  и f¬  или их щлвиваленты в верхнем азгистре,
аспользуютщя длы  представления чисел  ±0,011.  12, 13, $14  к  15.
соответственно. Восьмеричная  и шеСтнадцатиричная  запиби  напболее
пмлeзны для  записи  набора  биІов;  нрименение  этих  записей  для
выраддния обычных0 чисел можҐт приbести к неожиданностям."Например,
на машинд,  где  int  прэдсъавляется  как  $воичнод  дополнительноб
шестнадцатЕрияное Целое,  8xffff является0 отриц`тельэым десятичным
чбсkом -1;  дсли бы для предстаbленич целого испо«шзовалось большgе
цисло%бштпв, то оно было бы числом 65535.
     2&4.2 Лонстанты с Плаврющей Точкой

  Кюmстанты с плаваюйеЙ точкой имеют тип(double. Как и в прбдыдущем
слычае, комПилятор  еолжен предупреждать  о(константах  с плаваюyей
*                    0    0!  - стр 68 -

точиой, котОрые  сйишком0ждлики,  чтобы$Ёх  моцно было предсbавить.
Вот некоторые константы с плавающeй рочкой:Љ
  1.23    .23      0.23     1.    1.0  (  1.2e10    1.23e-15

Заметьте, что  к се°едине  конхтанты с `плабающей точоой  нд $может
ўбтречаться oробел.  Наoример, 65.43  e-21 является не константой с
плагающей точкой(  а  ·етуремя  отdель­ыми  лексичесвими  символами
*лек±емами-

  65.43    d    -    21	

и выповет$синтавсическію ошибку.-
  Если вы  хотите иметь константу с плавающей точкой тмпа float, вы
можете опседелить ез так (#24.6):

  const flo`t pi = 3.q415926%;
    "2.4.3 Бимвжыэные КонСуанты

  Хотя в  C++ и  mет Отдельного  скмвольного`типр  данных,  точнее,
синвол`¬ожет  хранjться в  целюм типе, $в эем!"для$химволов имеевся
специальная и  удобнвя запись.  Символьнря константа  -`это симвжл,
заключенный в  Оминарные кавычки;  например,  'a'  или `'0'.  Такиe
символьные констрнты  в  действитЕльносґи  яжляются  символическими
Єонстаптами для  целогк знАченмю  символов0в  наборе  симвпыов  той
маши­ы,  на   кnторой$ будет   выполняъься! программа  (который  ме
обязательно  совпадает0 с  набором  символов,  применяемом  на  тои
компьотере,  где   ярограмма  компилируется).   Поэтмму,  если   вы
в{полняеъесь на  машине,( шспоkьзующей  набор  символоb &ASCЙH,  то
знауением '0'` будеъ 48,  нж если ваша машийа испкл|зуеу EBCDIC, то	
оно буДеу` 240. Употребление  симвкльных констант вместо фесятичнол
записи делает программу более переносимой. Несколфко!символов т`кже
имеют стандартнуе  имена$   в которых обратная косая \ используетсякак esc!pe-символ:

   `  '|b'    возрат назад
      \f'!   перевод фордата
      '\n'  " новая строка
    $ '\r'    возврат каретии
      '\t'    горизонтальная`т буляция
      '\v'    веръИкальная табуляциэE
      'L\'    обратная косая (оeратный слэш)
      '\''    одинарэая кавычка
      '\"'    дтойНдя кавычла
      '\0'    null, пустой синвол, целое значение 0

  Вопреки их  в­ешнему ваду  ка¦дое являетсЮ  одним символом. Можно
такке представЛять  символ одно-, дву- или трехзначНым%вмсьмЕричным
числом (символ  \, за! которым идут восьмеричные цифры), или одно-,
дву% илЁ  тсехзначным шестнадцатиричным числом ,\x, Зв которым идут
шестнидцари°ичные юифры). Например:

      !   `                  - стр 69 -

  'Ь6/      '\y6'     ! (6        ASCII ack
  '\60'     §\x30'`      48       ASCII '8'
  '\137' 4  '\x05f'      95 (     ASCII '_'Љ
Это0 пкзволяет  предстаклять  кажаый  символ "из  машинногк  набора
щимволов, и в част­ости вставлять(такие си¬волы в символьные сrроки
(см. сгедующий` таздел). Орименение  числовой зиписи  для  символовделаеу программу непереэосмеой между машинами х рачличными наборами
римволпв.

     2,4.4 Строки
  Строковая   константа `" -   это   послҐдовательность  (симвоkог,	
паключенная в двойные кавычки:

  "это стсова"

Каждая строковая  констднта со¤ержит" на оеип $смьвол  больше,  чЕм
кажется; все пни заканциваются пустым уймволом §\0' со зНаwением 0.
Например:

  sijeof("asdf")==5;
" Строка имеет  тhп "вектор$ Из соктветствующего(!числа  символов",
поэтому "asdfў  имеет тип ghar[5]> Пустая сттока записывается "" (и
имеет  ткп   char[1]).  Заметьте,   чт®   для   каждой   строки   s
ctrlen(s)==sizgof(s)-1¬ поскмльку strlun() не учитывает заверъающий
0.
  Qоглаёение о! представленаи  неЈрвфических  симвюлов  р  обратной
косой  можно  использовать  такfе0  и  вэутри   строки.  Хъо  даерЈозоожность представлять  в строjе  двойные кавычки И escape-сиьвол
\. Саиым  обычным символом 0этого$рода является безусловно,$уимвол
новюй щтр®ки '\n'. Например

"(cott ь< "гудок в ионце спогщенмя\007\n"	

где 7 - зн`чение ASKII символа вe, 8звонок).
  В ср°оке некозlожн® иметь "настоящую" новую строку:

  "это не сттока,
  а синтаксаческая(ошиЙка#
M
Оенако в  строке может  стоят| юбратная  корая, сра§у после которой
идет новАя строка; и то, и друлое будет!проигнорированж. Например:

  cwt << "здесь все \-  ok"

напечатает

  здпсь вще ok

Ноаая строка,  пҐред  которой  идет  escape  (обратн`я  иосая-,  не
пфЁводит  к   пояжления  в   строке  йовой   стшоки,0  это 0 прпсто
договофенность о$записи.

                             - стр 70 --

  В строке  можно имець  пустой симвоы,  по Бюльшинство программ не
будет предполагать,  чцо`есть симвюлы после  него. Например, строка
"asdf\00phjkl" будзт  рассматриваться станда°тными функциями  вроде	
strcpy() и strlej(), как "asdf".
 `Вставляя чшщлҐннsю (константу в стpоку с помощью восьоеричной или
ше±тнвдцатИричной еаписи блаборазумно аселда использзожать число!йз
трех цифр.  Читать$запись  достаточно тргднО! и  без  необхnдимостЁ
беспоjоитэся о  том, явkяется  ли симгОл после констануы цифрой или
mет. Разбе°ате эти зримнры:

  char ~![] = a\x0fAh0121";    // 'a' '\xfa'`'h' '\12 '9/
  char v2[] 9 "a\xfah\129";      ./ 'a' '^yfa' 'h7 '\12' '9'
  chaz v3[] = "a\xfad\1r7ў;      // 'a7 '\yfad' '\137'Н

Амейте в виду, уто!двузначmой шeстнадцатифичнюй записи па машиеах с
9-битовым байтnм будет эедостаточно.

     2.4.5 Ноль

 !Ноль  (0)   можно  употреблять   как  константу  !любого  целого,
пгавающего или укапате«ьноуо0типа. НЁкакой объект не размещается по
адрхсу  0.  Тип  нуля  определяется  контекстмм.   "Обычно$ (но  не
обязательно)   он  ` представляется    наборон    битов    все-ныли
соотверствуюыей дпины.

   " 2.4.6 Cnst
  Ключевое слово  const мооет дмебвляться к описанкю объекта, чтобы
сделать эт®ц`объект Консуаптой, а нх перемемнол. Например>

 `const hot model"= 145;
` sonst int v[] = { 1, 2, 3, 4 }3
J  Поскольку константе  ничего нельзя  пТисвокть,  онб  должна  быть
инициализирована. Описание  чего-нибудь как  aonst гарануирует, что
его значение не изменится в области видимоСти:
` model`= 145;        // ошибка
  model+;;    `       / ошибкб

  Заметьте, чrо  const изменяет  тип, то  есть"fграничивает  спnс¬б
мупопьзования  объекта,   вместю  тобО,   чтобы   задавать   сoособЉразмещения константы.  Понтооу мапример  жполне разумно, а иногда и
полежно, описывакь функцию как возвращающую cojst:
  const"char* peekhint i)
 ${
!$    return private[i]»
  }

Функцию вроде  этой можно  было бы  использовать  для  того,  чтобы
давать кооу-нибудь читать строку- котораї не может быть затерта илипереписана (этим кем-то).

                             - стр ·1 -

  С   другой   стороны,   компилятор   можеІ   несколькимИ   путями
воспользоваться тем,  что объект  является лонстантой  (конечно,( в
зависимоqти от того, насколько он сообразителен+. Самое очевидное -
это то,  что для  константы не требуется выделять п`мять, поскольиу
компилятор зндет  ее значение.  Кроме уого, анициализатор конст нуы
часто!(но  эн всегда)  являетря константным  выражением, то есть он
может быть  вычмслен  mа  стадии  компиляции.  Одйако  дкя  вектора
констант обычнж  приходится выделять память, поскюльку компилятор в
общем случае  не может вычислить, на какие элементы вЕктора сделаны
ссылки в  выражхниях. Однбко  на многих  машинах даже в этом случае
может достигаться пювышение эффективности путем размещения векворов
кжмстант в память, доступную только для чъения>
  Использование указателя  вовлекаеТ два  объекта: сам  указатель и
указываемый обшект.  Снабжение описания указателя "префиксом" const
желает объект, но не`сам указатель, константой. Например:

  const char* pc = "asdf";    // указителЬ на константу
  pc[3] =!'a';                // ошибка
  pc = "ghjk"9                // ok

Чтобы  опиСать(  сам  указатель,   а  не  укдзываемый  объект,  как
кюнстантпый, используется`nперацйя const*. Например:

  char *const cp } "asdf";    // константный увазатель
  cp[3] = 'a';             !  // ok
( cp = "ghjk";  0             /o ошибка

Чтобы сделать  константами оба$объекта, их оба нтжно описать #onst.
Например:

  cons4 char *const cpc = "asdf"; $  //`cgnst улазатель на const
  apc[1] =('a';           `       !  // ошибка-
0 cpc = "ghji";     (                // ошибка

  Объект, являющийся  кnнтстантон при  доступе к  нему  через  один
указателю,  может  быть  переиенной,  когда  доступ  осуществлюется
другими путями.  Эуn в  частноси полежно  для  пашаметров  цункции.
П®средством  описания   параметра  указаТеля   как  const  $функции
запрещается(изменять объект, на который он указывает. Например:

  char* strcpy(char* p, const char* u); // ­е может`изменить q

  УкаеатҐыю  на   константу  можно  лрисвривать  адрес  переменной,
поскольку никакого  вреда от  этого бытю  не может.  Однако  нельзяприсвоить `дрес  константы указателю,  на который  не было еалоЖено
ограничение, поскольку  это позаолило бы0изменить еначение объекта.
Йапример:

0 int a = 1;
  const c =(2;
  const* p1 = &c;    // ok
  const* p2 = &a:    // ok
  int* r2 - &c;      // ошибка
  *p3 = 7{           // меняет знаяение c

Как обычно, если тhп в ояисании опущен, то он предполкгается"int.

                             - стр 72 -

     2.4.7 ПеречИсления

 !Есъь другой  мерод определепия  целых  констант,  которыi  шногдр
ао«ее удобен, чем применение const. Например:

  enum { ASM, AUTO, BREAK };

определэет  три   целых  константы,  называемы  перечислителями,! и
присгаивает  им  значения.  Поскольку0 значения  перечислитдлей  по
гмолцанию присваиваются  начиная с  0 в  порядке  возрастания,  это
эквивалентно записи:

  co~st AQM =!0;
  const AUTO = 1;
  const BREAK = 2;

ПерҐчисление может быть именованным. Напримеф:

  dnum keyword { ASM, AUTO, BRMAK };

  Имя перечисления  станожится синонидом  int, а (не  новым  типом.
описанйҐ переменной  keyword, а  не  просто  int,  ьожет  дить  как
программищту, так` и компилятору подскрзку о том, ·то использование
преднамеренное. Например:

  keyword key;
Љ  swivch (key) {
  case ASM:
      // что-то Dелает
      break;  case BREAK:  (   // что-то делает
      break;
  }

побуждает компилятор  выдвть предупреждение  поскольку только  два
значения jeywoтd из трех используются.
  Можно т`кже задавать знахения перечислителзй явно. НрпРимеР:
  enum int16 {Ќ
     (sign=014000,               // зпак
      most_significant=040000,   `// самый значимый
      least_signyficant=1         // эаименее значимый
  };

Такие значения не обязательно должны быть рачличными, возрастающими
ипи положительными.

     2,5 Экономия ПространсТва

  В  ходе   проГраммирокания  нетривиальных   разрабкток  неизбежню
насрупает время,  когда хочется  иметь больше  пространства памяти,
чем  имеется   или "отпущеню.  Есть  два  способа  выжать  побольше
простраmства из вого, что доступно:

              $              - стр 73 -

  [1] Помещение b байт более ждного небольшого объекта; и
  [2] Испольчование  одного и  того же  пространства  для  хранения
     фажных объекров в!разное время.
  Первого можно  достичь с  помощьѕ использовдния  полей¬ второгж -
через исполмзование` объединений.  Эти  конструкции  описываются  в
бледующих разделах. Пnскольку обычное их примене­ие состоит$чисто вJоптимизации программы,  и ®ни! в сольшинстве  случаев нҐпереносимы,
программихту следует  дважды подуиать,  прежде чем кспользовать их.-Часто лучше  иеменить способ  управления$данэыми;  например, больше
полаг`ться на  динамически выделяемую "память$(#3.2.6)  и меньшд на
заранеҐ выделеннуюстати·ескую намят|.
     2.5.1 Поля

  Использокдние  char   для  предсцагления   двоичной   переменнпй,
напримeр,  переключателю   вклюзено/выключено,   можер   показаться
экстравагантнъм,   но char  является нбименьшим объектом, который в
C++ может   выделяться  независимо. 0Можно,  однако,  сгрупгировать
несколько таких  крошечных переменных  вместе в  виде0полей struct.
Член определяется  как полн `путем указания  после его  имени числа
битов, которые  он занимает.  Долустимы неименованные  поля; они не
влияют на  смысы  именованных  полей,  но  неким0 машинно-зависимым
образом могут улучшить размещение:

  struct sreg {
      unsigned`enable : 1;
      unsigned page : 3;
      unsigned : 1;        // неиспользуемое
      wnsigned mode : 2;
      unsigned : 4;   $    // неиспольгуемое
      unsignEd`Access : 1;!     unsigned length : 1;
   "  unsigned jon_resident : 1;
  }

Получикось  размещение   регистра  0   с®сояния  DEC   PDP11/45  (ж
предположении, что  поля в  слове размещаются  слева направо). Эrот
пример  также   иллюстриtует  другое   основное  применение  полей:
имбновать части  внешне предписднного  размещения.!Поле должно бывь
целозо типа0 и используется  как дфугше целые, за исключением того,
чтк невозможно  взїть адрес поля. В ыдре операционной системы или в
отладчике тип sreg можно Ўыл® бы использовать так:

  sreg* sr0 = (sreg*)0777572;
  //...
 0if (sr->access) {        // нарушение доступа
      // чистит массив
      sr->acceуs = 0;
  }*
  Однаjо применение полей для`упаковки нескольких перЕменных в один
Байт   не   обязательно   экономит   пространстжм.   Оно   экономит
пространство, занимаемое  данными, но  объем кода, необэодшмого для
манипуляции этими  переменными, на  большинутвн  машин  возраувает.
Извесвны прогсрммы,  котОрые зм`хителэно  сжимались, когда двоичнуе

                             - стр 74 -
леременные преобразовывались  из полей  бит в  символы! Вроме того,
фоступ к  Char или  int обычно $намного быстрее, чем доступ к поыю.
Поля 0-   это  просто  удобная  и  Єраткая  заЇись  для  применҐйия
логических операций  с целью  извлечения информации  из части слова
или введения$информации в нее.

     2.5.2 Объединения

  Рассмотсим проектирование  символьной таблицы,  в которой  каждый
элемент содерўит  имя  и  значение,  и  значение  может" быть  лмбо
строкой, либо целым:

  struct entry {Ќ
      char* na}e;
   0  char  txpe;
      char* string_value;   0    /? испойьзуетуя если type == 's'
      int   int_value;           // используется если type == 'i'
  };

  void print_entry(entry* p)
  {
   0  switch p->type {
      case 's':
          cout0<< p->strino_value;
          break;
      case 'i':
          cout ј< p->int_value;
          brеak;
      default:
     (  $ cerr << "испорчеm type\n";
     `    freak;
      }
  }

  Поскольку   string_value    и   iоt_value    никогда   не  !могут
использоватьщя  одновременно,   ясно,  что  пространство  пропадает
впустую. Это можно легко ихправить, указав, что оба они должны бытю
членами union 8оеъединения); напршмер, так:

  struct dntry {
      chav( name;
      char  type;
      union {
          chap* string_value;   (// используется$если uype == 's'
         0int   int_value;       // исполшзуетря если type == 'i'
      };
  };

  Это  осравляет  всю  часть( прогшбммы, $использующую  entpy,  без
изменений, но обеспечивает< что при размещении entry stryng_valte и
int_value имеют` один и тот же адрхс. Отсюда следует, что все члепы
объединения вместе  замимают лишь  столько памЯти, сколько заеимает
наибольший"член.
  Использование  объефиненай   таким  образом,   хтобы  при  чтхнии
значения всегда  применягся тот  члеН, с  прйменением которого  онп

   !  `                      - стр 75 -

записывалось,  совершенно `!оптимально.  Но  в  больших  програм¬ах
непросто гарантировать,  что объедиеения  используются только таким
образом,  и  из-за  непррвильного  мспользования  могут `появляться
трудно уловимые  ошибки. Можно  капсуыизировать  объединение (такимЌ
образом, чтобы  соответствиз межфу  поkем тип` и типамк членов бъло
гарантированно правшыьным (#5.4.6).
  ОaъединениЯ иногда  испольуют (для  "преобразоваэия  типов"  (это
делают гкавным  образом программисты,  воспитд­ные  на  языках$  не
жбладающих  средствами   преобразования  ткпов,   где  жульниwество
явлпется неоеходамым).  Например,"это  "преобразует" на VAX'е int в
int*, просто предП®лагая побштовую эквивалентность:

  struc4 fudgE 
      union {
          inT  i;
 !      " iot* p;
      };
  };

  fudge a;
  a.i = 4096;
  int* p = a.p;    // плохое испоыьзование

  Но на  самом деле  эъо совсеl  не  преобразование:  на  некоторых
машинах  "int и! int* занидают0неодинаковое количество памяти, а на
дрггих  никаКое   целое  не   может  иметь  нечетный  адрес.  Такое
применение объединений  непереносиьО, а  есть явный 4споспб указать
преобразование типа (#3.2.5).
  Изредка   объединенкя   умышленно   применяют,   чтобы   избежать
преобразпвания типов.  Можно, например,  мспользовать fudge,  чтобы
узнауь представление укизателя 0:

  fudwe.p = 0;
  int i = fudfe.i;    // i не!обязательmо должно быть 0
Љ  Можно  также   дать  объединению   имя,  то   зсть  хделать   его
полноправным тияом. Например, fudge можно было бы описать так:

 !wnion fudge {Љ          int  i;
          int* p;
  };

и использовать (непра"ильно) в точнnсти как ъаньше. Имеются также и
оправданпыд применения именованных объединений; см. #5.4.6.

     2.6 Упражнения

  1. (*1) ЗастАвьте работать программу с "Hello, world" (1.1.19.M
  2. (*1) ДЛЯ  каждого опи±ания  в #2.1  сделайте  следующее:  ЕслиЉ    $описание  не   ывляется  определемием, $ напишште   для   него
     определение. Если описание является опшеделением, напишите для
     него описвние, которое при этом не является определением.
  3. (*1) Напишите описания для: указаrеля на симвnл; веитора из 10
   0 целых; ссылки  на вектор  из 10  целых; указателя на вектор из

    $                        - стр 74 -
     символьных  строк;   укауателя   на   указатель   на   символ
 `   консТантного  целого;   указателя  на   конщтантное  целое;  и
     константноcо   ук з`теля    на!  целое.    Каждый    из    них
    (инициализируйте.  4. (*1.5) Напишhте программу, коІорая печатдЕт размеры`основн{х и
 "   указательных уипов. Ищпользуйте операцию sizeof.
  5. (*1.5) Напиъите  программі,0которая печатант буквы!'a'...'z' и
     цифры '0'...'9'  и их  числовуе значения.  Сделайте`то  ве для
`    остальмях печатаемыХ  символов. Сделайте  то же,  но испольgуя
     шесТнадцатиричную запись.
  6. (*0) Напечатайте набор битnв, которым представляется указатель
     0 на вбшей системх. Подсказка: #2.5.2.
  7. (*1.5)  Нбпишите   функцию,  печатающую   порядок !й  мануиссу
     параметра типа double.
  8. (*2)  КаКовы   наибольшие  и  наименьщие  значения,  нА  вишей
     системе, следующих  типов:  chcr,  short,  int,  long,  float,
   0 double$  unsigned,   char*,   inu*   и   void*?   Имеются   лh
     жоoолнительные ограничения  на принимабмые ими значения? Может
   0!ли,$ например,   int*   приниlатм   нзчзтное " еначение?   Как
" (  выравниваются в памяти объекты этих типпв? Может ли, например,
     int иметь!нхчетный адрес?
  9. (*9) Какое  ±амое длиннже  локальное имя  можно использовать в
     C+; программе!в вашей системе? Какое самое длинное внешнее имя
     можно использокать  в C++  прюграмме`в  вашей системе? Есть ли
    (какие-нибудь ограничения на символы, которые ¬ожно употребляць
     г имени?
 $10. (*2) Определите one следующим образом:

 !     const kne Ѕ 1;

!   $Попытайтесь  поменять   значение  one  на  2.  Определите  num
    (следующим образом:

       const num[] = { 1, 2 };

     ПопыцайтеСь поменять знаwение num[1}"эа 2.
  11. (*1) Напишите  функцию,(переставляющую  два целых   (меняющую
     значенъя). Используйте в качесте типб параметра int*. Напишите
     другую пнреставляющую 0фінкцию, ислользующую  в  качесте  типа
     параметра int&.
  13. (*1) Каков размер аектоса {tr в слздующеМ примерд:

  $    char strY]0=0"a short string";

   " Какова длина строки "a slort string"?Ќ
  13. (*1.5) ОпреДелите  таблицу названий месятев года и числа дней	
     в них.  Выведите ее. Сделайце это два раза: один фаз используя
     вектот для  названий и  велвор для  числа (дней,  и  один$ раз
     испо«ьзуя  вектор  структур,  в  каждой  из  которых  хранится
     название месяюа и"чиСло дней в нем.
  14. (*1) С (помощью typedef  определштҐ тизы:  беззнаковый  char3
     кОнстантный0беззнаковый char; указатель на целое; указатель на
     укдзатель на  #har; указатель на вектора символов; векrор йз 7
     целых указауелей;   указатель ­а вектор ип 7 целых указателей;
     и вектор из 8 вектоРок из 7 целых указатзлей.-

 "  `       `              Ллава ;

        "              Выражения и операторы

b  "                       `  " $                 С Другой стороны.
   !                   (     мы не можем игнорировать эффективность
                     0                                - Джон Бентли

  C++ имеет `неБольшоб, но  гИбкий набор разлИчных видов операторов
для контроля потока упрбтления в прогрбмме и бмгатый н`бор операцкй
для манипуляции  даннымиn С  накболее общепринятыми  среествами0вас
познакомит  один   законченный  яример.   ПослҐ   него   приводится
резюмирующий обзор  выражений и  с  еовольно  подробно  описываются
явное  описание   типа  и   р бота  со$$ свободной  памятью.  Потом
представлена враткая  сводка операций,  а в конце обсуждаются стиль
выравниванЁя* и комментарии.

0 @0 3.9 Настольный калькулятnр

  С операторами 0и выражениями  вас  познакомит  привеdеннач  здесь
программа  (настольпого   калькуkятора,   предост вляющего   четыре
стандартные арифметические опреациИ над числами с плааающей точкжй.
Нользователь может  такжЕ  определять  переменные.  Например,  если
вводится

  r=2.4
  apea=pi*r*r
(pi опренелнэо заранее), во проврамма калькуЛяткра напишет:

( 2.5
  19.635

гфе 2.5  - результат  первой`введенной сррпки, а"19.635 ­ резсльтат
жторой.
  Калькулятор  состоиц   из  четырех   ос­овэых  частей:  программы
синтаксияеского разбора  (par{er'а), функvии  ввода, таблицы иьен!и
управляющей  программы   (драйвера).  Фактичхски,! это( миншдтюрный
компилятор, в( котором программа синтаксического разбора производитM
синтаксихеский  анализ<   функция   вго¤а"  осуществляет   ввод   и
лексическйй  днализ,   в  таблице!  имен  хранится   долговременная
информация,  а  !драйвер  распоряжается  инициализцией,  выводом  и
обработкой  ошибок.   Можпо  было   бы  многое   добАвить  в   этпт
калькулятор, чтосы  сделать его  более п¦лезным,  но в существующем
вкде ята  программа и  так достаточно"длинна (200 строк), и большая
часць дополнительных  возмюжймстей прюсто  утеличит текст программыЌ
не давая дополнительного Пжнимания применения C++.

___[_________W_____J  * Нам  неизвестен русскоязычный термин, эквивалентный английскому
indentation. Иногда это называется отступами. (прим. перев.)

                             - стр 78 -

     3.1.1 Програмна синтаксического разбора

  ВоТ грамматика языка, допускаемого калькулятором:

  program:
      END          "         // END - это конец ввода
 (    expr_list END

 $expr_list:
      expression PRI^T      // PRINT - это или '\n'!или ';'
      expzession PRINT expr_list
  expression:
      expression + term
      expression - term
      term

  term:
      term / primary
      term * primary
      prmmary

  primarщ:
      ОUMBER                // число с плавающей точкой в C++
      NAME                  // имя C++ за исключением '_'
      NAME = expression
      / primary
      ( expression )

Другими словами¬  программа есть  последовательность строк.  Каждая
стржка состоит  из одног® мли более выражений- разделенпые запятой.
Основными элементами  выражения являются числа, имена и опербции *,
/, +,  - (унарный  и бинарный)  и =.  Имена не  обязательно  должны
описываться до использования.
  Используемый  метод  синтаксического  анализа  обычно  называется
рекурсивным спуском;  это популярный  и простой нисходящий метод. В
таком языке,  как C++,    в  котором  вызовы  функций  относительно
дешевы, этот  метод к  тому же  и эффективен.  Для каждого  правила
вывода  грамматики  имеется  функция,  вызывающая  другие  функции.
Терминальные символы   (например,  END, NUMBER, + и -) распознаются
лексическим  анализатором  get_token(),  а  нетерминальные  символы
распознаются функциями  синтаксического анализа  expr(),  term()  и
prim().  Как  только  оба  операнда  (под)выражения  известны,  оно
вычисляется; в  настоящем компиляторе  в  этой  точке  производится
генерация кода.
  Программа  разбора   для  получения   ввода  использует   функцию
get_token(). Значение  последнего вызова  get_token()  находится  в
переменной curr_tok;  curr_tok имеет  одно из значений перечисления
token_value:

  enum token_value {
      NAME        NUMBER    END
      PLUS='+'    MINUS='-'    MUL='*'    DIV='/'
      PRINT=';'    ASSIGN='='    LP='('    RP=')'
  };
  token_value curr_tok;

                             - стр 79 -

  В каждой  функции разбора  предполагается, что  было обращение  к
get_token(), и  в curr_tok  находится очередной  символ, подлежащий
анализу.  Это  позволяет  программе  разбора  заглядывать  на  один
лексический символ  (лексему) вперед  и заставляет  функцию разбора
всегда читать  на одну  лексему больше,  чем используется правилом,
для обработки  которого она  была вызвана.  Каждая функция  разбора
вычисляет "свое"  выражение и  возвращает значение.  Функция expr()
обрабатывает сложение  и вычитание;  она состоит из простого цикла,
который ищет термы для сложения или вычитания:

  double expr()                   // складывает  и вычитает
  {
      double left = term();

      for(;;)                     // ``навсегда``
          switch(curr_tok) {
          case PLUS:
              get_token();        // ест '+'
              left += term();
              break;
          case MINUS:
              get_token();        // ест '-'
              left -= term();
              break;
          default:
              return left;
          }
  }

Фактически сама функция делает не очень много. В манере, достаточно
типичной для  функций более  высокого уровня  в больших программах,
она вызывает  для выполнения  работы другие  функции. Заметьте, что
выражение 2-3+4 вычисляется как (2-3)+4, как указано грамматикой.
  Странная  запись   for(;;)  -   это  стандартный   способ  задать
бесконечный  цикл;  можно  произносить  это  как  "навсегда"*.  Это
вырожденная  форма   оператора  for;   альтернатива   -   while(1).
Выполнение оператора  switch повторяется  до тех пор, пока не будет
найдено ни  + ни  -, и  тогда выполняется  оператор return в случае
default.
  Операции +=  и  -=  используются  для  осуществления  сложения  и
вычитания. Можно  было бы  не изменяя смысла программы использовать
left=left+term() и  left=left-term(). Однако  left+=term() и  left-
=term()  не   только  короче,   но  к   тому   же   явно   выражают
подразумеваемое действие.  Для бинарной  операции @  выражение x@=y
означает x=x@y  за исключением  того, что x вычисляется только один
раз. Это применимо к бинарным операциям

  +    -    *    /    %    &    |    ^    <<    >>

поэтому возможны следующие операции присваивания:

  +=    -=    *=    /=    %=    &=    |=    ^=    <<=    >>=

____________________
  * игра слов: "for" - "forever" (навсегда). (прим. перев.)

                             - стр 80 -

  Каждая  является  отдельной  лексемой,  поэтому  a+  =1  является
синтаксической ошибкой  из-за пробела  между +  и  =.  (%  является
операцией взятия  по модулю;  &,| и ^ являются побитовми операциями
И, ИЛИ  и исключающее  ИЛИ; <<  и >>  являются операциями  левого и
правого сдвига).  Функции term()  и get_token() должны быть описаны
до expr().
  Как организовать  программу в  виде набора  файлов, обсуждается в
Главе 4.  За одним  исключением все  описания  в  данной  программе
настольного  калькулятора   можно  упорядочить   так,   чтобы   все
описывалось ровно один раз и до использования. Исключением является
expr(), которая  обращается к  term(), которая обращается к prim(),
которая в  свою очередь  обращается к expr(). Этот круг надо как-то
разорвать; описание

  double expr();    // без этого нельзя

перед prim() прекрасно справляется с этим.
  Функция  term()  аналогичным  образом  обрабатывает  умножение  и
сложение:

  double term()                    // умножает и складывает
  {
      double left = prim();

      for(;;)
          switch(curr_tok)    {
          case MUL:
              get_token();         // ест '*'
              left *= prim();
              break;
          case DIV:
              get_token();         // ест '/'
              double d = prim();
              if (d == 0) return error("деление на 0");
              left /= d;
              break;
          default:
              return left;
          }
  }

  Проверка, которая  делается, чтобы  удостовериться в том, что нет
деления на  ноль, необходима,  поскольку результат  деления на ноль
неопределен и  как правило  является роковым.  Функция error(char*)
будет описана позже. Переменная d вводится в программе там, где она
нужна, и сразу же инициализируется. Во многих языках описание может
располагаться  только   в  голове   блока.  Это  ограничение  может
приводить к  довольно скверному  искажению  стиля  программирования
и/или излишним  ошибкам. Чаще всего неинициализированнные локальные
переменные являются  просто признаком  плохого  стиля;  исключением
являются переменные,  подлежащие инициализации посредством ввода, и
переменные векторного  или структурного  типа, кторые нельзя удобно

                             - стр 81 -

инициализировать одними  присваиваниями*. Заметьте,  что = является
операцией присваивания, а == операцией сравнения.
  Функция prim,  обрабатывающая primary,  написана в основном в том
же духе, не считая того, что немного реальной работы в ней все-таки
выполняется, и  нет нужды  в цикле,  поскольку мы попадаем на более
низкий уровень иерархии вызовов:

  double prim()                 // обрабатывает primary (первичные)
  {
      switch (curr_tok) {
      case NUMBER:              // константа с плавающей точкой
          get_token();
          return number_value;
      case NAME:
          if (get_token() == ASSIGN) {
              name* n = insert(name_string);
              get_token();
              n->value = expr();
              return n->value;
          }
          return look(name-string)->value;
      case MINUS:               // унарный минус
          get_token();
          return -prim();
      case LP:
          get_token();
          double e = expr();
          if (curr_tok != RP) return error("должна быть )");
          get_token();
          return e;
      case END:
          return 1;
      default:
          return error("должно быть primary");
      }
  }

  При обнаружении  NUMBER (то  есть, константы с плавающей точкой),
возвращается  его  значение.  Функция  ввода  get_token()  помещает
значение в  глобальную  переменную  number_value.  Использование  в
программе  глобальных   переменных  часто   указывает  на  то,  что
структура не  совсем прозрачна,  что  применялась  некоторого  рода
оптимизация.  Здесь   дело   обстоит   именно   так.   Теоретически
лексический  символ   обычно  состоит  из  двух  частей:  значения,
определяющего вид лексемы (в данной программе token_value), и (если
необходимо) значения  лексемы. У  нас имеется  только одна  простая
переменная  curr_tok,  поэтому  для  хранения  значения  последнего
считанного NUMBER  понадобилась глобальная переменная number_value.
Это  работает   только  потому,  что  калькулятор  при  вычислениях
использует только одно число перед чтением со входа другого.
  Так же,  как значение  последнего встреченного  NUMBER хранится в
number_value, в  name_string   в виде  символьной  строки  хранится
представление последнего прочитанного NAME. Перед тем, как что-либо
____________________
  * В  языке немного  лучше этого с этими исключениями тоже надо бы
справляться. (прим. автора)

                             - стр 82 -

сделать  с  именем,  калькулятор  должен  заглянуть  вперед,  чтобы
посмотреть, осуществляется  ли присваивание  ему,  или  оно  просто
используется. В  обоих случаях надо справиться в таблице имен. Сама
таблица описывается  в #3.1.3;  здесь надо  знать только,  что  она
состоит из элементов вида:

  srtuct name {
      char* string;
      char* next;
      double value;
  }

где next используется только функциями, которые поддерживают работу
с таблицей:

  name* look(char*);
  name* insert(char*);

  Обе возвращают  указатель на  name, соответствующее  параметру  -
символьной строке;  look() выражает  недовольство, если имя не было
определено. Это  значит, что  в калькуляторе можно использовать имя
без  предварительного   описания,  но   первый   раз   оно   должно
использоваться в левой части присваивания.

     3.1.2 Функция ввода

  Чтение ввода  - часто самая запутанная часть программы. Причина в
том, что  если программа должна общаться с человеком, то она должна
справляться с  его  причудами,  условностями  и  внешне  случайными
ошибками. Попытки  заставить человека  вести себя более удобным для
машины  образом   часто   (и   справедливо)   рассматриваются   как
оскорбительные. Задача  низкоуровненовой программы  ввода состоит в
том, чтобы читать символы по одному и составлять из них лексические
символы более  высокого уровня. Далее эти лексемы служат вводом для
программ  более   высокого  уровня.   У  нас  ввод  низкого  уровня
осуществляется get_token(). Обнадеживает то, что написание программ
ввода низкого  уровня не  является ежедневной  работой;  в  хорошей
системе для этого будут стандартные функции.
  Для калькулятора  правила ввода  сознательно были выбраны такими,
чтобы функциям  по работе  с потоками  было  неудобно  эти  правила
обрабатывать; незначительные изменения в определении лексем сделали
бы get_token() обманчиво простой.
  Первая сложность  состоит в  том, что  символ новой  строки  '\n'
является для калькулятора существенным, а функции работы с потоками
считают его  символом пропуска.  То есть,  для  этих  функций  '\n'
значим только  как ограничитель лексемы. Чтобы преодолеть это, надо
проверять пропуски (пробел, символы табуляции и т.п.):

  char ch

  do {    // пропускает пропуски за исключением '\n'
      if(!cin.get(ch)) return curr_tok = END;
  } while (ch!='\n' && isspace(ch));

                             - стр 83 -

  Вызов cin.get(ch)  считывает один  символ из  стандартного потока
ввода в ch. Проверка if(!cin.get(ch)) не проходит в случае, если из
cin нельзя  считать ниодного  символа; в  этом случае  возвращается
END,  чтобы   завершить  сеанс  работы  калькулятора.  Используется
операция  !  (НЕ),  поскольку  get()  возвращает  в  случае  успеха
ненулевое значение.
  Функция (inline)  isspace() из  обеспечивает стандартную
проверку на  то, является  ли символ пропуском (#8.4.1); isspace(c)
возвращает ненулевое значение, если c является символом пропуска, и
ноль в  противном случае.  Проверка реализуется  в  виде  поиска  в
таблице,  поэтому  использование  isspace()  намного  быстрее,  чем
проверка на  отдельные символы  пропуска;  это  же  относится  и  к
функциям isalpha(),  isdigit() и  isalnum(), которые используются в
get_token().
  После  того,   как  пустое   место  пропущено,   следущий  символ
используется для  определения того, какого вида какого вида лексема
приходит. Давайте  сначала рассмотрим  некоторые  случаи  отдельно,
прежде чем  приводить всю  функцию. Ограничители  лексем '\n' и ';'
обрабатываются так:

  switch (ch) {
  case ';':
  case '\n':
      cin >> WS;    // пропустить пропуск
      return curr_tok=PRINT;

Пропуск  пустого   места  делать  необязательно,  но  он  позволяет
избежать повторных  обращений к  get_token(). WS  - это стандартный
пропусковый объект,  описанный в ; он используется только
для сброса  пропуска. Ошибка  во вводе  или конец  ввода  не  будут
обнаружены до следующего обращения к get_token(). Обратите внимание
на то,  как можно  использовать несколько  меток case (случаев) для
одной и  той же  последовательности операторов,  обрабатывающих эти
случаи. В  обоих случаях  возвращается лексема PRINT и помещается в
curr_tok.
  Числа обрабатыватся так:

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case '.':
      cin.putback(ch);
      cin >> number_value;
      return curr_tok=NUMBER;

  Располагать метки  случаев case  горизонтально, а не вертикально,
не очень  хорошая мысль,  поскольку читать  это гораздо труднее, но
отводить по одной строке на каждую цифру нудно.
  Поскольку операция  >> определена  также и  для чтения констант с
плавающей точкой  в double,  программирование этого  не  составляет
труда: сперва начальный символ (цифра или точка) помещается обратно
в cin, а затем можно считывать константу в number_value.
  Имя, то  есть лексема  NAME, определяется  как буква,  за которой
возможно следует несколько букв или цифр:

                             - стр 84 -

  if (isalpha(ch)) {
      char* p = name_string;
      *p++ = ch;
      while (cin.get(ch) && isalnum(ch)) *p++ = ch;
      cin.putback(ch);
      *p = 0;
      return curr_tok=NAME;
  }

  Эта часть  строит в  name_string строку,  заканчивающуюся  нулем.
Функции isalpha()  и   isalnum() заданы  в ; isalnum(c) не
ноль, если c буква или цифра, ноль в противном случае.
  Вот, наконец, функция ввода полностью:

  token_value get_token()
  {
      char ch;

      do {    // пропускает пропуски за исключением '\n'
          if(!cin.get(ch)) return curr_tok = END;
      } while (ch!='\n' && isspace(ch));

      switch (ch) {
      case ';':
      case '\n':
          cin >> WS;    // пропустить пропуск
          return curr_tok=PRINT;
      case '*':
      case '/':
      case '+':
      case '-':
      case '(':
      case ')':
      case '=':
          return curr_tok=ch;
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
      case '.':
          cin.putback(ch);
          cin >> number_value;
          return curr_tok=NUMBER;
      default:            // NAME, NAME= или ошибка
          if (isalpha(ch)) {
              char* p = name_string;
              *p++ = ch;
              while (cin.get(ch) && isalnum(ch)) *p++ = ch;
              cin.putback(ch);
              *p = 0;
              return curr_tok=NAME;
          }
          error("плохая лексема");
          return curr_tok=PRINT;
      }
  }

                             - стр 85 -

  Поскольку     token_value  (значение   лексемы)   операции   было
определено  как  целое  значение  этой  операции*,  обработка  всех
операций тривиальна.

     3.1.3 Таблица имен

  К таблице имен доступ осуществляется с помощью одной функции

  name* look(char* p, int ins =0);

  Ее второй  параметр указывает,  нужно ли сначала поместить строку
символов  в  таблицу.  Инициализатор  =0  задает  параметр,  кторый
надлежит использовать по умолчанию, когда look() вызывается с одним
параметром. Это  дает удобство записи, когда look("sqrt2") означает
look("sqrt2",0), то  есть просмотр,  без помещения в таблицу. Чтобы
получить  такое   же  удобство  записи  для  помещения  в  таблицу,
определяется вторая функция:

  inline name* insert(char* s) { return look(s,1);}

  Как уже отмечалось раньше, элементы этой таблицы имеют тип:

  srtuct name {
      char* string;
      char* next;
      double value;
  }

Член next используется только для сцепления вместе имен в таблице.
  Сама таблица - это просто вектор указателей на объекты типа name:

  const TBLSZ = 23;
  name* table[TBLSZ];

Поскольку  все  статические  объекты  инициализируются  нулем,  это
тривиальное описание  таблицы table  гарантирует  также  надлежащую
инициализацию.
  Для нахождения  элемента в  таблице в  look() принимается простой
алгоритм хэширования  (имена с одним и тем же хэш-кодом зацепляются
вместе):

  int ii = 0;        // хэширование
  char* pp = p;
  while (*pp) ii = ii<<1 ^ *pp++;
  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

То есть, с помощью исключающего ИЛИ каждый символ во входной строке
"добавляется"  к  ii  ("сумме"  предыдущих  символов).  Бит  в  x^y
устанавливается   единичным    тогда   и    только   тогда,   когда
соответствующие биты  в x и y различны. Перед применением в символе
исключающего ИЛИ,  ii  сдвигается  на  один  бит  влево,  чтобы  не

____________________
  * знака этой операции. (прим. перев.)

                             - стр 86 -

использовать в  слове только  один байт.  Это можно было написать и
так:

  ii <<= 1;
  ii ^= *pp++;

Кстати, применение  ^ лучше  и быстрее,  чем  +.  Сдвиг  важен  для
получения приемлемого хэш-кода в обоих случаях. Операторы

  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

обеспечивают, что  ii будет лежать в диапазоне 0...TBLSZ-1; % - это
операция взятия по модулю (еще называемая получением остатка).
  Вот функция полностью:

  extern int strlen(const char*);
  extern int strcmp(const char*, const char*);
  extern int strcpy(const char*, const char*);

  name* look(char* p, int ins =0)
  {
      int ii = 0;        // хэширование
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= TBLSZ;

      for (name* n=table[ii]; n; n=n->next)    // поиск
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;                     // вставка
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = table[ii];
      table[ii] = nn;
      return nn;
  }

  После вычисления  хэш-кода ii  имя находится  простым  просмотром
через поля  next. Проверка  каждого name  осуществляется с  помощью
стандартной функции  strcmp(). Если строка найдена, возвращается ее
name, иначе добавляется новое name.
  Добавление нового  name включает в себя создание нового объекта в
свободной  памяти   с  помощью   операции  new  (см.  #3.2.6),  его
инициализацию,  и   добавление  его   к  списку   имен.   Последнее
осуществляется просто путем помещения нового имени в голову списка,
поскольку это  можно делать  даже не  проверяя, имеется список, или
нет. Символьную  строку для  имени тоже нужно сохранить в свободной
памяти. Функция strlen() используется для определения того, сколько
памяти нужно,  new -  для выделения  этой памяти,  и strcpy() - для
копирования строки в память.

                             - стр 87 -

     3.1.4 Обработка ошибок

  Поскольку программа  так проста,  обработка ошибок  не составляет
большого труда.  Функция обработки  ошибок просто  считает  ошибки,
пишет сообщение об ошибке и возвращает управление обратно:

  int no_of_errors;

  double error(char* s) {
      cerr << "error: " << s << "\n";
      no_of_errors++;
      return 1;
  }

  Возвращается значение  потому, что  ошибки обычно  встречаются  в
середине  вычисления  выражения,  и  поэтому  надо  либо  полностью
прекращать вычисление,  либо возвращать  значение, которое  по всей
видимости  не  должно  вызвать  последующих  ошибок.  Для  простого
калькулятора  больше   подходит  последнее.   Если  бы  get_token()
отслеживала  номера   строк,   то   error()   могла   бы   сообщать
пользователю, где  приблизительно обнаружена  ошибка. Это наверняка
было бы полезно, если бы калькулятор использовался неитерактивно.
  Часто бывает  так, что  после появления  ошибки программа  должна
завершиться,  поскольку  нет  никакого  разумного  пути  продолжить
работу. Это  можно сделать с помощью вызова exit(), которая очищает
все вроде  потоков вывода  (#8.3.2), а  затем  завершает  программу
используя свой параметр в качестве ее возвращаемого значения. Более
радикальный  способ  завершения  программы  -  это  вызов  abort(),
которая обрывает  выполнение сразу  же или  сразу после  сохранения
где-то информации  для  отладчика  (дамп  памяти);  о  подробностях
справьтесь, пожалуйста, в вашем руководстве.

     3.1.5 Драйвер

  Когда все  части программы на месте, нам нужен только драйвер для
инициализации и  всего того, что связано с запуском. В этом простом
примере main() может работать так:

  int main()
  {
      // вставить предопределенные имена:
      insert("pi")->value = 3.1415926535897932385;
      insert("e")->value = 2.7182818284590452354;

      while (cin) {
          get_token();
          if (curr_tok == END) break;
          if (curr_tok == PRINT) continue;
          cout << expr() << "\n";
      }

      return no_of_errors;
  }

                             - стр 88 -

  Принято  обычно,   что  main()  возвращает  ноль  при  нормальном
завершении программы  и не  ноль в  противном случае,  поэтому  это
прекрасно может  сделать возвращение  числа ошибок. В данном случае
оказывается,  что   инициализация   нужна   только   для   введения
предопределенных имен в таблицу имен.
  Основная работа  цикла -  читать выражения  и писать  ответ.  Это
делает строка:

  cout << expr() << "\n";

  Проверка cin  на каждом  проходе  цикла  обеспечивает  завершение
программы в  случае, если с потоком ввода что-то не так, а проверка
на END  обеспечивает корректный  выход из  цикла, когда get_token()
встречает конец  файла.  Оператор    break  осуществляет  выход  из
ближайшего содержащего  его оператора  switch или  цикла (то  есть,
оператора for, оператора while или оператора do). Проверка на PRINT
(то есть,  на '\n'  или  ';')  освобождает  expr()  от  обязанности
обрабатывать  пустые   выражения.  Оператор   continue   равносилен
переходу к самому концу цикла, поэтому в данном случае

  while (cin) {
      // ...
      if (curr_tok == PRINT) continue;
      cout << expr() << "\n";
  }

эквивалентно

  while (cin) {
      // ...
      if (curr_tok == PRINT) goto end_of_loop;
      cout << expr() << "\n";
      end_of_loop
  }

  Более подробно циклы описываются в #с.9.

     3.1.6 Параметры командной строки

  После того,  как  программа  была  написана  и  оттестирована,  я
заметил, что  часто набирать выражения  на клавиатуре в стандартный
ввод надоедает,  поскольку обычно использование программы состоит в
вычислении одного  выражения. Если  бы можно  было представлять это
выражение как  параметр командной  строки, не  приходилось  бы  так
много нажимать на клавиши.
  Как уже  говорилось, программа  запускается вызовом main(). Когда
это происходит,  main() получает  два параметра:  указывающий число
параметров, обычно  называемый argc,  и вектор  параметров,  обычно
называемый argv.  Параметры -  это символьные  строки, поэтому argv
имеет  тип  char*[argc].  Имя  программы  (так,  как  оно  стоит  в
командной строке)  передается  в  качестве  argv[0],  поэтому  argc
всегда не меньше единицы. Например, в случае команды

  dc 150/1.1934

                             - стр 89 -

параметры имеют значения:

  argc        2
  argv[0]        "dc"
  argv[1]        "150/1.1934"

  Научиться пользоваться  параметрами  командной  строки  несложно;
сложность   состоит    в   том,    как    использовать    их    без
перепрограммирования.  В   данном  случае  это  оказывается  совсем
просто, поскольку поток ввода можно связать с символьной строкой, а
не с файлом (#8.5). Например, можно заставить cin читать символы из
стандартного ввода:

  int main(int argc, char* argv[])
  {
      switch(argc) {
      case 1:        // читать из стандартного ввода
          break;
      case 2:        // читать параметр строку
          cin = *new istream(strlen(argv[1]),argv[1]);
          break;
      default:
          error("слишком много параметров");
          return 1;
      }

      // как раньше
  }

  Программа осталась  без изменений,  за исключением  добавления  в
main() параметров  и  использования  этих  параметров  в  операторе
switch. Можно  было бы  легко модифицировать  main() так, чтобы она
получала несколько  параметров командной строки, но это оказывается
ненужным, особенно потому, что несколько выражений можно передавать
как один параметр:

  dc "rate=1.1934;150/rate;19.75/rate;217/rate"

  Здесь  кавычки  необходимы,  поскольку  ;  является  разделителем
команд в системе UNIX.

     3.2 Краткая сводка операций

  Операции  C++  подробно  и  систематически  описываются  в  #с.7;
прочитайте, пожалуйста,  этот раздел.  Здесь же  приводится краткая
сводка и  некоторые примеры.  После каждой  операции приведено одно
или   более   ее   общеупотребительных   названий   и   пример   ее
использования. В  этих примерах имя_класса - это имя класса, член -
имя члена,  объект -  выражение, дающее в результате объект класса,
указатель  -  выражение,  дающее  в  результате  указатель,  выр  -
выражение, а lvalue - выражение, денотирующее неконстантный объект.
Тип может  быть совершенно  произвольным именем  типа (со  *, ()  и
т.п.) только  когда он  стоит в  скобках, во всех остальных случаях
существуют ограничения.

                             - стр 90 -

  Унарные операции  и операции  присваивания правоассоциативны, все
остальные левоассоциативны. Это значит, что a=b=c означает a=(b=c),
a+b+c означает (a+b)+c, и *p++ означает *(p++), а не (*p)++.

             Сводка Операций (часть 1)
   ---------------------------------------------------------------
   -----
   ::        разрешение области видимости   имя_класса :: член
   ::        глобальное                     :: имя
   ---------------------------------------------------------------
   -----
   ->        выбор члена                    указатель->член
   []        индексация                     указатель [ выр ]
   ()        вызов функции                  выр (список_выр)
   ()        построение значения            тип (список_выр)
   sizeof    размер объекта                 sizeof выр
   sizeof    размер типа                    sizeof ( тип )
   ---------------------------------------------------------------
   -----
   ++        приращение после               lvalue++
   ++        приращение до                  ++lvalue
   --        уменьшение после               lvalue--
   --        уменьшение до                  --lvalue
   ~         дополнение                     ~ выр
   !         не                             ! выр
   -         унарный минус                  - выр
   +         унарный плюс                   + выр
   &         адрес объекта                  & lvalue
   *         разыменование                  * выр
   new       создание (размещение)          new тип
   delete    уничтожение (освобождение)     delete указатель
   delete[]  уничтожение вектора            delete[ выр ]
   указатель
   ()        приведение (преобразование типа)     ( тип ) выр
   ---------------------------------------------------------------
   -----
   *         умножение                      выр * выр
   /         деление                        выр / выр
   %         взятие по модулю (остаток)     выр % выр
   ---------------------------------------------------------------
   -----
   +         сложение (плюс)                выр + выр
   -         вычитание (минус)              выр - выр

  В  каждой  отчерченной  части  находятся  операции  с  одинаковым
приоритетом. Операция  имеет  приоритет  больше,  чем  операции  из
частей, расположенных  ниже. Например:  a+b*c означает a+(b*c), так
как *  имеет приоритет  выше, чем  +,  а  a+b-c  означает  (a+b)-c,
поскольку  +   и  -  имеют  одинаковый  приоритет  (и  поскольку  +
левоассоциативен).

                             - стр 91 -

            Сводка Операций (часть 2)
   ---------------------------------------------------------------
   -----
   <<       сдвиг влево                     lvalue << выр
   >>       сдвиг вправо                    lvalue >> выр
   ---------------------------------------------------------------
   -----
   <        меньше                          выр < выр
   <=       меньше или равно                выр <= выр
   >        больше                          выр > выр
   >=       больше или равно                выр >= выр
   ---------------------------------------------------------------
   -----
   ==       равно                           выр == выр
   !=       не равно                        выр != выр
   ---------------------------------------------------------------
   -----
   &        побитовое И                     выр & выр
   ---------------------------------------------------------------
   -----
   ^        побитовое исключающее ИЛИ       выр ^ выр
   ---------------------------------------------------------------
   -----
   |        побитовое включающее ИЛИ        выр | выр
   ---------------------------------------------------------------
   -----
   &&       логическое И                    выр && выр
   ---------------------------------------------------------------
   -----
   ||       логическое включающее ИЛИ       выр || выр
   ---------------------------------------------------------------
   -----
   ? :      арифметический if               выр ? выр : выр
   ---------------------------------------------------------------
   -----
   =        простое присваивание            lvalue = выр
   *=       умножить и присвоить            lvalue = выр
   /=       разделить и присвоить           lvalue /= выр
   %=       взять по модулю и присвоить     lvalue %= выр
   +=       сложить и присвоить             lvalue += выр
   -=       вычесть и присвоить             lvalue -= выр
   <<=      сдвинуть влево и присвоить      lvalue <<= выр
   >>=      сдвинуть вправо и присвоить     lvalue >>= выр
   &=       И и присвоить                   lvalue &= выр
   |=       включающее ИЛИ и присвоить      lvalue |= выр
   ^=       исключающее ИЛИ и присвоить     lvalue ^= выр
   ---------------------------------------------------------------
   -----
   ,        запятая (последование)          выр , выр

                             - стр 92 -

     3.2.1 Круглые скобки

  Скобками синтаксис  C++ злоупотребляет;  количество  способов  их
использования  приводит   в  замешательство:  они  применяются  для
заключения в  них параметров  в вызовах  функций, в них заключается
тип в  преобразовании типа  (приведении к типу), в именах типов для
обозначения функций, а также для разрешения конфликтов приоритетов.
К счастью,  последнее требуется не слишком часто, потому что уровни
приоритета и  правила  ассоциативности  определены  таким  образом,
чтобы выражения  "работали ожидаемым  образом" (то  есть,  отражали
наиболее привычный способ употребления). Например, значение

  if (i<=0 || max
3.2.2 Порядок вычисления

  Порядок вычисления подвыражений в выражении неопределен. Например

  int i = 1;
  v[i] = i++;

                             - стр 93 -

может вычисляться  или как (v[1]=1, или  каъ v[2]=1. При отсутствии
огранЁчений на" поряджк вычисления( выражения может  генерироваться
более  хпроший  код.  Было  бы  gамечательно,  если  бы  компилятпр
предупрбждал"  о    поеобных   неоднозначнОстях,   но   бnльшинстўо
компиляцорож этого не делают.
  Отнобительно операций

  ,    &&    ||

гбрантируерся, что их левый опҐранд вычиспїется раньше, чем правый.
Нап°имер, "=(a=2,a=1)  присвоит b  3. В  #3.3.1 приводятся  приМеpы
ибяользования &$  и  ||.  Еаметьте,  что  онзрация  последжвания  ,
(запятая) ыогически отличается от запятой, которря используeтсч дкяJрагееления параметрмв в вызове функцйи. Фассмотрим

  f1 v[i],i++-;     ! //!два паррметра
  f2( (v[i],h++) )   !+/ один Параметр

В вязове  f1 два  параметра,  v[i]  и  i++," и  порядок  вычаслеmивыраЖений-параметров неопредекен.  Еависиморть0 выражения-параметаа*nт  порядка   вычиuления    -  это !очень  пЛохоЙ  стиль,  а` также
непереmосимо. В "вызове$f2  один  параметр,  выражение  С  запятой,
которое эквивалентно y).
  С помощью  скобок нельзя  задарь  порядок  вычисления.  Наoример,
a*(b/c	 можер  вычисляться и  как  a*b)/c,  поскольку *  и /  амеют
одинаковый  праоритҐт.   В  тех!  случаяu,  когда ( важен   порядок
жычисления,  можйо  вводить  дополнИъельмую  переиенную,  например.
(t=b/c,a*t).

     3.2.2 Увеличение и уменьёение*

  Операция ++  используется для  явного выражения приращеэия вместоего  неявного   выражения   с " помощью   комбинвции   слмжения   ипшисваивания. По  определению ++lvalu%  означает lvalue+=1,  что 0в	свою(очеаедь  огначает lvalue=lvalu%+1  при услогии,  что lvalue не
вызывает  никакиф(  побочных  эффектов.   Cыражение,   пбознахающее
(денотирующее) объект, (который долоеН  быть увеличен,  вычисляется
один рАз$ (толькк). Андлогично, уменьшение выражбетбя операцией --n
Опердции ++  и $--  могут  применпться  и  как  паефиксные,$ и как
постфиКсные. ‡наченидм  ++x является  новое (Іо  есть  увеличенное)
значҐние0x.  Например, y=++x  эквивалент­о y=(z;=1).  Значенид x++,
напротив< есть  старое знаїение  x.  Например(  y=x++  эквиаалеэтнк
y=(t5x,x+=1,t), гме p - переменная тоўо же типа, что и0x/
  Операции придащения (особенно полезны для увеличения и гменьшения
переменных в (цикkах. Например.  оканчиваѕyуюся нулем "строку можно
ккпировать так:

  inline void cpy,cha2* p, coNst chaz* q)
  {
      while (*x++ = *q++- ;
  }
___________________
  * Следовало  бы пeсевофить  как "инкремент" и "декремент", nднако
мы следювали  терминологии, принятой! в"переводной литературе по C,
поскольку эти пперациа унаследованы от B. (Прим. перев.)

                             - стр 94 -

Напомню,  что  уЖеличение  и  уменьшение  указателей,  так  же  каj
сложение  и   bычиуание  укаЗате«ей,  dосуществляется  в$  терминае
элементов жектора,  на кюторые0 указывает ука§втель; p++ зриводит к
тому, что p указывает на следующий элемент. Для уъазателя p тмпа T*
по олредеыению выполняетСя(следующме:

  long(p+1) ==0long(p)+sizeob(T);
     3.2.4 Побитовые логачесъие операции

  Побитовъх логические оПерации

  &   0|    ^    ~    >>    <<

применяются к целым$ то есть к объектам типа char, sxort, int, long-
и их uоsig.ed аналогам, фезультаты!тожб целые.
  Одно из (стандартпых(применЕний  побитовых ыогичесЄих  ппераций -
реализация маленькиогк  множества (вектора  битов). Ж  этом  случае
Ъаждый бит  беззнакового целого$представляет один Член множества, а
число  членов`  ограничено  чисыом   битовn  Бинарная  $операция  &
интерпретишуется как  пересечение,  |  как  объздинение,  а  ^  как
разностф. Для имееокания"член®в такого мнмжества ¬ожно использжвать
перечисление. Вжт  маленький прймер,  заимствованный(из  рнализрции
(не полЬзовательского0инІзрфелса) :

  enum state_value { _good<0- _eof=1$ _fail=2, _bad=4};
                   // хорошп, кЋне¶ файла, ошибJв, плохо
Оптеделение _good  не Являерся  не®бходкмым. Я  пфостж хотел, чrfбы
состояние, когда  всб в  порпдке, имеко "подходящее иМя.  Бостояние
потока можно усъановить занкво следующио образом:
  cou|.stAte = _good;

  Нвпример, так  мозно проверить,  не был  ли  испорчен" oоток0 или
допущен` операционная ошибка:

  if (cout.wtata&(_bad|_fail)) // не go/d

Еще  однй  скобки  необходимы,  поскольъу  &  амееъ  более  высокик*приоритет, чем <.  Функфия, достигающая конца ввода, может сообщатм об этом так:

! cin.spaue |= _eof;

Опeрация |=  использчется потому,"чуо!поток уже мОжет быть испмрчен
(то есуь, sdate==_bad), поэтому

  cin.spate`= _eof;

очистл® бы"этот`пригнак. РазличЁе двух потоКов можно находмть так:

  уtate_falue diff = cin.stateVcout.state;

                             - утр 95 -

В сkучае  тип  stream_state  собтояние потока)  такаї разность  неЉоченэ мужна,  но для  dругих похових  типов она  оказывает±Я  самой
полезной. ЌаЇример," прЁ  сравнении  вектора  бмт,  премставляющнго
меожество   прерываний.    jоторые   обрабатлваются,    с   дрчгимl
®редставляющим прерывания, Ждущкз обрабжтки.
  Следует   замeтить,    чтѕ   использование   полеi   (#2.u.1)   в
дейсувительности!является сокращенной записью сдвига и маскирования
для иевлечения  полей бит из слова. Это, конхчно, можно(сделауь и(с
по¬ощью погитовых логйчесиих опеРаций, Например, извлечь среднке 06
еит из 32-битоволо йnt м®жно следіющим образюм:

  unsigоed short middle(int a) { return (c>>8)&0xfvff; }

  Нх  путайте   поaитоbые   лоуические   операюии   с   логическимh
опешациями:

  &&!   ||    !

  Последние!вочвращают  0 или 1, и они главныь обрд§ом используются
для записи  проверки в  операторае  ifm  while  или  for  (#3.31).
НапримЕр, !0  (нз нолЬ)  естэ знвченИе  1, тогд  как ~0 )дополнение
нуля!  есть   набор  битов  все-единицы," котюрый  обычно  яв{яется
значением /1.

     3.2.5 Преобррзованще типа

  Бывает необхОдимо  явно  преобразовать  значение  одного` типа  вз­ачейие другого.  Явпое преобразование  типа дает` значение одного
типа длЯ динного gначения другого"типа. НаприМер:

  float R = float(1);

пеРзд присваиванием  пРеобразует целое  значенhе  1  j" значению  с
плавающей точкой (1.0. Результат  преобразоваеиея типа 0не является
lvahue, поэтому ему0нельзя нрисваивать (еслЁ только тип не является
ссылnчным типом).
  Есть два  способа записи(яв­ого преображования типа: традицимнная
в C  заяибј!привбдения  к Типу   double)a h  функциональная  запись
double(a). Функционалэн я  зрпксь`не  можетприменяться  мля типов,
Кжтошые не  имеют пРостого  имени.  Например,  чвобы  преобразжвать	
значение  к   указателЬному  типу   эадо0 иги  использовать  заПмсь
прhведения

! char* p`= (char*)0777;

йли nпрефелит| новое имя типа:

  typedef char* Pchar;  chiv* p =!Prhar(0777);

По моему  мнЕнию, функционильная  запЁсь  в  нҐтривиалјных  случаях
предпочтительна. Рассмотрим джд эквивапентных примера

                      "     $- стр 96,-

  Pname n2 =0Pbase(n1)>tp)->b_name;   "   (// функциональная заПись
  Pname ns = ((Pbase)n2->tp)-b_naee;        ?/ запЁсь приведееиы к
 !типу

Поскольку операция  -> имеет  больший  приоритзт,  чем  псиведение,
послдднее выражение интерпреrируется как

  ((Pbase)(n2->tp))->b_fame

С помощью  явного зреобраз®вания  типа к  указатҐлэнщм типам  м®жно
сымитироват|,  что   оaъект  имеет   совершеннж  Произвкльный  тип.-
Например:

` any_type* p = (any_type*)&soнe_object;
пжзвкпкт работать  посредством p  с некоторым  объеєтом some_oFjeat
как с`любым типом any_type.  КОгда преобразованид  тип` не  нбОбходимоl его  следует избегать.
Првграммы, в которых иСпользуется мпого явэых преобразnваний типов,
труднез понимать,  чеь те,  в котnрых это не делаерс* Однако такие
прогр ммы легче  понимать, ·ем  программы, просто  не  использующие
типы для  представления понятий( более гысокого  уровня  (например,
прОграмму, которая оперйрухт регистром устройсъва с нЮмющью  сдвига
h маскирования,  вместо того, "чrобы определить пОдходящую svbuct иЌ
оперировать  ею;  см.  #2.5.2).  Кроме `того,  правильнюсть  явногопреобразования типа  часІо критическим образ®м зависит от пюниманшя
прогрдммистом  того,   каким  образом   объбкты   разлиуных   типов
®брабатываюуся в  языке, и  очень часто от подробностей реализации.Напримбр:

  int i = 1;
  ch`r* pc = "asdg";
  int* pi = &i9

  i = (int)pc;
  pc = (char*)i;  ! // остерегайтесь: значение pc может ижмениrься
      $             /? на нек®торых машинах
       0            // sizmof(in4)
3.2.6 Свободная п мять
Ќ( ИмннованНый обzект является либо статическим, либо автоматмческиь
(см. #2.1Ї3)" Статичзский  объект  размещается `во  время  запуска
программы  и  существует  в  течение  всего  кылоЛнения  проcраммы.Автоматихехкий объект риз¬ещВетщя каждый шаз при"аходе!в"его блок ш
существует только  до тех пор, пока из }того блока не вышли. Однако
часто еываеу яолезно создбть новый ®бъект, хуществующий до тЕх пор,
пока оm  не станeт  больше0Не  нужей. В  частности,  часто  пnлеено
созdать  объект,  которЫй  можно  мспольповать  после $возвСАца  из
функции, г¤е( он создается.  Вакие мбъeкты  создаеу операция new, а
впослддствие уничтожать  их можно  операцией delute.  Про  объекты,
выделенные с  помощЬю жперации  new, говорят,  что они  в сbободнол
памяти. Такими  объектами  обычно  явыяьтся  вершины  деревьев  илш
элементу связанныu  списожв, являющие±я  частью  еольшей  стрыктуры
даннлх, размер кот®рой не может быть известен на стидии компиляции.Рассмотрим,  квм  `можно  было   бы  написдть   кюмпилятор  в  духе
написанного  ндсто«ьного   кил|кулятора.  Функции   симтаксическово
анализа мпгут  стрмить дрнвовидНое представленид выраОениб, которое*будет(ихпкльзоbаться при генерации кода. Например:

  struct enode {
      token_6alue oper;
      enode* left;
   !  e.odej right;
  };

  mnode* ex0r()
  {  enode* left = term();

  for;;)
  ! ` cwitch(aurr_4ok) {
      case PLUS:M
  (!  case0MINUS:	
$         get_tokdn()+         !enodu* n = new enode;
          n->oper = cubr_tkk;          n>left = left;	          n-?righф$= term()3
      "   мeft = n;
          break;
      default:
          re4urn left{
      }
  m

Получающееся дерево генератор кода может использовАтј например так:

  !                          - стр 98 -

  void wenesqte(enode* o)
  {
     !swiuch (n)>nperi {
     "case PLUS:
    !     // делает нечто соответствуюшее
    0     deleTe n;
      }
  }

  Жбъект, соеданный  с помощью `new, существует  пока он  не будзт
явно    унЁчтозен  deldte,  похле  чего  прострайство,  которое  он
занимал,  опять  может  испольgоваrься  new.    Никакогк  "сборщhка
мусораў,$ который  аищет  объекты¬   на  кюторые!  mет  ссылок,   иЌ
предоставляет их  в распоряжение  new, нет.  Опдрация delete  можзт
применяться тольъо к указатдль* коворыб был возвраыеп операцей new,
ила к нулю. Применение delete к нтлю не тызывает никАких аействий.
  С зомощью new можео также создавать вектора объбктов. НаЇример:J
  clar* seve_sdring(char* p)
  {
      char* s } nEw0char[strlen(p)+1];0     strcpy(s,p);
      return s;
  }
Следузт замеrить,` что чтобы  освободить  пространство,  выделенное
ndw, delete  должна ймбць возможность опрЕ¤злить разиер выделенного
объекта. Йапример:

  int mdin()ft argc, ciar* argv[Э)
  {
      if (argc < 2) exit(1);
      chcr: p = save_string(argv[1]);
      delete p:
  }

Ято приводит(к тооу, что объект, выделенпый стандартной реализачиҐй
oew, будет  занимать больше  месца, чем  статический обыект (обыно,
больше mа пдно слмво).
  Йожно также  Яўно указлврть размер$веjrора в операции унмчтожения
delete. Например:
  int0main(int ergc, char* argv[])
 "{
 $    if (argc < 2) eшit(1);
      int size = strlen(argv[1])+1;
 (    char. p = save_string(argv[1]);
      delete[size] p;
  }Ќ

Заданпый пользователем !ррзмЕр0вектора  кгнорирухтся за исключениемнекоТорых типов, определяемых п®льзоварелем (#5.5.5).J  Операции свободной пдмяти реализуются функциями (#с&7.2/3):

  void operator new(lono);
  void operator delete(void*);:
       ( 	     "             - стр 99 -
*  Стандартная сеализажhя lew не инициализирует возвришвемый объeът.
  Что происходит,  когд`  new  не "наuодит  памяти  для  выделепия?
Поскольку  даже  виртуильная0 память  конечна,  это  иногда  фолжно
происходить. Gапрос вроде

  cHar* p ? new char[1p000000];

как правило,  приводит к каким-тм неприятностпм. Когма у lew ничего
не" получается,   она  вызыжахт  функцию,  указываемую  чкажаетелем
_ndw_handler (указатели на функциh обсуждаются в #4.6.9!.$Вы$можете
задать указатель  явно или  использовать функцию set_new_handler().Например:Ќ
	
  #include

  void out_of_store()
  {Ќ
      cerr <<`"опеРация new не прошла:"gа преdелами памяти\j#;
0     exit(1);
( }

  typedef void (*PF)();    // тмп ыказАтель на функцию
J  extern PF set_new_lan ler(PF);

  maйn()
  {
      set_new_han$ler(ouu_of_stor%);
     (char* p = new char[100000p00];
   `  cout <4 "хдeлано- p = " << long(р) <> "\n";
  }

Как правиыо,  не будет  писать  "Сделано",  в  будет  вместо  этого
выдавать
  операция new mЕ прошла:`за пределами памятиm

  _new_handLer может днлать и кое­чъо поумнее, чем просІо заверрдтьвыполнение програьмы.  Если вы  пнаете, как! работают ne и delete,
йапрммер, потому,  что вы  зад`ли свои собственные operator new() и
operator  femete(),  проГрамма  обрабятки  может  попытаться  найти
некоторое  количещтво   памяти,  которое   возв°атит( new.  Другимш
словамЁ, пользователь  мовет бделать  сборщшк мусорв. сделав, таким
образом, использпв`ние deleфe ннобязатепьным. Но это, конечно, все-таки задача ­е для начинающего.
  Яо историческим  причин`м new прохтк возвращает(указатель$0, есла-
она не  может найти  достаточное воличество  памяти и  не был задан
никакой _new_handlev.0Например
-
  include

  main()
  {
      char* p = new char[10000p000\;      cout << "сделано, p = " <ј long(p) << "\n";  }

  а      !                   - стр 100 -

выдаср

( сделано, p`= 0M
Вам  сделаги   предупреждение%  Жаметэте,!  что  тот,   кто  задает
_new_h`~dler, берет на себя заботу по провешке!истощения памїти при
каждом использовании  new в  програме (за исклюуенЁем случая. когда
пользовдТель задал  Отдельные подпроcраммы  для размещения объектовЉзаданных типов, определяемых пользователзм; см. #5.5.6).
     3.3 Сводка опер`торов

  Оператошы  C++   щисрематиче±ки  И  полНостью  изложены  в$`#с.9,
прочиъайте, пожалуйсуа,  этот раздел.  А здесь  приводится  краукая
сводка и некоторые пршмеры.

             "       `     Синтаксиу оператори
   -------------------------------------------------------%-----
   -----
 ¤ операторє
       описайиҐ
       {список_операторкв opt}
     ! выражение opt

       if Ё выраженин ) опреарор
       if$( выРажениe ) опер`цор mlse оператор
      `swmtch ( выражение ) ппбратор
     $ wlile ( влражение ) оператор
       do оператор while (выражение)
     ! жor ( оператор  выражение opt ; выражение opt ) пператор

       case констанъное_вырижение :`операrор
       default : оператор
 "    $break ;
       гonvmnue ;

       rgturn въражение opt ;

    (  goto hдентификатор ;
     " идентифиКатор : оператмр

       списов_опер торов:
          &оператор
           Опешаумр списжк_опер торов

  Gаметьте, что  описание являетуя оператором, и что нет операторов
п°исваикамия и  кызова  прочедуры.  Присваивание  и  в»зов (функцИи
ойрабатываются как выраfҐния.

              0              - стр 10y -

     7.3.1 Проверки

  Протерка значения  может жсуществыяться  или оператотпм 0if,  илй
операторnм switch:

  if ( выражение ) оператор
  if ( выраженйе ) олератор elSu опхраторЌ
  switch ( вырацение ) оператор

  В C++ нет оrделмнмго булевского типа. Ояервции сравнения

  ==    !=    <    <=    >    6=

Возвxащают цдлое  1, еСли сравнение$истинно, иначе аозврайаЮт!. Не
тао уж  непривычно вкдеть,  что ИСТИНА  определена как  1¬  а  ЛОЖЬ
опредeлена как 0.
  В операторе  if пешвый 4(или единственнуй) опервтор гыполняется в
вюм0случае,  бсли выражеЙие  ненулдвое,  иначе  выпоЛняется  второй
оператор"(если  он збдан).  Отсюда следуец,  уто в качестве условия
может использовАться  любое целОе  выражение. В  частности, если! a
целое, то

  if (a) // ...

эквиВалентнn

  if (a != 0) // ...

 $Логические операцки

  &&    ||    !

наиголее часто $используются!в  тсловиях. Операции && и ||(не будут
вычислять второл аргумент, если это ненуж­о. Напри¬ер:

  if (p 6& 1count) // ...

вначаке проверяет,  является ли  p не нулем, и толькм есйи это так,
то проверїет 1count.
  Некоторые oростыб" операторы if  могут быть  с удобством заменены
выражениями арифнетического if. Например:

  iv (a <= d)
      max ? b;
  else
      max = a;

лучше выраfаетсЯ так:
  max = (a<=b)"? b :"a;Љ
Скобки вокруг !условия необязательны,  но я  считаю, что  когда онЁ
используются, программу легче читать.
  Некоторые простыз  операторы switch 0можно по-дсугому  записать в
виде набора0операторов if. Например:

                             = стр 102 -

  switch (vam) {
  case 5:
      f*);
      break;
  case 2;
      з();
      break;
  default:
      h();
      break;
  }

иначе можно быkо бы записать так:

0 if"(val == 1)
      f();
  else if (val == 2)
      g();
  else
    $ h();

  Смысл тот  же, однако  первый вариант  (switch) предпо·тйтельнее,
яоскольку  в   этом  случае   явно  выражаеІся   сущность  действия
(сопоставление знбчения  с рядом констант). Поэтому в йетривиальmых
случаях опер тор switch0чмтаеюся легче.
  Заботьтесь о  том, чтп  switc( должен  как-то "завершаться,  дсли
то«юко(вы не хотите, чтобы выполнялся у«емующий case. Например:

  switgh (val) {    // осторожно
  casе 1:
      cout << "case 1Ьn";
  case 2;
      bout << "case 2\n";
  default:
     (cout << "default: case нe mайден\n";
  }

при val==1 напечатает

  case 1
  case 2
  default: casE не найден

к великому изімлению некосвященного. Самый обычный способ завершить
случай - это break, иногда можно даже использовать goto.$Напримеp:

                       !      стр 103 -

  switch (val) {    // осторожэо
  cese 0:
      cout << "case 0\n"{
  case1:
 $case 1;
      cout << "case 1\n";
    # return;
 !gasm 2;
      cout << "case 2\n&;
      goto cas%1;
 "default:
    0 cut << "default2 case не найден\n;
      return;
! }

При обращении к нему с val==2 выдабт

  case 2
  case 1

Заметьте, что  метка case  нҐ подходит как метка для употребленhя в
операторе goto:

  go4o case 1;      ( // синтаксическая!ошибка

     3.3.2 Woto*
  C++ снабжен имеющим дурную репутацию оператором goto.-

  goto идентификатот;
 "идентификатор : оператор

  В ®бщем,  в программировании  высокого уровня он имеец очень мало
применений, эо  он может  быть очень  полезен, когда  C++ програмlа
генерируется программой,  и не  пишется непосшед±твенно  человеком.
Например,  операторы   goto  можно  использовать  в  синтаксическом
анализаторе, порождаемом  генератором синтаксических  анаkизаторов.
Оператор copo  может быть0 также вижен  в реХ рееких случаях, ъnгда
важна наиыучшая эффективность, например, во внутреннем цикле какой-
нигудь пРограммы, работающей В реальном"времени.
  Одно  из   немногих  разумных  применений  состоит  в  выходе  из
вложенного  цикла   или  пешеключателя   (break   лишь   прекращает
выполнение  самого   внутреннего  охватывающего   его   цикла   или
переключателя). Н`пример:

  for (int i = 0; i
3.4 Комментарии и Выравнивание

  Промуманное   использогание    комментариев    и    согласованное
использование отступов  может сделать  чтение и понимание программы
нвмного  болех  приятным.  Сущещтвует (несколько  различных  стилей
согласованноЈо  исЇользования  отступов.  Автор  не  видит  никаких
серьезных  оснований   предпочесть  одмн  другому  (хотя  как  и  у
бо«ьринства с  меня есть $свои предпочтения).  Сказинное относится
также и к$стилю комментариеж.
  Неправильное исполјзование0 ломмейтариев может  серьезно повлиять
на удобочитаемость  программы, Компилявор  не  понимает  содержание
комментария, поэтому  он никаКим рпособом не может убедиться в том,
что комментарий
  [1] осмлслен;  [2] описывает п°ограмму; иM
  [3] не устарел.
  Непонятные,  двусмыленные   и  просто0  неправильные 0jомментарии
содержатся в  большинстве программ.  Плохой комментарий  может`быть*хуже, чем никакой.
  Если что-то можно сформулировать средствами самого языка, Следует
это сдегать,  а не  просто отметить в комментарии. Данное замeчание
относится к коммеэтариям вшоде:

  ./(оеременная "v" догжна быть инициализироваНа.

  // переменная "v" должна использоваться толЬкп функциҐй "f()".
  // вызвать$фтнкцию init() перед вызовом
  // любой другой функции в этом файле.

  // вызовите функцию очиститки "cleanup()" в конюe вашей
  программы.

  // не используйте функцию "wierd()".

 $// функция "f()" получазт два параметра.

При правильном  использовании C++ $подобные комменварии как пр вилоЌ
становятся ненужными. Чтобы предыдущие комментарии стали излишмими,
можно,  наЇример,   использпвать  правила   комноновки   (#4.2)   и
видимостьl  инициализацию   и  правила  очистли0 для  классов  (см.
#5.5.2)*
  Если  что-то0 было  ясно  сформулироврно  на  языке,  второй  раз
упоминать это в комментарии не следует. Например:

  a = b+c3    // a станпвится!b+c
  count++;    // увеличить счетчик

Такие комментарии  хуже чем  просто излишни,  они уўеличквают осъед
теъса, который  надо прочйтрть,  они часто  затума­ивают  структуру
прогрдммы, и они могут быть неправильными.
  Аввор предпочитает:
Ќ                      `     !- стр 105 -

  [1] Комьентарий для каждого"исходного файлв, сообщающий, дкя чего
     в целом  предназначнны находящиеся  в нем  коммейтарии, дающий
     ссылки на  спракочники и  рукпводсрва, общие  рекомендации  по
     использованию и т.д.;
" [2\ Комментарий  длэ  каждой  нетРквиальной! функции,  в  котором
     сформулировано ее  назначение, использгемый  алгоритм (если юн
     неочевиден)  и,   быъь  может,  что-то (о  принимаемых  в  ней
     предположениях относительно с°едъ выполнения;
  [] Небольщое число  комментариев в  тех  местах.  где  программа
     неочевидеа И/или непереносhма; и
  [] Очень мало чтм еще/
  Наяример:

! // tb|.k: РеалИзация твблицы имен
  /*
      Гауусовское исключение с частичнымЌ
      Ум. Ralston: "A first course ..."$стр. 411.
  j/

  // swap() прeдполагает размхщение стека AT&T sB20/
-
  /*******************************(******

      Copyright (c) 1984 AT&T, Inc.
     "Anl rights reserved

  ***********************
*****.**********/
-
  Удачно подобранные"Ё хорошо написанные комментарии - сгщественначасть програмМы. Написание фороших комментариев может быть столь же
сложным< сколь ш написание самой пpограlмы.
  Gаметьте тавже,  что если "в функции  используются  исключительно
комментарии //,  то любую часть этой функюии можно закоммхнтироВать
с помощью комментариев /* */, и наоборот.

     3.5 Упражнения

  1. (*1) Перепишите  следующиi оператор  for в виде"экживалентного
     оператора while:

       for (i=0; Im
       *p.m
       *a[I]

  7. (*2)  Напишите функции:  strlen(),  которая pвозвращант  длину     стфоки, strcpy(),  ооторая кжпирыҐт  одну`строКу  в другую,  и
     strcmp(), которая  сравнивает две  строки. Разберйтесь,  какие
     должны быть  типы парамхтров  и типы  возвращаемых значений, а
     потом сравнице  их со стандартными версиями, ккт®рые описаны в
      и в вашем руководсуве.
  8. (j1) Посмотрите, как ваш компилятор реагмрует на ошибки:

       a := b+1;
       if (a = 3) //`...
       if (a&077 == 0) // ...

     Придумайте орибки попрощх, и посмотрите, вак компилятор на нах
     реагирует.
  =. (*2)  Напишиъе   функцЁю  cat(),   полсчающгю  два   строковых
$    парамЕтра   и    возвращающую   строку,    которая  ` является
     конкатенацией параметров.  Используйте new, чтобы наити память
     для  результата.  Mапишите  функцию  rev(),  котораэ  получает
     строкч и  переставляет в  ней символы  в обратпом  порядке. То
     есть,  после  вызова  rev(p)  последний $символ  p (становится
     первым.
  1p. (*2) Что делает следуюыая программа?

                 0           - стр 107 -

  $    void send(recister* to, register* from, register0count)
   $   // Пплезные(л®мментарии несомненно уничтожены.
       {
           regispeт n=(count;7)/8;
           switch (c/unt%8) {
           !   case 0: do {a   *to++ = *from++;
 (             case 7: do {    *to++ = *from++;
     !         case 6: do {    *to«+ = *from++;
               case 5: do {    *tз++ = *from++;
             0 case 4: do {    .to++ = *from++;
               case 3: do`{ ` !*to++ = *from++;
         $     case 2: do!{    *to++ = *from++;
               case 1: do {    *to++ = *from++;
                   while (--n>0);
   (       }
       }

     Заяем кто-то мог написать нецто похожее?
  11. (*2)  Напищите   функцию  atoi(),  которая  лолучает  строку,
     содержащую  цифры, и возвращает соответствующее int. Напрммер,
     atoi("123") -  это 123. Моаифицируйте adoi() так, чтобы помимо
     обычной  десятичной   она  обрабатывала`  еще  восьмеричную  и
     шестнадцатмричную записи  C++. Нодифицирыйте atoi() так, чтобы
     обрабатывать записш  символьной  вонстанты.  Напишмте  функцию
     itoa(), которая  съроит представление  целого параметра в виде
     строки.
  12. (*:i Перепишите  get_token() (!3.1.2),  чтобы она за ожин раз
  $  читала строкт  в буфер- $а  затеь  составляла  лекщемы, "читая
     символы из буфе°а.
  13. (*2) !Добавьте   в  настрольный  каkькулютор  из  #3.1 dтакие
     функции, как  sqrt(), log()`и sin(). ПодскАзка: предопределите
     имзна и  вызывайте функции  щ помощью  вектора  указателей  на
     функции. Не забывайте проверять пдраметры в вызове функции.
  14.`(*3) "Дайте пользователю  тозможность (определять  функции  в     настольном калькуляторе.  Подсказка: определяйтҐ  функции  как
     яоследовательность  действий,   прямо  так,   как  их   набрал
     польпователь. Такую  последовательность можно  хранить(или как
     символьную строкі,  или как  сЇисок лексем. После этого, когда
     функция выжывается, читайте и выполняйте эти дейсттия. Если вы
     хотите, чтобы  зользовательская функция получала парамевры, вы
     докжны придумать форму записи этого.
  15. **1.5) Преобразуйте  настольный калькулятор так, чтоаы вместо
     ститических    пешеменных   ( оamg_string    и    number_value
     использовалась структура символа symbol:

       strucu symbol {
           token_value tok+
   "       union {
               double number_value;
               char* name_string;
           };
       u;

  16. (*2.5) Напишите программу, которая выбсасываеr комментарии из
     C+; программы.  То есть,  читает из  cin, тдаляет  // и  /* */
     комментарии и пишет резулјтат в cout. Не заботьтесш о приятmом

                             - стр 108 -

     вкде выходного тексТа (это могло бы быть другим, более сл®жным
     упражнение¬).  Не$  беспокойтесь  о   правильности   программ.
     Остерегайтесь //  и /*  и  */  внутри  комментариев,( хтрок  и
$    символьных консвант.
  17. (*3) Посмотрите  какие-нибудь программы, чтобы понять принцкп
     разпичных  стилей   коммеэтирования  и  выравнивания,  которые
     используются на практике.


          "                Глава 4

                          Ьункции и Файйы

                             (       Итерация свойственна человеку,
     !                                         рекусия божнстгенна.
                             (                    " - Л.!Питер Дойч

  Все нетрижи`льные  программы собираются  из нескольких  раздельно
компилируемых едиmи¶  (их принято  напывать просто файлами). В эІой
главе  описано,   как  раздельно  откомпилированные  функции  могут
обращаться  друг   к  другу,  как  такие  фунлции  м®гут  совместно
пользоўаться данными $(разделять данные),  и как  можмо  обеспечить
согласованность  типов,   которые  используются   в  разных  файлах
программы>  Функции  обсуждаются  довольно  подрпбно.  Сюда  входяв
передача$ оараоетров,   параметры  по  умоЙчанию,  перегрузка0 имен
функцкй, и,  конечно же,  описанае и  определҐние фуноций.  В конце
описываются макрохы.

  ( "4.1 Введепие

  Иметь всю  программу в  одном файле  обычно невозможно, поскольку
коды стандартнъх  библиотек и опетационной системы нАходятся где-то
в другом  месте. Кроме  того, хранить  вехь текст  oользовательской
программы в  одном файле как правило mепрактично и неудобно. Способ
организации программы  в файля  может помочь чиrающему охватить всю
структуру программы,  б также  может дать  возможность$ компилятору
реализовать эТу  структуру. Поскольку  единицей компиляции являетСя
файл, то во всех случаях, когда в файл вносится измейение (сколь бы
мало оно  ни былк),  весь файл муцно компилировать заново. Даже для
прозраммы    умеРенных    размеров    время,    затрачиваемое    на*перекомяипяциЮ,! можно  значительно  снизить  с `помощью  ррзбиения
программы на файлы0подходящих размеров.
  Рассмотрим пример  с калькулятором.  Он был  представлен  в  виде
пдного ищходного tайла. Если вы его набили, тю у вас нбверняка были
небогьшие трудности( с расположением описаний в яравильном порядке,
й пришлось  использовать по меньёей мере одно "фальшивое" опасание,
чтобЫ  компhkятор   смог  обработать  тзаимно  рекурсивные0 функции
expr(), term()  и prim((. 0В тексте  уже отмечалосьl  что пРограмма
состоит йп  четырбх  ч стей  (леЄсического  анализатора,  программы
синтаксического разбора,  таблицы имен и драйвера), но это никак не
было отражено  в тексте  самой программ{. По сути дела, калькулятор
был написан  зо-другому. Так  этм не  делвеrся; даже  если  в  этой
программе "на0 выброс" пренебречь  всеми соображениями  методологии
программирования, эjсплуатации  и эфdективн®сти  компиляцкиl  авТор
все равно  разобьет эту  программу в`200 сурок на неслолько файлов,
чтобы програмировать еыло oриятнее.
""Программа,  состояшая   из "нескольких 0 раздельно  комЇилируемых
файkов, должна  быть согласпванной  в снысге  использования имен  и
типов, точно так же, как и программа, ±пстоящая из одного исходного
файла. В принципе, это может обеспечить и компоновщик*. Компоновщик
- это  программа, стыкующая отдельно скомпилирОванные части вместе.
_____________^_____
  * или линкер. (прим. перев.)
!                    "       - стр 110 -

Компоновщик  часто   (путая)   называют   загрузчиком/   В   UNIX'е
компоновщик  называется   ld.  Однако  $компоновщики,  имеющиеся  в
большинстве систем,  оеесзечивают очень  слабую oоддержку  нроверки
согласованности.-
  Программист может скомпенсировать недостаъок0поддержки со сторОны
кnмпоновщика, (предоставик   дополнительпую  информ цию  $n   типах
(описания). После  этого соглАсованность  oрограммы "обеспечивается
проверкой согласованности  описаний, кОторые  находятся в  отдельно
компипируемъэ ·асъях. (Средства, которые  эво обеспечивают, а вашей
системе будут. C++ разработан так, чтобы способств®вать Іакжй явной
компоновке**.

     4.2 Компоновка

  Ехли не указано иное, то имя, не яbляющееся локальным для фынкции
Или класса, ` в  каждой части  программы,  компилируемой  отдельно,
аолжно относиться  к однооч  и тому  же типу, пначению, функции или
объелту. То  есть, в  программе может  быть только омhн ндлокальный
тин, значение,  ґункция  или  объект  у  этид  именем.  Рассмотрим,
напрммер, два Файла:

  // file1.c:
(     int a = 1;
      int f() { /* что-тn делает */ }

  // file2.c:
      extern int a;
      int f();
      void g() { a = f(); }

a и f(), ищпользуеоые g() в фаiле file2.c,- те же, чтп определены в
файле dile1.c.  Ключевое  слово  extern  (жнешнее)  указыврет,  что-
описание  a $ в  file2.c   является  (только)   описанием,   а   не
определением. Если  бы a  иниvиализировагось, extern былп бы прОсто
прюигнорировано,  посколькг   описание  с   инициалипацией   гсегда
является  определением.  Объект "в  программе  должен  определяться
только один  раз. Описываться  он можеъ  много раз,  но типы должны
точно соглдсовываться.(Мапример:
  // gila1.c:
      inф a = 1;
      int b = 1;
      extern int c;

" // file2.a:
      int a;
      extern double b;
      extern int c;

____________________
  ** C  разработан  так,  чтобы  в  большинстве  случаев  позволять
осуществлять неявную  компоновку. Применение  C,  однако,  возросло
неимоверно,  поэтому   случаи,  когда  можно  использовать  неявную
линковку,  сейчас  составляют  незначительное  меньшинство.  (прим.
автора)

                             - стр 111 -

Здесь  три   ошибки:  a   определено  дважды   (int   a;   является
определением, которое  означает  int  a=0;),  b  описано  дважды  с
разными типами,  а c  описано дважды,  но не  определено. Эти  виды
ошибок (ошибки  компоновки) не  могут быть обнаружены компилятором,
который за один раз видит только один файл. Компоновщик, однако, их
обнаруживает.
  Следующая программа не является C++ программой (хотя C программой
является):

  // file1.c:
      int a;
      int f() { return a; }

  // file2.c:
      int a;
      int g() { return f(); }

  Во-первых, file2.c  не C++,  потому что  f() не  была описана,  и
поэтому  компилятор  будет  недоволен.  Во-вторых,  (когда  file2.c
фиксирован) программа  не будет скомпонована, поскольку a определно
дважды.
  Имя можно сделать локальным в файле, описав его static. Например:

  // file1.c:
      static int a = 6;
      static int f() { /* ... */ }

  // file2.c:
      static int a = 7;
      static int f() { /* ... */ }

  Поскольку каждое  a  и  f  описано  как  static,  получающаяся  в
результате программа  является правильной.  В каждом файле своя a и
своя f().
  Когда  переменные  и  функции  явно  описаны  как  static,  часть
программы легче  понять (вам  не надо  никуда больше  заглядывать).
Использование static  для  функций  может,  помимо  этого,  выгодно
влиять на расходы по вызову функции, поскольку дает оптимизирующему
компилятору более простую работу.
  Рассмотрим два файла:

  // file1.c:
      const int a = 6;
      inline int f() { /* ... */ }
      struct s { int a,b; }

  // file1.c:
      const int a = 7;
      inline int f() { /* ... */ }
      struct s { int a,b; }

  Раз правило  "ровно одно  определение" применяется  к константам,
inline-функциям и  определениям функций так же, как оно применяется
к функциям и переменным, то file1.c и file2.c не могут быть частями
одной C++  программы. Но  если это  так, то  как же два файла могут
использовать одни  и те  же типы и константы? Коротко, ответ таков:

                             - стр 112 -

типы, костанты  и т.п.  могут  определяться  столько  раз,  сколько
нужно, при  условии, что  они определяются  одинаково. Полный ответ
несколько более сложен (это объясняется в следующем разделе).

     4.3 Заголовочные Файлы

  Типы во  всех описаниях  одного и  того же  объекта  должны  быть
согласованными. Один  из способов  это достичь  мог бы  состоять  в
обеспечении средств  проверки типов  в компоновщике, но большинство
компоновщиков  -   образца  1950-х,   и  их   нельзя  изменить   по
практическим соображениям*.  Другой подход  состоит  в  обеспечении
того,  что  исходный  текст,  как  он  передается  на  рассмотрение
компилятору,  или  согласован,  или  содержит  информацию,  которая
позволяет   компилятору    обнаружить    несогласованности.    Один
несовершенный, но простой способ достичь согласованности состоит во
включении заголовочных  файлов, содержащих интерфейсную информацию,
в исходные  файлы,  в  которых  содержится  исполняемый  код  и/или
определения данных.
  Механизм включения  с помощью  #include - это чрезвычайно простое
средство обработки  текста для  сборки кусков  исходной программы в
одну единицу (файл) для ее компиляции. Директива

  #include "to_be_included"

замещает строку,  в которой  встретилось #include, содержимым файла
"to_be_included". Его содержимым должен быть исходный текст на C++,
поскольку дальше  его  будет  читать  компилятор.  Часто  включение
обрабатывается отдельной  программой, называемой  C препроцессором,
которую CC вызывает для преобразования исходного файла, который дал
программист, в  файл без  директив включения  перед тем, как начать
собственно компиляцию. В другом варианте эти директивы обрабатывает
интерфейсная система  компилятора по мере того, как они встречаются
в исходном  тексте. Если  программист хочет посмотреть на результат
директив включения, можно воспользоваться командой

  CC -E file.c

для препроцессирования файла file.c точно также, как это сделала бы
CC перед  запуском собственно  компилятора. Для включения файлов из
стандартной  директории   включения  вместо   кавычек  используются
угловые скобки < и >. Например:

  #include       // из стандартной директории включения
  #define "myheader.h"     // из текущей директории

  Использование  <>   имеет  то   преимущество,  что   в  программу
фактическое имя  директории включения не встраивается (как правило,
сначала просматривается  /usr/include/CC, а  потом usr/include).  К
сожалению, пробелы в директиве include существенны:

  #include < stream.h >    // не найдет
____________________
  * Легко  изменить один  компоновщик,  но  сделав  это  и  написав
программу, которая  зависит от  усовершенствований, как  вы  будете
переносить эту программу в другое место? (прим. автора)

                             - стр 113 -

  Может показаться,  что перекомпилировать  файл заново каждый раз,
когда он  куда-либо включается,  расточительно, но время компиляции
такого файла обычно слабо отличается от времени, которое необходимо
для чтения его некоторой заранее откомпилированной формы. Причина в
том,   что    текст   программы    является   довольно   компактным
представлением программы,  и в  том, что  включаемые  файлы  обычно
содержат только  описания и  не  содержат  программ,  требующих  от
компилятора значительного анализа.
  Следующее эмпирическое  правило относительно того, что следует, а
что  не   следует  помещать   в  заголовочные  файлы,  является  не
требованием языка, а просто предложением по разумному использованию
аппарата #include.
  В заголовочном файле могут содержаться:

 Определения типов           struct point { int x, y; }
 Описания функций            extern int strlen(const char*);
 Определения inline-функций  inline char get() { return *p++; }
 Описания данных             extern int a;
 Определения констант        const float pi = 3.141593
 Перечисления                enum bool { false, true };
 Директивы include           #include
 Определения макросов        #define Case break;case
 Комментарии                 /* проверка на конец файла */

но никогда

 Определения обычных функций  char get() { return *p++; }
 Определения данных           int a;
 Определения сложных
  константных объектов        const tbl[] = { /* ... */ }

  В системе  UNIX принято,  что заголовочные  файлы  имеют  суффикс
(расширение) .h.  Файлы, содержащие определение данных или функций,
должны   иметь    суффикс   .c.   Такие   файлы   часто   называют,
соответственно,  ".h  файлы"  и  ".c  файлы".  В  #4.7  описываются
макросы. Следует заметить, что в C++ макросы гораздо менее полезны,
чем в  C, поскольку C++ имеет такие языковые конструкции, как const
для определения  констант и inline для исключения расходов на вызов
функции.
  Причина  того,   почему   в   заголовочных   файлах   допускается
определение простых констант, но не допускается определение сложных
константных объектов,  прагматическая. В  принципе,  сложность  тут
только в  том, чтобы  сделать допустимым  дублирование  определений
переменных (даже  определения функций  можно было  бы дублировать).
Однано для  компоновщиков старого  образца слишком трудно проверять
тождественность нетривиальных  констант и убирать ненужные повторы.
Кроме того,  простые случаи  гораздо более  обиходны и потому более
важны для генерации хорошего кода.

     4.3.1 Один Заголовочный Файл

  Проще всего  решить проблему  разбиения  программы  на  несколько
файлов поместив  функции и  определения данных  в подходящее  число
исходных файлов и описав типы, необходимые для их взаимодействия, в
одном заголовочном  файле,  который  включается  во  все  остальные

                             - стр 114 -

файлы. Для  программы калькулятора  можно  использовать  четыре  .c
файла: lex.c,  syn.c, table.c  и main.c,  и заголовочный файл dc.h,
содержащий описания  всех имен,  которые используются  более чем  в
одном .c файле:

  // dc.h: общие описания для калькулятора

  enum token_value {
      NAME,    NUMBER,    END,
      PLUS='+',    MINUS='-',    MUL='*',    DIV='/',
      PRINT=';',    ASSIGN='=',    LP='(',    RP=')'
  };

  extern int no_of_errors;
  extern double error(char* s);
  extern token_value get_token();
  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern double expr();
  extern double term();
  extern double prim();

  struct name {
      char* string;
      name* next;
      double value;
  };

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) { return look(s,1); }

  Если опустить  фактический код, то lex.c будет выглядеть примерно
так:

  // lex.c: ввод и лексический анализ

  #inгlude$"dc.h*
  #include

  token_valu% curr_tok;
  double number_value;
  char name_string[256];

  token_value get_token() { /* ... */ }

Заметьте, что  такое иупойьзование заголовочных файлов гарантирует,
что каждое  ояисание в  заголовочном файле  объекта, `определенного
пользователем, будет  в какой-то  момент вълючено  в файл,  где  он
определяется. Например,  при  кОмпиляции  lex.c  компилптюру  будет
передано:

  extern token_vclue get_token();
  // ...
  token_value get_token() { /* ... */ }

           0                 - стр 115 -

Ято   обеспечивает    то,   что    компилчтор    обнаружкт    любую
несогласованность в  типахl указанных  для имени. Например, если бы*get_token()`была  описана кик возвращающая token_value, но при ятом
определена как  возвращаощая int, компиляция lex.c не проъла бы из-
за ошибки ­есоответствия типов.
  Файл syn.c будет выглядеть примерно так:

  // syn.c: синтаксический анализ и вычисление

  #include "dc.h"

  double prim() { /* ... */ }
  double term() { /* ... */ }
  double expr() { /* ... */ }

  Файл table.c будет выглядеть примерно так:

  // table.c: таблица имен и просмотр

  #include "dc.h"

  extern char* strcmp(const char*, const char*);
  extern char* strcpy(char*, const char*);
  extern int strlen(const char*);

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Заметьте, что  table.c  сам  описывает  стандартные  функции  для
работы со  строками, поэтому  никакой проверки согласованности этих
описаний нет.  Почти всегда  лучше включать  заголовочный файл, чем
описывать имя  в .c  файле как  extern. При  этом может  включаться
"слишком много",  но это  обычно не оказывает серьезного влияния на
время, необходимое  для компиляции,  и как  правило экономит  время
программиста. В  качестве примера  этого, обратите  внимание на то,
как strlen() заново описывается в main() (ниже). Это лишние нажатия
клавиш и  возможный источник неприятностей, поскольку компилятор не
может проверить  согласованность этих  двух опредхлзний.  На  самом
деле, этой( сложности можно  было бы  избежать, будь  bсе  описания
extern  пкмещены   в  dc.h,   как  и   предлагалось  сделать.   Эта
"небрежность" сохранена  в программе,  поскольку это  очень типичноJдля C  программ, очень  соблазнительно  для  пСограммиста,  и  чаще
приводит, чем  не приводит, к ошибкам, которЫе"трудно обнаружить, иЉк программам, с иоторыми тяжело работать. Вас предупредили!
  И main.c, наконец, выглядиц так:

                             - стр 116 -

  // main.c: инициализация, главный цикл и обработка ошибок

  #include "dc.h"

  int no_of_errors;

  double error(char* s) { /* .., */ }

  extern inф strlen(const char*);

  main(int argc, char* argv[]) { /* ... */ }

  Гажнъй $случай,   когда  размер  заголовочных  файлов  становится
берьбзной помехой.  Набор з`головочных  файлок и  библиотеку  можно
использовать для  шасширения языка  множеством обще-  и специально-
прикладных типов  (см. Главы  5-8).  В  таких  случаях  не  принято
осуществлять чтение тысяч строк заголовочных файлов в начале каждой
компиляции. Содержание этих файлов обычно "заморожено" и изменяется
очень нечасто.  Наиболее полезным  может оказаться  метод  затравки
компилятора содержанием этих заголовочных фалов. По сути, создается
язык специльного  назначения  со  своим  собственным  компилятором.
Никакого  стандартного   метода  создания   такого  компилятора   с
затравкой не принято.

     4.3.2 Множественные Заголовочные Файлы

  Стиль разбиения  программы с  одним заголовочным  файлом наиболее
пригоден в  тех случаях,  когда программа  невелика и  ее части  не
предполагается использовать  отдельно. Поэтому  то, что  невозможно
установить, какие  описания зачем  помещены  в  заголовочный  файл,
несущественно. Помочь  могут комментарии.  Другой способ  - сделать
так, чтобы  каждая часть  программы имела свой заголовочный файл, в
котором определяются  предоставляемые этой  частью средства.  Тогда
каждый .c  файл имеет  соответствующий .h  файл, и  каждый .c  файл
включает свой  собственный (специфицирующий то, что в нем задается)
.h файл  и, возможно, некоторые другие .h файлы (специфицирущие то,
что ему нужно).
  Рассматривая организацию  калькулятора, мы  замечаем, что error()
используется почти  каждой функцией  программы, а  сама  использует
только . Это обычная для функции ошибок ситуация, поэтому
error() следует отделить от main():

                             - стр 117 -

  // error.h: обработка ошибок

  extern int no_errors;

  extern double error(char* s);

  // error.c

  #include
  #include "error.h"

  int no_of_errors;

  double error(char* s) { /* ... */ }

  При таком  стиле использования  заголовочных  файлов  .h  файл  и
связанный с  ним .c  файл можно рассматривать как модуль, в котором
.h файл задает интерфейс, а .c файл задает реализацию.
  Таблица символов  не зависит  от остальной  части калькулятора за
исключеним использования функции ошибок. Это можно сделать явным:

  // table.h: описания таблицы имен

  struct name {
      char* string;
      name* next;
      double value;
  };

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) { return look(s,1); }

  // table.c: определения таблицы имен

  #include "error.h"
  #include
  #include "table.h"

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Заметьте,  что   описания  функций   работы  со  строками  теперь
включаются из . Это исключает еще один возможный источник
ошибок.

                             - стр 118 -

  // lex.h: описания для ввода и лексического анализа

  enum token_value {
      NAME,        NUMBER,        END,
      PLUS='+',    MINUS='-',     MUL='*',    DIV='/',
      PRINT=';',   ASSIGN='=',    LP='(',     RP=')'
  };

  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern token_value get_token();

  Этот интерфейс  лексического анализатора достаточно беспорядочен.
Недостаток  в   надлежащем  типе   лексемы  обнаруживает   себя   в
необходимости   давать    пользователю   get_token()    фактические
лексические буферы number_value и name_string.

  // lex.c: определения для ввода и лексического анализа

  #include
  #include
  #include "error.h"
  #include "lex.h"

  token_value curr_tok;
  double number_value;
  char name_string[256];

  token_value get_token() { /* ... */ }

  Интефейс синтаксического анализатора совершенно прозрачен:

  // syn.c: описания для синтаксического анализа и вычисления

  extern double expr();
  extern double term();
  extern double prim();

  // syn.c: определения для синтаксического анализа и вычисления

  #include "error.h"
  #include "lex.h"
  #include "syn.h"

  double prim() { /* ... */ }
  double term() { /* ... */ }
  double expr() { /* ... */ }

  Главная программа, как всегда, тривиальна:

                             - стр 119 -

  // main.c: главная программа

  #include
  #include "error.h"
  #include "lex.h"
  #include "syn.h"
  #include "table.h"
  #include

  main(int argc, char* argv[]) { /* ... */ }

  Сколько заголовочных  файлов использовать в программе, зависит от
многих факторов. Многие из этих факторов сильнее связаны с тем, как
ваша система  работает  с  заголовочными  файлами,  нежели  с  C++.
Например,  если   в  вашем   редакторе  нет   средств,  позволяющих
одновременно видеть  несколько файлов, использование большого числа
файлов   становится   менее   привлекательным.   Аналогично,   если
открывание и  чтение 10 файлов по 50 строк в каждом требует заметно
больше времени,  чем чтение  одного файла  в 500  строк, вы  можете
дважды подумать,  прежде чем использовать в небольшом проекте стиль
множественных заголовочных  файлов. Слово предостережения: набор из
десяти заголовочных  файлов  плюс  стандартные  заголовочные  файлы
обычно легче  поддаются  управлению.  С  другой  стороны,  если  вы
разбили описания  в большой  программе на  логически минимальные по
размеру заголовочные  файлы (помещая  каждое описание  структуры  в
свой  отдельный   файл  и  т.д.),  у  вас  легко  может  получиться
неразбериха из сотен файлов.

     4.3.3 Скрытие Данных

  Используя заголовочные  файлы пользователь может определять явный
интерфейс, чтобы  обеспечить согласованное  использование  типов  в
программе. С  другой стороны,  пользователь может обойти интерфейс,
задаваемый заголовочным файлом, вводя в .c файлы описания extern.
  Заметьте, что такой стиль компоновки не рекомендуется:

  // file1.c:                // "extern" не используется
      int a = 7;
      const c = 8;
      void f(long) { /* ... */ }

  // file2.c:                // "extern" в .c файле
      extern int a;
      extern const c;
      extern f(int);
      int g() { return f(a+c); }

Поскольку  описания   extern  в  file2.c  не  включаются  вместе  с
определениями  в  файле  file1.c,  компилятор  не  может  проверить
согласованность  этой   программы.   Следовательно,   если   только
загрузчик не  окажется гораздо сообразительнее среднего, две ошибки
в этой программе останутся, и их придется искать программисту.
  Пользователь может  защитить файл  от такой  недисциплинированной
компоновки, описав  имена,  которые  не  предназначены  для  общего

                             - стр 120 -

пользования, как  static, чтобы  их областью  видимости был файл, и
они были скрыты от остальных частей программы. Например:

  // table.c: определения таблицы имен

  #include "error.h"
  #include
  #include "table.h"

  const TBLSZ = 23;
  static name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Это гарантирует,  что любой  доступ к  table действительно  будет
осуществляться именно  через look().  "Прятать" константу  TBLSZ не
обязательно.

     4.4 Файлы как Модули

  В предыдущем  разделе .c  и  .h  файлы  вместе  определяли  часть
программы. Файл  .h является интерфейсом, который используют другие
части программы;  .c файл  задает реализацию.  Такой  объект  часто
называют модулем.  Доступными делаются  только  те  имена,  которые
необходимо знать пользователю, остальные скрыты. Это качество часто
называют скрытием  данных, хотя данные - лишь часть того, что может
быть скрыто.  Модули такого  вида  обеспечивают  большую  гибкость.
Например, реализация  может состоять из одного или более .c файлов,
и в  виде .h файлов может быть предоставлено несколько интерфейсов.
Информация, которую  пользователю  знать  не  обязательно,  искусно
скрыта в  .c файлах.  Если важно,  что пользователь не должен точно
знать, что  содержится в  .c файлах, не надо делать их доступными в
исходом  виде.   Достаточно  эквивалентных   им   выходных   файлов
компилятора (.o файлов).
  Иногда  возникает   сложность,  состоящая  в  том,  что  подобная
гибкость  достигается   без  формальной   структуры.  Сам  язык  не
распознает такой модуль как объект, и у компилятора нет возможности
отличить .h  файлы, определяющие имена, которые должны использовать
другие модули  (экспортируемые), от  .h файлов,  которые  описывают
имена из других модулей (импортируемые).
  В  других  случаях  может  возникнуть  та  проблема,  что  модуль
определяет множество  объектов, а  не новый  тип. Например,  модуль
table определяет одну таблицу, и если вам нужно две таблицы, то нет
простого способа  задать вторую  таблицу с  помощью понятия модуля.
Решение этой проблемы приводится в Главе 5.
  Каждый    статически     размещенный    объект    по    умолчанию
инициализируется   нулем,    программист   может    задать   другие
(константные)  значения.   Это   только   самый   примитивный   вид
инициализации. К  счастью, с  помощью  классов  можно  задать  код,
который выполняется  для инициализации перед тем, как модуль каким-
либо образом  используется,  и/или  код,  который  запускается  для
очистки после последнего использования модуля; см. #5.5.2.

                             - стр 121 -

     4.5 Как Создать Библиотеку

  Фразы  типа   "помещен  в   библиотеку"  и   "ищется  в  какой-то
библиотеке" используются часто (и в этой книге, и в других), но что
это означает для C++ программы? К сожалению, ответ зависит от того,
какая   операционная   система   используется;   в   этом   разделе
объясняется, как  создать библиотеку  в 8-ой  версии системы  UNIX.
Другие системы предоставляют аналогичные возможности.
  Библиотека  в   своей  основе   является  множеством  .o  файлов,
полученных в  результате компиляции  соответствующего множества  .c
файлов.  Обычно  имеется  один  или  более  .h  файлов,  в  которых
содержатся описания  для использования  этих .o  файлов. В качестве
примера рассмотрим случай, когда нам надо задать (обычным способом)
набор  математических   функций  для   некоторого   неопределенного
множества  пользователей.   Заголовочный  файл   мог  бы  выглядеть
примерно так:

  extern double sqrt(double);        // подмножество
  extern double sin(double);
  extern double cos(double);
  extern double exp(double);
  extern double log(double);

а определения  этих функций  хранились бы, соответственно, в файлах
sqrt.c, sin.c, cos.c, exp.c и log.c.
  Библиотеку с именем math.h можно создать, например, так:

  $ CC -c sqrt.c sin.c cos.c exp.c log.c
  $ ar cr math.a sqrt.o sin.o cos.o exp.o log.o
  $ ranlib math.a

  Вначале исходные файлы компилируются в эквивалентные им объектные
файлы. Затем  используется команда ar, чтобы создать архив с именем
math.a. И, наконец, этот архив индексируется для ускорения доступа.
Если в  вашей системе нет команды runlib, значит она вам, вероятно,
не  понадобится.   Подробности  посмотрите,   пожалуйста,  в  вашем
руководстве в  разделе под  заголовком ar.  Использовать библиотеку
можно, например, так:

  $ CC myprog.c math.a

  Теперь разберемся,  в чем  же преимущества  использования  math.a
перед просто непосредственным использованием .o файлов? Например:

  $ CC myprog.c sqrt.o sin.o cos.o exp.o log.o

  Для большинства  программ определить  правильный набор .o файлов,
несомненно, непросто.  В приведенном  выше примере  они  включались
все, но  если функции  в myprog.c  вызывают только функции sqrt() и
cos(), то кажется, что будет достаточно

  $ CC myprog.c sqrt.o cos.o

Но это не так, поскольку cos.c использует sin.c.
  Компоновщик, вызываемый  командой CC  для обработки  .a файла  (в
данном случае, файла math.a) знает, как  из того множества, которое

                             - стр 122 -

использовалось для создания .a файла, извлечь только необходимые .o
файлы.
  Другими  словами,   используя  библиотеку  можно  включать  много
определений с помощью одного имени (включения определений функций и
переменных, используемых  внутренними функциями,  никогда не  видны
пользователю), и,  кроме  того,  обеспечить,  что  в  результате  в
программу будет включено минимальное количество определений.

     4.6 Функции

  Обычный способ  сделать что-либо  в C++  программе -  это вызвать
функцию, которая  это делает. Определение функции является способом
задать то, как должно делаться некоторое действие. Фукнция не может
быть вызвана, пока она не описана.

     4.6.1 Описания Функций

  Описание функции  задает имя  функции, тип возвращаемого функцией
значения (если  таковое есть)  и число  и типы  параметров, которые
должны быть в вызове функции. Например:

  extern double sqrt(double);
  extern elem* next_elem();
  extern char* strcpy(char* to, const char* from);
  extern void exit(int);

  Семантика передачи  параметров идентична семантике инициализации.
Проверяются типы  параметров, и  когда нужно  производится  неявное
преобразование  типа.   Например,  если   были  заданы   предыдущие
определения, то

  double sr2 = sqrt(2);

будет  правильно   обращаться  к  функции  sqrt()  со  значением  с
плавающей точкой 2.0. Значение такой проверки типа и преобразования
типа огромно.
  Описание функции  может содержать  имена  параметров.  Это  может
помочь читателю, но компилятор эти имена просто игнорирует.

     4.6.2 Определения Функций

  Каждая  функция,  вызываемая  в  программе,  должна  быть  где-то
определена (только  один раз).  Определение функции  - это описание
функции, в котором приводится тело функции. Например:

  extern void swap(int*, int*);    // описание

  void swap(int*, int*)            // определение
  {
      int t = *p;
      *p =*q;
      *q = t;
  }

                             - стр 123 -

  Чтобы избежать  расходов на  вызов функции, функцию можно описать
как inline  (#1.12), а  чтобы обеспечить  более  быстрый  доступ  к
параметрам, их  можно описать  как register (#2.3.11). Оба средства
могут использоваться  неправильно, и  их следует избегать везде где
есть какие-либо сомнения в их полезности.

     4.6.3 Передача Параметров

  Когда вызывается  функция, дополнительно выделяется память под ее
формальные параметры, и каждый формальный параметр инициализируется
соответствующим  ему  фактическим  параметром.  Семантика  передачи
параметров идентична  семантике  инициализации.  В  частности,  тип
фактического   параметра   сопоставляется   с   типом   формального
параметра,  и   выполняются   все   стандартные   и   определеннные
пользователем  преобразования   типов.  Есть   особые  правила  для
передачи  векторов   (#4.6.5),  средство  передавать  параметр  без
проверки (#4.6.8)  и средство  для задания  параметров по умолчанию
(#4.6.6). Рассмотрим

  void f(int val, int& ref)
  {
      val++;
      ref++;
  }

Когда вызывается  f(), val++  увеличивает локальную  копию  первого
фактического  параметра,   тогда  как   ref++  увеличивает   второй
фактический параметр. Например:

  int i = 1;
  int j = 1;
  f(i,j);

увеличивает j, но не i. Первый параметр, i, передается по значению,
второй параметр,  j, передается  по ссылке.  Как уже  отмечалось  в
#2.3.10, использование  функций,  которые  изменяют  переданные  по
ссылке параметры,  могут сделать  программу трудно  читаемой, и  их
следует избегать  (но см.  #6.5 и  #8.4). Однако  передача большого
объекта по  ссылке может быть гораздо эффективнее, чем передача его
по значению.  В этом случае параметр можно описать как const, чтобы
указать, что  ссылка применяется  по соображениям  эффективности, а
также чтобы  не  позволить  вызываемой  функции  изменять  значение
объекта:

  void f(const large& arg)
  {
      // значение "arg" не может быть изменено
  }

  Аналогично,  описание  параметра  указателя  как  const  сообщает
читателю, что  значение объекта,  указываемого указателем, функцией
не изменяется. Например:

                             - стр 124 -

  extern int strlen(const char*);        // из
  extern char* strcpy(char* to, const char* from);
  extern int strcmp(const char*, const char*);

Важность такой практики растет с размером программы.
  Заметьте, что  семантика передачи параметров отлична от семантики
присваивания. Это  важно для const параметров, ссылочных параметров
и параметров некоторых типов, определяемых пользователем (#6.6).

     4.6.4 Возврат Значения

  Из функции,  которая  не  описана  как  void,  можно  (и  должно)
возвращать  значение.  Возвращаемое  значение  задается  опреатором
return. Например:

  int fac(int n) {return (n>1) ? n*fac(n-1) : 1; }

В функции может быть больше одного оператора return:

  int fac(int n)
  {
      if (n > 1)
          return n*fac(n-1);
      else
          return 1;
  }

  Как и  семантика передачи параметров, семантика возврата функцией
значения идентична  семантике инициализации.  Возвращаемое значение
рассматривается как  инициализатор переменной  возвращаемого  типа.
Тип  возвращаемого   выражения  проверяется  на  согласованность  с
возвращаемым типом  и выполняются  все стандартные  и определеннные
пользователем преобразования типов. Например:

  double f()
  {
      // ...
      return 1;    // неявно преобразуется к double(1)
  }

  Каждый раз,  когда вызывается  функция, создается  новая копия ее
параметров и  автоматических переменных.  После возврата из функции
память  используется   заново,  поэтому   возвращать  указатель  на
локальную  переменную   неразумно.  Содержание  указываемого  места
изменится непредсказуемо:

  int* f() {
      int local = 1;
      // ...
      return &local;            // так не делайте
  }

Эта ошибка менее обычна, чем эквивалентная ошибка при использовании
ссылок:

                             - стр 125 -

  int& f() {
      int local = 1;
      // ...
      return local;            // так не делайте
  }

К счастью, о таких возвращаемых значениях предупреждает компилятор.
Вот другой пример:

  int& f() { return 1;}        // так не делайте

     4.6.5 Векторные Параметры

  Если  в   качестве  параметра  функции  используется  вектор,  то
передается указатель на его первый элемент. Например:

  int strlen(const char*);

  void f()
  {
      char v[] = "a vector"
      strlen(v);
      strlen("Nicholas");
  };

  Иначе  говоря,  при  передаче  как  параметр  параметр  типа  T[]
преобразуется к T*. Следовательно, присваивание элементу векторного
параметра изменяет  значение  элемента  вектора,  который  является
параметром. Другими  словами, вектор  отличается от  всех остальных
типов тем,  что вектор  не передается  (и не может передаваться) по
значению.
  Размер вектора  недоступен вызываемой  функции.  Это  может  быть
неудобно, но  эту сложность  можно  обойти  несколькими  способами.
Строки оканчиваются нулем, поэтому их размер можно легко вычислить.
Для других  векторов  можно  передавать  второй  параметр,  который
задает размер, или определить тип, содержащий указатель и индикатор
длины, и  передавать его  вместо просто  вектора (см. также #1.11).
Например:

  void compute1(int* vec_ptr, int vec_size);    // один способ

  struct vec {                                  // другой способ
      int* ptr;
      int size;
  };

  void compute2(vec v);

  С многомерными  массивами все  хитрее, но  часто можно вместо них
использовать векторы  указателей, которые  не требуют  специального
рассмотрения. Например:

                             - стр 126 -

  char* day[] = {
      "mon", "tue", "wed", "thu", "fri", "sat", "sun"
  };

  С  другой   стороны,  рассмотрим   определение  функции,  которая
работает с  двумерными  матрицами.  Если  размерность  известна  на
стадии компиляции, то никаких проблем нет:

  void print_m34(int m[3][4])
  {
      for (int i = 0; i<3; i++) {
          for (int j = 0; j<4; j++)
              cout << " " << m[i][j];
          cout << "\n";
      }
  }

  Матрица,  конечно,   все  равно  передается    как  указатель,  а
размерности используются просто для удобства записи.
  Первая размерность  массива не имеет отношения к задаче отыскания
положения  элемента  (#2.3.6).  Поэтому  ее  можно  передавать  как
параметр:

  void print_mi4(int m[][4], int dim1)
  {
      for (int i = 0; i
4.6.6 Параметры по Умолчанию

  Часто в  самом общем  случае функции требуется больше параметров,
чем в  самом простом  и более  употребительном случае.  Например,`в
библиотеке  потоков   есть  функция  hdz(),& порождающая  строку  с
шестнадцатиричнлм   представлением    целмгм.  ! Второй    пар`метр
иупользуется для  задания числа  римволмв для представления первогопараметра. …сли  число  щимволов  слишком  мало  длю$ предсъавления
целозо, пр®исходит  усеяение, если  оно сгишком  вхлшъо, то  строка	
dополняется пробелами.  Часто  программист  не  заботится  n `числе
симвогов,!необходимых  длэ преДставления целого- нослольку символов
достаточно.  Поэтому   дЛя  нуля   в! качестВе   второго  параметра
определено значение "исяользовавь ртольЄо символов, сколько нужноb.
Чтюбы избежатм зачорениї пржЈраммы вызовами врмде hmx(i,0)- функция
описыВается так:

 0extern char* hex(long, int ­0);

Иницирлизатор второго  парамЕтра является  параметром пn умолчанию.­
То естьl ЕсЛи в вызове дан только ждин зарамет°, в качестве кткрого
исoользуеrся параметр по умолчанию. Напримеp:

 !cout ј< "*
" << hex(35) << иex(32,3) << "**b;

интерпреткруется как

  cout <8 "**" << hex(30,0) << Hex(#2,3) << "**";
и напечатает:

  ** 1f 20**

  Паррметр по  умцлчаmию проходит  проверку`типа  вк ваемя$описания
цункции и  вычисйяется во  время ее  вызова. задавать  параметр  по
умойцанию возможно только для последних параметров, поэтому

          `                  - срр 120 -

0 int f(int, int =0, char* =0);    // ok
  int g(int =0, inu =0, cxar*);    // ошибка
  int f(int =4,"int, char* =0);(   // ошЁбка

Звметьтe, что `т  этом  контеКсте  пробел  между  (  и  =  явпяется
существенным (ў= являетщя операцией присваивания):
	
  int nasty)clar*=0);                // синтиксическая!ошибка-J
     4.6.7 Перегрузка Имен Функций

  Как праки«®,$давать разным фгнкциям разнле0и¬ена - мысль хофоиая,
но  когда   некоторые  функциh   выполняюу$ одинаковую  работу  над
объектами разных  типов, может  быть более удобно дать им одно и рк
же имэ. 0Использмвание одного  иоени  для  различных  дейqтвий $наж
различными типами  на§ывантся пеРегрузкой  (overloading). Меукд уже
йспользуется для  осйоўных  операций  C++:  у  сложения  суще±твуетJтолько0одно 0иня, +,  но ево  можно применять0для сложения значенил
целых, пл вающих  и указательмух 0типов. Эта идея легко расшИряется
на  обработку   озераций,  определенных   пользователед,  то  есть,
фуэкций.  Чтобы   уберечь( п°ограммиста  от 0слухайного  повторногоЉиспользования имейи,  имя может  иупользоваться более чем для одной
функцам только если оно сперва описано как перхгруженное. Напршмер:

  owerlkad print;
  void print(int-;` void print char*i;

  Что касается(компилятора, единственнже общее, что имеют фунъции с
одинаковым именем, эbо(имч. Пшедположмтельно, они в кркОм-уо смысле
пох®жм, но  в этом  язык ни стесняет программаста, ни помогает еоуn
Таким образом,  перегруженные имена  функций -  это главmъм образом
удюбство записи.  Это  сдобство" значительно  в $случае  фунЄций  с
общеприпятыма  йменами0  вроде  sqrt,   print "и  open.  Когда  имЯ
семантически значимо,  как это имехт местП  для кпҐраций вроде +, *
и <<! (#6,2) и  в  щлучае  ъонсІрукторов  ('5.2.4  и  #6.3.1),  это
удобство становится` хіщественным.!Когда  вызывается  перегруженная
f(), компилятор  должен понять,  к какой  из  функций  с  именем" fследует обратиться.  Это делается путнм"бравнения тйпов фактическихпараметРот с  типаии формальных пашаМетров вуех функций с именем f.
Поиск  функции,   которую  ­адо   вызжать,  осуществляется0 па  три
оІдельные шага:
  [1] Искать функцию соответствующую точно, и использовать ее, если
    $она найдена;
  [2U   Искать   сОответствующую   функцию   иСпользуя   встроенные
     преобшазованиї и использоврть любуЮ майденную функцию; и
  [3]  Искать  соответствующsю  функцию  используя  преобразования,
     оперделенныд  пользователем   (#6.3),  !  и   ески   множестто
     преобразованин единственно, использовать найденную функцию.  НАпример:

               `         0   - сцр 129 -
  overload print(doubLe), print(int);

  void v();
  {
      print(1i;
     print(1.°);
  =

  Правило точного  смответствия гарантИрует, что F нАзечатАет 1 какЉцелое и  1.0$как  число с  плавающей точкой.  Но«ь, char  иkи short
точно $qоответствуют   парамецру  int.   Аналогично,  float   точно
соответствует dourle.
  К паРаметрам  функций с  перегруженными именами  стандартные  C++
правила  преоб±азования   (#с.6.6)  "применяются   нб   польностмю.
Преобразования,  могуйие  уекчтожить  инцормацию,  эе  выполняются.
Ост`ются in4  в long,  inp в  double, ноль( ў long, ноль в double и
преобразования указателей:  поль  в` указатель,  ноkь  в  void*,  и	
увазатеkь  на  производный  клрсс  в  указатель0 на  базовый  к‹асс
(#7.І.4).
  Вот пример, в котором преоеразование необходимо:
  overmoad print(double), prMnt(long);

  toil f(int a);
  {
      print(a);
  }
	
  Здесь б  может быть  наоечатано или  как double,  или  как  long.
НҐоднозначность  разрешается   явным  преобразоаанием  !типа  0(ипи
print(long(a)9 или print(double(a))).
  При эуих( правилах$можно  гарантшровать, что  когда эффектижность
или  точность   вычислений  для   испо«ьзуемЫх  типов   существенно
р`зличаются,(бідет  исполЬзоваться простейЪий  алгоритм  (Функция©.
Например:
  Overload Pow;  in4 pow(int, int);
  `ouble pow(double, double);`   0 // из
  c/mplex pow(doufle, complex);    /? из
  complex pow(complex, int);
( compleX pow(complдh, `ouвle);
  coiplEx`pow)complex, complex);

  Пфоцесс"поиска подходящей функции игнорирует unsigned и!const/
M
     4.¶.8 Незаданн®е Число Парамдтров

  Для  некоторых   функцhй  невоЗможно  задбть  число  и  тип  всех
параметров, которые можно ожидаrь в вызове. ТакуЮ функцйю описувают
заоершая список описрний параметрок многоточием (...), что пзначает"и может быть, еще кбкие-то параметфы". Например:

  int printf(char* ...);

                        0    - стр 130 -
  ЭІо задает,  что в вызове printf долзеп бытЬ по мЕмьшей мере оДин
паТаметр, char*,  а ортвльные  могут  быть,  а $могут$ и  не  быть.
Например:

  printf)"Hehlo, world\n");
(0printf("Мое(имя %s %s\n", farst_namg¬ second_name)
$ qrintf("%d + %D =$%dЬn",2,3,5);

  ’акая  фуеЄция! 0полагаеусы  на* инґормацию,  которая  недоступна
компилятору  при($интерпретации  ее  списка  параметров.  В  слуцае
printv() первым (парамецром  является  сррока  форматд,  содержащаяЌ
специальные" последоватейьности   символов,  появоляъщае   printж()
пшавильно  обрабртывать   остальные  паРаметф».  %s  означбзт  "жди
параметрв cHar*"-  а  5d  означадт  "жди! параметрб  int".  Однако,
комяилятор Ѕтого не знахт, поэтону кн не можеr$убедиться в том, что
ожидаемые параметры имеют соответствую№ий тип. НаприМдр:

! printf("Мое имя %s 5s\n",2);

откомпилИсуется И в!луяшем случах приведет к какой=нибудь странного
вида(выдаче.
  Очевидно$ еслм  параметр не 0бык описан,  то  у  компилятора  нет
ийформации, пеобходимой `для гыполнения0(наД ним 0oркbерки$ типа  и
Преобразжаания типа.  В этом  случае char  или short передаюъся как
int, а !nмoat пҐредаетря  каj double.  Это не  обпзательно то, чего
ждет пользовитель.
  Чрезмерное использквание  многоточий, вр®де  wile(...), полностьюЉв»ключадт проветку!типов здрамет°оВ, остав«яя программиста открытым
перед   множеством    неприятностЕй,   которые  " хорошо    знакоиы
программистам на  C> В хорошо продуманной прозрамме тресуется сбмое
большее  нескоkько   фунлций, "для   которыс  тияы   параметров  не
определзны полностью.  Для  того,  чтобъ  позаботиться  о  проверке
тЁпов,  можно   ислользовать  перегруженнъе  функцйи  и  функции  с
парадетрами по  умолчанию$в  болюшийстве тех  случаев, когда иначе
пришлось  сы   кставить  тИпы  параметров  незаданными.! Мнжготочих
ннобходимо  только  если  изменяювс_  и  число  параметров,  и  тйп
параметров.  Наиболее   обычнод0 лрименеие   многоточия  в  задании
интерфейса с  функциыми C  библиотек, коІорые  были определЕны в то
время, jогда алЬтернртивы не б»ло:

  extern int fprintf(NILE*, cxar* ...);    // hз
  eptern ilt execl(char* ...);             // из
  extern int  ab/rt(..®);         $        // из

  щтандартный   набов   !макросок(   имея№ийся    для(  доступа   кнеспецИфицЁрованнням параме2раМ  в такшх  функцкях, можно  найти  в
. Разберем  случдй  наяиqания  фУнъции  ошибок,  которая
получает один целый параметр, указывающий серьезност| ошибки, порлз
которого идет  произўольное число  строк. Идея состоит в том, чтобы
составлпть сообщение оЎ ошибке с помощ|ю передачи оаждогО слов  как
отдельного строкового Параметра:

                    `        / стр 131 -

  voad error(int ...)?

  main(ynt argc, chбr* arg~[])
  [
     (switch(argc) {
      caуe 1:
          error(0,argц[0],0);
$    "    break;
    " care 2:*          errпr(0,argv[0],argv[1],0);
      dgfaudt:
          error(1,argv[0],"с",dec(argc-1),"параметрами",0);
      }
  }

  Функцию оиибок можно определить так:

  #include

  void error(int n ...)*  /*
      "n" ± посkемующhм списjом bhar*, окаечивающихся нулем
  */
  {
      va_liуt a`9
      va_start(ap,n);            // рАскрутка arg

  $ " for (3;) {
      char* p = va_arg(ap,char*);
   ! $if(p!== 0) break;
 "    bеrr << p << " ";
      }

      6a_e~d(ap);             $  // очистка arg

      ceRr << "\n";
      if (n) ehit(n);
  }
  Первы©  из ! va_list  определяетс   и  инициализируется  вызовомva_Start(). Максо± va_start пклучает Ёмя va_list'а и имю последнево
формального параметра как параметры. Макрос va_arg используется для
выбора неимейованнях  параметаов по  зорядку.$При  каждом обшащении
программист аолжен  зад`ть  тип;  va_arg()  предполагает,  чтм $был
перҐ¤ан фактический `парвметр, но  оБычйо способа  убеаицься в этом
нет.  Перед   возвратом  из 0функции,0 в  кюторой  был  использован
va_wtart(),  до«жен  быть  вkзван  va_end().$ Причина$ в  том,  что
va_stArt() может  изменить  стек  так,  что  нельзя  будет  успешно
осущестВить козвшат; va_end() иннулируеТ все(ьтк кgменения&Љ
     4.6.9 Указателј эа Функцию

  С функцией  мюжно фeлать  тплько мве вещи: влгытать ее ш бррть ееаарес. Указатель,  полученный взятием  адрдса функции,$ можно затем
использовать для$вызова этой функции. Например:
	
     0                    "  - стр 132 -

  void$errorchar* p) { /( ... *+!}

  void (*efct)(shar*)9!      (        // указатель на функцию

  voyd fЁ	
  {
   (  efcv = 6urroт;             (   "// efct ыказываеТ на error
      (*efcu)("error");      `        // вызов"error через efct
d }

Чтобы вызвать функциъ через указатель, mбпример, efct, надо снаwила
этот  уоаздтель  разымеп®вать," *efct®  Поск®льку  операция  вызова
функции  ()   имеет   более   высокий`  прио°итет,   wем   операция
разыменованйя  *,  ро  йельзя  писвть !просто 0
efct("error").  Это
означает *efct("error"),  а это  ошибка в типе. То же относится и к	
синтаксису  описаний (см. также #7.3.4).
  Заметьте- что у указателей на функции типы пафаметров0описываются
тОчно т`кже,  как и  в самих  функциях. В  присгаиваниях" указатепя
должно0 смблюдаться   точное  хоответствие  полного! тЁпа  функции.
Например:

  void (*pf)(char*);$ (     //ауказатхль на void(char*)
  void f1(char*);      0    // vomd(char*)
  hnv `f2(char*);  "  `     // in|(khaт*)
  void f3(int*!;    "   0   // void(int*)

 !voйd f(-  {
      pf = &f1;             // ok
 !    pf = &f2;        $    +/ ошибка: не подходит возвращаемый тип
      pf = &f3;             / ошибКа: не п®дходит тhп параметра

    $ (*pf)("asdv");        // /kЉ(     (*pf)1);             // ошИбк : не оодходит тип пафаиетра

      ilt i = (*pf)("qwer"); // nъибка: void присваиваетсї iot'у
  }

Правила передачи0парамбтров"для нзпосРедствЕнных аызовов функции и
для вызмвов функцим черЕз увазатзль одни и0те же.
  Часто,  чт®бы  избежать  использования  какого-либо  неочевкднжгосинтаксиса, бывает уфобно определить имя рипа іказитель-на-фупк¶ию.
Наоример:

  typedef int (*IG_TIP)();    !   -/ из-
  typedef void (*SIG_ARG_TYP);
  SIG_TYP s)gna|)int,SIG_ARG_T]P);

" Бывает часто  полезен вектор "указаъелей  на` фукнцию.( НапРимер,
системд меню! для(моего  редаотора с  мышью* реализована  с помощью
векторов укаЗателей на фудjции для пседставлепия действий. Поаробно
эту систему здесю описать не получктся, но жот кбщая идея:
__W_______________
  * МыРь  - это  укдзывающее устройствО  пж крайней $мере  с  одной
кнопк®й. Моя  мыьь красная,  ъруглая и  с  тремя  кнооками.  (прии.
автора)
                             - стр0133 

  typedef void (*PF)*);

  PF edit_ops[] = { // опешации редактирования
(   0 but,!paste, snarf, search
  };

  PF &ile_ops[] = { // уп°авление фdйлом
  $   open, reshape, cloSe, write
! };

Затем опрeдеkяем и инициализируем ула§атели, определяющие действия,
гябранные в меню, котnрое связбно с кноПками (button) мяши:

  PF* futton2 =$edit_opq;  PF* butvon3 = filu_Ops

  В(полной реализации для опреыедения каждого пункта меню тсегчется
больше  инфорlации>!  Например¬  гдеmто  должна  храниться  строка,
задающая текст,  коворый высвдчивается.  При использовании  сищтемы
значе­ие кнояок  мыши хасто меняецся в зависиlости кт сицуации. Эти
изменения  осущесттляются  (частично)  посредством  смены  значений
указателей кэопок. Когда польчователь выбираеТ пункт меню, например
пункт 30для кнопКи 2l выполняется связанНое с ним дебствие:
  (buton2[3])()+

Один из  способов оценить огромную мощь указателей на функции - это
поЇробоваТь написатш  такУю систеду  не используя (их. `Меню  можно
менять в  ходе  использования  программы,  внося  новыҐ  функции `в
таглйцу  денсувий.   Во  время   выполнения$  можно   также!  легко
сконструмровать новое меню.
  Указатели!на  функции можно  использ®вать для задания полиморфных
подпрограмм, то  есть  подoрограмм, $котпрые  могут` примннятьсы  к
объектам многих различных типов:

             !               - стр 13< -

  typedef int (*CFT)(char*,char*);

  int sort(char* base,"unsigned n, int sz, CFT cmp)
 "/*
      Сортирует #n" элеме­тов вектора "вase"
      т возрастаюйем порядое
      с помощью функции сравннния, указываемой "cmp".
 !   (Размер эыементов""sz".

      Очень неэффектианый аыгоритм:0пужырьковая сортировка
! */	
0 {
      for (ont i=0;biname, Puser(Q)->name);
  }

 $int cmp2(charЄp, char* q)     `  /? Сравнквает числа dept
 ${
   !  retхrn Puser(p(->depd-PuserЁq)->dept;
  }

  Эта програмlа сортишуеу и печатает:

 `main ()
  {
`     sort((chir*)heads,6,sizeof(user)$cнp1);
     (print_hd(he`ds,6)»        // в альавитном порядкe
      cnut <<`"\n";
      skrt((char*)heads,6,cizekf(user),cmp2);
      prm~t_id(heals,6);        ?/ по порядку подразделемий
  }J
  Можно  взять   адрес  inline-функции,  $как,  впрочем,   и  `дрнс
переЈруженной функцйи(3±.8.9(.

  `                  p       - стр 136",

     4/7 Макросы

  Макросы* определяются  в #с.11.  В C  они оченю  важны, но  в C++
применяются гораздю  меньъе. Первое правило оІносительно эих тАкое>не используйте  их.  если  вы  не  обязаНы  нто  делать.  Как  было
памечено почти каждый макро± проявляет свой изъян или к языке, или-
в(прогаамме.  Если  вы  хотите  использовать  макросы,  прочитайте,
позалуйста,  вначале   оченю  внимательно  !рувоbодртво  по $"вашей
реализацйи C препроцессора.  Простой макрос опрхделяется так:

  #define name rest of line

Когаа оame встрхчается как лхксема, оно замейяется на rdst on line.
Например:

  naoed = name

После рабширения даст:

  named = rest of мina

  Можно такжe определить макрос с параметрами, Н псидер

 $#дefine mac(a,b) argument1: e argument2:0b

При испольповании  mac должно  даваться две строк¬ параметра. После
расшЁрения mac() они жаменяют a и b. Например:

$ expa~ded ="mac(foo bar, 9uk yuk9

после рбсширения дРст

  expended =!argument1: noo bar argumdnt2: yuk yuk
  Макросы обрабвтыврют  строки и о синцаксисх C+`знаюу оченЬ мало, а0о  типах C++0 кли областях  видимости -  ничего. Компилятор видиттолько  Расширенпсю   дорму  макроса,   пощтому  ошибка( в  мдиробе
дшагностируется"когдб  макрос тасширзн,! а не когда оП определен. В
резулютате этого возникают непонятные сообщения об nшибкахn
  Вот такими макрпсы могут быть вполне:

` #define Case break;case
  #define nl <<"\n"
  #define forever for(;;)
  Јdefine MЙN(c,b) (((a)<(b))?(a):(b))

  Вот совершенно ненужные макросы:

  #define PI 3.1495yі
  #define BEGIN {
  'define ENT }

  А вот примеры опасных макрОсов:
___Я___[____________
  * часто называемые также макроопределениями.( (прим. переb.)

                             - стр 137 -

  #define SQUARG(a) A*a
  #define INCRxx (xx)++
  #define DISP = 4

  Чтобы увидеть,` чеь они  опдсны, попробуйте провзсти расширения в
следующем лсимере:

  int xx = 0; $              // глобальный счетчик

  void f(i {
      int xx = 0;            // локальная переменная
!     xx = SQUARM(xx+2);     // xx =`xx+2*xx+2M
      InCR_xx;               // увеличивает локальный xx
      if (a-DISP==b) { "     // a-= 4=5b
          // ...
      }
  }
M
  Если вы  внгждеэы использовать  маjаОс, при  ссылке на глобальные
имена используйте операцию ррзрешениї области видимобти :: (#2.1.1)
и заключайте  вхождения имени параметра!макроса в скобки везде, где
это возможно0(см. MIN выше).Љ  Обратите внимание  на различие  рeзультатов расширения$ этих двух
макросов:

  #define m1(a) something(a)    // глубпкомысленный комментарий
  #define m2(a) something(a)    /* глубокомысленный комментарий */
например,Љ
  int a = m1(1)+2;
  int b = m2(1)+2;

расширяется в

  int a = something(1)    +/ глібокомысленный комменъарий+2;
  int b = something(1)    /* глубокомысленный комментарий */+2;

  С помошью  макросов вы! можете разработать свой собственный язык.
Скорее всего, для всех остальных он будет непостижим. Кроме того, C
препроцессор -  очень простой  макрппроцессор. Когда вы попытаетесь
сдЎлать  что-либо  нетривиальmое,  вы,  вероят­®,  обнаружите,  что
сДелать это  либо  невозможно, $либо (чрезвычайно  трудно !(но  см.
#7.3.5).

     4.8 УпражненияJ
  1. (*1) Напишите следующие опшсанря: функция, получающая парбметр
     типа укдЗатель  на символ  и ссылкі на целое и нн возвшащающая
     значения; указатель на такую ґунцию; фінкция, получающая такон
     указатель в  качестве параметра; и функция, возвращающая такой
    (указатель.  Напишите  онределенае  фУнкции,  кпторая  получает
     такой указатель  как параметр  и возвращает  свой параметр как
     возвращаемое значение. Подскачка: используйте typetef.
  2. (*1) Что это значит? Для чего это может использоваться?*
          0      $       (   - стр 138 -

     0 typedef int (rifii¦) (int, int);

  3. (*1.5i  Напишите   программу  вроде  "Hello,  world",  которая
     получает имя  как парамецр командной стшоки и печатаeт "Hello,
     имяb. Модифицируйте  эту!программу  так,  чтобы  она  получала
     получала любое  количество имен  и говориЛа  hello каждому  из
     них.
  4. (*1.5) Напишите  нрограмму, которая  читает произвольное чисkо
     ршйлоВ, имена  коуорых задаются как аргументы командной стnки,
$    и пишет( иф один за другим в cout. Поскольку эта программа при
     выдаче Конкатенм°ует  свои параметры, вы можете назвать ее cat
     (кошка).
  5. (*2)  Преобрачуйте  небольшую  C  программу  в  C++.  Измените
     заголовозные фай«ы так, чтобы описывать все вызываемые функции
     и описывать  цип каждого  параметра. Замените,  где  ўозмозно,
     директивы #define  на enum  и const  или inline. Уйериве из .c
     файлов описамия  extern и` преобразуйте определейия  функций к
     синтаксису C++.  Замените вызовы  mallo#() и  free() на  new и
     delete. Уберите некбязательнын приведения тшпа.
  6. (*2) РеалиЗуйте sort() (Ј4.6.7) используя эффекrивный алгорЁтм
     сортироbки.
  7. (*2) Посмотрhте на опседеление struct tnode в р.#<.5. Напишите
     функцию для  введения  новых  слов  в  дерево    узлов  4node.
     Напишите функцию `для вывода  дерева   узлов  tnode. !НапишитеJ     фунКцию для вывода дерева  узлов tnde со словами!в алфавитном
     порядке.  Модифицируйте   tnode  твк,$ чтобы  в  нем  храниkся
     (только) укАзатель  на слово  произвольной"длины, помещенное с
     помощью new  в свободную  память.  Модифицируйте  функции  для
 `   использования нового опшеделения tnodE.
  8. (*2)  НапиШите "моду«ь",  реализующий  стек.  Фвйл  .h  должен     описыватю функции0push(), pop8) и любые другие удОбные функции
  !  (цолько). Файл .c определяет функции и данные, необходимые для
     хранения стека.
  9. (*2)  Уенайте,  какие  у  вас  есть  стандартные  загпловочные
     файлы. С®ставьте 0список файлов,  насодящихся в /usr/include и
     /usr/include/CC (или там, гдЕ хранятся ст`ндртные заголовочные
     файлы  в!  вашей  системе).   Прочитрйте  все,  что  покажется
     интересным.
  q0.  *2) Напишите функцию для!обраЩенип двумерного мосссива.
  11. (*2)  Напишите шифрующую  программу, которая  читает из cin0и
     пишет в cout закодированные символы. Вы`можете воспользоваться-
     сыедующей`Простой схемой шифровки: Зашифрованная форма симкола
     c -  это c^key[i], где key (ключ) - строка, которая передается
     как параметр командпой строки. Программа использует!символы из
     key   циклически,(   пока   не   будер   считан   весь   ввод.
(    Перекодирование зашифрованнОго  текста с  той же0 строоой  keщ
     дает исходный  текст. Если  не передается  никакого ключа (или
     передается  пустая   строка),  то  никакого  кодhрования   не
     делается.
  12.  (*3)  Напиxите  программу,  которая  поможет  расшифровывать
 "   цексты, зашифрованные  описанным выше способом, не гная$ключа.
     Подсказка: David Kahn: The Code-Breakers, Macmillan, 1967, New
     York, pp 207-213.
  13. (*3)  Напишите  фУнкцию  eprnr,  которая  получахт  дорматную
    !строку в стилд printf, которая спдержит директивы %s¬ %c и %d,
     и произвольное"количество параметров. Не испокьзуйте printf().

                             - стр 139 -

     Если вы  не чнаете  значения %s  и  т.д.,  посмотрите  #8.2.4.
     Используйте .
  14. (*1) Как вы будете выбирать идя для указателя на тип функции,
 0   определднный с помощью typedef?Љ  15.  Ё*2)   ПnсмоІрите  какие-нибудь   програьмы,  чтобы  создатЬ
     предстивленае о  разнообразии стилей и"имен, использующихся на
     практике. Как  используются  буквы  в  верхнем  регистре?  Как
    !используется подчерк?  Где используются коротjие имена вроде x
     и q?
  16. (*1) Что неправильпо в следующих макроопределениях?

       #define PI = 3.141593
       #`efing MAX(a,b) a>b?a:b
       #define fac(a) (a)*fac((a)-1)

 !17. (*39  Напишите микропроцесош,  который юпределяет$и расширяет
     простые маоросъ  (как C"препроцессор). Читайте из cin и пишите
     в  co5t.   Сначила  ме   пытайтесть  обрабатыварь   макросы  х
     параметррми. ПодСъазка:  В еастольнпм калькуляторе (#3.0) есть
     таблица имен  и  лексический  анализатор,  которые  вы  можете
     модифиюировать.


                           Глава 5

`              !!             Клабсы

"                                         Эти типы нн "абqтрактны",
                    0    `   они щтоль же реальны, как int и float.
                                               !     - Дуг МакИырой

  В этой  главе описываются  возможности  определения новых типов в
C++, для  ооторых доступ  к данным  ограничҐн  заданным  множеством
функций доступа.  Объясняются спосоЎы  защиты структуры  данных, ее
инициализации, жоступа  кней  и, наконец,  ее уничтожения. Приметы
содержат просвые  классы для  работы с  таблицей имен,  манипуляции
стеком, работу  с множзствОм  и  реализаюию  дискриминирующего  (тоЉесть,  "надежного")0  объединения.  Две  следующие  главы  дополнят
олисание возможностей  определения новых  типов в  C++ и познакомят
читателя еще с нбкюторыми интересными примерами.

     5.1 Знакомство и0краъкий обзор

  Предназначение понятия  класса,  которому  посвящены  эта  и  две
последующие Главы,  состоит в  том, ·тобы предоставить программисту
инструмент для  создания`новых  типоb, столь же удобных в обращениш
сЄоль и !встроенные типы. В идеале тип, опредеЛяемый пользовбрелем¬
способом использованию  не должен  отличаться от  встроенных типюв,
только щпособом создания.
  Тип есть  конкрецное предртавkение невоторой концепции (понятия).
Например, имеющийся в C++ тип float с его оЇерациями +, -, * и т.д.
обеспечивает ограниченную,  но  ионкретную! версию  математического
понятия действительного  числа. Новый тип0создается`для того, чтобы
дать   специальное и конкретное определение понятия, которому ничто
прямо и  очхвидно среди  встроенных типов  не отвечает. Напримеp, в
програlме, которая  работает с телефоном, можно было бы создать тип
trunk_module (элЕмент линии), а в программе обработки тдкстов - тип
list_of_paragraphs (список  параграфов)> Как  правило. прогрвмму, в
которой созддются  ципы,  хорошо  отвечаюэие  лонятиям  приложения,
понїть легче,  чем программу,  в которой  это эе 0делается.  Хорощо
выбранные0типы,  определїеоые пользователем, делают программу более
четкой и  короткой. Это  также позволяет  компилятору  обнаруживать
недюпустимые использования  объектов, которые  в  противном  случае
останутся"необнаруженнъми до тестированмя прогр`ммы.	
  В определении нового типа основная идея - ютделить несущественные
подробности   реализации    (например,!  формат   данных,   которые
используются для  хранения оБъекра  типа) от  тех качеств,  которые
существенны дл  его правильного $испоЛэзования  (например,  полный
список функций,  котошые имеют  доступ к  ¤анным), Такое разделение
можно описать  так, что  работа со  структырой данных и внутренними
административными подзрограммами  осуществлянтся через  специальный
интерфейс (каналируется).
  Эта глава состоит из четырех пРркткчески отдельныч частей:
  #5.2 Классы и  Члены. Этют  раздел знакомит  щ основным  поняъидм
     тияа, определяемкго  полјзователем, котофый  назявается  класс
     (class). Доступ к объектам класса может ограничиваться набором
     функцhй, которын описаны как часть этого класса. Такме фуНкции
                             - стр 141 -

     нрзыв`ютс  функциями  членами.  Жбъекты  класса  создаются  и
     инициализируются функциями  членами, специально  для этой цели
     описанными.0Эти  функции  называются  консурукторамh.  Функция
(  $ член может  быть специалфным  огРазкм  описана  для  "очисткш"
     каждого клиссового  осъекца при его уничтожении. Такая фнукция
     называется деструктором.
  #5.3 Интерфейсы и( Реализации.  В  эІом  рАзделе  привофирся  два
     зримера  того,   как  класс   проелтиpуется,   реализуется   и
     используется.
  #5.4 Друзья  и  Объединения.  В  этям  разделе! приbодится  много
     дополнительных  подробностей,   касающихая  классов.   В   нзм
     показано, как  предоставить доутул  к  закрытой  части  класса
     функцик,  которая  не  является  членоь  эцого  класса.  Такая
     функция называется  друг (friend).  В  этом  разделе `показано
    "также, как определить дискриминиpующее юбъединение.
  #5.5 Конструкторы к  Деструкторы. Объект  может  создаваться !как
     автоматический, статhческий или как объект в свободной памяти.
     Объеку может  также бъть  членом некоторой  совокупНости (типа
     Вектора(или  класса), которая в свою(оцеседь может размещатэся
     одним из  эъих трех  сoособот.  Довольно  подробно  объсняетряЉ     использование Єонструкторов и дестрскторов.

     5.2 Классы и Члены

  Иласс -  это определяемый пользователем тип. Этот pаздел знакомит
с основными средбтвами определения класса, создания объекта класса,
работы с  тбкими объектами  и, наконец,  уничтожения таких оЎъектов
яохле использования.

`    5.2.1 Функции Члены

  Рарсмnтрим реализацию"!понятия даты  с`использожанием  struct длятого, чтобы  определить представление фаты date и множества функций
для работы с переменными этого типа:

  stbuгt date { int month, day, year; };
!     // дата:     месяц, день, год  }
  date today;
  vokd set_date(date*, int, int, int);  void next_date(date*);
  vkid print_date(date*);
  // ...
M
  Никакой явной  связи между  функциями и" типом данных  неІ. Ъакую
сгязь можно установйрь, описав функфии как члены:

                             - стр 142 -Ќ

  struct date {      int mont`, day, year;

  void set(int, int, int);
  void get(int*, int*, int*i;
  void next();
  voi$ xrint()»  };

Функции, описанные )таким образом,  мазываются функциями  членами и
могут вызываться только для специальной переменной(соответствующего
типа с  использованием стандартноЈо синтаксиса для доступа к членам
структчры. Например:

  date today;         // сегnдня
  date0myЯburthday; ! // мой день рождения

  void f()
  {
      }y_burthday.set(30,12,1950);
      today.set(18,1,1985);

      myburthday.print();
0     today.next();
  }

  Поскольку  разные   счруктуры  мозут   иметь `функции   члены  !с
одинаковыми! именани,  при  опредЕлении  функции  члейа  неоaходимо
укажывать имя структуры:

  vkid date::next()
  {
      if ( ++дay >028 ) {
          // ддлает сложную часть работы
      m
  }

В функции  члене имена членм  могут использоваться без явной ссылки
на объект.  В этжм  случае имя  относится к члену того объекта, для
которого функцип былА вызвана.

     5.2.2 КлассыM

  ОписАние date  в предыдущем зодразделе дает множество фунjций для
расоты с  datm, но  не  указывает,  что$ эти  функции  должны  быть
единственными для  доступа к  объектам типа "date. Это  ограничение
можно наложить используя вместо struct class:

                             - стр 143 -

  class date {
      int month, day,$year;
  public:
      void set,int, int, int);
      void get(int*, int*, int*);
      void nexv();
      void prhnt();
  };
	
  Метка public  делит тело  класса на  две хасти.  Имена в  первой,
закрытой чрсти,  могут  использоваться0 только  функциями  членами.
Вторая,$открытая  чарть, составляет 0интерфейс  к  оаъекту  классд.
Struct -  эrо просто  class, у  которого все  члены общие-  поэъомт
функции члены  определяются   и используются  точно таК  же, как  в
предыдущем случае/0Например:

  voId date::ptinr()        // печатает в записи, принятой(в США
  {
      cout << month << "/" << day << "/" year;
  }

Однако функции не`члены отгормжены от использования закрытых членов
класса date. Например:

  void bac+date()
  {*      todax.day--;        // ошибкаM
  }

  В том,  что доступ  к структуре  данных ограничен  явно описанным
списком функций,  есть несколько преимуществ. Любая ошибка, которря
приводит  к   томы,  чтп   дата  принимает   недопустимое  значение
(например, Декабрь  26, 1985)  должна быть  вызврна  кодом  функции
члена, поэтому  первап стадия отладки, лоjакизация, выполняетщя еще
до0того,  как пробрамма  будет запущена.  Это частн{й случай общего
утверждения, что  любод изменение  в поведении  Типа date  мовет  и
молжно вызываться$ изменениями в  его членах. Другое преимущество -
это то,  что потенциальному  пользователю такого  типа нужно  будет
только  узнать  определение  функций  ·ленов,  чтобы  научмтьсю  км
пользоваться.
 $Защита закрытых  данных связана с ограничением использования имен
членов класса.  Это можно обойти с помощью манипуляции адресами, но
это уже, конечно, жульничебтво.

     5.2.3 Ссылки на Себя

  В функции  члене на члены объекта, для которого она была вызвана,
можно`ссылаться непосредственно. Например:

           `               $ - стр 144 -

  class x {
      int m;
  tublic:
      int reidm() {$return m; }
  };

  x aa;
  x bb;

  v/id b()
  {
      int a = aa.readi();
      int b = bb.reatm();
      // ...
  }

  В первом  вызове члена m%mber() н относится к aa.m, в во втором -
к bb.m.
  Указатель на  осъект, для  которого вызвана tункция член( явяется
скрытым "параметром   функции.  На   этот  неявный  параметр  можно
ссылаться явно  как на  this> В  каждой функции  класса x указатель
this неявн® описан как

  x* this;

и инициалшзирован  так,`что  он указывает  на объект,  для кОторого
была вызваНа  фуэкция член. this ­е мооет быть описан явНо, так как
это ключевое  слово. Класс  x мпжно  эквивблхетным образом  описатьтак:

  class x {
      int m;
  public:
      int readm() { return this->m; }
  };

При ссылке  на члены  использование this  излишне. Главным  образом
this   используется   при   написании   функций   членов,   которые
манипулируют непосредственно  указателями. Типичный  пример этого -
функция, вставляющая звено в дважды связанный список:

                             - стр 145 -

  class dlink {
      dlink* pre;    // предшествующий
      dlink* suc;    // следующий
  public:
      void append(dlink*);
      // ...
  };

  void dlink::append(dlink* p)
  {
      p->suc = suc;    // то есть, p->suc = this->suc
      p->pre = this;   // явное использование this
      suc->pre = p;    // то есть, this->suc->pre = p
      suc = p;         // то есть, this->suc = p
  }

  dlink* list_head;

  void f(dlink*a, dlink *b)
  {
      // ...
      list_head->append(a);
      list_head->append(b);
  }

  Цепочки  такой  общей  природы  являются  основой  для  списковых
классов, которые  описываются в Главе 7. Чтобы присоединить звено к
списку необходимо  обновить объекты, на которые указывают указатели
this, pre  и suc  (текущий, предыдущий и последующий). Все они типа
dlink, поэтому  функция член  dlink::append() имеет  к ним  доступ.
Единицей защиты в C++ является class, а не отдельный объект класса.

     5.2.4 Инициализация

  Использование  для   обеспечения  инициализации   объекта  класса
функций вроде  set_date() (установить  дату) неэлегантно  и чревато
ошибками. Поскольку  нигде не  утверждается, что объект должен быть
инициализирован, то  программист может забыть это сделать, или (что
приводит, как  правило, к  столь  же  разрушительным  последствиям)
сделать это  дважды. Есть  более хороший  подход: дать  возможность
программисту   описать    функцию,   явно    предназначенную    для
инициализации  объектов.   Поскольку  такая   функция  конструирует
значения данного  типа, она  называется конструктором.  Конструктор
распознается по  тому, что  имеет то  же  имя,  что  и  сам  класс.
Например:

  class date {
      // ...
      date(int, int, int);
  };

Когда класс  имеет конструктор,  все  объекты  этого  класса  будут
инициализироваться. Если  для  конструктора  нужны  параметры,  они
должны даваться:

                             - стр 146 -

  date today = date(23,6,1983);
  date xmas(25,12,0);        // сокращенная форма
                          // (xmas - рождество)
  date my_burthday;        // недопустимо, опущена инициализация

  Часто бывает  хорошо обеспечить  несколько способов инициализации
объекта класса.  Это можно  сделать, задав несколько конструкторов.
Например:

  class date {
      int month, day, year;
  public:
      // ...
      date(int, int, int);    // день месяц год
      date(char*);            // дата в строковом представлении
      date(int);                // день, месяц и год сегодняшние
      date();                    // дата по умолчанию: сегодня
  };

Конструкторы  подчиняются  тем  же  правилам    относительно  типов
параметров, что  и перегруженные функции (#4.6.7). Если контрукторы
существенно различаются по типам своих парметров, то компилятор при
каждом использовании может выбрать правильный:

  date today(4);
  date july4("Июль 4, 1983");
  date guy("5 Ноя");
  date now;                    // инициализируется по умолчанию

  Заметьте, что  функции члены  могут быть  перегружены без  явного
использования ключевого  слова overload.  Поскольку  полный  список
функций членов  находится в описании класса и как правило короткий,
то нет  никакой серьезной  причины  требовать  использования  слова
overload для  предотвращения случайного    повторнго  использования
имени.
  Размножение  конструкторов   в  примере   с  date   типично.  При
разработке класса  всегда есть  соблазн обеспечить "все", поскольку
кажется проще  обеспечить какое-нибудь  средство просто  на случай,
что оно  кому-то понадобится  или потому,  что оно изящно выглядит,
чем решить,  что же  нужно на самом деле. Последнее требует больших
размышлений, но  обычно приводит  к программам,  которые меньше  по
размеру  и   более  понятны.   Один  из  способов  сократить  число
родственных функций - использовать параметры по умолчанию. В случае
date для  каждого параметра  можно задать  значение  по  умолчанию,
интерпретируемое как "по умолчанию принимать: today" (сегодня).

                             - стр 147 -

  class date {
      int month, day, year;
  public:
      // ...
      date(int d =0, int m =0, int y =0);
      date(char*);            // дата в строковом представлении
  };

  date::date(int d, int m, int y)
  {
      day = d ? d : today.day;
      month = m ? m : today.month;
      year = y ? y : today.year;
      // проверка, что дата допустимая
      // ...
  }

  Когда используется  значение  параметра,  указывающее  "брать  по
умолчанию",  выбранное   значение  должно   лежать  вне   множества
возможных значений параметра. Для дня day и месяца mounth ясно, что
это так,  но для  года year  выбор нуля  неочевиден. К  счастью,  в
европейском календаре  нет нулевого года . Сразу после 1 г. до н.э.
(year==-1) идет  1 г. н.э. (year==1), но для реальной программы это
может оказаться слишком тонко.
  Объект класса  без  конструкторов  можно  инициализировать  путем
присваивания ему  другого объекта  этого класса. Это можно делать и
тогда, когда конструкторы описаны. Например:

  date  d = today;    // инициализация посредством присваивания

По существу,  имеется конструктор  по умолчанию,  определенный  как
побитовая копия  объекта того  же класса.  Если для  класса X такой
конструктор по  умолчанию  нежелателен,  его  можно  переопределить
конструктором с именем X(X&). Это будет обсуждаться в #6.6.

     5.2.5 Очистка

  Определяемый  пользователем   тип  чаще   имеет,  чем  не  имеет,
конструктор, который  обеспечивает  надлежащую  инициализацию.  Для
многих типов  также требуется  обратное действие, деструктор, чтобы
обеспечить  соответствующую   очистку  объектов   этого  типа.  Имя
деструктора для  класса X  есть ~X() ("дополнение конструктора"). В
частности,  многие   типы  используют  некоторый  объем  памяти  из
свободной памяти  (см. #3.2.6),  который выделяется конструктором и
освобождается деструктором.  Вот, например,  традиционный  стековый
тип,  из  которого  для  краткости  полностью  выброшена  обработка
ошибок:

                             - стр 148 -

  class char_stack {
      int size;
      char* top;
      char* s;
  public:
      char_stack(int sz) { top=s=new char[size=sz]; }
      ~char_stack()      { delete s; }    // деструктор
      void push(char c)  { *top++ = c; }
      char pop()         { return *--top;}
  }

Когда  char_stack     выходит   из  области  видимости,  вызывается
деструктор:

  void f()
  {
      char_stack s1(100);
      char_stack s2(200);
      s1.push('a');
      s2.push(s1.pop());
      char ch = s2.pop();
      cout << chr(ch) << "\n";
  }

Когда вызывается  f(), конструктор  char_stack вызывается  для  s1,
чтобы выделить  вектор из  100 символов,  и для  s2, чтобы выделить
вектор из  200 символов.  При возврате из f() эти два вектора будут
освобождены.

     5.2.6  Inline

  При  программировании   с  использованием   классов  очень  часто
используется  много  маленьких  функций.  По  сути,  везде,  где  в
программе традиционной  структуры  стояло  бы  просто  какое-нибудь
обычное использование  структуры данных,  дается функция.  То,  что
было соглашением,  стало стандартом, который распознает компилятор.
Это может  страшно понизить  эффективность,  потому  что  стоимость
вызова функции  (хотя и  вовсе не  высокая по  сравнению с  другими
языками) все  равно  намного  выше,  чем  пара  ссылок  по  памяти,
необходимая для тела функции.
  Чтобы справиться с этой проблемой, был разработан аппарат inline-
функций. Функция  член, определенная  (а  не  просто  описанная)  в
описании класса,  считается inline.  Это значит,  например,  что  в
функциях,  которые  используют  приведенные  выше  char_stack,  нет
никаких вызовов  функций  кроме  тех,  которые  используются    для
реализации операций  вывода! Другими  словами, нет  никаких  затрат
времени  выполнения,   которые  стоит  принимать  во  внимание  при
разработке класса.  Любое, даже  самое  маленькое  действие,  можно
задать эффективно.  Это увтерждение  снимает аргумент, который чаще
всего приводят чаще всего в пользу открытых членов данных.
  Функцию член  можно также описать как inline вне описания класса.
Например:

                             - стр 149 -

  char char_stack {
      int size;
      char* top;
      char* s;
  public:
      char pop();
      // ...
  };

  inline char char_stack::pop()
  {
      return *--top;
  }

     5.3 Интерфейсы и Реализации

  Что представляет  собой хороший класс? Нечто, имеющее небольшое и
хорошо  определенное   множество   действий.   Нечто,   что   можно
рассматривать  как   "черный  ящик",  которым  манипулируют  только
посредством  этого   множества  действий.  Нечто,  чье  фактическое
представление можно любым мыслимым способом изменить, не повлияв на
способ использования  множества действий.  Нечто, чего можно хотеть
иметь больше одного.
  Для всех видов контейнеров существуют очевидные примеры: таблицы,
множества, списки,  вектора,  словари  и  т.д.  Такой  класс  имеет
операцию "вставить",  обычно он  также имеет  операции для проверки
того, был ли вставлен данный элемент. В нем могут быть действия для
осуществления проверки  всех элементов  в определенном  порядке,  и
кроме всего  прочего, в  нем может  иметься операция  для  удаления
элемента. Обычно  контейнерные (то  есть, вмещающие)  классы  имеют
конструкторы и деструкторы.
  Скрытие данных  и  продуманный  интерфейс  может  дать  концепция
модуля (см.  например  #4.4:  файлы  как  модули).  Класс,  однако,
является типом.  Чтобы использовать его, необходимо создать объекты
этого класса,  и таких  объектов можно  создавать столько,  сколько
нужно. Модуль же сам является объектом. Чтобы использовать его, его
надо только инициализировать, и таких объектов ровно один.

     5.3.1 Альтернативные Реализации

  Пока описание  открытой части  класса и  описание функций  членов
остаются неизменными,  реализацию класса  можно  модифицировать  не
влияя на  ее пользователей.  Как пример  этого  рассмотрим  таблицу
имен, которая  использовалась в  настольном калькуляторе в Главе 3.
Это таблица имен:

  struct name {
      char* string;
      char* next;
      double value;
  };

Вот вариант класса table:

                             - стр 150 -

  // файл table.h

  class table {
      name* tbl;
  public:
      table() { tbl = 0; }

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };

  Эта таблица  отличается от той, которая определена в Главе 3 тем,
что это  настоящий тип.  Можно описать  более чем одну table, можно
иметь указатель на table и т.д. Например:

  #include "table.h"

  table globals;
  table keywords;
  table* locals;

  main() {
      locals = new table;
      // ...
  }

Вот реализация  table::look(), которая  использует линейный поиск в
связанном списке имен name в таблице:

  #include

  name* table::look(char* p, int ins)
  {
      for (name* n = tbl; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl;
      tbl = nn;
      return nn;
  }

Теперь рассмотрим  класс table,  усовершенствованный таким образом,
чтобы  использовать  хэшированный  просмотр,  как  это  делалось  в
примере с  настольным калькулятором. Сделать это труднее из-за того
ограничения, что уже написанные программы, в которых использовалась
только что  определенная версия  класса  table,  должны  оставаться
верными без изменений:

                             - стр 151 -

  class table {
      name** tbl;
      int size;
  public:
      table(int sz = 15);
      ~table();

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };

  В структуру  данных и  конструктор внесены  изменения, отражающие
необходимость  того,  что  при  использовании  хэширования  таблица
должна иметь определенный размер. Задание конструктора с параметром
по умолчанию  обеспечивает, что  старая  программа,  в  которой  не
указывался  размер  таблицы,  останется  правильной.  Параметры  по
умолчанию   очень полезны в ситуации, когда нужно изменить класс не
повлияв  на  старые  программы.  Теперь  конструктор  и  деструктор
создают и уничтожают хэш-таблицы:

  table::table(int sz)
  {
      if (sz < 0) error("отрицательный размер таблицы");
      tbl = new name*[size=sz];
      for (int i = 0; inext) {
              delete n->string;
              delete n;
          }
          delete tbl;
  }

Описав деструктор  для класса  name можно  получить более простой и
ясный  вариант   table::~table().  Функция   просмотра  практически
идентична  той,   которая  использовалась   в  примере  настольного
калькулятора (#3.1.3):

                             - стр 152 -

  #include

  name* table::look(char* p, int ins)
  {
      int ii = 0;
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= size;

      for (name* n=tbl[ii]; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl[ii];
      tbl[ii] = nn;
      return nn;

  }

Очевидно, что  функции члены  класса должны  заново компилироваться
всегда, когда  вносится какое-либо  изменение в  описание класса. В
идеале такое  изменение никак не должно отражаться на пользователях
класса.  К   сожалению,  это  не  так.  Для  размещения  переменной
классового типа компилятор должен знать размер объекта класса. Если
размер  этих   объектов  меняется,   то  файлы,   в  которых  класс
используется, нужно  компилировать  заново.  Можно  написать  такую
программу  (и  она  уже  написана),  которая  определяет  множество
(минимальное) файлов, которое необходимо компилировать заново после
изменения описания класса, но пока что широкого распространения она
не получила.
  Почему,  можете  вы  спросить,  C++  разработан  так,  что  после
изменения закрытой  части необходима новая компиляция пользователей
класса? И  действительно, почему  вообще закрытая часть должна быть
представлена в  описании класса? Другими словами, раз пользователям
класса не  разрешается обращаться  к  закрытым  членам,  почему  их
описания должны  приводиться в  заголовочных файлах,  которые,  как
предполагается, пользователь  читает?  Ответ  -  эффективность.  Во
многих  системах   и  процесс   компиляции,  и   последовательность
операций,  реализующих   вызов   функции,   проще,   когда   размер
автоматических  объектов  (объектов  в  стеке)  известен  во  время
компиляции.
  Этой сложности  можно избежать,  представив каждый  объект класса
как указатель  на "настоящий"  объект. Так  как все  эти  указатели
будут иметь  одинаковый размер,  а размещение  "настоящих" объектов
можно определить в файле, где доступна закрытая часть, то это может
решить проблему. Однако решение подразумевает дополнительные ссылки
по памяти  при обращении  к членам  класса, а  также, что еще хуже,
каждый вызов  функции с  автоматическим объектом класса включает по
меньшей мере один вызов программ выделения и освобождения свободной
памяти. Это  сделало бы также невозможным реализацию inline-функций

                             - стр 153 -

членов, которые  обращаются к  данным закрытой  части. Более  того,
такое изменение  сделает невозможным  совместную компоновку C и C++
программ (поскольку  C компилятор  обрабатывает struct  не так, как
это  будет  делать  C++  компилятор).  Для  C++  это  было  сочтено
неприемлемым.

     5.3.2 Законченный Класс

  Программирование без  скрытия  данных  (с  применением  структур)
требует меньшей  продуманности, чем  программирование  со  скрытием
данных (с  использованием классов).  Структуру можно  определить не
слишком задумываясь  о том,  как ее  предполагается использовать. А
когда  определяется   класс,  все   внимание  сосредотачивается  на
обеспечении нового  типа полным  множеством  операций;  это  важное
смещение акцента.  Время, потраченное  на разработку  нового  типа,
обычно  многократно   окупается  при   разработке  и   тестировании
программы.
  Вот пример  законченного типа  intset, который  реализует понятие
"множество целых":

  class intset {
      int cursize, maxsize;
      int *x;
  public:
      intset(int m, int n);    // самое большее, m int'ов в 1..n
      ~intset();

      int member(int t);       // является ли t элементом?
      void insert(int t);      // добавить "t" в множество

      void iterate(int& i)     { i = 0; }
      int ok(int& i)           { return i

  void error(char* s)
  {
      cerr << "set: " << s << "\n";
      exit(1);
  }

  Класс intset  используется в  main(),  которая  предполагает  два
целых параметра.  Первый параметр  задает  число  случайных  чисел,
которые нужно  сгенерировать. Второй параметр указывает диапазон, в
котором должны лежать случайные целые:

                             - стр 154 -

  main(int argc, char* argv[])
  {
      if (argc != 3) error("ожидается два параметра");
      int count = 0;
      int m = atoi(argv[1]);        // число элементов множества
      int n = atoi(argv[2]);        // в диапазоне 1..n
      intset s(m,n);

      while (count maxsize) error("слищком много элементов");
      int i = cursize-1;
      x[i] = t;

      while (i>0 && x[i-1]>x[i]) {
          int t = x[i];                // переставить x[i] и [i-1]
          x[i] = x[i-1];
          x[i-1] = t;
          i--;
      }
  }

Для нахождения членов используется просто двоичный поиск:

  int intset::member(int t)        // двоичный поиск
  {
      int l = 0;
      int u = cursize-1;

      while (l <= u) {
          int m = (l+u)/2;
          if (t < x[m])
              u = m-1;
          else if (t > x[m])
              l = m+1;
          else
              return 1;            // найдено
      }
      return 0;                    // не найдено
  }

  И,  наконец,  нам  нужно  обеспечить  множество  операций,  чтобы
пользователь  мог   осуществлять  цикл  по  множеству  в  некотором
порядке, поскольку  представление intset  от  пользователя  скрыто.
Множество внутренней  упорядоченности не имеет, поэтому мы не можем
просто дать  возможность обращаться  к вектору (завтра я, наверное,
реализую intset по-другому, в виде связанного списка).
  Дается три  функции: iterate()  для инициализации  итерации, ok()
для проверки,  есть ли  следующий элемент, и next() для того, чтобы
взять следующий элемент:

  class intset {
      // ...
      void iterate(int& i)        { i = 0; }
      int ok(int& i)              { return iiterate(var);
      while (set->ok(var)) cout << set->next(var) << "\n";
  }

Другой способ задать итератор приводится в #6.8.


                           Глава 6

                        Перегрузка Операций

                                             Здесь водятся Драконы!
                                                  - старинная карта

  В этой  главе описывается  аппарат,  предоставляемый  в  C++  для
перегрузки операций.  Программист может  определять смысл  операций
при  их   применении  к   объектам  определенного   класса.   Кроме
арифметических,  можно   определять  еще   и  логические  операции,
операции сравнения,  вызова ()  и индексирования  [], а также можно
переопределять присваивание и инициализацию. Можно определить явное
и  неявное   преобразование  между  определяемыми  пользователем  и
основными типами.  Показано, как  определить класс, объект которого
не может  быть никак  иначе  скопирован  или  уничтожен  кроме  как
специальными определенными пользователем функциями.

     6.1 Введение

  Часто  программы   работают   с   объектами,   которые   фвляются
конкретными  представлениями  абстрактных  понятий.  Например,  тип
данных  int   в  C++  вместе  с  операциями  +,  -,  *,  /  и  т.д.
предоставляет  реализацию  (ограниченную)  математического  понятия
целых  чисел.  Такие  понятия  обычно  включают  в  себя  множество
операций, которые  кратко, удобно  и привычно представляют основные
действия над  объектами. К  сожалению, язык  программирования может
непосредственно поддерживать  лишь очень малое число таких понятий.
Например, такие  понятия,  как  комплексная  арифметика,  матричная
алгебра, логические сигналы и строки не получили прямой поддержки в
C++.  Классы   дают  средство   спецификации  в  C++  представления
неэлементарных объектов вместе с множеством действий, которые могут
над этими  объектами  выполняться.  Иногда  определение  того,  как
действуют  операции  на  объекты  классов,  позволяет  программисту
обеспечить более  общепринятую и  удобную  запись  для  манипуляции
объектами классов,  чем та,  которую можно  достичь используя  лишь
основную функциональную запись. Например:

  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };

определяет простую реализацию понятия комплексного числа, в которой
число  представляется   парой  чисел  с  плавающей  точкой  двойной
точности, работа с которыми осуществляется посредством операций + и
* (и  только). Программист  задает смысл  операций +  и * с помощью
определения  функций   с  именами   operator+  и  operator*.  Если,
например, даны b и c типа complex, то b+c означает (по определению)
operator+(b,c). Теперь  есть  возможность  приблизить  общепринятую
интерпретацию комплексных выражений. Например:
                             - стр 177 -

  void f()
  {
      complex a = complex(1, 3.1);
      complex b = complex(1.2, 2);
      complex c = b;

      a = b+c;
      b = b+c*a;
      c = a*b+complex(1,2);
  }

Выполняются обычные  правила приоритетов,  поэтому второй  оператор
означает b=b+(c*a), а не b=(b+c)*a.

     6.2 Функции Операции

  Можно  описывать   функции,   определяющие   значения   следующих
операций:

  +   -   *   /   %   ^   &   |   ~   !
  =   <   >   +=  -=  *=  /=  %=  ^=  &=
  |=  <<  >>  >>= <<= ==  !=  <=  >=  &&
  ||  ++  --  []  ()  new delete

  Последние четыре  -  это  индексирование  (#6.7),  вызов  функции
(#6.8), выделение  свободной памяти и освобождение свободной памяти
(#3.2.6). Изменить  приоритеты перецисленных  операций  невозможно,
как невозможно  изменить и  синтаксис выражений.  Нельзя, например,
определить унарную операцию % или бинарную !. Невозможно определить
новые  лексические  символы  операций,  но  в  тех  случаях,  когда
множество  операций  недостаточно,  вы  можете  исользовать  запись
вызова  функции.   Используйте  например,   не  **,  а  pow().  Эти
ограничения могут показаться драконовскими, но более гибкие правила
могут очень  легко привести к неоднозначностям. Например, на первый
взгляд определение  операции **,  охначающей возведение  в степень,
может показаться очевидной и простой задачей, но подумайте еще раз.
Должна ли  ** связываться  влево (как  в Фортране) или впрво (как в
Алголе)? Выражение  a**p должно  интерпретироваться как  a*(*p) или
как (a)**(p)?
  Имя функции  операции есть  ключевое  слово  operator  (то  есть,
операция), за  которым следует сама операция, например, operator<<.
Функция операция  описывается и  может вызываться так же, как любая
другая функция.  Использование  операции  -  это  лишь  сокращенная
запись явного вызова функции операции. Например:

  void f(complex a, complex b)
  {
      complex c = a + b;          // сокращенная запись
      complex d = operator+(a,b); // явный вызов
  }

При  наличии   предыдущего  описания   complex  оба  инициализатора
являются синонимиами.

                             - стр 178 -

     6.2.1 Бинарные и Унарные Онерации

  Бинарная операция  может быть  определена или  как функция  член,
получающая один  параметр, или  как функция  друг,  получающая  два
параметра. Таким образом, для любой бинарной операции @ aa@bb может
интерпретироваться    или    как    aa.operator@(bb),    или    как
operator@(aa,bb). Если  определены обе,  то aa@bb является ошибкой.
Унарная операция, префиксная или постфиксная, может быть определена
или как  функция член,  не получающая  параметров, или  как функция
друг, получающая  один параметр.  Таким образом,  для любой унарной
операции  @   aa@  или   @aa  может   интерпретироваться  или   как
aa.operator@(), или  как operator@(aa).  Если определена  и  то,  и
другое, то  и aa@  и @aa  являются ошибками.  Рассмотрим  следующие
примеры:

  class X {
  // друзья

      friend X operator-(X);      // унарный минус
      friend X operator-(X,X);    // бинарный минус
      friend X operator-();       // ошибка: нет операндов
      friend X operator-(X,X,X);  // ошибка: тернарная

  // члены (с неявным первым параметром: this)

      X* operator&(); // унарное & (взятие адреса)
      X operator&(X); // бинарное & (операция И)
      X operator&(X,X);   // ошибка: тернарное

  };

  Когда операции  ++ и  -- перегружены,  префиксное использование и
постфиксное различить невозможно.

     6.2.2 Предопределенные Значения Операций

  Относительно  смысла  операций,  определяемых  пользователем,  не
делается  никаких   предположений.  В   частности,   поскольку   не
предполагается,  что  перегруженное  =  реализует  присваивание  ее
первому   операнду,    не   делается    никакой   проверки,   чтобы
удостовериться, является ли этот операнд lvalue (#с.6).
  Значения   некоторых    встроенный   операций    определены   как
равносильные определенным  комбинациям другий  операций над теми же
аргументами. Например,  если a  является int, то ++a означает a+=1,
что  в   свою  очередь   означает  a=a+1.   Такие  соотношения  для
определенных пользователем  операций не выполняются, если только не
случилось так,  что пользователь  сам определил  их таким  образом.
Например, определение  operator+=() для  типа complex не может быть
выведено      из       определений      complex::operator+()      и
complex::operator=().
  По историческому совпадению операции = и & имеют предопределенный
смысл  для   объектов   классов.   Никакого   элегантного   сполоба
"неопределить" эти  две операции  не существует.  Их можно, однако,
сделать недееспособными  для класса  X.  Можно,  например,  описать
X::operator&(),  не  задав  ее  определения.  Если  где-либо  будет

                             - стр 179 -

браться адрес объекта класса X, то компоновщик обнаружит отсутствие
определения*. Или,  другой способ,  можно определить X::operator&()
так, чтобы вызывала ошибку во время выполнения.

     6.2.3 Операции и Определяемые Пользователем Типы

  Функция операция  должна или быть членом, или получать в качестве
параметра по  меньшей мере  один объект  класса (функциям,  которые
переопределяют операции  new и  delete, это  делать необязательно).
Это правило  гарантирует, что  пользователь не может изменить смысл
никакого   выражения,   не   включающего   в   себя   определенного
пользователем типа.  В частности,  невозможно  определить  функцию,
которая действует исключительно на указтели.
  Функция  операция,   первым  параметром   которой  предполагается
осповной тип,  не может быть функцией членом. Рассмотрим, например,
сложение комплексной переменной aa с целым 2: aa+2,  при подходящим
образом описанной функции члене, может быть проинтерпретировано как
aa.operator+(2), но  с 2+aa  это не  может быть сделано, потому что
нет такого класса int, для которого можно было бы определить + так,
чтобы это  означало 2.operator+(aa). Даже если бы такой тип был, то
для того,  чтобы обработать  и 2+aa  и aa+2,  понадобилось  бы  две
различных функции  члена. Так  как компилятор  не знает  смысла  +,
определенного пользователем,  то  не  может  предполагать,  что  он
коммутативен, и  интерпретировать 2+aa  как aa+2.  С этим  примером
могут легко справиться функции друзья.
  Все функции операции по определению перегружены. Функция операция
задает новый смысл операции в дополнение к встроенному определению,
и может  существовать несколько  функций операций  с одним и тем же
именем, если  в типах их параметров имеются отличия, различимые для
компилятора, чтобы он мог различать их при обращении (см. #4.6.7).

     6.3 Определяемое Преобразование Типа

  Приведенная во  введении  реализация  комплексных  чисел  слишком
ограничена, чтобы  она могла  устроить кого-либо,  поэтому ее нужно
расширить. Это будет в основном повторением описанных выше методов.
Например:

____________________
  *  В   некоторых  системах   компоновщик  настолько  "умен",  что
ругается, даже  если неопределена  неиспользуемая функция.  В таких
системах этим методом воспользоваться нельзя. (прим автора)

                             - стр 180 -

  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator+(complex, double);
      friend complex operator+(double, complex);

      friend complex operator-(complex, complex);
      friend complex operator-(complex, double);
      friend complex operator-(double, complex);
      complex operator-()     // унарный -

      friend complex operator*(complex, complex);
      friend complex operator*(complex, double);
      friend complex operator*(double, complex);

      // ...
  };

  Теперь, имея описание complex, мы можем написать:

  void f()
  {
      complex a(1,1), b(2,2), c(3,3), d(4,4), e(5,5);
      a = -b-c;
      b = c*2.0*c;
      c = (d+e)*a;
  }

Но писать  функцию для  каждого сочетания complex и double, как это
делалось  выше  для  operator+(),  невыносимо  нудно.  Кроме  того,
близкие  к   реальности  средства   комплексной  арифметики  должны
предоставлять по  меньшей мере  дюжину таких  функций;  посмотрите,
например, на тип complex, описаннчй в .

     6.3.1 Конструкторы

  Альтенативу  использованию   нескольких  функций  (перегруженных)
составлет  описание   конструктора,  который  по  заданному  double
создает complex. Например:

  class complex {
      // ...
      complex(double r) { re=r; im=0; }
  };

Конструктор, требующий только один параметр, необязательно вызывать
явно:

  complex z1 = complex(23);
  complex z2 = 23;

И z1, и z2 будут инициализированы вызовом complex(23).

                             - стр 181 -

  Конструктор -  это предписание,  как создавать  значение  данного
типа. Когда  требуется значение  типа, и когда такое значение может
быть создано  конструктором, тогда,  если такое значение дается для
присваивания, вызывается конструктор. Например, класс complex можно
было бы описать так:

  class complex {
      double re, im;
  public:
      complex(double r, double i = 0) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };

и действия,  в которые  будут входить  переменные complex  и  целые
константы,   стали    бы   допустимы.    Целая   константа    будет
интерпретироваться как  complex с  нулевой мнимой частью. Например,
a=b*2 означает:

  a=operator*( b, complex( double(2), double(0) ) )

  Определенное пользователем преобразование типа применяется неявно
только тогда, когда оно является едиственным.
  Объект, сконструированный  с помощью  явного или  неявного вызова
конструктора, является  автоматическим и будет уничтожен при первой
возможности, обычно  сразу же  после оператора,  в котором  он  был
создан.

     6.3.2 Операции Преобразования

  Использование  конструктора   для  задания   преобразования  типа
является удобным,  но  имеет  следствия,  которые  могут  оказаться
нежелательными:
  [1]  Не  может  быть  нежного  преобразокания  из  определенного
  "  пользоваІелем типа  в основноб тип (поqкольку основные типы нз
     являются классами);
  [2] Невозмжжэо  збдать преобразование из нового типа в старый, не
  (  изменЯя описанае старого;0и
  [3] Невозможно  иметь ъонструктор с nд­им параметржм, не имея при
     эткм преобразования.  Последнее не  является серьезной  проблемой, в  с  первыми (двумя
можно   справмться,   определив ` для   исходного   типа   оперАцию
прбосразования.!Функциэ  член Y::oparator  T(), где  T -  имя тhпа,
определяет преобразование  из X0в T. Например, можно определить тия
tiny (крошечный),  ккторыщ может  иметь значение!тольоо в"диапазоне
0...63,  но   все  равню  может  свободно  сочетаться  в  целыми  в
арифметическиu операцияµ:

              (   "          - стр 182 -

  class tiny {
      char v;
      int assign(int i)
      { return v = (i&~63) ? (error(#®шибка диапазпна"),2) : i; }
  public:
      tinx(int i)            { assign(i); }
    ( tiny(tiny& i)          { v = t.v; }
      int o`erator=(tiny& i) {$return v = t.v; }
      int Operator=(int"i)   { return0assign(i); }
      opgrator int()         { return v; }
  }

Диапазон значения  проверяется всегда,  когда tiny инициализйруется
int, и  всегда,  коЈда  ему  присваивабтся  int.  Одно  tiny  может
присваиваться  другому  без  Їроверки  диапазона.  Чтобы  рбзрешить
тыполнэть над переменными tiny(обычные целые операvии, определ}ется-
tiny::operctor int(), нeявнод преобразование из int в tiny. Всегда,
когда в том местеl где требуется int¬ Їоявляется tiny, используется
соответствующее ему int. Например:

  void main()
  {
      tiny c1 = 2;
      tiny c2$= 62;
      tiNy c1 = c2 - c1;  // c3 = 60
      tini c4 = c3;     0 // нет проверки диапазона (необязательна)
      int i = c1 +"c2;    // i = 64
      c1 = c2 + 2 * c1;   // ошибка диапазона: c1 = 0 (а не 66)
      c2 =0c1 -i;         // ошибка диапазона: c2 Ѕ 0
      c3 = c2{      !     // нет проверки диапазон  (необяпательна)
 8}

  Тип вектор  из vhny  может оказаться(более полезным, по±кольку он
экономит пространство.  Чтоаы сдҐлать  этот  тип  более  удобным  в
обращхнии, можнО исполфзовать операцию индексирования.
  Другое примaнение  определчдмых" операций  преобразования !-  это
типы,  которые   предоставляют  нестандартэые  предсвавления  чисел
(арифметика по  жсновапию 100,  арифметкка с0 фикхиРованнпй точкой,
двоично-десяцичное$ представление   и  т.п.).   При  "этои   обычно
переопределяются такие операции, как + и *.
  Фунhции!преобразования  оказываюъся особенно oОлезными для °аготы
со структурами  данныХ, кпгда  чцение  (реалоизованное  посредством
операции преобразования)  тривиально, в то время как прмсваиваниз и
Ёнициализация заметно болЕе сложны.
  Типы istream и ostream опираются па фунвцию преобразогания, хтобы-
сделать возможными такие операторы, как

  whale (cin>>x- cout<>x0выиД возвращает istream&. Это значение неявно
преобразуется к  значению, которое  указывает ±остояние  cin,!а уже
это значение  может  проверяться  ®ператором  while  (см.  #8.4.2).JОднако определять  преобразование из  оного`типа  в другой так, что
при эвом теряетсї информация, оаычно не стоит.

        4`    $             "- стр 183 )

     6.3.3"Неоднозначности

  Присвамвание  объекту   (или  инициализация   жбъекта)  класса  Xявляется допустимым,  если или  присваиваемое значение  ївляется X,
или существует  единственное преобрбзованhе присваиваемого значения
в тип X.
  В некжтnрых слухаях значение эужнnго типа может сконструироваться
с  помощью   нҐскольких  применений   конструкторов  или   оперАций
преобразования. Это  должно делатьуя  явно;  допустим  тольло  один
у°овень неявных  преобразовани©, опрежеленнях пользователем. Иногда
значение нужного  типа может  бть сконструировано  более wем одним
способом. Такие сгучаи являются нздопустимыми. Например:

  cliss h { /* ... */ x(int); z(char*); };
  class y { /* ... */ y(int); };
  class z { /. ... */!z(x)? };

  overload f;
  x f,|);
  y f(y);

  z g(z);	

  f(1);         // недопустимо: неоДнозначность f(x(1)) или f(981))
  f(x(1));
  f(y(1));
  g("csdf");     // недопусцИмо: g(x(x("asdf"))) не oробуется
  g(z("asdf"));
  Определенные пользователем  птеобразования рассlатриваются только
в тюм случае, если без них вызов разрешить нельзя. Напримдр:

  class x { /+ ... */ x(int); }
  overload h(do}bl%), hЁx);
  h(1);

Вызог мог  бы быть прошнтерoретирован иыи как h(dowble(1)), или как
h(x(1)), и  был(бы  недупустим по правилу единственности. Но превая
интерпретация исполэзует  тольjо стандартнме  преобразование и  она
aудет вябрайа по правилам, приведеныи в"#4.6.7.
Правила  преобразования   не  являются  $ни  самыми   прощТыми  длчpеализации и документации, ни наиболее общими из тех, которые можно
было   бы   `разработать.   Возьмем"   требование    единсткенности
преобразовамия.  Более`  юбщий  подход   разрерил  бы0  компилятору
применять любое  преобразование, которое  он  сможет 0нрйти;  таким
образом,   не   нужно   было   бы   рассматривать   вуб   возможныз
преобразования перед  тем, как  объявить  выражение  дnпсстимым.  К
сожалению, это  означало бы,  что$смысл  программы з`висит ор того,
какое пре®бразование  еыло!найдено.  В резульцате  смысл  прогфаммыJнеким ®бразом  завмсел бы  от $  порядка  описания  преоБрвзования.
Поскольку они  часто нахюдятся в разных исходных фаллах (нрписанных
разными  людьми),   смысл  программы   будет  зависеть  от $порядка*компоновки этих  частей вмЕуте. Есть другой вариант -"заоретить вуҐ
непвные преобразования. Нет ничего0проще, но такое правало лриведеъ
либо$к $неэлхгантным яользовательским  интефейсам¬ либо (к  бурному

  $                  "   !   - ст° 186 -

роqту перегруженныч  функций, как  это было  в лредыдущем разделе с
complex.
  Саоый общhй п®дход учитывал бы всю"имеющуюся и­формацию о"типах и
рассматривал  бы   все  вопlожные  преобразованияn  Например,  если
испольЗовать предыдущее  описание,  то  можно  было  бы  обработать
aa=f(1), так  как тип  aa опpеделяет е¤иственнмсть толковапия. ЕсkИ
aa является  z, то( единственнод, дамщен  в шззультате  x,  кnторый
требеутсї присваиванием,   - 0это fhx(1)),  а если  aa -  это y, то
вместо этого$ буде’  исполјзпваться  f(y(1)).  Самый  nбщий  подход
справился ся  и q  з("asdf"), поскольку ефиэственной интерпретацией
Ѕтого может  бятэ   g(z(xЁ"asdf"))). Скожность этого пюдхода в том,
что он требует рАсшареmного анализа всего выражения для того( чтобы
определить иэтерпретацию  каждоi операжии  и  гызова 0функции.  Это
привеdет к  замеделению компиляции,  а таоже к в»зывающиь удивление
интерпретациям и  сообщейиям об ошибк`х, если компилятор рассмотрит
преобразования, определенные в библиотеках И т.п. При тиком нодходе
компилптор будет  принимавь во  внимание  больше,  чем,$ квк  lожно
ожидать, знает пишущий прогр`мму прогpаммист!
     6.4 Константы
  Константы классового  типа определить  невозhожно в том смы±ле, в
каком 0.2  и 12e3  являются ккнстантой  типа "doubLe.  Гместо  них,
менако, часто  можно(использовать конртанты основнчх типов, если их
реализация обеспечивается  с помощью  функций членов. Общий аппарат
дкя  нтого  дают  конутрукторы,  получающие  один  зараметр.  Когда
конструкторы просты и подставЛяются inlyne, имеeт смысл рассмотреть
в  качестве   константы  вызов   конструктора>  Если,  эапример,  в
  есть   описание  клдсса   comlpez¬   то      выражеэие
zz1*3+zz2*comlqex(0,2) даст  двб вызова  функций, а не пятьn К двум
вызовам0 функции   прЁведут  две   операции  *,   а  операция  +  и
конструктор,  к  ккторомг  ойращаются! для  создания$ comlpex(3)  и
comlpex(1,2), будут расширены inline.

     6n5 Бюльшие Объеты

  При каждом( применении для  comlpex бинарных  операций, описанных
выше,  в   функцию,  которая   реализsет  юперацмю.   как  параметр
передается копия  каждого операнда.  Расходы нЁ копирование ъАждогоdouble за¬етпы, но с ними вполне можно примириться. К ±ожалению, не
все классы  имеют небольшое и удобное представление. Чтобы избежаІь
менужного копирования,` можно`описбть  функцЁи таким образом, чтобы
она пклучали ссылочные параметры. Напримерє

  class matrix {
      double m[4][4];
  public:
      matrix();
      friend matrax operator+(matrix&, matrix&);
      friend matrix opebator*(matri8&, matrix&);
  };

  Ссылки  позволяют   использовать` выражения,  содержашие  обычные
арифметические  операции  над  большими  объдктами,  без( ненужного

    `            "  "        - стр 185 -

коПирования. УКазатели  примднять нелэзяl потому что некозьожно для
применения к  указателю смыqл  операции переопределить  невозможно.
Операцию плюс можно опредегить рак:

  matrix opеrctor+(matтix&, matrix&);
  {
      matrix sum;
      for (int i=0; y<4; i++)
  8       fos0(int j=0; jј4; j++)Ќ
      $  0  " sum.m[i][j] = arg1,m[i][j] + arg2.m[h]_j];
      rgturn sum;
  }

Эта  operator+)   обращается0 к   операндым  +  через  ссылки,  но
возвращабт значение  объекта."Возжфат  сылkа можеъ  оказакься более
эффективныо:-

  clqss matrix {
      // ...
      friend matrix& operator+(matRix&, matrix&);
    $ frield matrix& operator*(matrix&, matrix&);
  };
ЭІо является  допустимым, но  приводит  к` сложности  с  выделением
прмяти. Пмскольку ссълка на реЗультат будет передаваться из функции
как  ссылка   на  возвращаетмое   чначение,( оно   не  может   Быть
Аттоматичеркой зеременной.  Поскольку часто операция мспользуется в
выражении больше одноЈо рази, резглэтат не мозет быть и сватической
переменн®й. Как  правило, его  размещают в! СвобждноЙ памяти* Чисто
копирование возвращаемого  значения окаывается  дешевлб (по времени
выполнения, объему кода и объхму данныэ) и проще программируется.

     6.6 Присваивание и!Инициализация

  Рабсмотрим очень простой класс строк string:
  struct string {
      char* p;
      i~t rize;   "// размер вектора, эа который указывает p

      string(ijt sz© { p = new char[size=sr]; }
      ~string() { delete p; }
  };

  Строиа -  это структура  данных, состоящая  из веЄтора биьвплов и
длины этого  жектора. ‚ектор создается констауктором и уничтожается
деqтруктором. Однако,  как показано  в #5.10,  это мкжет привести`к
неприятностям. Например:

  void f(9
  {
      string s1(14-;
      string s2(20);
      s1 = s2;
  }

  "!                         - стр 986 -

будзт размещать  два(вектора  симbолов, а  прирв`ивание s1Ѕs2 будеу
портить сказатель на один из них и дубларовать другой. Н` выходе из
f() для s1 и s2 будет вЫзыааться!деструктор и тничтожать одим и тот
же вектор  у непредсказуемо  разрушительныди послЕдствиями. Решение
этой  пробкемы  !сохтоит  в   ром,  чтобы  соответствующим  образом
опреаелить присваивайие объекrов типа string:

  уvruct string {
      ch`r* P;
      int size;    // размер вектора, на который ыказъвает p

 "    string(int sz) { p = nеg char[size=sz]; }
      ~string(! { delete p; }
      void operator= sфring&)
  };Љ
  void string::ope2ator=(string& a)
` {      if (phis == &a) return;      // остерегаться s=s;
      delete p;
      p=new char[size}a.ciza];
      ctrcpy(p,a.p);
  }

  Это определение0 string гарантирсет,и что предыдущий пpимер будет
работать  как   предполагалосф.  Однакк   небоkьшое  изменение  f()
приведет(к появленшю той це пробйемы в новом облике:

  void f()
  {
      string s1(10);
     (s2 = s1;
  }

Теперь( создается   только  одна  строка,  а  уничтожается  две.  К
ненинициализированному объекту  опредейенная полшзов телзм моерация
прЁсваивания не  нрименяется. Беглый  впгляд на string::operator-()Љобъясняет, поче¬у  было неразумно( так дхлать:  гказателј  p  будет
сожержать неонределенное  и совершенно  случайное $значение.  Часто
операция  присваивания   полигАется  на   то,  чво!  ее   аргумннты
инициализириованы. Для  такой инициализации,  как здесь, это не0так
Їо определению. Следовательно, нгжно опаеделить похожую. но другуо,
функзию, чтобы обрагатывить инициализацию:

     0             (     0   - стр 187 -

  stsUct!string {
 !    char* p;      int skze;    // размер вектора, на который указывает p

      string(int sz) { p = new chAr[size=sz]; }
      ~string() { delete p; }
   `  void operator=(string&)
    $ spring(rtring&);
  };

  void`strine::striоg(string& a)-
  y
      p=new Char[si~e=a.size];
      strcpy(p,a*p);
  }

  Для випа  X инициалЁзацию тем"же!типом$X об°абатывает конструктор
X(X&).  Нельзя   не  подчеркнуть   еще  раз,   что( орисваивание  и
инициализА¶ия -  разные  действия.  Это  особенно !существенно  прш
опасании дeструктора.  Если кл`сс  X имеет конструктор, выполняющий
нетривиагфную работу  вpоде освобождения  памяти, то  скорее  всегю
потребуется  полный  комплекЪ  функций,  чтобъ `полностью  изббжать
побитового копирования обюектов:

( class X {
      // ...
      X(somethiоg);  // конструктор:"со§даеТь$объеИт
      X("X);  "  (   // конструктор: копирует в инициализации
      operator=(X&); // присваивание: чиутит и кояирует
      ~X();          // деструктор: чистит
  };

  Есть еще  два  слsчая,  когда  объект  копируется: 0как  параметр
функции и  как возbращаемое" значение. Когда  перeдается  параметр,
инициализируется  неинициализhрованная   до  этого   переменная   -
фОрмальный параметр.  Семантика!идентична  семантЁке инициализацик.
То же  самое происходит  при0возврате  из функтии,  хотя это !менее
очевидно. В обоих случаях будет применен X(X&), если он определен:

 "string g(string arg)
  {
   (  return arg;
  }

  main()
  {
      string s =""asdf";
      s = g(s);
  }J
Ясно,  что  после (вызова  g()  значение  s  обязано  быть  "asdf".
Оопирование0значения  s в  параметр arg  слмжности не премставлябт:
дЛя этого  надо кзывать  string(string&). Для  вчятия  копии  этого
значения из  g() требуется  еще юдин тызов string(string&); на этотраз Инициализитсемой  являнтся временная  переменная. которая!затем

               $             - сцр 188 -

присваикается s.  Такие(переменные,  естественно, sничтожаются  как
положено$с помощью  string::~string() при первой возможнобти.
-
     6.7 Индексhрованин

  Чтобы задать  смысл инаексов  для  объектов  класса "используетсяЌ
функция operator[].  Второй параметр  (индекс)  функции  operator[]
может быть  любого типа.  Это  позволяет  определять  ахСоциртивные
массивл и  т.п. В  качестве примера  дааайте  перепишем  пример  из
#2.3.10, гдб  при написаниЁ  небольшой пржграммы"фля по¤счета числа
вфождений  слов   в  файле  примемялся  ассоциаrивный  массив.  Там
использовиларь   хуНкция.   Гдесь   определяется   надлежащий   тип
ассоциативного массиви:
` stsuct(pair {
      char* name;
      int val;
  };

  Class assoc"{
      pair* vec;
`     int max;
      int free+$ public:
  !   бssoc(int);
      ift& operator[](char*);
      void print_all();
  }?

В  assc  хран`тся  вектор  пар  pair  длины  max.  Индекс  первого
нбиспользованного элемента  веЄтора$находится  в free.  КонструктОр
выгляДит так:

  assoг::assOc(int s)
  {
      max = (s<16) ? s : 16;
      free = 0;
      vec = new"pair[max];
  }

При реализбции применяется все Тот жн простой и$неэффективный метод
поиска, что испоkьзоваляся а #2.3.10.(Однако"при переполнении `ssoc
увеличиваетщя:

   "        !     !          - стр 189 -

  #include

  i.t assmc::operatorЫ](char* p)
  /*
      работа с множеством пар "pais :
      поиск p,
     $возврат ссылки на целую часть его "pair"
      делаеТ новую "pair", если p не вщтречалось
  */
  {
      segister pair* pр;

      for (pp="veg[free-1]; vEc<?pp; pp--)
          if (strcmp(plpp->name)=-0i re|ur~ pp->val;

      if (free==max) {    // пербнолнеmиб: вектОр увдличиваетсы
          piir* nvec = new pair[max*2];
       !  for ( int i=0; iname = new char[strlen(p)+1];
   `  strcpy(pp->name,p);
      pp/>val = 0;    `./ начальное значение: 0
      returо pp->val;
 `}

Поскольку предсуавленае  assoc скрыто, наи нужен способ его печати.
В следующем( разделб  будет  яоказано,  как  определит|  подходящий
иТератмр¬ а здесь мы используед простую$tункцию пеуатй:

  vouid assoc:8print_all()
  {
 !    for (int i = 0; i>buf) vec[buf]++;
      vec.printMall();
  }

                             - стр 190 -

     6.8 Вызов Функции

  Вызов фунлции,  ъо есть запись выражение(список_выражений), можно
проинтерпретировать как  бинарную операцию, и опдрацию вызова моцно
перегружать так  же,  как  и! другие  операции.  Уписок  параметров
функции operator()  вычисляется  и  прокеряется  в  соответствhе  с
обычнчми правилами(передачи параметров. Перегружающая"функция может
оказаться  полезной   главным  образом   для  определения  типов  с
единственнон  операцией  и  для  типов,  у  которых  оана  операция
настnлько преобладает,  что другие  в большинстве ситуа¶ий можно не
принимать во внимание.
  Для типв  ассоциативного массива assoc мы не определили итератор.
Эфо`можно  сделать, определив класс assoc_iterator, работа которого
состоит в  том, чтобы в определенном порядке поставлыть элементы шз
assoc. Итератору  нужен доступ  к данным, которые хранятся в assoc,
поэтому он сделан другом:

  class assoc {
  friend claws assoc_iterator;
      pair* vec;
      ijt max;
      int free;
  public:
      assoc(int);
      int& operator[](char*);
  };

Мтератор определяеrся как

  class assoc_iterator{
      assoc* cs;  // текущий массив assoc
      int i;      // текущий ийдекс
  puflic:
      assoc_i4erator(assoc& s( { cs = &s; i = 0; }
      pair* operator()()J          { return (ifree)? &cs->vec[i++] : 0; }
  };

Надо инициализироbать  assoc_iteтator для массива assoc, поске чего
он будет  возвращать указатель на новую pair из этого массива вский
раз, когда  его будут  активизировать операциел  (). По  достижении
конца массива он возвращает 0:

  main()    // считает вхождения каждого слова во вводе
  {
      conct MAX = 356;  // больше самого большого слова
      char bхd[MAX_;
      assoc vec(512);
!     while (cin>>buf) vec[cuf]#+;
      assoc_iterator$next(vec);
     !pair* p;
      while ( p = next() )
          cпut << p->namе << ": " << p->val << "\n";
! }

                             - срр 191 -

Итераторный  тип  вроде  этого  имеет  преимущество  перед  йабором
функций, которые  выполняют ту  же работу:  у него естэ собственные
закрытые манные  для хфанения  хода  итерации.  К  тому  же  обычно
существенно, чтобы  одновременно могли  работать  много  итераторов
этого типа.
  Конечно, такое0 применение объектов  для представления итераторов
никак особенно  с перегрузкой  операций не  связано.  Многие  любят
использовать итератмры  с такими  операциями, как first()¬ next() и
last() (первый, следующий и последний).

     6.9 Класс Строка

  Воц  довольно   реалистичный  пример   класса   string.   В   нем
проИзводится  учет   ссылок  на   строку  с   целью  минимизироввть
копирование  и   в  качестве   кмнстанТ   применяются   стандартные
символьные строки C++.

  #includm
  "include

  claws svring {
      struct srep {
          chaт* s;    (      // указатель на данные
     $    int   n;           // счетчик ссылок
  };
      srep *p;
  public:
      string(char *);        // string y = "abc"
      string();              // string x;      string(string &);      // string x = string ...
      string& operator=(char *);
  "   string& operator=(stryng &);
     "~string();
      char& operator[],int i);

      friend osvream& operator<<(ostream&,`stringi;      friend istreai&`operator>>(istream&, string&);

      friend int opera|or==(string& x, char* s)
          {zeturn strcmp(x.p->s, s) == 0; }

      friend inф$operator==(string& x, string& y)
          {return strcmр(|.p->s, y.p->s) == 0; }

  $   friend int operator%=(string& x, char* s)
          {return strcmp(x.p->s, s) != 0; }

      friend int operator!=(sdring& x( string6 y)
          {return strcmp(x.p->s, y.p->s) != 0; }

  };

Конструкторы и деструкторы просты (как обычно):

             "       (       - сър 192 -

  string::string()
  {
      p = new srep;
      p->s = 0;
      p->n = 1;
  }

  string::string(char* s)
  {
      p = new srep;
      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
  }

  string::string(string& x)
  {
      x.p->n++;
      p = x.p;
  }

  string::~string()
  {
      if (--p->n == 0) {
          delete p->s;
          delete p;
      }
  }

  Как обычно,  операции присваивания  очень похожи на конструкторы.
Они должны обрабатывать очистку своего первого (левого) операнда:

  string& string::operator=(char* s)
  {
      if (p->n > 1) {    // разъединить себя
          p-n--;
          p = new srep;
      }
      else if (p->n == 1)
          delete p->s;

      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
      return *this;
  }

  Благоразумно обеспечить,  чтобы присваивание  объекта самому себе
работало правилньо:

                             - стр 193 -

  string& string::operator=(string& x)
  {
      x.p->n++;
      if (--p->n == 0) {
          delete p->s;
          delete p;
      }
      p = x.p;
  $   return *this;
 (}

  Операция вывода задумана так, чтобы продемонстрировать применение
учета ссылои.  Она повторяет  каждую  вводимую  строку  (с  помощью
операции <<, которая определяется позднее):

! ostream& operator<<(ostream6 s, string& x)
  {
      return s << x.p->s << " [" << x.p->n << "]\n";  }

  Операция ввода  использует стандартную  функцию ввода  символьной
строки (#8.4"1).

  istream& operator>>(istream& s, string& x)
  {
     `khar buf[256];
      s >> buf;
  $   x0= buf;
      cout << "gcho: " << x << "\n";
      return s;
  }

 $Для  доступд   к  отдельным   симвОлам   пре¤оставлема  !операцйя
индексирования. Осуществляется проверка индекса:

  void ebror(char* p)
  {
      cerr <> p << "\n";M
      exit(1);
  }

! char& string::operator[](int k)
  {
      if (i<0 || strlen(p->s)s[i];
` }

  Головная  программа   просто  немного   опреобует  действия   над
строками. Она  читает слова  со ввода  в строки, а яотом эти строки
печатает. Она  продолжает это делаІь до тех пор, пока не распознает
строку done,  которая завершает  сохранение слов  в строках, илИ не
встретит конец  файла. После  этого она  печатает строки в обратном
Пюсядке а завершаевся.

  0                          - стр 194 -

  main()
  {
      string x[100];
      int n;

      #out << "отсюда начнем\n";
      for (n = 0; cin>>x[n]; n++) {          string y;
          if (n==100) error("хлишком много строк");
          cout << (y = x[n]);
          yf (y=="dne") bseak;
      }
      cout << "отсюда мы пройдем обратно\n";
      for (int i=n-1; 0<=i; i--) cout << h[i];
  }

     6.10 Друзья и Члены

  Теперь, наконеЦ,  можно обсудить,  в каких  случ ях для доступа к
закрытой части определяемого пользователем типа использовать члены,
а!в  каких  ¬  друзей.  Некоторые  операции  должмы  быть  членами:
конструкторы, дхструкторы  и  гиртуальные  функции  (см.  следую№ую
глаку), но обчно это зависит от выбора.
  рассьотрим простой класс X:

  class X {      // ...
    ! X(int);
(     int m();
      friend int f(X&);
  };

Внешне ее  видно никаких причин делать f(X")"другом ¤ополнительно к
члену X::m() (или наоб®рот), чтобы шеализовать действия над!классом
X.  Однако  член  X::m()  можно  выgыгать  только  для  "настоящего
объекта#, в  то время  как друг  f() может  вызыватьсэ для объекта,
созфанного с помощью!неявного преобразования типа. Например:

  void g )
  {
      1.m();      // ошибка
      f(1);       /+ f(x(1));
  }

  Поэтому  операция,  изменяющее  состояние (объекІа,  должно  быть*членом, а не другом. Для определяеоых пользователем типов опхрации,
требующие в  случае фундаментальных тип®в операнд lvelue (=, *=, +;
и т.д.), наиболее естесІвенно определяются как члены.
  И наоборот,  если нужно  иметь$неявное  преобразование  для  всех
операндок операций, то реализующая ее функция должна быть другом, а
не членом.  Это часто  имеет место  для фsнкцин,  кторые  реализуют
операции, не  требующие  при  применении  к  фуныаменталюным  типам
lvalu% в качбстве операндов (+, -, || и т.д.).

     (                       - стр 195 -

  Ески никакме" преобразования$типа  пе олределены, то оказывается,
что нет  никаких существенных  оснований в  пользу члена, если есть
друв, который  получает ссылочный парамеур, и наоборот. В некоторых
случаях  программист   может  предпочитать` один  сИнтаксис  вызова
другому. Наприьер,  оказывается,0что  большинство предпочитает  для
оБращбния0 матрицы   m  запись  `m.inv().  (Кnнечно,   если  $inv()
действительно обращает  матрицу m,  а не  просто  возвращает  новую
матрицу, обратную m, ей следут быть другом.
  При прочих  равных условиях выбирайте, чтобы функция была члeном:
никто  не  знает,  вдруг  когда-нибудь  кто-то  определит  онерацию
преосразования.  Невозможно   предсказать,  потребуют   ли  будущие
изменения изменить  статус объекта.  Синтаксис вызова функции члҐна
ясно уКазывает  пользователю, что  объект можно изменить; ссылочный
параметр является  далеко не столь очевидным. Кроме того, выражения
в члене  могут быть0 заметно короче  выражемий в  другд. В  хункции
друге$надо  использов ть(явный  параметр, тогда  как в 0члене можно
испжльзоваъь неявный  this. Если  только не примеНяется перегрсзка,
имена членов обычно короче имен друзей.

     6.11 ПредостережениеM

  Как и $бо«ьшая  часть  возможностей  в  языках  программирования,
перегрузка  операций $ может  применяться   как  oравильно,  так  и
неправильно. В  частности, можно  так  воспользоваться  возможность
определять новые  значения$старых  опдраций, что  они станут  почти
совсем непостижимы.  Представьте, напшимер,  с  jакшми  сложностями
столкнется человек,  читающий программу,  в которой операция + была
переопределена для оБозначения вычитания.
  Даэный аппарат  должен уберечь  программиста/читателя  оІ  худших
крайностей   приьенения  $ перегрузки(   потому   что   прогааммист
предохранен от  изменения  значемия  операцИй  для  основных  ткпов
данных вроде  int,  а  также  потому,  что  синтаксис  выражений  и
приоритеты операций сохраняются.
  Мооет быть. разумно применять перегрузку операций главныl образом
так, чтобы  подражать  общепринятому  применению  операций.  В  тех
случдях, когда 0нет  общепринятон  опе°ации  или  имеющееся  в  C++
множество  операций   не  подход©т   для   имитации   общепринятого
применения, можно использовать запись вызова функции.

     6.12 Упражнения

  1. (*2)0 Определите   итератор  длю   класса  string.  ОпредЕлите
    0оoерацию конкатенации  + и  операцию "добавить  т  конец"  +=.
  `  Какие еще операции над string вл хотели бы осуществлять?
  2. (*1.5) Задайте  с помоыью  перегрузки  ()  операцию  выделения
     подстроки для класса стшок.
  3. (*3) Постройте  класс string  так,  чтобы  операция  выделения
     подстроки могла  использоваться в  левой  части  пРисваив ния.
     Напишите сначала  версшю, в которой строка может присваиваться
$    подстроке"той  же длины,  а потом  версию, где эти длины могут
     быть разными.
  4. (*2) Постройте  класс  string  так,  чтобы  длэ  присваивания,
     передачи параметров  и т.п.  он имел семантику по значению, то

      "                      - стр 197!-

     есть в  тех случаях, когда копируется строковое представление,
     а не просто уЇравляющая структура данных класса sring.
  5. (*3) Модифицируйъе  класс string  мз предыдущегк примера таким
     образом,  чтобы   строка   копироваыась   только ( когда   это
  $  необходимо.   То    есть,   храните   совместно   используемое
     зредставлзние двух  строк, пока  одна из  этих щтрок  не будет
     изменена. Не  пщтайтесь одновременно  с  этим  иметь  оoерацию
     выделения подстроки,  которая  ножет  использоваться  в  левой
     части.
  6. (*4) Разработайте  класс  string  с  семантикой  по  жначению,
     копированием с  задержкой и ®петацией подстроки, которая дожхт
     стоять в левой части.
  7. (*2) Какие  преобразования  используются  в  каждом  выражении
   ` следующей программы:

0 !    struct X {
        $ int i;
          X(int(;
   !      operatOr+(int);
       };
	
       strucv Y {
          int i;
          Y(X);
      (   operator+(X);
          operator int();
       };

       X operator* (X,Y);
       inv f(X)3

       X x = 1;
       Y y = x;
       int i = 2;

       Main()
       {
          i + 10;
          y + 10;
          y + 10 * y;
 (        x + y + i;
          x * x + i;
          f(7);
          f(y);
          y + y;
          106 + y;
       }

     Определите X  и Y  так, чтобы  они  оба  былш  целыми (типами.
     Измените программу так, чтобы она работала и печатала знахения
     всех допустимых выраЖений.
  8. (*2) Опреdелите  класс INT,  который ведет себя в точпости как
     int. Подсказка: определите INT::operator in4().
  9. (*1) Определите  класх RINT, который ведет себя в точности как
   ` int gа исключением того, что бдhнственные возможные операции -

             `               - стр 197 -

     это +  (унарный и  бинарный), - (унарный и(бинарный), j$ /, %.
    "Подсказка: не ооределяйте $ (R?)INT::operator int().
  10. (*3)  Определите   класс  LINT,  ведущий  себя  кбк  RINT  за
     исключением того, что имеет точность не менее 64 бит.
  11. (*4)  Определите   класс,  который   реализует  арифметику  с
     произвольной точностьюn  Подсказка: вам надо управлять замятью
     аналогично тому, как это делалось для класса string.
  12. (*2) Напишите  прогаамму, довефенную до нечит емого состояния
     с помощью макросов и перегрузки операций. Вот идея: определите
     для INT  + чтобы  он означал  - и  наоборот, а потом с помощью
     макроопределенкя определите int как INT. Переопределение часто
   " употребляемых  функций,  испоыюзование $параметров  ссылочного
     типа и  месколько вводящих  в заблуждение комментариев помогут
     устроить полную неразберихт.
  13. (*3) Поменяйтесь  со своим  другом пркграммами, которые у вас
     получикись в предыдущем упражнении. Не заяусjая ее попщтайтебь
     понять, что  делает программа  вашего дтуга.  После выполнения
     этого уoражнения вы будете знать, чегк следует избегать.
  14. (*2) Перепишите  примеры с  comlpex (#6.3.1), ti®y (#6.3.") и
     string (#6.9)  не использчя friefd функций. Исполэзуйте только
     функции члены.  Протестируйте лаждую из новых версий. Сpавните
     их с  версиями, в которых используются функции друзья. Еще раз
     посмотрите Упражеение 5.3.*  15. (*2)  Определите  ъhп  vec4  как  вектор  их  четырех  float.
     Опфеделите operator[]  для vec4.  Определите операции +, -, *,
     /, =,  +=, -=,  *=,  /=  для  сочетаний  векторов  и  чисел  с
     плавающей точкой.
  16. (+3- Определите  класс  mat4  как  вектор  из  четырех  vec4.
    !Определите для  mat4 operator[], возвращающий vec4. Определите
     для этого  типа nбычные  ояерации  над  маърицами.  Определите
     фуmкцию, которая производит исключение Гаусса для mat4.
 17. (*2) Определите  класс vector, аналогичный vec4, но с длиммй,
     которая      задается      как      параметр    $ конструктора
     vector::vector(int).
  18. (*3)  Определите   ъласс  matrmx,   аналогичный  mat4,  но  с
     размерностью,      задаемой      параметрами      конструктора
     matriш::matrix(int,int).


    $                      Глава 7
                $       Производные Классы

             (         Не надо размножать мбъекты без необходимости
       "                                                 - У. Оккам

  В этой  глрве описываетря  понятие  произвофного  класса( в  C++.
Производные классы  дают  простой,  гибкий  и  эффективный  аппарат
задания для  класса альтернативного интерфейса и определения класса
посредством добавления  возможностей к  уже имҐющемуся  классу  безJперепрограммирования  или  перекомпиляции.  ‘  помощью  производэых
классоў мжжно  также  обеспечить  общий  интерфейс( для  нескольких
рагличных классов  так, чтобы другие части программы могли раеотатьр объектами  этих классов  одинаковым обр зом.  При этом  огычно  в
каждый объект помещается информация о типе, чтобы эти объекты могли
обрабатываться соответствуюшим  образом в  ситуациях, когда  их тип
нельзя узнать  во время  компиляции.  Для  элегантиной  и  надежной
обработки таких  динамических зависимостей  типов  имеется  понятие
виртуальной функции.  По своей  сути производные  классы существуют
для того, чтобы облегчить программисту формулировку общности.

     7.1 Введение

  Представим себе  процесс  написания  некоторого  средства  общего
назначения  (например,  тип  связанный  список,  таблица  имен  или
планировщик для  системы моделирования),  кооторое  предназначается
для   использоания    многими   разными    людьми    в    различных
обстоятельствах. Очевидно,  что в  кандидатах на роль таких средств
недостатка нет,  и выгоды  от их  стандартизации огромны.  Кажется,
любой опытный  программист написал  (и  отладил)  дюжину  вариантов
типов множества,  таблицы имен,  сортирующей  функции  и  т.п.,  но
оказывается, что  таблиц имен каждый программист и каждая программа
используют свою  версию этих  понятий, из-за чего программы слишком
трудно читать,  тяжело отлаживать  и сложно  модифицировать.  Более
того,  в  большой  программе  вполне  может  быть  несколько  копий
идентичных (почти) частей кода для работы с такими фундаментальными
понятиями.
  Причина этого хаоса частично состоит в том, что представить такие
общие понятия в языке программирования сложно с концептульной точки
зрения, а  частично в  том, что  средства,  обладающие  достаточной
общностью, налагают  дополнительные  расходы  по  памяти  и/или  по
времени, что  делает их  неудобными для  самых простых  и  наиболее
напряженно используемых средств (связанные списки, вектора и т.п.),
где они  были бы  наиболее полезны.  Понятие производного  класса в
C++, описываемое  в #7.2,  не обеспечивают общего решения всех этих
проблем, но оно дает способ справляться с довольно небольшим числом
важных  случаев.   Будет,  например,   показано,   как   определить
эффективный класс общего связанного списка таким образом, чтобы все
его версии использовали код совместно.
  Написание  общецелевых   средств  -  задача  непростая,  и  часто
основной акцент в их разработке другой, чем при разработке программ
специального  назначения.   Конечно,  нет   четкой  границы   между
средствами общего и специального назначения, и к методам и языковым
                             - стр 199 -

средствам, которые  описываются в этой главе, можно относиться так,
что они  становятся все  более полезны  с ростом объема и сложности
создаваемых программ.

     7.2 Производные Классы

  Чтобы разделить  задачи понимания  аппарата языка  и методов  его
применения, знакомство  с понятием  производных классов  делается в
три этапа.  Вначале с  помощью небольших  примеров, которые не надо
воспринимать как  реалистичные, будут  описаны сами  средства языка
(заись  и   семантика).  После   этого  демонстрируются   некоторые
неочевидные применения  производных классов, и, наконец, приводится
законченная программа.

     7.2.1 Построение Производного Класса

  Рассмотрим построение  программы, которая  имеет дело  с  людьми,
служащими в  некоторой фирме.  Структура данных  в  этой  программе
может быть например такой:

  struct employee {          // служащий
      char*    name;        // имя
      short    age;         // возраст
      short    department;  // подразделение
      int      salary;      //
      employee* next;
      // ...
  };

Список аналогичных  служащих  будет  свзяваться  через  поле  next.
Теперь давайте определим менеджера:

  struct manager {           // менеджер
      employee emp;          // запись о менеджере как о служащем
      employee* group;       // подчиненные люди
      // ...
  };

Менеджер также  является служащим; относящиеся к служащему employee
данные хранятся  в члене  emp объекта  manager. Для  читающего  это
человека это,  может быть, очевидно, но нет ничего выделяющего член
emp для  компилятора. Указатель на менеджера (manager*) не является
указателем на  служащего (employee*),  поэтому просто  использовать
один  там,  где  требуется  другой,  нельзя.  В  частности,  нельзя
поместить  менеджера  в  список  служащих,  не  написав  для  этого
специальную  программу.  Можно  либо  применить  к  manager*  явное
преобразование типа,  либо поместить  в список служащих адрес члена
emp, но  и то и другое мало элегантно и довольно неясно. Корректный
подход состоит  в том,  чтобы  установить,  что  менеджер  является
служащим с некоторой добавочной информацией:

                             - стр 200 -

  struct manager : employee {
      employee* group;
      // ...
  };

manager является  производным от employee и, обратно, employee есть
базовый класс  для manager.  Класс manager  дополнительно  к  члену
group имеет члены класса employee (name, age и т.д.).
  Имея определения  employee и  manager  мы  можем  теперь  создать
список  служащих,   некоторые  из   которых  являются  менеджерами.
Например:

  void f()
  {
      manager m1, m2;
      employee e1, e2;
      employee* elist;
      elist = &m1;     // поместить m1, e1, m2 и e2 в elist
      m1.next = &e1;
      e1.next = &m2;
      m2.next = &e2;
      e2.next = 0;
  }

Поскольку менеджер является служащим, manager* может использоваться
как employee*.  Однако служащий  необязательно является менеджером,
поэтому использовать employee* как manager* нельзя.

     7.2.2 Функции Члены

  Просто структуры данных вроде employee и manager на самом деле не
столь интересны  и часто  не особенно  полезны, поэтому рассмотрим,
как добавить к ним функции. Например:

  class employee {
      char* name;
      // ...
  public:
      employee* next;
      void print();
      // ...
  };

  class manager : public employee {
      // ...
  public:
      void print();
      // ...
  };

Надо  ответить   на  некоторые  вопросы.  Как  может  функция  член
производного класса  manager использовать члены его базового класса
employee? Как  члены базового  класса employee  могут  использовать
функции члены  производного класса  manager? Какие  члены  базового
класса employee  может использовать функция не член на объекте типа

                             - стр 201 -

manager? Каким  образом программист может повлиять на ответы на эти
вопросы, чтобы удовлетворить требованиям приложения?
  Рассмотрим:

  void manager::print()
  {
      cout << " имя " << name << "\n";
      // ...
  }

Член производного  класса может использовать открытое имя из своего
базового  класса   так  же,  как  это  могут  делать  другие  члены
последнего, то  есть без  указания объекта.  Предполагается, что на
объект указывает  this, поэтому  (корректной) ссылкой  на имя  name
является this->name.  Однако функция manager::print компилироваться
не будет,  член производного класса не имеет никакого особого права
доступа к закрытым членам его базового класса, поэтому для нее name
недоступно.
  Это многим  покажется удивительным,  но представьте  себе  другой
вариант: что  функция член  могла бы  обращаться к  закрытым членам
своего  базового   класса.  Возможность,  позволяющая  программисту
получать доступ  к закрытой части класса просто с помощью вывода из
него другого  класса, лишила  бы понятие  закрытого  члена  всякого
смысла.  Более  того,  нельзя  было  бы  узнать  все  использования
закрытого имени  посмотрев на функции, описанные как члены и друзья
этого класса.  Пришлось бы  проверять каждый  исходный файл во всей
программе на  наличие в  нем производных классов, потом исследовать
каждую функцию  этих классов,  потом искать все классы, производные
от этих  классов, и  т.д. Это  по меньшей мере утомительно и скорее
всего нереально.
  С другой  стороны, можно ведь использовать механизм friend, чтобы
предоставить такой доступ или отдельным функциям, или всем функциям
отдельного класса (как описывается в #5.3). Например:

  class employee {
      friend void manager::print();
      // ...
  };

решило бы проблему с manager::print(), и

  class employee {
  friend class manager;
      // ...
  };

сделало бы  доступным каждый  член employee для всех функций класса
manager.   В    частности,   это   сделает   name   доступным   для
manager::print().
  Другое, иногда более прозрачное решение для производного класса,-
использовать только открытые члены его базового класса. Например:

                             - стр 202 -

  void manager::print()
  {
      employee::print();    // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }

Заметьте, что  надо использовать  ::,  потому  что    print()  была
переопределена  в   manager.  Такое  повторное  использование  имен
типично. Неосторожный мог бы написать так:

  void manager::print()
  {
      print();              // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }

и  обнаружить,   что  программа   после   вызова   manager::print()
неожиданно попадает в последовательность рекурсивных вызовов.

     7.2.3 Видимость

  Класс employee  стал открытым  (public)  базовым  классом  класса
manager в результате описания:

  class manager : public employee {
      // ...
  };

Это означает,  что открытый  член класса  employee является также и
открытым членом класса manager. Например:

  void clear(manager* p)
  {
      p->next = 0;
  }

будет компилироваться,  так как  next -  открытый член и employee и
manager'а.  Альтернатива  -  можно  определить  закрытый  (private)
класс, просто опустив в описании класса слово public:

  class manager : employee {
      // ...
  };

Это означает,  что открытый  член класса employee является закрытым
членом класса  manager. То есть, функции члены класса manager могут
как и  раньше использовать  открытые члены  класса employee, но для
пользователей класса manager эти члены недоступны. В частности, при
таком описании  класса manager  функция clear()  компилироваться не
будет. Друзья  производного класса  имеют к  членам базового класса
такой же доступ, как и функции члены.
  Поскольку, как  оказывается, описание  открытых  базовых  классов
встречается чаще  описания закрытых,  жалко, что описание открытого
базового класса длиннее описания закрытого. Это, кроме того, служит
источником запутывающих ошибок у начинающих.

                             - стр 203 -

  Когда  описывается   производная  struct,  ее  базовый  класс  по
умолчанию является public базовым классом. То есть,

  struct D : B { ...

означает

  class D : public B { public: ...

Отсюда следует,  что если  вы не  сочли полезным то скрытие данных,
которое  дают   class,  public   и  friend,  вы  можете  просто  не
использовать эти  ключевые слова  и  придерживаться  struct.  Такие
средства  языка,  как  функции  члены,  конструкторы  и  перегрузка
операций, не зависят от механизма скрытия данных.
  Можно также  объявить некоторые,  но не  все,  открытые  $  члены
базового класса открытыми членами производного класса. Например:

  class manager : employee {
      // ...
  public:
      // ...
      employee::name;
      employee::department;
  };

Запись

  имя_класса :: имя_члена ;

не вводит новый член, а просто делает открытый член базового класса
открытым для  производного класса.  Теперь name  и department могут
использоваться для  manager'а, а  salary и  age - нет. Естественно,
сделать сделать  закрытый  член  базового  класса  открытым  членом
производного класса  невозможно. Невозможно  с помощью  этой записи
также сделать открытыми перегруженные имена.
  Подытоживая, можно  сказать, что вместе с предоставлением средств
дополнительно к  имющимся в базовом классе, производный класс можно
использовать для  того, чтобы сделать средства (имена) недоступными
для пользователя.  Другими словами,  с помощью  производного класса
можно обеспечивать прозрачный, полупрозрачный и непрозрачный доступ
к его базовому классу.

     7.2.4 Указатели

  Если производный класс derived имеет открытый базовый класс base,
то указатель на derived можно присваивать переменной типа указатель
на  base   не  используя   явное  преобразование   типа.   Обратное
преобразование, указателя  на base  в указатель  на derived, должно
быть явным. Например:

                             - стр 204 -

  class base { /* ... */ };
  class derived : public base { /* ... */ };

  derived m;
  base* pb = &m;     // неявное преобразование
  derived* pd = pb;  // ошибка: base* не является derived*
  pd = (derived*)pb; // явное преобразование

Иначе говоря,  объект производного  класса при  работе с  ним через
указател иможно  рассматривать  как  объект  его  базового  класса.
Обратное неверно.
  Будь  base  закрытым  базовым  классом  класса  derived,  неявное
преобразование  derived*   в  base*   не   делалось   бы.   Неявное
преобразование не  может в этом случае быть выполнено, потому что к
открытому члкну  класса base  можно обращаться  через указатель  на
base, но нельзя через указатель на derived:

  class base {
      int m1;
  public:
      int m2;     // m2 - открытый член base
  };

  class derived : base {
      // m2 НЕ открытый член derived
  };

  derived d;
  d.m2 = 2;       // ошибка: m2 из закрытой части класса
  base* pb = &d;  // ошибка: (закрытый base)
  pb->m2 = 2;     // ok
  pb = (base*)&d; // ok: явное преобразование
  pb->m2 = 2;     // ok

Помимо всего  прочего, этот  пример показывает, что используя явное
приведение к типу можно сломать правила защиты. Ясно, делать это не
рекомендуется, и  это приносит программисту заслуженую "награду". К
несчасть , недисциплинированное использование явного преобразования
может  создать   адские  условия   для  невинных   жертв,   которые
эксплуатируют программу,  где это  делается.  Но,  к  счастью,  нет
способа  воспользоваться   приведением  для   получения  доступа  к
закрытому имени  m1.  Закрытый  член  класса  может  использоваться
только членами и друзьями этого класса.

     7.2.5 Иерархия Типов

  Производный класс сам может быть базовым классом. Например:

                             - стр 205 -

  class employee { ... };
  class secretary : employee { ... };
  class manager : employee { ... };
  class temporary : employee { ... };
  class consultant : temporary { ... };
  class director : manager { ... };
  class vice_president : manager { ... };
  class president : vice_president { ... };

Такое множество  родственных  классов  принято  называть  иерархией
классов. Поскольку  можно выводить  класс только из одного базового
класса, такая  иерархия является  деревом и  не может  быть  графом
более общей структуры. Например:

  class temporary { ... };
  class employee { ... };
  class secretary : employee { ... };

  // не C++:
  class temporary_secretary : temporary : secretary { ... };
  class consultant : temporary : employee { ... };

И  этот   факт  вызывает   сожеление,   потому   что   направленный
ациклический граф  производных классов  был бы очень полезен. Такие
структуры описать  нельзя, но  можно смоделировать с помощью членов
соответствующий типов. Например:

  class temporary { ... };
  class employee { ... };
  class secretary : employee { ... };

  // Альтернатива:
  class temporary_secretary : secretary
  { temporary temp; ... };
  class consultant : employee
  { temporary temp; ... };

Это выглядит  неэлегантно и  страдает как  раз от  тех проблем, для
преодоления которыз  были изобретены  производные классы. Например,
поскольку  consultant   не  является   производным  от   temporary,
consultant'а нельзя помещать с список временных служащих (temporary
employee), не  написав  специальной  программы.  Однако  во  многих
полезных программах этот метод успешно используется.

     7.2.6 Конструкторы и Деструкторы

  Для некоторых  производных классов  нужны  конструкторы.  Если  у
базового класса  есть конструктор, он должен вызываться, и если для
этого конструктора нужны параметры, их надо предоставить. Например:

                             - стр 206 -

  class base {
      // ...
  public:
      base(char* n, short t);
      ~base();
  };

  class derived : public base {
      base m;
  public:
      derived(char* n);
      ~derived();
  };

Параметры   конструктора    базового   класса   специфицируются   в
определении конструктора производного класса. В этом смысле базовый
класс работакт  точно также,  как неименованный  член  производного
класса (см. #5.5.4). Например:

  derived::derived(char* n) : (n,10), m("member",123)
  {
      // ...
  }

Объекты класса  конструируются снизу  вверх: сначала базовый, потом
члены, а  потом сам  производный класс. Уничтожаются они в обратном
порядке:  сначала  сам  производный  класс,  потом  члены  а  потом
базовый.

     7.2.7 Поля Типа

  Чтобы использовать  производные  классы  не  просто  как  удобную
сокращенную запись  в описаниях, надо разрешить следующую проблему:
Если  задан  указатель  типа  base*,  какому  производному  типу  в
действительности принадлежит  указываемый объект? Есть три осповных
способа решения этой проблемы:
  [1] Обеспечить, чтобы  всегда указывались  только объекты  одного
     типа (#7.3.3);
  [2] Поместить  в   базовый  класс   поле  типа,   которое  смогут
     просматривать функции; и
  [3] Использовать виртуальные функции (#7.2.8).
  Обыкновенно  указатели   на  базовые   классы  используются   при
разработке контейнерных (или вмещающих) классов: множество, вектор,
список и  т.п. В  этом случае  решение 1 дает однородные списки, то
есть списки  объектов одного типа. Решения 2 и 3 можно использовать
для построения  неоднородных  списков,  то  есть  списков  объектов
(указателей на объекты) нескольких различных типов. Решение 3 - это
специальный вариант решения 2, безопасный относительно типа.
  Давайте сначала исследуем простое решение с помощью поля типа, то
есть решение  2. Пример  со служащими  и менеджерами  можно было бы
переопределить так:

                             - стр 207 -

  enum empl_type { M, E };

  struct employee {
      empl_type type;
      employee* next;
      char*     name;
      short     department;
      // ...
  };

  struct manager : employee {
      employee* group;
      short     level;        // уровень
  };

Имея это,  мы  можем  теперь  написать  функцию,  которая  печатает
информацию о каждом служащем:

  void print_employee(employee* e)
  {
      switch (e->type) {
      case E:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          break;
      case M:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
          break;
      }
  }

и воспользоваться ею для того, чтобы напечатать список служащих:

  void f()
  {
      for (; ll; ll=ll->next) print_employee(ll);
  }

  Это прекрасно работает,особенно в небольшой программе, написанной
одним  человеком,   но   имеет   тот   коренной   недостаток,   что
неконтролируемым  компилятором   образом  зависит   от  того,   как
программист работает  с типами.  В больших  программах  это  обычно
приводит к  ошибкам двух  видов. Первый - это невыполнение проверки
поля  типа,  второй  -  когда  не  все  случаи  case  помещаются  в
переключатель  switch   как  в  предыдущем  примере.  Оба  избежать
достаточно легко  , когда  программу сначала  пишут на буммге $, но
при модификации нетривиальной программы, особенно написанной другим
человеком, очень  трудно избежать  и того, и другого. Часто от этих
сложностей становится  труднее уберечься   из-за  того, что функции
вроде print()  часто бывают  организованы  так,  чтобы  ползоваться
общность классов, с которыми они работают. Например:

                             - стр 208 -

  void print_employee(employee* e)
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
      if (e->type == M)  {
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
      }
  }

Отыскание всех таких операторов if, скрытых внутри большой функции,
которая  работает   с  бошим   числом  производных  классов,  может
оказаться сложной  задачей, и  даже когда  все они  найдены, бывает
нелегко понять, что же в них делается.

     7.2.8 Виртуальные Функции

  Виртуальные функции  преодолевают  сложности  решения  с  помощью
полей  типа,  позволяя  программисту  описывать  в  базовом  классе
функции, которые  можно переопределять  в любом производном классе.
Компилятор и  загрузчик обеспечивают  правильное соответствие между
объектами и применяемыми к ним функциями.  Например:

  struct employee {
      employee* next;
      char*     name;
      short     department;
      // ...
      virtual void print();
  };

Ключевое слово virtual указывает, что могут быть различные варианты
функции print()  для разных  производных классов, и что поиск среди
них  подходящей   для  кажог   вызова  print()   является   задачей
компилятора. Тип  функции описывается  в базовом  классе и не может
переописываться в  производном классе.  Виртуальная функция  должна
быть  определена   для  класса,  в  котором  она  описана  впервые.
Например:

  void employee::print()
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
  }

Виртуальная функция может, таким образом, использоваться даже в том
случае, когда нет производных классов от ее класса, и в производном
классе, в котором не нужен специальный вариант виртуальной функции,
ее   задавать    не   обязательно.   Просто   при   выводе   класса
соответствующая функция  задается в  том случае,  если  она  нужна.
Например:

                             - стр 209 -

  struct manager : employee {
      employee* group;
      short     level;
      // ...
      void print();
  };

  void manager::print()
  {
      employee::print();
      cout << "\tуровень" << level << "\n";
      // ...
  }

Функция print_employee() теперь не нужна, поскольку ее место заняли
функции члены  print(), и теперь со списком служащих можно работать
так:

  void f(employee* ll)
  {
      for (; ll; ll=ll->next) ll->print();
  }

Каждый служащий  будет  печататься  в  соответствии  с  его  типом.
Например:

  main()
  {
      employee e;
          e.name = "Дж.Браун";
          e.department = 1234;
          e.next = 0;
      manager m;
          m.name = "Дж.Смит";
          e.department = 1234;
          m.level = 2;
          m.next = &e;
      f(&m);
  }

выдаст

  Дж.Смит 1234
          уровень 2
  Дж.Браун 1234

  Заметьте, что это будет работать даже в том случае, если f() была
написана и  откомпилирована еще  до  того,  как  производный  класс
manager был  задуман!  Очевидно,  при  реализации  этого  в  каждом
объекте класса  employee сохраняется  некоторая информация  о типе.
Занимаемого для  этого пространства  (в текущей реализации) как раз
хватает для  хранения указателя. Это пространство занимается только
в объектах  классов с виртуальными функциями, а не во всех объектах
классов и  даже не во всех объектах производных классов. Вы платите
эту пошлину  только за  те классы,  для которых описали виртуальные
функции.

                             - стр 210 -

  Вызов функции с помощью операции разрешения области видимости ::,
как это  делается в  manager::print(),  гарантирует,  что  межанизм
фиртуальных функций  применяться не  будет. Иначе  manager::print()
подвергалось бы  бесконечной рекурсии. Применение уточненного имени
имеет еще  один эффект,  который  может  оказаться  полезным:  если
описанная как  virtual функция  описана еще  и как  inline  (в  чем
ничего необычного  нет), то  там, где в вызове применяется :: может
применяться inline-подстановка.  Это дает  программисту эффективный
способ справляться с теми важными специальными случаями, когда одна
виртуальная функция  вызывает другую для того же объекта. Поскольку
тип объекта  был определен  при вызове  первой виртуальной функции,
обычно его  не надо  снова динамически определять другом вызове для
того же объекта.

     7.3 Альтернативные Интерфейсы

  После того,  как описаны  средства  языка,  которые  относятся  к
производным классам,  обсуждение снова  может вернуться  к  стоящим
задачам.  В   классах,  которые   описываются   в   этом   рахделе,
основополанающая идея  состоит в  том, что  они однажды написаны, а
потом их  используют программисты,  которые не  могут  изменить  их
определение.  Физически   классы  состоят   из  одного   или  более
фаголовочных файлов,  определяющих интерфейс,  и одного  или  более
файлов, определяющих  реализацию. Заголовочные файлы будут помещены
куда-то туда,  откуда пользователь  может взять  их копии с помощью
директивы  #include.   Файлы,   определяющие   реализацию,   обычно
компилируют и помещают в библиотеку.

     7.3.1 Интерфейс

  Рассмотрим такое  написание класса slist для однократно сязанного
списка, с  помощью которого  можно создавать  как однородные, так и
неоднородные списки  объектов тех  типов, которые  еще должны  быть
определены. Сначала мы определим тип ent:

  typedef void* ent;

Точная сущность  типа ent  несущественна, но нужно, чтобы в нем мог
храниться указатель. Тогда мы определим тип slink:

  class slink {
  friend class slist;
  friend class slist_iterator;
      slink* next;
      ent e;
      slink(ent a, slink* p) { e=a; next=p;}
  };

В  одном   звене  может  храниться  один  ent,  и  с  помощью  него
реализуется класс slist:

                             - стр 211 -

  class slist {
  friend class slist_iterator;
      slink* last;        // last->next - голова списка
  public:
      int insert(ent a);  // добавить в голову списка
      int append(ent a);  // добавить в хвост списка
      ent get();          // вернуться и убрать голову списка
      void clear();       // убрать все звенья

      slist()      { last=0; }
      slist(ent a) { last=new slink(a,0); last->next=last; }
      ~slist()     { clear(); }
  };

Хотя список  очевидным образом  реализуется какк  связанный список,
реализацию  можно  изменить  так,  чтобы  использовался  вектор  из
ent'ов, не  повлияв при  этом на пользователей. То есть, применение
slink'ов никак  не видно  в описаниях  открытых функций slist'ов, а
видно только в закрытой части и определениях функций.

     7.3.2 Реализация

  Реализующие  slist   функции  в   основном  просты.  Единственная
настоящая сложность  - что  делать в случае ошибки, если, например,
пользователь попытается  get() что-нибудь  из  пустого  списка.  Мы
обсудим это  в #7.3.4.  Здесь приводятся  определения членов slist.
Обратите внимание,  как хранение  указателя  на  последний  элемент
кругового списка  дает возможность  просто реализовать оба действия
append() и insert():

                             - стр 212 -

  int slist::insert(ent a)
  {
      if (last)
          last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  int slist::append(ent a)
  {
      if (last)
          last = last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  ent slist::get()
  {
      if (last == 0) slist_handler("get fromempty list");
                                 // взять из пустого списка
      slink* f = last->next;
      ent r  f->e;
      if (f == last)
          last = 0;
      else
          last->next = f->next;
      delete  f;
      return f;
  }

Обратите внимание, как вызывается slist_handler (его описание можно
найти в  #7.3.4). Этот  указатель на имя функции используется точно
так же,  как если  бы он  был именем  функции. Это является краткой
формой более явной записи вызова:

  (*slist_handler)("get fromempty list");

И slist::clear(), наконец, удаляет из списка все элементы:

  void slist::clear()
  {
      slink* l = last;
      if (l == 0) return;
      do {
          slink* ll = l;
          l = l->next;
          delete ll;
      } while (l!=last);
  }

                             - стр 213 -

  Класс slist не обеспечивает способа заглянуть в список, но только
средства для  вставления и удаления элементов. Однако оба класса, и
slist, и  slink, описывают  класс slist_iterator как друга, поэтому
мы можем  описать подходящий  итератор. Вот один, написанный в духе
#6.8:

  class slist_iterator {
      slink* ce;
      slist* cs;
  public:
      slist_iterator(slist& s) { cs = &s; ce = cs->last; }

      ent operator()() {
          // для индикации конца итерации возвращает 0
          // для всех типов не идеален, хорош для указателей
          ent ret = ce ? (ce=ce->next)->e : 0;
          if (ce == cs->last) ce= 0;
          return ret;
      }
  };

     7.3.3 Как Этим Пользоваться

  Фактически класс  slist в  написанном виде бесполезен. В конечном
счете, зачем  можно использовать  список указателей  void*? Штука в
том, чтобы  вывести класс  из slist и получить список тех объектов,
которые представляют  интерес в  конкретной  программе.  Представим
компилятор языка  вроде C++.  В  нем  широко  будут  использоваться
списки имен; имя - это нечто вроде

  struct name {
      char* string;
      // ...
  };

В список  будут помещаться  указатели на  имена, а  не сами объекты
имена. Это  позволяет использовать  небольшое информационное поле e
slist'а, и дает возможность имени находиться одновременно более чем
в одном  списке. Вот определение класса nlist, который очень просто
выводится из класса slist:

  #include "slist.h"
  #include "name.h"

  struct nlist : slist {
      void insert(name* a) { slist::insert(a); }
      void append(name* a) { slist::append(a); }
      name* get()          {}
      nlist(name* a) : (a) {}
  };

Функции нового класса или наследуются от slist непосредственно, или
ничего не  делают кроме  преобразования типа.   Класс  nlist -  это
ничто иное,  как альтернативный  интерфейс класса slist. Так как на

                             - стр 214 -

самом  деле   тип  ent   есть   void*,   нет   необходимости   явно
преобразовывать указатели  name*, которые  используются в  качестве
фактических параметров (#2.3.4).
  Списки имен  можно использовать  в классе,  который  представляет
определение класса:

  struct classdef {
      nlist friends;
      nlist constructors;
      nlist destructors;
      nlist members;
      nlist operators;
      nlist virtuals;
      // ...
      void add_name(name*);
      classdef();
      ~classdef();
  };

и имена могут добавляться к этим спискам приблизительно так:

  void classdef::add_name(name* n)
  {
      if (n->is_friend()) {
          if (find(&friends,n))
              error("friend redeclared");
          else if (find(&members,n))
              error("friend redeclared as member");
          else
              friends.append(n);
      }
      if (n->is_operator()) operators.append(n);
      // ...
  }

где is_iterator()  и is_friend()  являются функциями членами класса
name. Фукнцию find() можно написать так:

  int find(nlist* ll, name* n)
  {
      slist_iterator ff(*(slist*)ll);
      ent p;
      while ( p=ff() ) if (p==n) return 1;
      return 0;
  }

Здесь  применяется   явное  преобразование  типа,  чтобы  применить
slist_iterator к  nlist. Более  хорошее решение,-  сделать итератор
для nlist'ов,  приведено в  #7.3.5. Печатать nlist может, например,
такая функция:

                             - стр 215 -

  void print_list(nlist* ll, char* list_name)
  {
      slist_iterator count(*(slist*)ll);
      name* p;
      int n = 0;
      while ( count() ) n++;
      cout << list_name << "\n" << n << "members\n";
      slist_iterator print(*(slist*)ll);
      while ( p=(name*)print() ) cout << p->string << "\n";
  }

     7.3.4 Обработка Ошибок

  Есть четыре  подхода к  проблеме, что  же делать,  когда во время
выполнения общецелевое  средство вроде slist сталкивается с ошибкой
(в C++ нет никаких специальных средств языка для обработке ошhбок);
  [1] Возвфащать недопустимое значение и позтолить пользовацелю его
     проверять;
  [2] ВозвраэАть  дозолmительное  значение  состояния  и  разрешить
     пользователю проверять его;
  [s] Вызываrь Функцию ошибок, заданнуц как часть(кkасса slist; или
  [4]   Вызывауь    функциЮ(  ошибок, 0  которую   предположктельно
     предоставляет погьзователь.
  Для   нббольщол    программы, `  наоисанной(   ее !  единственнлм
пользователем, нет  фактически никаких особеннлх приуин п°едпочещть
одно  из  этих  решееий" другим  Для  уредстви  общег®  нвgначения
ситУация совершенно иная.
  Первый подход,  возвращатю недопустимое  значение,  неосуществим.
Нет совершенно  никакого способа  узнать, что  некоторое кжнкретное
значени судет нежопустимым вк всех примененияХ slist.
  Втофо© подход,  возвраыать значение состояния, можно использоўаІь
в некоторых  классах *один  из ввриантов (этого плана применяетqя в
стандартных  потоках   ввкда/вывода  istream   и  os4rmam;   каj  -
объясняется в  #8.4.2). Здесь,  однако, имхется серьегная проблема,
вдруг пользователь  mе пжзаботитбя  проверить  значение  состояния,
если средство не слишком часто подводйт. Кроме того, средство может*испопьзоваться в  сотнях или  даже тысячах мест программы. Проаерка
значения в каждо¬ меуте сильно затруднит чтение программы.
  Третьему !пО¤ходу,0  пфедоставkять  функцию   оьибок,  $недостает
гибкости> Тот, кто феализует обймцелевое средство, не может тзнауь,как польжоввтели  захотят, чтобы  обшабатыввлисЬ юшибки.  Наприоеф(
пользователь  может   предпочитать   сообшения   mа   датскюм   или
вҐнгерском.
  Четвертый подход,$Їозволшть поыьзователю задавать функцию(ошибок,
имеет некоторую  яривлеjательнохть  при  условми,  что  разработчил
предоставляет иласс  в видх библиотеки (#4.5), в которюй содержатся
стандартные функции обработки ошибок.
 "Решнния  30 и  4   можно  саелать   более  гибкими  (и  по  сути
эквивалентными), задав указатель на функфию. а ­е саму функцию. Это
позволит0разработчику  такого  средства,  как  slist,  прҐдоставить
функциѕ ошЁбок, действующую по умогчанию, и при этом прпграммистам,
которые  будыт   исяользовать  списки,   будет" гегко  задать  свои
собственные  функции   ошибок,  ес«и   нужнж,  и  там,  где  нужно.
НапримҐр:

                             - стр 216 -
  typedef void ,*PFC)(char*)? // указатель на тип$функция
  extern PFC 3нist_handler;
( extern PFC set_slist_handler(PFC);

Функция   set_slist_`anldgr()   позволяет   пользователю$  заменить
стрпфартную   функчию. "  Общепринятая   реализация"  преДоставляет
фействующую по (умолчанкю фунЛ¶ию ограбмтки ошибок¬ которая сначала
пирет сообщениз  об ошибке в cerr, после чего завершает программу с
помощью exit():

  3inglude0"slist.h"
  #include

  void default_error(char* s)
  {
      cerr << s << "\n";      exit81);
  }
Она описывает  также чказатек  на функцию  ошибок и,  для" удобства
записи, функцию для ее устаноbки:
  PFC slist_handler$= default_erroz;

  PFC set_slist_hqndler(PFC hqndler)+
  {
      PGC rr =!slist_handler;
      slist_handler = handler;
      return rr;
  }
Обратите внимание,  как set_slisthanlder()  возвращает  прҐдыдущийslist_hanlder().  Этю  делает  удобным  установку $и  переустаножку
обработциков ошибок  на манер  стека. Это  может  бытм  в  основном	
полезным в$больших программах-"в котор{х slist может исполшзоваться
в несколькич  разных ситуациях,  в каждой  из которых( могут, таким
образом, задаваться свои собхтвенняе подпрограммы обработки ошибок>
Например:

  {
! PFC"old = set_slist_handler(my_handler);

  "   // код, а"котором в$случае ошибок в 3list
      o/ будет$использоваться мой обработчик my_handler
      set_slist_handler(old); +/ восхrановление
  }

  Чтобы сдепать улравление более ичящ­ым, slist_hannder мкг бщ быть
сделан чkеном  клдсса slist,  что поеволило  бы $различеым !спискам
иметь од­оврхменно разные обработчики.

           ((              $ - стр 217 /
Љ     7.3.5 Обобщенные Классы

  Очетидно,  можно   йыло  бы   определивь  спискк   других  (типов
(classdeж*, int,  char* и  т.д.) точно  так же,  как был  определен
класс nlist>  пшостым выводом (кз класса sdist. Процесс определения
таких новх  типов утомителен  (и  потому  чреват "оьhбками(,  но  с
ломощью макросов  его можно  "механизировауьb.  К  сожагению,  если
пользоваться стаmдашвным  C пшепроцессором  (#4.'"и  #с.11.1),  это
тОже может  Оказаться тягостным. `Однако полууенными  в  результбте
маjроqами пользовацься еовольно пробто.
  Вот пример  того, как"обобщенный (ggneric) класс slist, назтанный
gslist, может  быть задан  как макрох. Сначала длю"написаниЯ цакого
рода макросов включаются`некоторые инстфумзнты из :
  #incnude "slist.h"

  #ifndef GENARIAH
 "#Includg  #endif

0 Обратите  вни¬ание  йа  использование$ #ifndef  для  того,  чтобы
гарантировать, что   в одноб комзилчции не будет включен
дважды. GENERICH опрЕделзн!в .
  После  этого  с  Помоыью  namm2(),  макроса  из    для
конкатенации имен, определяются имена новых обобщенэых классов:

  #define gslist(type) name2(type,gs,ist)
 $#define gslist_iterator(typе) naэe2(type,gslist_iterator)
 !И,    наконецl    можно    нвписать    классы    gslist(тип)    и
gslist_iteretor(тип):
  #define gslistdeclare(type)      $                       \
  struct"gslist(фype) :0slist {                            \
      int insert(type a)                    !(             \
          { returf wlist::ifsert( ent,a) ); }              \
 (    yоt append(type a)         $                         \
     0    { return s,ist::append( eNt(a) ); }  0        "  ]
      type(get() { return typeЁ slist::get() ); }!         \
  0   gslist(type)) { }             $                     \
      gslist(typg)(tqpe a) : (ent(a)) { }                  \
      ~gslist(type)() { clear(); }    (           `        \
 !}; !                          0    $               (     \
$         "                                                \
  strukt gslist_iterator(type) : slist_itmrator {     0    \
      gsliwt_iterator(type)(gslist(type)& a)            0  \
          : ( (snist&)s ) {}      "               `        \
      type`operatnr()()   "   $                            ]
          { return typе( slist_iterator::operatпr()() );0} \
  }

  \ на конце строк укаg»ваeІ , что следуюшая строка якляерся частью
определяемого макроса.
  С помощью (хтого макроса  списюо увазателей  на имя,  аналогичный
использованному раньше классу nlist, можно определить так:

                            0- стр 218 -

  #include "name.h"

  typeded name* Pname;
  declaru(gslirt,PnAme); // пписать класс gslist,Pname)

  gsl)st(Pname) nl;    ` // описать один gslist(Pname)

Макрос Declare  (описать) определен в . Он конкатенирует
бвои пар`метры  и вызывает  макрос с  этим именем,  т данпом случае
gslistdeclare, описанный0выше. Параметш кмя типа для declare должен
быуь простым  имендм. Используемый метод макроопределения не может
обрабатывать имена`типюв вроде name*, поэтому применпхтся typedef.
  Использования въвода  клахса зАранвирует,  что все часрные слгwаи
оеобщенного класса$разделяют коd. Этот метод можно применятм тойько
для создания $клдссов объектов  того же  размера! илр  менјше,  чем
бажовЫй класс, которыл используетсї в макросе. gslist применяется в
#7.6.2.

     7.3>6 Ограниченные Йнтерфейщы

 "Класс slist - довольно оещего характера. И­огда п®добная общность
не требуется  илм даже  нежелательна.  Ограниченные  виды  слискпв,
такие0как (стеки и  очереди, даже  более обыцн», чем сам обойщенный
спксок. Такие  структур№ данных  можно задать,  не  описав  базовый
клаес как$юткрытяй. НияриМер, очередь целых можно определить такє

  #include "slist.h"

  class iqueue : slist {
                 //прееполагается sizeof(int)<=sizeof(void*)
  publkc:
      void put(int a) { slist::appind(8void*)a)? }
   0  ant det()       { return int*slist::get()); }
      iqumqe()        {}
  =3

При таКом выводе остщеСтвляюцся два логически"разделенных действия:
понятие списка8ограншчивается понятием очдреди (сводится к нему), и
зидается тип  int< чтогы  свести  понятие  очереди  к  типу  данных
очередь  целых¬   iqueue.  Эти   два  деяствия  м®жно  выполняуь  и
раздельно. Зdесь  первая часть  - это список, огр ниченный так, что
он может использоваться только как стек:

  #includm "slist.h"
  class Stac{ : wlist {
  pubhic:
      clist::insert{
 8    s|ist::get;
      stack() {}
      stack(ent a) : (a) {|
  };

который потом  испольgунцся для  создания типа  "стек укачртелей наJсимволы":

                             - qтр 619 m

  #include "stack.h"

  class cp : stack {  public:
      toid pusx(char* a) ы slist:єinsert(a); }
      char( pop() { return (char*)slisф::get(); }
      nlist() {}
  };

 (  7.5 Добавление к Классу

  В`преДыдущhх  примерах произвоеный  кгасс ничего  не  добавлял $к
базовому  классу.  Для  прОиеводного  кыасса  Дуmкции  определялись
тоkько чтобы  обесoечить"преобразоbание  типа.  Каждый  произв®дный
класс просто  задавал альтернативный  интерфебс к  обЩему множествуM
программ. (Этот  специальный  случай  важен(  но $наисолее  обычная
причина$определеншя новх класскв как пpоизводных классов"в тои, что
кто%то хочеъ  имеуь то,  цто нреаосІавляев  б зовый класс, плюс еще
чуть-чуть.
 `Для  производного   класса  можно  опреддлитэ  данные  и  функции
дополниТбльно к  тем, коуорые( наследуются из  его базового класса.
Это дает  альтернативную стратегию  обеспечить средствб  связанного
спискд. Заметьте,  когда в$ тот slisd,  который  определялся  выше-
помещается элемент,  то Qоздается  slinc, содержащий дв` укизателп.
На их  создАние тратится  время, а  ведь сaз  ожного из  укаеателей
можно кбойтись,  при условии,  что нужно  только чтобы  объект  мог
находиться в  офном списке.  Тдк что  указатель next  на  следующий
можно помесъить  в ±ам  объект, вlесто  того, чтобы  помЕщать ело в
отднльный мбъект  slink. Идея" состоит в  том, чтобы  создать jласс
olink с  единственным полем  next, и  класу  olist,  коворый  может
обрабатывать укизагелями  на такие звенья olink. Тогда olist сможет
манипу«ировать объекТАми  луюоуо  класса( (производного  от$ olink.
Буква "o"  в назВанияч0 стоит для  того, чтобы  напоминать вам, что
объекъ может ­аходиться!одноврхменно тжлэко в одном$списке olisф*,
  struct olink {
      olink* nеxt;
  };

Кла±с olist  очень напоминает  класс slйst.  Отличие состоит в том,
что пользоватдль  класса пlist  манипулирует объектами класса olink
незоррхдсвенно:

  class olist {
      olink* last;
  public:
      void insert(olink* p);
      vohd apрend(olink* p);
      olink: ge4();
   !  // ...
  };
JМы мкжем вывесІи из ккасса olink класс name:

          0     "`   4       = стр 230 -

  class name : pubмйc olink {
      // ..
  };
  Теперь легко  сделать  список, 0который  мжжно  использовать  без
накладных расходов вреьени на размещение или прмыти.
  Объектыl помхщаемы  в olist,  теряюІ свой  тип. Это означаҐт, что
компилчтор знает  только то,  что они olink'и. Правильный тип можйо
восстановитЬ с помощью явного преобразования типа объектов( вынутых
из olist. Например:

  void f(©
  {
      ghist Ll;
      name nn;
     !lм.insert(&nn);         !    // тип &nn потерян
      nake* pn = (name*)ll.get();  // и восстаэовлен
  }

Дттгой споqоб:  тил можно  восстановить, выведя  еще один  класС из
olqst для обработки преобразогания тиПа:

  cliss olest 8 public olist {
      // ...
    ( name* ggt() { return (name*)olist::get(); }
  };	

  Имя name  может одновремeнЇо находиъься&только!в одном ohist. Для
Ёмен это  может быТь  и неподходит,  но в` илассах, дпя которщх это
подойдет полноqтью,  недосцатка нет.  Например, класс  фйгур( sjapеисполязует для  поддержки ±писка  всех  фигур  имхнно  этот  метод.
Обратите  в­имание,   что  мозно   было  гы  опреdелить  slisd  как
производпый от  olyst, объединяы  таким образмм жба понятия.(Однакп
использование  $бызовых    и   производных    кл`ссов   на    таком
микроскопическом уровне мкжет очень сильно исказить кпд.

     7.5 Неоднородные Спискм

  Предыдущие спи±ки  были однородными. Ро есть, в список помещалкбь
только  объекты   одноуо   типа.   Эцо   обеспечивалось   аппаратоМ
Їрпиgводных   классов.    Спи±ки   ­е   обязательно!  должны  $быть
одднородными. Список,  заденный в  виде указаетнлей на класс, моцет
соdержать оЎъекты  любогn класса,  нр®изакдного от этого класса. То
зсть, список  доfет быть  неоднотодным. Верояуно,  это единртвенный
еаиболее важный !и полезный аспект"производеыч классов, и он ВесьМр
сущхственно  используется   в   стилх   программифования,0  который
демонСтрируется   приведенным    вышх    примерnм.    Этот "  стильпрограммирования    часто    называют    объектно-основанным    Или
объектно-жриентированйым. Он! опиррется на  то,  ято  действия  над
оБъектами  неоднородных  списков  вылолняются  одинаковум  обррзом.
Смысл "этих   действищ  гАгисит   оц  фалтичебкого  типа  обънкrов,
находяyихся в  спиуке (что  становится`известно  только 0на $стадии
ВыполнЕния!,  а   не  просто  от$ типа( элементов  списка  (который
иомпилятору известен).

                            !- стр 221 -
     7.6 Законченна ПрограммаЌ

  Разберем процесс "написания программы  для  риСювания  на  экране
геметрических фигур.  Она хстественным  образом разделяется  на ури
части:
  [1] Админихтратор экрана: п®дпрограммы низкого уровня и структуры
     данных, ппределяющие экран; он ведает только точками и прямыми*     линиями;
  [2] Библиотека "фигур: набор  определений оосновных  фигур  вроде
"    прямоуголь­ика и  крчга и  стандартные программы  д«я работы с
     ними; и
 )[3]     Прикладная      програмна:     мноздсуво`    определҐний,
     специализированных для  манйого приложеэия,  и лод,$ в котюром
     они используются.
 !Эти три  части$скорее  всего бчдут  писать разные  люми (в Разных
отганизациях и  в рвзное  вшемя). Прh эцом части будчт скорее ксего
писать   именно    в 0 указаннкм  ! порядке   с   тхм   осложняющим
обстоятельством,  что  у  разработчиков  нижнего  уровня  не  будет
точного представления,  для чего  их вод! в  ко­ечном  сцете  будет
использоваъься. Это отражено в приводимюм примере. Чтмбы Лркмхр был
короче,  графиЧехкая  `бкблиотека   прҐдостатляет 0 толэко  (вебьмА
ограниченный сервис,  а сама  прйкладная  программ`  очень  проста.
Чтобы читатель смог испытать программу, дажн если у него пет совсео
никаких  гр фических   средств-  используется  чрезвыяайно  просТая
конценция экрайа.  Не дол¦но  составить Труда заменить эту экранную
часть прпгранмы  чхм=нибудь подходящим,  эе изменяя  ко¤ библиотеки
Фигур и прикладной програмоы.
J     7.6.1 Администратор Экранд

  Внаяале гыло намерени написать афминистратор экрана на C (а не на
C++),  чтобя   подчеркнуть ўразделение   уровней  реализации.   Это
оказалось !слишком  0утомительным,! поэтому   пришkось   пойти ( на
коьпромисс:`испольеуется  стилэ C "(нет функций членов, виртуальных
функций,  определчемых   пользователеь  операций  и  т.п.), `однако
орименяются  конструкторы,   надлежащим   образом   описываются 0$и
проверыются параметры  функций  и  т.дn( Оглядываясь  назад,  можно
сказрть, чъо  администратор экраmа  очень  похож  на  C  прnграмму,
кпторую потом  момифицировали, чтобы воспользовдться средстўами C++
не переoмсывая все полностью.J  Экран oредставляется  как двумешный  массив  символов,  работу  с
которым осуществлчют функции put_point() и put_line(), использующие
при ссылке на экран структуру point:

     (      `   (            - стр 222 -

  // файл screen.h

  consu XMAX=40, YMAX=24;
Љ  struct poin| {
      int x,y;
    ` point,) {}
    ($po)nt(int a int b) { x=a; y=b; }
  };

  overload put_point;
  extern void put_point(int a, int b);
  inline vOid put_point(point p) { pхt_p/int(p.X,p.y); }

 !ovebload put_li.e;
  extern void put_lile(int, int, int, in|);
  inline void put_line(point a, point b)
      { put_line(a.x,a.y,b.x,b.y); }

  ex4ern void screen_init();  extern void skreen_refresh();
  uxtern void screen_clear();
  #include

  Перeд   первым    использованием   функции    put   экран    надо
инициблизировать с  помощью screen_init(),  а иеменения в структуре
данных  экрана   отображаются `на   }кране  только   после   вязова
screen_refresh().  Как   увидит  пользовасель,   это   "обновлнние"
("refresh") осуществляется  просто посредством  печати новой  копии
экрана под  его нредыдущим  вариантом. Вот  функции  и  жпределеmия
данных для экрана:

  #include "screen.h"
  #include

  enum color { black='*', white=' ' };

  char screen[\MAX][YNAX];

  void screen_init()
 "{
 $    for (int y=0; y=a || a<=b) y0 += dy, eps -= two_a;
      }
  }

Предоставляются функции для очистки экрана й его обэовления:

  void screun_clear() { screen_init(); }  // очистка

  void screen_refrgsi()                   // обнnвлееие
  {
      for (int y=ЩMAX-1; 0<=i; y--) {     // сверху вниз
         !for  int x=0; x
7.62!Библиотека Фигур

  Нам нужно  опрбделить общее  пончтие  физуры  (уhape).  Это  надо
сделать таким обр`зом, чтоб» оно использовалось (как базовый класс)
всеми конкретными фигурами (например, кругами и квадфатами), и так,
чтобы любой  фигурой можно  было манипулировать исключитЕльно через
интесфейс, предоставляемый классом shape:

  struct shape {
    $ shape() { shape_list.append(this); }

      virtual point north() { return point(0,0); } // север
      virtuam point south() { return point(0,0); } // юг      virtual point east() { return point(0,0); }  // восток
      virtual point neast() { beturn point(0,0)? } // северо-восток
      virtual point seast() { return point(0,0); } // юго-восток

      virtual void draw() {};           !          // нарисовать
   !  vyrtual void move(int, int) {};              // перембстить
  };

  Шдея состоит  в том,  что фасположение  фигуры зад`ется с пооощью
move(), и фигура помещается на экран с помощью draw(). Фигуры можно
фАсполагать  относительно   друг  друга,  используя  понятие  точки
соприкосновения, и  эти точки (перечисляются после точек на кюмпасе
(сророн света)& Каждая конкретная фигура определяет свой смысл этих
точек, и  каждая  определяет  способ,  которым  она  рисуется.  Для
экономии месца  здесь на самом дбле определяются только необходимые
в этом  примере стороны света.$КонстрУктор shape::shape() добав«яет
фигуру в$ спихок фигуp  shape_list. Этот список является gslist, то
есть,  одним   из` вариантов   обобщенного  однксвязанного  списка,
опреееленного в  #7.3.5. Он`и соотвдтствуюЩий итеравор были сделaны
так:

  typeeef shape* sp;
  declare(gslist,sp);

  typgdef gclIst(sp) slapeЯLst;
  typedef gslist_ituraTor(sp) sp_iterator;
поэтому shape_list можно описать так:

  shape_lst sha0e_lIst;

Линиц можно  построить ыибо зо двум точкам, либо по точке и целому.
В последнем  случае создается  горизонталэнаэ линйя,0 длину которой
определяет целое.  Знак целого  указывает,  каким! концом 0явлэется
точка: левым или правым. Вот определение:

                             - стр 225 -M

( class line : public shape {
  /*
      линия из 'w' в 'e'
      north() определяется как `hвыше"центра
 (    и йа севеР как до самой сеўерной точки''
  */
      point w,e;M  public:
      point nosth()
          { return point((w.xe.x)/2,e.ydraw();
      sгreen_refresh();
  }

           "                 - сур 227 -

И!вот,  наконец, настоящая  сервисная функция (утилита). Она кладетЉодну фигуру  на верх другой, задавая,(что south() одной должен(быть
сразу над north() другой:

  void stack(shape* q, shape* p)   // ставит p на верх q
  {
      point n = p->north();Ќ
     "point s = q%>south(){
      q­>move(n.x-s.x,n.y-s.i+1);
  }

  Теперь   представим    себе,   что   эта   библиотека   считается
собственностью  некоел   компании,  которая   продает   программное
обеспхчение, и  что  они  продают  вам  только  заголовочный  файл,
содержацhй   опрeделения   фигур-   и   откомпилироВанный   вариант
определений  фуйкций.  И  у  вас  все  равно 0остается  возможность
определять нмвые  фигуры И использовать для ваших собственныэ фигур
сераисные!функции.*
     7®6.3 ПршКладная Программа

  Прикладная  прогшамма   чрезвщчайно  проста.$ Определяется  новая
фигура my_sh`pe  (на печати  она немнюго похожа на рожицу), а потом
пhшется главная  прогрдмма, которая  надевает на нее шляпу. Вначале
описа­ие }y_shape:

  #include "shape>h"

  class myshape : public re#tangle {
      line* l_eye;                   // леўый глаз
"     line* r[eye;                   // правый глаз
      line* mouth;                   // рот
( public:
      myshape(point, point);
( !   voi` draw();
      void move(int, int);
  };

  Глаза и  рот -  отдельные и  независимые объекты, ъоторые создает
конструотор my_shape:

  myshape::myshape(point a, poinv r) : (a,b)
  {
      int ll = neast().x-swest().x+1;
      int hh = neast().ymswest().y+1;
 (    l_eye = new$line(
          point(swest().x+2,swest(i.y+hh*3/4),2);
 "    r_eye = new line(
          pint(swest().z+ll-4,swEst().y+hh*3/4),2);
      mouth = new line(
          point(swest().x+2,swest().y+hh/4©,ll,4);
  }

  Объекты  глаза   и   рот   порознь   рисуюъся   заново   функцией
shape_refresh(), и  в принципе0 могут обрабитываться  независимо из

        !  $$           `    - стр 228 -

пбюекта  my_shape,   которому  они  приmадлежат.  Это  один  способ
опрееелятю средства  для иерархически$ построенных  объектов  вроде
my_shape. Другой  способ демонсrрируется  на примере  носа. Никакой
нос не  определяется.  его  просто  добавляет  к  картинке  функция
draw():

  void myshape::draw()
  {
      rectangle::draw();
      put_point(point(
          (swest().x+neast().x)/І,(swest().y+least().y)/2));
  }

my_shape    передвигается    посредством    перемещения    базового
прямоугоыьника rectangle  и вторичных объектов l_eye, r_eye и mouth
(левого глаза, правого глаза и рта):

  void myshape::move()
  {
      rectangle::mnve();
  `   l_eye->move(a,b);
      r_eye>move(a,b);
      mouth->movd(a,b);
  }

Мы  можем,   наконец,  построить   несколько  фигур  и  немного  их
подвилать:

  main()
  {
      shape* p1 = new rectangle(point(0,0),point(10,10));
      shape* p2 = new line(point(0,1%),15);
      shape* p3 = new myshape(point(35,10),point(37,38));
  "   shape_rebresh();      p3->move(-10,-10);
      stack(pІ,p3);
      sta#k(p1,p2);
      shapе_refresh();
      2eturn 0;
  }

  Хще раз  обратите вниманих,  как фунКции  вроде shape_refresh() и
stack() манипулируют `объектами типов,  определяемых гораздо позже,
чем  бщли  написдны  (и,  может` быть,  откомпилированы)  сами  эти
фгнкции.

                             - стр 229 -

   $ ***********
 "   *         *
     *         *
     *         *
     *         *
     * (       *
     *         *
     *         *
     *      0  *
     *      $  *
     ***********
  *****************
    *************
    *           *
    * **     ** *
    *           "
    *     *     *
    *           *
    * ********* *
    *           *
   "*************

     7.7 Свободнаї Память

  Если вы  польgоались класром slist, вы могли обна°ужить, что ваша
орогшамма тратит  на чаметное  время на  размещение и  освобождение
объектов класса  slink.  Класс  slink  -  это  превосходный  пример
класса, который может значитзльно выиграть от того, что программист
возьмет поф  конуроль управление  свободной памятью. Для этого вида
объектов идеально  подходит оптимизируюсий  метод,`который описан в
#5.5.6.  Поскольку   каждый  {link   создается  с   ломощью  new  и
уничтожается с  помощью delete  членами клАсса slist, другой способ
выделения памяти не представляет никаких проблемм.Ќ
  Если$производный  класс осуществляет присваивание указатeлю this,
то конструктор  его базового  класср буддт  вызыватьуя только посйе
этоcо  присваиванмя,  и  зн`чение  ыказателя  this  в  конструjторе
базового  класха   будет  теь.   которое  присвое­о   ккнструктором
производного класса. Если базовый класс$присваивает указател~ this,
то"будет  прасвоено то  значение,  которое  использует  консттуктор
производного класса. Например:

       °           (  `      - стр 230 -

  #include

  struct base { ba{e();!};

  struct derived : base { derived(); }

  bawe::bese()
  {
      cout << 2\tbase 1: this=" << int(this) << "\n";
      if (this == 0) this = (base*)2?;
     (cout$<< "\tbase 2: this=" << int(this) << "\n";
  }

  derived::derhved()
  {
      cout << "\tderived 1: this=" << int(this) <ј "\n";
      this = (this == 0) ? (dmrived*)43 : this;
 "    cout << "\tderived 2: this=" << int(this) << "\n";
  }

  main()
  {
  cout << "base b;\n";
  base b;
  cout << "new base b;\n";
  oew base;
 0cout << "derived d;\n";
  derived d;
  cmut << "new derived d;\n";
  new derived;
  cout << "at the end\n";

  }

порождает вывод

  base b;
          base 1: phis=2147478307
    (     ba{e 2: this=2147478307
  new base;
       0  rase 1: this=0
          base 2: this=27
  derived d;
          derived 1: this=2147478306
          base 1: this=2147478306
          base 2: this52147478306
         $terived 1: this=2147478306
  new derived;
          derivef 1: this=0
          base 1: this=43
          base 2: thhs=43
          derived 1: tiis=43
  at the end

 !Если деструктор  производного  класса  осуществляет  присbаивание
указателю thys,  то будет  присвоено то  значение, которое  всретил

                             - стр 031 -

деструктор  его   базового  класса.   Когда   кто-либо   делает   в
консурукторе присваиванае"гказателю this, важно, чтобы присваивание
указателю this всречалось на всех путях в конструкторе*.

     7.8 Упражнения

  1. (*1) Определите

       class baqe {
       puвhic:
          virtuid void iam() { cout << "base\n"; }
       };

     Выведите из`base два класса и для каждого nпределите iam() ("я
   $ есть"), иоторая выводит иья класса!на печат|. Создайте объекты
     этмх классов  и  вызовите  для  них  xam().  Присвойте  адреса
  "  объекТов производных классов укрзателям bare* и вызовите iam()
     через эти"указатели.
  2. (*2) Реализуйте примитивы экрана (#7.6.1) подходящим для вашҐй
 "   системы образом.
  7. (*2) Определите  класс trianwlg  (треугольник) и  класс circle
     (круг).
  4. (*2) Определите функцию, которая рисует гинию, соединяющую"две
  `  фигуры, отыскивая  две  ближайшие  "точъи  соприкосновения"  и
     соединяя их.
  5. (*2) Модифицируйте  пример с  фигурами так,  чтобы  line  была
     rectangle и наоборот.
  6. (*2) Придімайте  и реализуйте дважды связанный список, который
 0   можно использовать без итератора.
  7. (*2) Придумайте  и реализуйте дважды связанный список, которым
     можно  ппльзоваться  только  посредством  итерарора.  Итератоф
$    должен иметь  действиї для  движения вперед  и н зад, действия
     для вставления и удалбния элементов списка, и способ доступа к
"    текущему элементу.
  8. (*2) Постройте оБобщенный вариант дважды свїзанного списка.
  9. (*4) Сделайте  список, в  котором вставляются и удаляются самЁ
     объекты (а не просто указатели0на объекты). Проделайтб это для     класса  X,   еля   которого   определены   X::X(X&),   X::nX()
     X::operator=(X&).
  10.!(*5)  Придумайте(  и  реализуйте   библиотеку  для  нрписания
   0 моделей, управляемых прерываниями. Подсказка: . Только
     это -  старая программа,  а вы могли бы написать лучше. Должен
     быть класс  task (-" задача). Объект  класха task  должен мочш
     сох°аняць свое  сощтояние и  восстанавливаться в это состкяние
     (ты ьожете  определить task::save()  и task;:restore()), чтобы
____________________
  Є К  сожалению, об  этоо присваивании  легко забыть.  Например, в
первом издайии  этой книгм  (анулийском  -  перев.)  вторая  строка
конструктор derived::derived() читайась так:*
  if`(this == 0) this = (derived*)43;

И следовательно,  для d конструктор базового класса base::baseh) не
вызывался. Программа )была"д®пустимой  и корректно  выполнялась, но
очевидно делала не то, что подразумевал ввтор. (прим. автора)

      $                      - стр 232 -

     он мог  действовать как  сопрогранма. Отдельные  задачи  можно
     определять как  объекты классов,  производн{х от  класса task.
     Пролрамма, которую$ должна исполнять  задачд, модет задаваться
     как виртуальная  функция. Должна  быть возьожность  передавать
     новой задаче  ее параметры  как параметры ее конструктора(ов).
     Там   должен    быть   планировщик,    реализующий   концепцию
     виртыального   !времени.     Обеспечьте    функцию    задержки
  `  tqsk::delay(), которая  "Іратит" виртуальное  время. Будет  ли
"    планировыик отднльным  или частью  класса task  - это  один из
     основных0вопросов,  которые надо  решить  при  проектировании.
     Задача должна  передавать данные. Для этого разработайте класс
     queue (очередь)/ Придумайте способ, чтобы зад`ча оЖидала ввода
   " из нескольких очередей. Ошибки в еоде выполнения обрабатыванте
     ндинообрагно. Как  бы вы  отлажижаки программы,  написанные  с
     помощью такой библиотеки?


                           Глава 8

                              Потоки

  Язык C++  не обеспҐчивает! средств для ввода/вывода. Е¬у это к не
нужно; такие  средства легко  и элегантно  можно создать  с помощюю
самого языка.  Описанная зжесь  стандартная  бибйиотека  потокового
ввода/вывода обеспечиўает  гибкий и  эффективный с  гарантией  типаметод обработки  символьного ввода  целых чисел,  чисел с плавающей
точкой и символьных строк, а также простую,модҐль`ее расширнния для
обработки типов,  определяемых полфзователем.  Ее  пользовательский
интерфейс находится  в .  В этой  главе описывается  сама
библиотека, некоторые  способы 0ее  применения  и  методы,  котоаые
использовались при ее реализации.

$  0 8.1 Введение

  Разработка и  реализация  стандартных  средств  ввода/вывода  для
языка программирования  зарекомдовала  себя  как  заведомо  трудная
рАбота.   Традиционно    средства   ввода/вывода    разрабатывались*исключительно для  небольшого числа встроенных типов данных. Однако
в C++  программах обычно  используется  много  типов,  определенных
пользователем, и  нужно обрабатывать  ввод и вывод также и значений
этих типов.  Очевидно, средство  ввода/вывода должно  быть простым,
удобным, надежным в употребелении, эффективным и гибким, и ко всему
прочему полным. Ничье решение еще не смогло угодить всем, поэтому у
пользователя  должна   быть  возможность   задавать  альтернативные
средства ввода/вывода и расширять стандартные средства ввода/вывода
применительно к требованиям приложения.
  C++  разработан   так,  чтобы  у  пользователя  была  возможность
определять новые  типы столь  же эффективные  и  удобные,  сколь  и
встроенные типы. Поэтому обоснованным является требование того, что
средства  ввода/вывода  для  C++  должны  обеспечиваться  в  C++  с
применением  только   тех   средств,   которые   доступны   каждому
программисту. Описываемые  здесь средства  ввода/вывода предсавляют
собой попытку ответить на этот вызов.
  Средства  ввода/вывода      связаны   исключительно   с
обработкой `  преобразквания  "  типизи°ованнных     объектов     в
послефовательности  символов   и  обратно.   Eсть  и  другиб  схемыЌ
ввожд/тывода, но  эта является  основополагающей в  системе UNIX, И
большая чахтьp видов бинарного  ввода/вывода  обрабатывается  через
рассмотрение  символа   просто  как   набор  бит,   при  этом   его
общепринятая свЯзь с аЛфавитом игнорируется. Тогда для программиста
ключевдя 0проблема   заключается  в   задании  соответствия   между
типизированным объектом и принципиальэо нетипизированноб строкой.
  Обработка  и   встроенных  И  $определенных  пользователем  типов
однородным образоь  и с гарантией типа достигаетqя с ломощью одного
перегрУженного имени функции для набора функций вывода. Например:
           "        (       "- стр 234 -M

  put(gerr,"x = "); //(cerr - поток вывода обшибок
  put(curr,x);
  put(cerr,"\o#);

Тип параметра  определяет то,!какая из функций pt будет вызываться
для каждого параметра. Это решение применялось в нескольких языках.
Однако ему недостает лаконичности. Перегрузка операции << значением
"поместить в"  дает более  хорошую запись  и позволяет программисту
выводить ряд объектов одним оператором. Например:

  cerr << "x = " << x << "\n";

где cerr  -  стандартный  поток  вывода  ошибок.  Поэтому,  если  x
является int  со значением  123,  то  этот  оператор  напечатает  в
стандартный поток вывода ошибок

  x = 123

и символ новой строки. Аналогично, если X принадлежит определенному
пользователем типу complex и имеет значение (1,2.4), то приведенный
выше оператор напечатает в cerr

  x = 1,2.4)

  Этот  метод  можно  применять  всегда,  когда  для  x  определена
операция <<, и пользователь может определять операцию << для нового
типа.

     8.2 Вывод

  В  этом   разделе  сначала   обсуждаются  средства  форматного  и
бесформатного вывода встроенных типов, потом приводится стандартный
способ спецификации  действий вывода для определяемых пользователем
типов.

     8.2.1 Вывод Встроенных Типов

  Класс ostream  определяется вместе с операцией << ("поместить в")
для обработки вывода встроенных типов:

  class ostream {
      // ...
  public:
      ostream& operator<<(char*);
      ostream& operator<<(int i) { return *this<
8.2.3 Некоторые Подробности Разработки

  Операция вывода  используется, чтобы избежать той многословности,
которую дало бы использование функции вывода. Но почему <<?
  Возможности  изобрести   новый  лексический  символ  нет  (#6.2).
Операция присваивания  была кандидатом одновременно и на ввод, и на
вывод,  но   оказывается,  большинство  людей  предпочитают,  чтобы
операция ввода отличалась от операции вывода. Кроме того, = не в ту
сторону связывается  (ассоциируется),  то  есть  cout=a=b  означает
cout=(a=b).
  Делались  попытки  оспользовать  операции  <  и  >,  но  значения
"меньше" и  "больше" настолько  прочно вросли в сознание людей, что
новые операции  ввода/вывода во  всех  реальных  случаях  оказались
нечитаемыми. Помимо  этого, "<"  находится на большинстве клавиатур
как раз на ",", и у людей получаются операторы вроде такого:

  cout < x , y , z;

Для таких операторов непросто выдать хорошие сообщения об ошибках.
  Операции <<  и >>  к  такого  рода  проблемам  не  приводят,  они
асимметричны в  том смысле,  что их  можно проассоциировать с "в" и
"из",  а  приоритет  <<  достаточно  низок,  чтобы  можно  было  не
использовать скобки  для арифметических выражений в роли операндов.
Например:

  cout << "a*b+c=" << a*b+c << "\n";

Естественно, при  написании выражений,  которые содержат операции с
более низкими приоритетами, скобки использовать надо. Например:

  cout << "a^b|c=" << (a^b|c) << "\n";

Операцию левого сдвига тоже можно применять в операторе вывода:

  cout << "a<
8.2.4 Форматированный Вывод

  Пока <<  применялась только  для неформатированного  вывода, и на
самом деле  в реальных  программах она  именно  для  этого  главным
образом и  применяется. Помимо  этого  существует  также  несколько
форматирующих функций,  создающих представление  своего параметра в
виде  строки,   которая  используется   для   вывода.   Их   второй
(необязательный) параметр  указывает,  сколько  символьных  позиций
должно использоваться.

  char* oct(long, int =0);    // восьмеричное представление
  char* dec(long, int =0);    // десятичное представление
  char* hex(long, int =0);    // шестнадцатиричное представление
  char* chr(int, int =0);     // символ
  char* str(char*, int =0);   // строка

Если не  задано поле нулевой длины, то будет производиться усечение
или  дополнение;   иначе  будет   использоваться  столько  символов
(ровно), сколько нужно. Например:

  cout << "dec(" << x
       << ") = oct(" << oct(x,6)
       << ") = hex(" << hex(x,4)
       << ")";

Если x==15, то в результате получится:

  dec(15) = oct(    17) = hex(   f);

  Можно также использовать строку в общем формате:

                             - стр 238 -

  char* form(char* format ...);

cout<
8.2.5 Виртуальная Функция Вывода

  Иногда функция  вывода должна  быть  virtual.  Рассмотрим  пример
класса shape, который дает понятие фигуры (#1.18):

  class shape {
      // ...
  public:
      // ...
      virtual void draw(ostream& s); // рисует "this" на "s"
  };

  class circle : public shape {
      int radius;
  public:
      // ...
      void draw(ostream&);
  };

  То есть,  круг имеет  все признаки  фигуры и может обрабатываться
как фигура,  но  имеет  также  и  некоторые  специальные  свойства,
которые должны учитываться при его обработке.
  Чтобы  поддерживать   для  таких  классов  стандартную  парадигму
вывода, операция << определяется так:

  ostream& operator<<(ostream& s, shape* p)
  {
      p->draw(s);
      return s;
  }

                             - стр 241 -

Если next  - итератор  типа определенного в #7.3.3, то список фигур
распечатывается например так:

  while ( p = next() ) cout << p;

     8.3 Файлы и Потоки

  Потоки обычно  связаны  с  файлами.  Библиотека  потоков  создает
стандартный поток  ввода cin,   стандартный  поток   вывода cout  и
стандартный поток  ошибок cerr.  Программист может открывать другие
файлы и создавать для них потоки.

     8.3.1 Инициализация Потоков Вывода

  ostream имеет конструкторы:

  class ostream {
      // ...
      ostream(streambuf* s);      // связывает с буфером потока
      ostream(int fd);            // связывание для файла
      ostream(int size, char* p); // связывет с вектором
  };

Главная работа  этих конструкторов  - связывать  с  потоком  буфер.
streambuf - класс, управляющий буферами; он описывается в #8.6, как
и класс  filebuf, управляющий  streambuf для  файла.  Класс filebuf
является производным от класса streambuf.
  Описание  стандартных   потоков  вывода   cout  и  cerr,  которое
находится  в   исходных  кодах   баблиотеки  потоков  ввода/вывода,
выглядит так:

      // описать подходящее пространство буфера
  char cout_buf[BUFSIZE]

      // сделать "filebuf" для управления этим пространством
      // связать его с UNIX'овским потоком вывода 1 (уже открытым)
  filebuf cout_file(1,cout_buf,BUFSIZE);

      // сделать ostream, обеспечивая пользовательский интерфейс
  ostream cout(&cout_file);

  char cerr_buf[1];

      // длина 0, то есть, небуферизванный
      // UNIX'овский поток вывода 2 (уже открытый)
  filebuf cerr_file()2,cerr_buf,0;

  ostream cerr(&cerr_file);

  Примеры двух  других конструкторов ostream можно найти в #8.3.3 и
#8.5.

                             - стр 242 -

     8.3.2 Закрытие Потоков Вывода

  Деструктор для ostream сбрасывает буфер с помощью открытого члена
функции ostream::flush():

  ostream::~ostream()
  {
      flush();       // сброс
  }

Сбросить буфер можно также и явно. Например:

  cout.flush();

     8.3.3 Открытие Файлов

  Точные  детали   того,  как   открываются  и  закрываются  файлы,
различаются в  разных операционных  системах и  здесь  подробно  не
описываются.  Поскольку   после  включения     становятся
доступны cin,  cout и  cerr, во многих (если не во всех) программах
не нужно  держать код  для открытия файлов. Вот, однако, программа,
которая открывает  два  файла,  заданные  как  параметры  командной
строки, и копирует первый во второй:

  #include

  void error(char* s, char* s2)
  {
      cerr << s << " " << s2 << "\n";
      exit(1);
  }

  main(int argc, char* argv[])
  {
      if (argc != 3) error("неверное число параметров","");

      filebuf f1;
      if (f1.open(argv[1],input) == 0)
          error("не могу открыть входной файл",argv[1]);
      istream from(&f1);

      filebuf f2;
      if (f2.open(argv[2],output) == 0)
          error("не могу создать выходной файл",argv[2]);
      ostream to(&f2);

      char ch;
      while (from.get(ch)) to.put(ch);

      if (!from.eof() !! to.bad())
          error("случилось нечто странное","");
  }

                             - стр 243 -

  Последовательность действий при создании ostream для именованного
файла та  же, что используется для стандартных потоков: (1) сначала
создается буфер  (здесь это делается посредством описания filebuf);
(2)  затем   к  нему   подсоединяется  файл   (здесь  это  делается
посредством открытия  файла с  помощью функции filebuf::open()); и,
накрнец, (3)  создается сам ostream с filebuf в качестве параметра.
Потоки ввода обрабатываются аналогично.
  Файл может открываться в одной из двух мод:

  enum open_mode { input, output };

Действие filebuf::open() возвращает 0, если не может открыть файл в
соответствие с  требованием.  Если  пользователь  пытается  открыть
файл, которого не существует для output, он будет создан.
  Перед завершением  программа проверяет,  находятся  ли  потоки  в
приемлемом  состоянии   (см.  #8.4.2).   При  завершении  программы
открытые файлы неявно закрываются.
  Файл можно  также открыть  одновременно для чтения и записи, но в
тех случаях,  когда это  оказывается необходимо,  парадигма потоков
редко оказывается  идеальной. Часто  лучше рассматривать такой файл
как вектор  (гигантских размеров).  Можно определить  тип,  котоырй
позволяет программе обрабатывать файл как вектор; см. Упражнения 8-
10.

     8.3.4 Копирование Потоков

  Есть возможность копировать потоки. Например:

  cout = cerr;

В результате этого получаются две переменные, ссылающиеся на один и
тот же  поток. Гавным  образом это  бывает полезно  для того, чтобы
сделать стандартное  имя вроде  cin ввылающимся  на  что-то  другое
(пример этого см. в #3.1.6)

     8.4 Ввод

  Ввод  аналогичен   выводу.   Имеется   класс   istream,   который
предоставляет операцию  >> ("взять  из") для  небольшого  множества
стандартных типов.  Функция operator>> может определяться для типа,
определяемого пользователем.

     8.4.1 Ввод Встроенных Типов

  Класс istream определяется так:

                             - стр 244 -

  class istream {
      // ...
  public:
      istream& operator>>(char*);      // строка
      istream& operator>>(char&);      // символ
      istream& operator>>(short&);
      istream& operator>>(int&);
      istream& operator>>(long&);
      istream& operator>>(float&);
      istream& operator>>(double&);
      // ...
  };

  Функции ввода определяются в таком духе:

  istream& istream::operator>>(char& c);
  {
          // пропускает пропуски
      int a;
          // неким образом читает символ в "a"
      c = a;
  }

  Пропуск определяется  как стандартнчй  пропуск в  C, через  вызов
isspase() в  том виде,  как она  определена  в    (пробел,
табуляция, символ новой строки, перевод формата и возврат каретки).
  В качестве альтернативы можно использовать функции get():

  class istream {
      // ...
      istream& get(char& c);                    // char
      istream& get(char* p, int n, int ='\n');  // строка
  };

Они обрабатывают  символы пропуска  так же,  как остальные символы.
Функция istream::get(char)  читает один  и тот  же  символ  в  свой
параметр; другая  istream::get читает  не более n символов в вектор
символов,  начинающийся   в  p.   Необязательный  третий   параметр
используется для  задания символа остановки (иначе, терминатора или
ограничителя), то  есть этот  символ читаться  не будет. Если будет
встречен  символ  ограничитель,  он  останется  как  первый  символ
потока. По  умолчанию вторая функция get будет читать самое большее
n  символов,   но  не   больше  чем   одну  строку,  '\n'  является
ограничителем по  умолчанию. Необязательный  третий параметр задает
символ, который читаться не будет. Например:

  cin.get(buf,256,'\t');

будет читать  в buf  не  более  256  символов,  а  если  встретится
табуляция ('\t'),  то это приведет к возврату из get. В этом случае
следующим символом, который будет считан из cin, будет '\t'.
  Стандартный  заголовочный  файл    определяет  несколько
функций, которые могут оказаться полезными при осуществлении ввода:

                             - стр 245 -

  int isalpha(char)    // 'a'..'z' 'A'..'Z'
  int isupper(char)    // 'A'..'Z'
  int islower(char)    // 'a'..'z'
  int isdigit(char)    // '0'..'9'
  int isxdigit(char)   // '0'..'9' 'a'..'f' 'A'..'F'
  int isspase(char)    // ' ' '\t' возврат новая строка
                       // перевод формата
  int iscntrl(char)    // управляющий символ
                       // (ASCII 0..31 и 127)
  int ispunct(char)    // пунктуация: ниодин из вышеперечисленных
  int isalnum(char)    // isalpha() | isdigit()
  int isprint(char)    // печатаемый: ascii ' '..'-'
  int isgraph(char)    // isalpha() | isdigit() | ispunct()
  int isascii(char c)  { return 0<=c &&c<=127; }

Все кроме  isascii() реализуются  внешне одинаково,  с  применением
символа в  качестве индекса  в таблице  атрибутов символов. Поэтому
такие выражения, как

  (('a'<=c && c<='z') || ('A'<=c && c<='Z')) // алфавитный

не только  утомительно пишутся  и чреваты  ошибками  (на  машине  с
набором символов  EBCDIC оно будет принимать неалфавитные символы),
они также и менее эффективны, чем применение стандартной функции:

  isalpha(c)

     8.4.2 Состояния Потока

  Каждый поток  (istream или  ostream) имеет  ассоциированное с ним
состояние,   и    обработка   ощибок    и   нестандартных   условий
осуществляется с помощью соответствующей установки и проверки этого
состояния.
  Поток может находиться в одном из следующих состояний:

  enum stream_state { _good, _eof, _fail, _bad };

Если состояние  _good или  _eof, значит  последняя  операция  ввода
прошла успешно.  Если состояние  _good, то следующая операция ввода
может пройти  успешно, в  противном случае она закончится неудачей.
Другими словами,  применение операции  ввода к  потоку, который  не
находится  в  состоянии  _good,  является  пустой  операцией.  Если
делается попытка  читать в  переменную v,  и  операция  окацивается
неудачей,  значение   v  должно   остаться  неизменным  (оно  будет
неизменным, если  v имеет один из тех типов, которые обрабатываются
функциями членами  istream или  ostream). Отличия между состояниями
_fail и  _bad очень  незначительно и предсавляет интерес только для
разработчиков операций ввода. В состоянии _fail предполагается, что
поток не  испорчен и  никакие символы не потеряны. В состоянии _bad
может быть все что угодно.
  Состояние потока можно проверять например так:

                             - стр 246 -

  switch (cin.rdstate()) {
  case _good:
      // последняя операция над cin прошла успешно
      break;
  case _eof:
      // конец файла
      break;
  case _fail:
      // некоего рода ошибка форматирования
      // возможно, не слишком плохая
      break;
  case _bad:
      // возможно, символы cin потеряны
      break;
  }

  Для любой  переменной z типа, для которого определены операции <<
и >>, копирующий цикл можно написать так:

  while (cin>>z) cout << z << "\n";

Например,  если   z  -  вектор  символов,  этот  чикл  будет  брать
стандартный ввод и помещать его в стандартный вывод по одному слову
(то есть, последовательности символов без пробела) на строку.
  Когда в  качестве условия используется поток, происходит проверка
состояния потока    и  эта  проверка  проходит  успешно  (то  есть,
значение условия не ноль) только если состояние _good. В частности,
в  предыдущем   цикле  проверялось   состояние   istream,   которое
возвращает cin>>z.  Чтобы  обнаружить,  почему  цикл  или  проверка
закончились неудачно,  можно исследовать  состояние. Такая проверка
потока реализуется операцией преобразования (#6.3.2).
  Делать проверку  на  наличие  ошибок  каждого  ввода  или  вывода
действительно не  очень удобно,  и обычно  источником ошибок служит
программист, не  сделавший этого  в том месте, где это существенно.
Например, операции  вывода обычно  не  проверяются,  но  они  могут
случайно не сработать. Парадигма потока ввода/вывода построена так,
чтобы когда в C++ появится (если это произойдет) механизм обработки
исключительных ситуаций  (как средство  языка или  как  стандартная
библиотека)   его   будет   легко   применить   для   упрощения   и
стандартизации обработки ошибок в потоках ввода/вывода.

     8.4.3 Ввод Типов, Определяемых Пользователем

  Ввод для  пользовательского типа может определяться точно так же,
как вывод,  за тем исключением, что для операции ввода важно, чтобы
второй параметр был ссылочного типа. Например:

                             - стр 247 -

  istream& operator>>(istream& s, complex& a)
  /*
      форматы ввода для complex; "f" обозначает float:
      f
      ( f )
      ( f , f )
  */
  {
      double re = 0, im = 0;
      char c = 0;

      s >> c;
      if (c == '(') {
          s >> re >> c;
          if (c == ',') s >> im >> c;
          if (c != ')') s.clear(_bad);    // установить state
      }
      else {
          s.putback(c);
          s >> re;
      }

      if (s) a = complex(re,im);
      return s;
  }

  Несмотря на  то, что  не хватает  кода обработки  ошибок, большую
часть видов  ошибок это на самом деле обрабатывать будет. Локальная
переменная c  инициализируется,  чтобы  ее  значение  не  оказалось
случайно  '('   после  того,   как  операция   окнчится   неудачно.
Завершающая проверка  состояния потока  гарантирует,  что  значение
параметра a  будет изменяться  только в  том случае,  если все идет
хорошо.
  Операция установки  состояния названа  clear() (очистить), потому
что она  чаще всего  используется  для  установки  сосояния  потока
заново как _good. _good является значением параметра по умолчанию и
для istream::clear(), и для ostream::clear().
  Над операциями  ввода надо  поработать еще. Было бы, в частности,
замечательно, если  бы можно  было задавать ввод в терминах шаблона
(как в  языках Снобол и Икон), а потом проверять, прошла ли успешна
вся  операция  ввода.  Такие  операции  должны  были  бы,  конечно,
обеспечивать некоторую  дополнительную буферизацию, чтобы они могли
воссанавливать поток ввода в его исходное состояние после неудачной
попытки распознавания.

     8.4.4 Инициализация Потоков Ввода

  Естественно,  тип   istream,  так   же  как  и  ostream,  снабжен
конструктором:

                             - стр 248 -

  class istream {
      // ...
      istream(streambuf* s, int sk =1, ostream* t =0);
      istream(int size, char* p, int sk =1);
      istream(int fd, int sk =1, ostream* t =0);
  };

Параметр sk  задает, должны пропускаться пропуски или нет. Параметр
t  (необязательный)   задает  указатель   на  ostream,  к  которому
прикреплен istream.  Например, cin  прикреплен к  cout; это значит,
что перед  тем, как  попытаться читать символы из своего файла, cin
выполняет

  cout.flush(); // пишет буфер вывода

  С помощью функции istream::tie() можно прикрепить (или открепить,
с помощью tie(0)) любой ostream к любому istream. Например:

  int y_or_n(ostream& to, istream& from)
  /*
       "to", получает отклик из "from"
  */
  {
      ostream* old = from.tie(&to);
      for (;;) {
          cout << "наберите Y или N: ";
          char ch = 0;
          if (!cin.get(ch)) return 0;

          if (ch != '\n') { // пропускает остаток строки
              char ch2 = 0;
              while (cin.get(ch2) && ch2 != '\n') ;
          }
          switch (ch) {
          case 'Y':
          case 'y':
          case '\n':
              from.tie(old);        // восстанавливает старый tie
              return 1;
          case 'N':
          case 'n':
              from.tie(old);        // восстанавливает старый tie
              return 0;
          default:
              cout << "извините, попробуйте еще раз: ";
          }
      }
  }

Когда используется  буферизованный  ввод  (как  это  происходит  по
умолчанию), пользователь  не может набрав только одну букву ожидать
отклика. Система  ждет появвения  символа  новой  строки.  y_or_n()
смотрит на первыйй символ строки, а остальные игноиррует.
  Символ   можно    вернуть   в    поток    с    помощью    функции
istream::putback(char).  Это   позволяет   программе   "заглядывать
вперед" в поток ввода.

                             - стр 249 -

     8.5 Работа со Строками

  Можно   осуществлять   действия,   подобные   вводу/выводу,   над
символьным  вектором,   прикрепляя  к  нему  istream  или  ostream.
Например, если веатор содержит обычную строку, завершающуюся нулем,
для печати  слов из  этого вектора  можно использовать  приведенный
выше копирующий цикл:

  void word_per_line(char v[], int sz)
  /*
      печатет "v" размера "sz" по одному слову на строке
  */
  {
      istream ist(sz,v); // сделать istream для v
      char b2[MAX];      // больше наибольшего слова
      while (ist>>b2) cout << b2 << "\n";
  }

Завершающий нулевой  символ  в  этом  случае  интерпретируется  как
символ конца файла.
  В помощью  ostream можно  отформатировать сообщения,  которые  не
нужно печатать тотчас же:

  char* p = new char[message_size];
  ostream ost(message_size,p);
  do_something(arguments,ost);
  display(p);

  Такая операция,  как do_something,  может  писать  в  поток  ost,
передавать ost  своим  подоперациям  и  т.д.  спомощью  стандартных
операций вывода. Нет необходимости делать проверку не переполнение,
поскольку ost  знает свою  длину и когда он будет переполняться, он
будет переходить  в состояние  _fail.  И,  наконец,  display  может
писать сообщения  в "настоящий"  поток  вывода.  Этот  метод  может
оказаться наиболее  полезным, чтобы  справляться  с  ситуациями,  в
которых окончательное  отображение данных  включает  в  себя  нечто
более сложное,  чем работу  с традиционным  построчным  устройством
вывода. Например,  текст из ost мог бы помещаться в располагающуюся
где-то на экране область фиксированного размера.

     8.6 Буферизация

  При задании  операций ввода/вывода  мы никак  не  касались  типов
файлов, но  ведь не  все устройства можно рассматривать одинаково с
точки  зрения   стратегии  буферизации.   Например,  для   ostream,
подключенного к  символьной строке,  требуется буферизация  другого
вида, нежели  для ostream, подключенного к файлу. С этими пробемами
можно  справиться,  задавая  различные  буферные  типы  для  разных
потоков  в   момент  инициализации   (обратите  внимание   на   три
конструктора класса  ostream). Есть  только один набор операций над
этими буферными  типами, поэтому  в функциях  ostream нет  кода, их
различающего. Однако  функции,  которые  обрабатывают  переполнение
сверху и  снизу, виртуальные. Этого достаточно, чтобы справляться с
необходимой в данное время стратегией буферизации. Это также служит
хорошим примером  применения виртуальных  функций для  того,  чтобы

                             - стр 250 -

сделать  возможной  однородную  обработку  логически  эквивалентных
средств с различной реализацией. Описание буфера потока в
выглядит так:

  struct streambuf {      // управление буфером потока

      char* base;         // начало буфера
      char* pptr;         // следующий свободный char
      char* qptr;         // следующий заполненный char
      char* eptr;         // один из концов буфера
      char  alloc;        // буфер, выделенный с помощью new

          // Опустошает буфер:
          // Возвращает EOF при ошибке и 0 в случае успеха
      virtual int overflow(int c =EOF);

          // Заполняет буфер
          // Возвращет EOF при ошибке или конце ввода,
          // иначе следующий char
      virtual int underflow();

      int snextc()        // берет следующий char
      {
          return (++qptr==pptr) ? underflow() : *qptr&0377;
      }

      // ...

      int allocate()      // выделяет некоторое пространство буфера

      streambuf() { /* ... */}
      streambuf(char* p, int l) { /* ... */}
      ~streambuf() { /* ... */}
  };

  Обратите внимание,  что здесь определяются указатели, необходимые
для работы  с буфером,  поэтому обычные посимвольные действия можно
определить (только один раз) в виде максимально эффективных inline-
функций. Для  каждой конкретной  стратегии  буферизации  необходимо
определять только  функции переполнения  overflow() и  underflow().
Например:

                             - стр 251 -

  struct filebuf : public streambuf {

      int fd;              // дескриптор файла
      char opened;         // файл открыт

      int overflow(int c =EOF);
      int underflow();

      // ...

          // Открывает файл:
          // если не срабатывает, то возвращет 0,
          // в случае успеха возвращает "this"
      filebuf* open(char *name, open_mode om);
      int close() { /* ... */ }

      filebuf() { opened = 0; }
      filebuf(int nfd) { /* ... */ }
      filebuf(int nfd, char* p, int l) : (p,l) { /* ... */ }
      ~filebuf() { close(); }
  };

  int filebuf::underflow()         // заполняет буфер из fd
  {
      if (!opened || allocate()==EOF) return EOF;

      int count = read(fd, base, eptr-base);
      if (count < 1) return EOF;

      qptr = base;
      pptr = base + count;
      return *qptr & 0377;
  }

     8.7 Эффективность

  Можно было  бы ожидать, что раз ввод/вывод  определен с
помощью обцедоступных средств языка, он будет менее эффективен, чем
встроенное средство.  На самом  деле это не так. Для действий вроде
"поместить   символ    в   поток"    используются   inline-функции,
единственные необходимые  на этом  уровне вызовы  функций возникают
из-за переполнения  сверху и  снизу. Для  простых объектов  (целое,
строка  и   т.п.)  требуется   по  одному  вызову  на  каждый.  Как
выясняется, это  не  отличается  от  прочих  средств  ввода/вывода,
работающих с объектами на этом уровне.

     8.8 Упражнения

  1. (*1.5) Считайте  файл чисел  с плавающей  точкой, составьте из
     пар считанных  чисел комплексные  числа и выведите комплексные
     числа.

                             - стр 252 -

  2. (*1.5)   Определите    тип   name_and_address   (имя_и_адрес).
     Определите  для  него  <<  и  >>.  Скопируйте  поток  объектов
     name_and_address.
  3. (*2)  Постройте   несколько  функций   для  запроса  и  чтения
     различного  вида   информации.  Простейший  пример  -  функция
     y_or_n() в  #8.4.4. Идеи: целое, число с плавающей точкой, имя
     файла, почтовый адрес, дата, личные данные и т.д. Постарайтесь
     сделать их защищенными от дурака.
  4. (*1.5) Напишите  программу, которая  печатает (1)  все буквы в
     нижнем регистре, (2) все буквы, (3) все буквы и цифры, (4) все
     символы, которые  могут встречаться  в идентификаторах  C++ на
     вашей системе,  (5) все символы пунктуации, (6) целые значения
     всех управляющих символов, (7) все символы пропуска, (8) целые
     значения всех символов пропуска, и (9) все печатаемые символы.
  5. (*4)  Реализуйте   стандартную   библиотеку   ввода/вывода   C
     () с  помощью стандартной библиотеки ввода/вывода C++
     ().
  6. (*4)  Реализуйте   стандартную  библиотеку   ввода/вывода  C++
     () с  помощью стандартной библиотеки ввода/вывода  C
     ().
  7. (*4) Реализуйте  стандартные библиотеки C и C++ так, чтобы они
     могли использоваться одновременно.
  8. (*2)  Реализуйте   класс,  для  которого  []  перегружено  для
     реализации случайного чтения символов из файла.
  9. (*3) Как  Упражнение 8,  только сделайте,  чтобы [] работало и
     для чтения,  и  для  записи.  Подсказка:  сделайте,  чтобы  []
     возвращало  объект   "дескрипторного   типа",   для   которого
     присваивание означало  бы присвоить  файлу через дескриптор, а
     неявное преобразование  в char  означало бы  чтение  из  файла
     через дескриптор.
  10. (*2) Как  Упражнение 9,  только  разрешите  []  индексировать
     записи некоторого вида, а не символы.
  11. (*3) Сделайте  обобщенный  вариант  класса,  определенного  в
     Упражнении 10.
  12. (*3.5)  Разработайте   и   реализуйте   операцию   ввода   по
     сопосталению с  образцом. Для спецификации образца используйте
     строки  формата   в  духе   printf.  Должна  быть  возможность
     попробовать  сопоставить  со  вводом  несколько  образцов  для
     нахождения фактического  формата. Можно  было бы вывести класс
     ввода по образцу из istream.
  13. (*4) Придумайте  (и реализуйте) вид образцов, которые намного
     лучше.


                     Справочное руководство по C++

                         1. ВВЕДЕНИЕ

  Язык  программирования   C++  -  это  C*,  расширенный  введением
классов, inline-функций,    перегруженных  операций,  перегруженных
имен  функций,   константных  типов,  ссылок,  операций  управления
свободной памятью,  проверки параметров  функций. Коротко  различия
между С++  и  "старым  С"  приведены  в  #15.  В  этом  руководстве
описывается язык по состоянию на Июнь 1985.

                 2. ДОГОВОРЕННОСТИ О ЛЕКСИКЕ

  Есть  шесть   классов  лексем:  идентификаторы,  ключевые  слова,
константы, строки, операторы и прочие разделители. Символы пробела,
табуляции и  новой строки,  а  также  комментарии  (собирательно  -
"белые места"),  как описано ниже, игнорируются, за исключением тех
случаев, когда  они служат разделителями лексем. Некое пустое место
необходимо  для   разделения  идентификаторов,   ключевых  слов   и
констант, которые в противном случае окажутся соприкасающимися.
  Если входной  поток  разобран  на  лексемы  до  данного  символа,
принимается, что следующая лексема содержит наиболее длинную строку
символов из тех, что могут составить лексему.

     2.1 Комментарии

  Символы  /* задают начало комментария, заканчивающегося символами
*/. Комментарии  не могут  быть  вложенными.  Символы  //  начинают
комментарий, который  заканчивается в  конце строки, на которой они
появились.

     2.2 Идентификаторы (имена)

  Идентификатор  -  последовательность  букв  и  цифр  произвольной
длины; первый  символ обязан  быть буквой; подчерк '_' считается за
букву; буквы в верхнем и нижнем регистрах являются различными.

     2.3 Ключевые слова

  Следующие  идентификаторы  зарезервированы  для  использования  в
качестве ключевых слов и не могут использоваться иным образом:

____________________
  * "Язык  программирования Си"  Брайэна В.  Кернигана и Денниса М.
Ритчи. Это  руководство было  построено на  основе  "C  Programming
Language -  Reference Manual" системы UNIX V с разрешения AT&T Bell
Laboratories. (прим. автора)

                             - стр 254 -

  asm       auto      break     case      char
  class     const     continue  default   delete
  do        double    else      enum      extern
  float     for       friend    goto      if
  inline    int       long      new       operator
  overload  public    register  return    short
  sizeof    static    struct    switch    this
  typedef   union     unsigned  virtual   void
  while

Идентификаторы signed  и volatile  зарезервированы для применения в
будущем.

     2.4 Константы

  Как  описано   ниже,  есть   несколько  видов  констант.  В  #2.6
приводится краткая  сводка аппаратных характеристик, которые влияют
на их размеры.

     2.4.1 Целые константы

  Целая константа,  состоящая из последовательности цифр, считается
восьмиричной, если  она начинается с 0 (цифры ноль), и десятичной в
противном случае.  Цифры 8  и 9  не являются восьмиричными цифрами.
Последовательность  цифр,   которой     предшествует  0х   или  0Х,
воспринимается как  шестнадцатеричное  целое.  В  шестнадцатеричные
цифры входят буквы от а или А до f или F, имеющие значения от 10 до
15. Десятичная  константа, значение  которой  превышает  наибольшее
машинное целое  со знаком, считается длинной (long); восьмеричная и
шестнадцатеричная константа,  значение которой превышает наибольшее
машинное целое со знаком, считается long; в остальных случаях целые
константы считаются int.

     2.4.2 Явно заданные длинные константы

  Десятичная,  восьмиричная  или  шестнадцатиричная  константа,  за
которой непосредственно  стоит l  (латинская буква  "эль")  или  L,
считается длинной константой.

     2.4.3 Символьные константы

  Символьная константа состоит из символа, заключенного в одиночные
кавычки  (апострофы),  как,  например,  'х'.  Значением  символьной
константы является  численное значение  символа в  машинном  наборе
символпв (алфавите).  Символьные константы  счиуаются данныии  типа
int.
  Некото°ыҐ ееграфичҐсКие  симво«ы, одиночная  кавычка Ґ0и обратная
косая \,  могут  быть  предхтавлены  в  соответствие  со  следующеi
таслицей esCape-последовательнортей:

   символ новой строки  $           NL(LF)       0\n
   горшзонтальнАя табіляция         NT          ! \t

       $            $        ­ стр 255 -	

   вертикальная табуляция       "   VP  !         \v   жозврат на шаг!     h     (      B[            \b
   возарат каретки      (      Ў    CR     0 $    r
   перевод формата                  FF(     !     \f
   обратная косая   (               \      (      \\
   одипочная кавычка (апостроф)     ' 0           \'
   мабор битов             !        1ddd    "     \ddd
   нрбор битов          `           0xddd         \xddd

  Escape-последовательность \dd$  состоит  из  обpатной  косоi,  за
котороб следуют  1, 2  или 3  восьмеричных цифры, задающие значениеЌ
требуемого символа.  Специальным слічаем  такой консрукции является-
\0!(mе  следует ни  одной  цифры),  жадающая  жустой  сиько«  NULL.
Escape-последовательность  \xddd  уостоит  из  обратноi  коqой,  зф
которой сыедуют  1,  2$ или  3  шестнадцатаричных  цифаы,  задаюыие
пначение требуемого  симтола.  Если  следующий  за  обрат­ойa косой
символ не  является  одним  из  перечисленн{х,  то  обратная  косая
игнорируется.

     2.4.4 Константы с плавающхй точкои

  Константа с  плавающей тозкой  состоив из целой части, десятичной
точки, мрнтиссы,  е илШ Е и`целого поиазателя степени (возможно, но
не обязателэно,  со знаком).  Целая часть и иантисса обе состоят из
последовательности цифр. Целая чбсть или мантисса (но нз обе срвзу)
может быть  опущена; или  десятичная точка, или е(Е) вместе с целыь
пжказателем степенш  (но не  ойе  части  однжвременно)  можбт  быть
опущена. Консъанта"с плавающей точкой имеет тип double.

     2/4.5 Перечислимые константы

 !Имена,  опиСанныд   как "перечислители,   (см.   #8.5i   являются	
ккнстантаМи типа int.

     2.4.6 Описанные константы

  Объект  (#5)   йюбого  типа  может  быть  определен  как  имеющий
постоянное чпазение  во всей  обласТи видимости (#5.1) его имени. В
случае указатзлей  для  д®стижения  эрого  используется  декларатор
:const; для  объектов, не  яглчющихся    указателями, (использіется
опксатель const (#8.2).

  (  2.5 Строки

 0Строка есть  побледовательность символов,  заключеепая(в  двойные
кбвычки:`"...".  Строка имеет  тип "масщив симгойов" и jласр0памяти
static (см. #4 ниже), она инициализируецся заДанными символами/ Все
строки, даже  если они  записаны  одинаково,  различны.  Компилятор
располагает в  конце каждой  строки нулеВой (пустой) аайт \0 с тем,
чтобы сканируюшая  строку прогРамма! мог«а найти ее конец. В строке
перед сиLволом двойной катычЄи " обяэательно должен стоять \; кроме

      0                      - стр 256 -

того, мкгут  испол|зоваться те 0же  escape-последовательности,  что
были описаны  для символьных  констант+ И,  mаконец, 0символ  йовой
строки может  появляться тольКо 'сразу я®сле  \; тогда  оба,=    и
символ"новой(строки,- игнорисуюъся.

     2.6 ХаРктеристики аппарауного обеспечения
       В  нижеследующей  таблице  собрвны  некоторые  харктерhстики
аппаратного обеспечения, разлкчающиеся$от машины к машинеn

_______________________________]____________________________
|           TEC VAX-11!Motorola 68000 IBM 370     AT&T 3B   |
|            ASCII      $ ASC	I  (    EBCDIC       ASCII    |
|_________W_______________________________________________|
| char     |    8 aит  |   8 бит   |  8 бит    |   8 бhт    |
| int      |   32 бит  | `16 бит   | 32 гиц 0  |  16 бит    l
| shopt    |   16 бит  |" 16 бит   | 16 бит    |  16 бит   `|
| long     |   32 бит! |  32 бит   | 3: бит    |  32 бйт    |
| float    |   32 бит  |  32 биц   } 32 бит    |  32 бит    |
| double   |   64 йит  |  64 qит   | 64 еит    | `64 бит "  |
| указатель|   32 бит  |  32 бит   | 24 бит    |  32 бит   `|
| диапазпн |  $        |       (   |        "  |            |
|    &loat | +_10E+_38 | +_10E+_38 | +_10E+_76 | +_10E+_38  |
l диапазон"|     `  0  |           |  (        |            |
|   doubl% | +_10E+_38 | k_90E+_38 | +_q0E+_76 | +_10E+_308 }| тhп chaR | "знаковый | без знака | без знака | без знака  |
| тиo поля |  знаковый l без знака ~ без знака | беп"знака  |
| порядок  |  справа   | слева     |  слева    | слева     `|
| "полей   |   налево  ~  направо  x   направо |  ниправо   |
|__________|___________|___________|___________|__S________|

                8   3. ЗАНИСЬ СИНТАКСИСА

  По используемым  в  д нном  рсководстве  синтаксичеслим "лравилам
записи синтаксические  категории выде«яются  курсивом а литеральные
слова  и$  символы  шаифтом   постоянной  ширины*.   Альтешнативные
кбтеуории   записыгаются    на   разных   строках.   Необязацельный
терминальный  или   нетерминальный0  ( символ  обожначается  нижним
индексом                       "opt",            так            что

  { выражение opt }

указывает  на   необязательность (выражению   в  фигурйых  скобках.
Синтаксис кратко!изложен в #14.

____________________
! * #!!  выделить "постоянной  ширины" шрифтом,  коrорым печатаются
программы и английщкие слова!!!

       `                   ( -$стр 257 -

                      0<. ИМЕНА И ТИПЯ

  Имя обозначает(денотирует)$ объект, функцию,  тип,  значение  или
метку.  Имя   вводится  в   програмне  описанием 0(#8).  Имя  ¬ожет
использоваться только  внутри области  текста программы, называбмойего  оелаqтью   видимости.  Имя   имеет   тип,   определяющий   его
исп®льзование. Объект  m это  область памяти.  Объект  имеет  класс
памяуи, определяющий его время жизни. Смысл значения,$обнаруженного
в объелте,  опреддляется типом имени< использnванного мл доступа к
нему.

     4.1 Область вкдимости

  Есть четыре вида обласІей видимости: локальная. файл, программа и
класс.
  Локальная: Имя, опксанное в Ўлоке (#9*2), локально в этом блоке и
     можец использоваться  только в  нем посые  места`описания "и в
     охватываемых" блоках.  ИСключение  составлчют  метки  (#9n12),
     которые могут  использоватэся в любом местб фsнкции, в которой
     они  (описаны.    Имена    формальных    параметров!   ф»нкцhи
     рассматриваются так,  как если  бы они  были олисаны  в  самом
     в¬ешнхм блоке этой функюии.
  Файл: Имя,  описанное вне  любого блока (#9.2) или класуа (#8&5),J   ` может иСпользовбться  в фай«е,  где оно  описано, после  места
  (  описаниї.
  Класс:  Имя   чпена  класса  локально  для  его (класса  и  может
     иСпользов ться только  в функции  члене этого!классб (#8.5.2),
     после примененной  к объекту  его класса (3w.1) операции . или
     после пшимененной  к указателю  на объект  его  класса  (#7.1)
     опбрации ->.  На статические  члены класса  (#8.5.1) и функции
     wлены можно также ссылаться с помощью операции :: там, где имя   " их класса  нахожктся в  областЁ  ви¤имосци.  Клбсс," описанныб
     внутри класса  (#8.5.15),  не  считается  членом,  и  его  имя
     Їринадлежит ОхватывающеЙ области видммости.
Имя может  быть скрыто` посредртвом явного описа­ия тово жЕ имени в
блоке или  классе. Имя  в блокб или классе может быть0скрыІо тогько
именем,  описанным   в  охватываемом   блоке  или` илассе.  Скрытое
непокальное имя  также  может  испокьзоварься,  когдр  его  область
тидимостм указана  опесацшей :: (Ў7.1). Имя класса(!скрытое именем,которое не  является именди  типа, все  равно можҐт использоваІься,Ќесли  перед   ним  стоит   class,0 struct  или  µnimn  (#8.2).  Имя
перечисления enum, скрыцое именем, которое пе являет±я именем типа,
все равно может испкльзоваться, если перед$ним стоит enum (#8.2).

     4.2 Nпрнделения

  Описание (#8)  эвляется определением, за искл~чзнием тех случаев,
кюгда оно  описывает функци,  не"задавая  тела фумкции (#10), когжа
оно содержит спецификаткр extern (1) и в нем нет инициализатора или
тела функции, или Когда оно чвляется описа­ием класса #.8).

                             - сцр 258 -

   0`4.3 Компоновка

  Имя в  файловой области  видимости, не опиханное явно квк уtatic,
является общим  для каждого  файла!многофайловой`программы. Ваковым
же является имы"функции. О таких имЕнах гокорится- что они внешнме.
Каждое описание  внешнеГо имееи $в програмие  отнжситбя к  тому  же
объекту (#5(,  функции (38.7),  классу (#8.5), перечислению (#8.10)или значению перечислителя (#8.10).
  Типы, хпецифицирожанные  то всех  описаниях$внешнего имени должны
быть  ифентичны.   М®жет  быть   большз  одного  определения  типа,
перечисйения,(inline-функции  (#8.1) или несоставного const (#8."),
при условии, что определения(шдентичны, пояляют±я в разных файлах и
вбе инициализаторы являются константными выражениями (#12). Во всех
мсъальных случаях  фолжно быть  ровно одно определенше для внешнего
имени в программе.
  Реализация   можбт $  потребовать,   чтжбы    сnставное    const,
использованное т м,  где не  всречено никакого  опреДеления  const,	
должно быть  явно описано $dxtern и  иметь в  программе ровно  одно
определениеn Это же ограничение может0налагаць±я на inlkne-функции.

     4.4 @Классы памяти

  Есть джа"описываемых клащса памяти: автпматический и ст тический.

  Автоматическше объекты локальны дйя каждого вызова блпка и
  сбрасыва~тся по выходе из него.-

  Статйческие объекты сущестгуют и сохраняют свое значение в
  течение выполнения ж±ей програмы.

  Некоторые объекцы $не связаны  с именами  и их времена жизни явно
управляются операторами  new и delete ; см. #7.2 к #9.14

            $            $   - стр 259 -

     4.5 Орновные типы

  Объекты, описанныЕ  как символы  (char), достаточны  для хшанееия
любого элеменrа  машинного набора  символов, и  если  принадлежащий
этому  наборі  символ  храпится  в  символьной  переменной,  то  ее
гначение равно целому коду этого символА.
  В настоящий  момент имеются  целыб треэ размеров, описываемые как
short int,   int  и  loоg  inu.  Более  длинные  целые  (lgng  int)
предоставляют не  меньше памяти,  чем йолее  короткие целые  (sjort
int!, но  при реализации  или длинные,  или короткие,  или и  те  и
другие мжгут  стать эквивалентными  обычным целым.  "Обычные" целые
имеют  есвественный  размерl  задаваеиый  архитектурой 0цднтрвлэной
мащины; ортальные  размеры  делаются  такими,  утобы  они  отвечали
специальным потсебностям.
  Каждое$перечисление (#ё.9) является набором именованных коmстант.
Свойства(enum идентичны свойствам int.
  Целые без  знака, описываемые  как unsiwned, подчиняются правилам
 рифметики по модулю 2n, где n - число бит в ие представйении.
  Числа с  плаврющей точJой  одинарной (float)  и двойной  (double)
точностк в некоторых машинных реализачиэх могут быть синониьами.M
  Поскольку  объeкты!  перечисленных  выше   типов   вполне ( можно
интерпретировать  как  числа,  мы  будем  говоpить  о  них" как  об
арифьетическмх типах.  Типы   char, int  всех размеров и enuM будут
собирательно называться  целыми типами.  Типы  float и double будут
собириІельно напываться плавающими типами.
  Тип дрэных  void (пусвой)  определяет пустое "множестко значеэий.
Значение (несуществующее)  объекра void нельзя"использовать никаким
образом не  могут применяться ни явное, ни неявное прежбразования.
Побкольку  пуст®е  выражение  обозначает  несгществующее  значение,
такое тыражение  такое выражение  может использовавься  только  как
оператор выражееие  (#.1) али  как левый  опеpанд  в  выражении  с
запятой (#7.15). Выражение может явно преобразовываться к тшяу void
(#7.2).

     4.4 Производные ципы

  Кроме  основных  арифметических  типов "концептуалюно  существует
бесконечно`много  производных типоб,  сконструирожанных из основных
типов следчощим образом:

   "  (                      - стр 260 -
  массивы объектов данного типа;

  функции, полгчающие аргументы данного типа и возвращающие объектыM
  данного типа;
M
  указатели на объекты  данного типа;

 (ссылки на объекры  данного типа;
Ќ
  константы, являющиеся значениями данного типа;

  классы, содер¦ащие последовательность объектов "различпЫх типов,
  мнnжество функций для работы с этима объектами и набор
  огр ничений на доступ к эти¬ объелтам и фуНкциям;
  структуры, являющиеся клбссами без ограничений досттпа;

  объединения( являюшиеся структурами, которые могут в разное время
  содержать объекты разных типов.

В целом0 эти способы  конструирования  объектов  могут  пвЁменяться
рекурсивно.
Обюект тип`` цoid*  (указатель  на  void)  можно  использовать  для
указания эа объекты неизвестного ткпа.

                5.$ ОБЪЕКТЫ И LVALUE(АДРЕСА)

  Объект  есть   область  памяти;lvalue   (адрес)  есть  выражение,
ссыл ющееся   на объект. Очевидный пример адрхСного выразения - имя
объекта. Есть операции, дающие адресные выражения: например, если Е
- выражение типа указатель, то *Е - адресное выражениб, ссылвющхес
на объект,  на"Єюторый  указывает Е.  Термин "lvalue" яроиСходит из
выражхния пристаиваншя  Е1=Е2, в  котором левый 0операнд Е1  должен
быть адресным "(value) выраждниео.  Ниже`при    обсуждении  каждогооператора  указывается,   трнбует     ли  он  адресные  операнды  и
жозвращает ли он адресное значение.

    !           0    6.  ПРЕОБРАЗОВАНИЯ

  Определенные  операции"  могыт  в  зависИмости  от  их  операндов
вызывать преобразование значееия ®периндд от одного т па к другому.
В !этой " части "объясняется,   каков  оЖидаемый   резсльтат  таких
преобразований> В  #6.6 содержится краткое описдние преоaразований,
требуемых наиболее  стандартными операциями;  оно будет допол­яться
пю мере  надобноски в процессе обсуждения каждой операции. В 38.5.6
описываются преобразования, определяемые пользователем.

     6.1 Символы и целые

  Символ  или  короткое  целое  могут  исполмзоваться,  если  моцет
йспользоваться0целоe.  Во всех  случаях  значение  преобразуется $к
целому. Преобразование  короткого целоло к длИнному всегда включает
в себя  знаковое расширение;  целыe являются  величинами со знаком.
Содержат  символы   знаковый  разряд   или  нет,  является  машинно

        (    0          (    - утр 261 -

зависимым; см.  #2.6. Более  явный тип   unsioned chaт ограничивает
измененше значения от 0 дп lашинйо зависимnго максимума.
 `В  маиинах,   где  символы   рвссматриваются $как0  имдющие  знак
(знаковые), уамволы  ьножества коди ASCII  эвпяются положительными.
Одн ко,   сиlвольнвя`   константа,   задаМн`я   ворьмеричной $esc-
последователфностью пкдверг ется знаковому °а±ширени~ и может стать
отрицательным числом; так наприиес, '\377' амеет значение -1.
  Когда длинное$ цзлое преобразУется  в короткое  или в  char,  оно
урезается влево; избыточные бЁты просто теряются.

     6.2 Float и double
Ќ
  Длэ выражений  float  могут  выпмлняться  действия  арифмецики  с
плав ющей точкой  одинарной точности.  Преобтазования между числрми
одиндрнмй и  двойной точности  выполняются н`столшко  оатематическш
коррбЄтно, наскnлюко позголяет аппаратура.

 !   6.3 Плавающие и целуе
Љ  Преобразования  плавающих   значений  в  интегральный  тип  имеет
склонность  быть   машинно  зависимым.   В  частности,  йаправыение
усечзния отрицательных  чисел различаеъся 0от нашины к$машине. Если
предпсцавляемого прострбнства для значения не хв@тахт( то результат
неопределен.
  Преобразование иптеГрального значения к плавающий тип выполняются
хорошо.  При   нехватКе  в   рппафатпюй  реализации  требуемых (бит
возникахт некоторая потеря точности.

     6.4 Указатели и целые

  Выражение целого  типи ьожно прибавить к указателю или вычеСтьаизJнего; в  таком случае  пертый преобразуется,  каj  указывихтся $при
обсуждении операции сложения.
  Можно производить  вычитанйе mад  двумя` указателями  на  объекты
одного типа;  в этом  сйучде результат п°еобразуется к типу int или
long в зависимости nт машины; см. #7.4.

     6.5 Unsigned

  Віегда лри  сочетании целого  без знака и обычного целого обычное
цекоз  преобр зуется  к$ типу  unsigned    и  резукьтат  имеет  тип
unsigned. Значением  явлюҐтся наhменьшее  целое гез  знака,  равное
целому со знаком (mod 2**(размзр слова)) (т.е. по модулю 2**(р змер
слова)). В дополнительном двоично¬ представлбнии это нреобразование
является  пустым,   и  никаких   реальных  изменений   в   двоичном
прҐдставлении не происходит.
  При преобразовании целозо без знака0в длинное значение результата
численно совпадает  со значением   целого без знака. Таким об°азом,
преобразование сводится к дополнению нулями слева.

                 0           - стр 262 -

     7.6 Арифметические преобразования

  Большое количество  операций вызывают  преобразования и  дают тип
результата одинаковым  образом.  Эъот  стереотип  будет  называться
"меычным грифмевичебким преобразованиeм".Љ
  Во-первых,0любые операнды типа chбr, unsigned char или short
  преобразуются к типу int.

  Далее, если один из операндов имеет тип double, то другой
  преобразуется к типу double и тот же тип имеет результат.

  Иначе, если один из!операндов имеет типdunsigned long$ то другой
  преобразуется к типу unsigned long и таков же тип результата.

  Иначе, если один и§ операндов имеет тип long, тю другой
  преобразуется к типу long и таков же тип результата.

  Иначе, если одйн из операндов имеет тип unsigned, то другой
  преобразуется к типу unsigned и таков же тип результара.

0 Иначе оба операнда должны иметь тип int и таков же тип
  результата.

     6.7 Преобразования указателей

  Везде,    где    указатели    присваиваются,    инициализируются,
сравниваются и т.д. могут выполняться следующие преобразоввния.

  Константа 0 может преобразовывиться в указатель, и гарбнтируется,
  что это значение породит указатель, отличный от указателя на
  любой объевт.

  Указатель любого типа может преобразовыкдrься в void*.

  Указатель на класс может нреобразовываться в указатель на
  открытый базовый класс этого класса; см. #8.5.3.

  Ммя вектора может преойтазовываться в указатель на его Первый
  элеlент.

  Иеентификатор, описаеный как "функция, возвращаьщая ...", всегда,
  Когда он не!используется в ппзиции имени функции в вызове,
  преобразуется в "указатель на функцию, возвращающую *..".

                             - стр 263 )

     6.8 Преобразования ссылок

  Везде, где  инициализируются ссылки¬ может выполнятЬся сследующее
преобраз®вание.

 0Ссылка на Єласс может преобразовываться в ссылку на открытый
  базовый класс этогж класса; см. #8.6.3.

                        7. ВЫРАЖЕНИЯ
*  Приоритет операций  в выраженях  такой"же,  как и порядок главных
подразделов в  этом раgдхле,  наибольший приоритет  у oервого.  Так
например, выражения,  о которых говорится как об операндах опеаацйи
+ (#7.4) $- это  те выражения,  которые определены  в    ##7.1-7.4.
Внутри каждого  подразфела операции  имеют одинаковый  приоритет. В
каждом подразееле  для рассматриваемых в нем операций  определяется
их левая  или правая ассоциативность ,порядок обработки операндов).
Приоритет и  ассоциативность всех операций скбран вместе в описании
грамматики в #14.	
 0В остальных( случаяс порядок  вычисления  выражения  неопределен.
Точнее, компилятор  волен вычислять  подвыражения  в  том  порядке,
который он  считает более  эффективным,  даже  если    подвыражения
вызывают побочные  эффекты. Порядок возникновения побочных эффектов
неопределен.  Выражения,   включающие  в   себя   коммутативные   и
асссоциативные операции (*, +,  &, |, ^), могут быть реорганизованы
произвольным  образом,   даже  при   наличии  скобок;  для  задания
определенного порядка  вычисления выражения необходимо использовать
явную временную переменную.
  Обработка  переполнения   и  контроль   деления  при   вычислении
выражения машинно  зависимы. В  большинстве существующих реализаций
C++ переполнение целого игнорируется; обработка деления на 0 и всех
исключительных ситуаций с числами с плавающей точкой различаются от
машины  к   машине  и  обычно  могут  регулироваться  библиотечными
функциями.
  Кроме стандартного  значения, описанного  в  #7.2-7.15,  операции
могут быть перегружены*, то есть, могут быть заданы их значения для
случая их  применения к  $типам,  определяемым  пользователем;  см.
7.16.

     7.1 Основные выражения
  Основные выражения, тключающие в себя$.  -> ,   индексирование и
жызовы фунКций, группируются слева направо.
     список_выражений:
          выражение
          список_выражений , выражение
     id:
          идентифиъатор
___________________Я
  * Этот  термин применяеrся  для описания  использованиы  в  языке
одной и  той же  лексемы для  пбознач§ниэ различных  процедур;  вид
процедурл  выбирается   компилятором  на  основании  дополнительной
информации в`виде числа и типа аргументов и т.п.

                      (      - стр 264 -
J          имя_функции_операции
          typedef-имя               ::                идентификатор
          typedef-имя :: имя_функции_опербции
     первичное_выражхние:
          idZ          ::                                          идентификатор
 !        константа
          строка
          this
          (                       выражение  $                    )
          первичное_выражениҐ             $  [      выражение     ]
        ` первичное_выражение        (   список_выражений   opt   )
          яервичное_выраже­ие                     .        (     id
     `    первичное_выражнние   -> yd
  Идентификатжр есть  первичное  выражение,  причем  соответственно
описбнное  (#8).   Имя_функции_операжии   есть ` идентификатор   со
спецшальным значением; см. #'.16$и #8.5.1.
  Операция ::, за которой следует идентификатор из файловой nбласти
вадимости. есть то же, что и идентификатор. Это позволяет ссылаться
на объект даже в том случае, когда его идентификатмр скрыт (#4.1).
  Typedef-имя (#8.8)  , за  которым слееует  ::, после чего следует
идентификатор, является  первичным выражением.  Typedef-имя  должно
обозначать класс  (#8.59, и  идентификатор должен  обозначвть  члеm
этоуо кгасса.  Его тип  специфицируется  описанием  идентификатора.
Typedef-имя может  быть скрыто  именеД, котороб  нЎ является именем
типа. В  этом случае typedef-имя все равно может быть найдено и его
можно использовать.
  Константа является  первичным выражением. Ее тип должен быть int,
long или double в зависимости от ее формы.

                             - стр 265 -

  Строка является первичным выражением. Ее тип - "массив символов".
Обычно он  сразу же  преобразуется в  указатель на ее первый символ
(#6.7).
  Ключевое слово this  является локальной переменной в теле функции
члена (см.  #8.5) . Оно является указателем на объект, для которого
функция была вызвана.
  Выражение,  заключенное  в  круглые  скобки,  является  первичным
выражением, чей  тип и  значение те  же, что  и у  незаключенного в
скобки  выражения.   Наличие  скобок  не  влияет  на  то,  является
выражение lvalue или нет.
  Первичное выражение,  за которым  следует выражение  в квадратных
скобках, является первичным выражением. Интуитивный смысл - индекс.
Обычно  первичное   выражение  имеет   тип  "указатель   на   ...",
индексирующее выражение  имеет тип int и тип результата есть "...".
Выражение Е1[Е2] адeнтично (по определению) выразению *((E1)+(E2)),
Все тонкие места< неоаходимые для понимания этой записи, Содержатся
b этом  разделе вместе  с  обсуждением  в  ##  7.,    7.2  и  7.4,
соответственно, идентификаторов, * и + ; ниже,  в #8.4.2 приводятся
следствия из этого.
  Възов функции  является песвичным  выражением, за Єоторщм следуют
скобки, содержащие  список (возможно, (пустой) pазделенных папятыми
выражений,  составляющих  "фактическЁе   параметры   для   функции.
ПЕрвичпое кыражение  должно иметь  тип "функциЯ,  возвращающая ..."
или "указатель  на функцию,  возвращающую ...",  и результат вызова
функции имеет тип "...".
  Каждый   формальный (  прраьетр   инициализируется    фактическим
параметром (#8.6).  Выполняются стандартные (#6.6-8)0и определяемые
пользователем  преобразования   (#8.5.6).  Функция  может  изме­ять
значенкя своих  формалюных параметров,  но эти  изменения не  дозут
повлиять на значения фактических  параметров за исключднием сгучая,
когда формальный параметр имеет ссылочнлй тип.
! Функция может  быть описана  как  получающая  меньше "или  большe
параметров, чем  специфицировано в  описании функции (#8.4)> Каждый
фактический параметр  типа( float,  для  которого  нет  формального
параметаа, преобразуются  к(типу   doub,e;  и,  как  обычно,  имена
массивов преобразуюrся  к уЄазателям. Порядок вычислеНия параметров
не определен языком; имейте в виду различия между компиляторами.
  Допустимы рекурсивные вызовы лябых"фуноций.
  Пергичное выражение,  после  кото°ого  стоит  точка,  за  котОрой
следует идентификатор (или идентификатоф, уточненный typedef-именем
с помощью опера¶ии ::) является выражением. ПеРвое выражение должно
быть объектом  класса, а  идентификатор должен именовать члЕп этого
класса. Значением является именованный член объекта, и оно является
адресным,  если   первое  выражение   является  адресным.   Следует
отметить, что  "классовые объекты" могут быть струвтурами (#8.5.12)
или объединениями (#8.5.13).
  Первичное выражение,  после которого  стоит  стрелка  ( -> ),  за
которой  следует   идентификатор  (или   идентификатор,  уточненныйJtypedef-именем с  помощью операцик ::) является выражением.  Первое
выражение должно  быть указателем на объект класса, а идентификатор
долЖен именювать  член этого  класса.  ЗнаЧение  являевся  адфесом,
ссылающимся  на  именованный  член  класса,  на  который  указывает
указательное выражение.  Так, выражение  E1->MOS  есть то же, что и
(*E1	.MOS. Классъ$обсуждаются в #8.5.
  Если пзрвичное  выражение дает  значение типр  "указатекь на ..."
(см.  #8.0     and   #8.6.3), !значением   выражения  был   объект,

                             - стр 266`-

nбозначаемый ссылкой.  Ссылку можно  считать  именем  объекта»  см>
#8.>.3.

    07.2 Унарные операции

  Выражения с унарными nперациями группируют справа налево2
     унарноевыражение:
          унарная_операция        `            (          выражение
          выражение                                              ++
          выражение                                              --
          sizeof           0                              выражение
          sizeof             ,       "      имя_типа!             )
  !       (            имя_типа             )             вЫражемие
          проqтое_имя_типа       (        список_выражений  $     )
  "       new               имя_типа       инициализатор        opt
          new      0       (       `    (` имя_типа               )
          delete                                          выражбние
          delete [ выражение ] выражение
     унррнап_операция:     "             одна                    из
$         *  &  -  !  ~  ++  -m
  Унарная операция * озеачает косвенное обращение: выражение должно
быть указателем  и резчльтатом будет lvalue, ссылающееся на объект,
на который указывает выражение. Если выражение имеет тип "указатель
на ...", то тип результата естф "...".
  Результатом унарной  олерации & "является указатель на объект, на
которлй  ссылается   операнд.  Операнд  должен  быть  lvalue.  Если
выражение имеет  тип "...",  то тип  результата есть  "указатель на
...".
  Результатом унарной  операции +  является  значение  ее  операнда
после выполнения  обычных  арифметических  преобразований.  Операнд
должен быть арифметического типа.
  Результатом унарной операции - является отрицательное значение ее
операнда. Операнд  должен  иметь  целый  тип.  Выполняются  обычные
арифметические преобразования.  Отрицательое  значение  беззнаковой
величины вычислятся посредством вычитания ее значения из  2n, где n
-число битов в целом типа int.
  Результатом операции  логического отрицания  ! является  1,  если
значение операнда  0, и  0, если  значение операнда не 0. Результат
имеет тип  int. Применима  к  любому  арифметическому  типу  или  к
указателям.
  Операция  ~   дает  дополнение   значения  операнда  до  единицы.
Выполняются   обычные арифметические преобразования. Операнд должен
иметь интегральный тип.

     7.2.1 Увеличение и Уменьшение

  Операнд прдфиксного  ++ получает  прирАщение. Операнд джлжен быть
адресным .  Значением является  новое значение  операнда, но оно не
амреснме. Выражение  ++x эквивалентно  x+=1.  По  поўоду  данных  о
oреобразованиях  см.   обсуждение  операций   сложения   (#7.4)   и
присваИвания (#7.14).
  Операнд префиксного -- уменьшается амалогично действию префиксной
операции ++.

              (              - стр 267 -

  Значение, получаемое  при  исполфзовапии  постфиксного  ++,  есть
значенье операнда.  Опeранд должен  быть адресным.  После того, как
результдт отмечен,  объект увеличивается так же, как и в префиксной
операции ++."Тип результата тот же, что и тип операнда.
  Значение,    получаемое     при    использовании      постфиксной
 --, есть  значение операнда.  Операнд должен  быть адресныэ. После
того, как  Резуйьтат отмечен,  объект увеличивается так`же, кАк и в
паефиксной операции ++. Тип результдта тот же, что и тип операнда.

     7.2.2 Sizeof

  Операция  sizeof   дает  размер   операнда  в  байтах.  (Байт  не
определяется языком  иначе, чем  через значение  sizeof. Однако, во
всех существующих  реализациях байт  есть пространтсво, необходимое
для хранения  char.) При  применении к массиву результатом является
полное количество байтов в массиве. Размер определяется из описаний
объектов, входящих в выражение. Семантически это выражение является
беззнаковой константой и может быть использовано в любом месте, где
требуется константа.
  Операцию sizeof  можно также  применять к  заключенному в  скобки
имени типа.  В этом  случае она  дает  размер,  в  байтах,  объекта
указанного типа.

     7.2.3 Явное Преобразование Типа

  Простое_имя_типа  (#8.2),  возможно,  заключенное  в  скобки,  за
которым идет  заключенное в скобки выражение (или список_выражений,
если тип  является  классом  с  соответствующим  образом  описанным
конструктором #8.5.5)  влечет преобразование  значения выражения  в
названный тип.  Чтобы записать  преобразование в  тип,  не  имеющий
простого имени,  имя_типа (#8.7)  должно быть  заключено в$ скобки.
Если имя  типа заключено  в скобки,  выражение заключатю  в  скобки
необязате«ьно. Такая запись ­аЗывается приведением к типу.
  Указатель может  быть явно  преобразован к люб®му из интегральных
випов, достаточно  по величине для его хранения. То, какой из int и
long требуется(  является машинно  зависимым. Отобразующаї  функция
также является  машинно зависимой,  но предполагается,  что nна  не
содержит сюрпризов  для  того,  кто  знает  струкцуру  адресации  в
машинe. Подробности дкя некоторых конкретных машин были приведены в
#2.6.
$ Объект  интегрального   типа  мюжет   быть  явно  преобразован  в
укагатель. Отображающая функция всегда превращает целое, полученное
из указателя,  обратно в  тот же  указатель, но в жстальных улучаясJявляется машинно зависимой.
  Ук затель на один тип может быть явно преобразован в указатель на
другой тип.  Исяользованиз полученнкго в pезультАте указателя может
привести  к   исключительноi  ситуации  !адресации,  если  исходный
указатель $не   указывает  на   объект,   соответствующим`  образом
выфавненный  в  памяти.  ГаРантируется,  что  указатель  на! объект
данного размера  может быть  прекбразован  в! указатель  на  объект
меньшеЈо размера  и обратно  без изменений.  Различные машины могут
различаться по  числу бит в указателях и тшебованиям к выравниванию
объектов. СоСтавные объекты выравниваятся по самой строгой границе,
требуемой каким-либо из его составляющих.

       "(                    - стт 068 -

  Объект может  преобразовываться в  объект"класса  только если был
описан  соответствующий  конструктор  или  операция  преобразования
(#8.5.6).
  Объект может  явно преобразовываться  в ссылочный  тип  &X,  если
указатель на эъот кбъект может явно преобразовываться в X*.

    `7.2.4 Свобюдная Память

  Операция new создахт объект( типа имя_типа (см. #8.7), к которому
он применен.  Вреья жизни  объекта, созданного  с пооощью  new,! не
ограничено областью  видимости, в  которой он  создан. Операция new
возвращает указатель  на созданный ей объект. Когда объект является
массивом, возвращается указаетль на его первый элемент. Например, и
new   int и  new int[10]  возвращают int*.  Для объектов  некоторых
классов надо  предоставлять инициализатор  (#8.6.2).  Операция  new
(#7.2) для получения памяти вызывает функцию

  void* operator new (long);

Параметр   задает    требуемое   число    байтов.   Память    будет
инициализирована. Если  operator new()  не  может  найти  требуемое
количество памяти, то она возвращает ноль.
  Операция delete  уничтожает объект,  созданный операцией  new. Ее
результат является  void. Операнд  delete должен  быть  указателем,
возвращенным new.  Результат применения delete к указателю, который
не был получен с помощью операции new. Однако уничтожение с помощью
delete указателя со значением ноль безвредно.
  Чтобы  освободить  указанную  память,  операция  delete  вызывает
функцию

   void operator delete (void*);

В форме

  delete [ выражение ] выражение

второй параметр  указывает на  вектор, а  первое  выражение  задает
число элементов  этого вектора.  Задание числа  элементов  является
избыточным за  исключением случаев  уничтожения векторов  некоторых
классов; см. #8.5.8.

     7.3 Мультипликативные операции

  Мультипликативные операции  *,   / и  % группируют слева направо.
Выполняются обычные арифметические преобразования.

  мультипликативное_выражение:
      выражение * выражение
      выражение  /  выражение
      выражение  % выражение

  Бинарная операция * определяет умножение. Операция * ассоциативна
и выражения  с несколькими  умножениями на  одном уровне могут быть
реорганизованы компилятором.

                             - стр 269 -

  Бинарная операция / определяет деление. При делении положительных
целых округление  осуществляется в сторону 0, но если какой-либо из
операндов  отрицателен,   то  форма   округления  является  машинно
зависимой.  На  всех  машинах,  охватываемых  данным  руководством,
остаток имеет  тот же  знак, что  и делимое.  Всегда истиинно,  что
(a/b)*b + a%b равно  a (если b не 0).
  Бинарная операция  % дает остаток от деления первого выражения на
второе. Выполняются обычные арифметические преобразования. Операнды
не должны быть числами с плавающей точкой.

     7.4 Аддитивные операции

  Аддитивные операции  + и  - группируют слева направо. Выполняюься
обычные  арифметические   преобразования.  Каждая   операция  имеет
некоторые дополнительные возможности, связанные с типами.

  аддитивное_выражение:
      выражение + выражение
      выражение  -  выражение

  Результатом  операции   +   является   сумма   операндов.   Можно
суммировать указатель  на объект  массива и  значение целого  типа.
Последнее во всех случаях преобразуется к смещению адреса с помощью
умножения его  на длину  объекта, на  который указывает  указатель.
Результатом  является  указатель  того  же  типа,  что  и  исходный
указатель,  уазывающий   на  другой   объект  того   же  массива  и
соответствующим образом  смещенный от первоначального объекта. Так,
если P  есть указатель  на объект  массива, то  выражение P+1  есть
указатель на следующий объект массива.
  Никакие другие комбинации типов для указателей не допустимы.
  Операция +  ассоциативна и выражение с несколькими умножениями на
одном уровне может быть реорганизовано компилятором.
  Результатом операции  - является  разность операндов. Выполняюься
обычные арифметические  преобразования. Кроме того, значение любого
целого  типа   может  вычитаться   из  указателя,   в  этом  случае
применяются те же преобразования, что и к сложению.
  Если вычитаются  указатели на  объекты  одного типа, то результат
преобразуется (посредством  деления на  длину  объекта)  к  целому,
представляющему  собой   число   объектов,   разделяющих   объекты,
указанные указателями. В засисимости от машины результирующее целое
может быть  или типа  int, или  типа long; см. #2.6. Вообще говоря,
это преобразование  будет давать неопределенный результат кроме тех
случаев, когда  указатели  указывают  на  объекты  одного  массива,
поскольку  указатели,   даже  на   объекты  одинакового   типа,  не
обязательно различаются на величину, кратную длине объекта.

     7.5 Операции сдвига

  Операции сдвига  << и  >> группируют слева направо. Обе выполняют
одно обычное  арифметическое преобразование  над своими операндами,
каждый из  которых должен  быть целым. В этом случае правый операнд
преобразуется к  типу int;  тип результата совпадает с типом левого
операнда. Результат  неопределен, если  правый операнд  отрицателен
или больше или равен длине объекта в битах.

                             - стр 270 -

     сдвиговое_выражение:
          выражение                  <<                   выражение
          выражение >> выражение
  Значением Е1  << Е2  является  Е1  (рассматриваемое  как  битовое
представление), сдвинутое  влево на  Е2 битов;  освободившиеся биты
заполняются нулями.  Значением Е1  >> Е2  является Е1  ,  сдвинутое
вправо на  Е2 битовых  позиций.  Гарантируется,  что  сдвиг  вправо
является логическим (заполнение нулями), если Е1 является unsigned;
в противном  случае он может быть арифметичевким (заполнение копией
знакового бита).

     7.6 Операции отношения

  Операции отношения  (сравнения) группируют слева направо, но этот
факт не очень-то полезен: a < b < c не означает то, чем кажется.
     выражение_отношения:
          выражение                   <                   выражение
          выражение                   >                   выражение
          выражение                  <=                   выражение
          выражение >= выражение
  Операции < (меньше чем), > (больше чем), <= и >= все дают 0, если
заданное соотношение  ложно, и  1, если оно истинно. Тип результата
int.  Выполняются   обычные  арифметические  преобразования.  Могут
сравниваться два  указателя; результат  зависит  от  относительного
положения объектов,  на которые  указывают  указатели,  в  адресном
пространстве. Сравнение указателей переносимо только если указатели
указывают на объекты одного массива.

     7.7 Операции равенства

     выражение_равенства:
          выражение                   ==                  выражение
          выражение  !=  выражение
  Операции ==  и !=  в точности  аналогичны операциям  сравнения за
исключением их  низкого приоритета. (Так, a
7.8 Операция побитовое И

     И-выражение:   выражение & выражение
  Операция  &   ассоциативна,  и  выражения,  содержащие  &,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом является побитовая функция И операндов.
Операция применяется только к целым операндам.

     7.9 Операция побитовое исключающее ИЛИ

     исключающее_ИЛИ_выражение:
          выражение ^ выражение
  Операция  ^   ассоциативна,  и  выражения,  содержащие  ^,  могут
реорганизовываться.     Выполняются      обычные     арифметические

                             - стр 271 -

преобразования; результатом  является побитовая функция исключающее
ИЛИ операндов. Операция применяется только к целым операндам.

     7.10 Операция побитовое включающее ИЛИ

     включающее_ИЛИ_выражение:
          выражение | выражение
  Операция  |   ассоциативна,  и  выражения,  содержащие  |,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом  является побитовая  функция включающее
ИЛИ операндов. Операция применяется только к целым операндам.

     7.11 Операция логическое И

     логическое_И_выражение:
          выражение && выражение
  Операция &&  группирует слева направо. Она возвращает 1, если оба
операнда ненулевые,  и 0  в противном  случае. В  противоположность
операции & операция  && гарантирует вычисление слева направо; более
того, второй операнд не вычисляется, если первый операнд есть 0.
  Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.

     7.12 Операция логическое ИЛИ

     логическое_ИЛИ_выражение:
          выражение || выражение
  Операция || группирует слева направо. Она возвращает 1, если хотя
бы один  из ее  операндов ненуелвой,  и 0  в  противном  случае.  В
противоположность операции  | операция  ||  гарантирует  вычисление
слева направо;  более того,  второй операнд  не  вычисляется,  если
первый операнд не есть 0.
  Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.

     7.13 Условная операция

     условное_выражение:
          выражение ? выражение : выражение
  Условная операция  группирует слева  направо. Вычисляется  первое
выражение, и  если оно  не  0,  то  результатом  является  значение
второго выражения,  в противном случае значение третьего выражения.
Если  это   возможно,   то   выполняются   обычные   арифметические
преобразования для приведения второго и третьего выражения к общему
типу. Если  это возможно,  то выполняются преобразования указателей
для  приведения   второго  и  третьего  выражения  к  общему  типу.
Вычисляется только одно из второго и третьего выражений.

                             - стр 272 -

     7.14 Операции присваивания

  Есть много  операций присваивания,  все группируют слева направо.
Все в  качестве левого  операнда требуют  lvalue, и  тип  выражения
присваивания тот  же, что  и у  его левого  операнда. Это lvalue не
может ссылаться  на константу (имя массива, имя функции или const).
Значением является  значение, хранящееся  в левом  операнде  просле
выполнения присваивания.

  выражение_присваивания:
      выражение  операция_присваивания  выражение

  операция_присваивания: одна из
      =  +=  -=  *=  /=  %=  >>=  <<=  &=  ~=  |=

  В простом  присваивании с  = значение  выражения  замещает  собой
значение объекта,  на который ссылается операнд в левой части. Если
оба  операнда   имеют  арифметический  тип,  то  при  подготовке  к
присваиванию правый  операнд  преобразуется  к  типу  левого.  Если
аргумент в  левой части  имеет указательный  тип, аргумент в правой
части должен  быть  того  же  типа  или  типа,  кторый  может  быть
преобразован к  нему, см.  #6.7. Оба  операнда могут быть объектами
одного класса.  Могут присваиваться  объекты некоторых  производных
классов; см. #8.5.3.
  Присваивание   объекту   типа   "указатель   на   ..."   выполнит
присваивание объекту, денотируемому ссылкой.
  Выполнение выражения  вида E1  op= E2  можно представить себе как
эквивалентное E1 = E1 op (E2); но E1 вычисляется только один раз. В
+= и  -= левый  операнд может  быть указателем,  и  в  этом  случае
(интегральный) правый  операнд преобразуется так, как объяснялось в
#7.4; все  правые операнды и не являющиеся указателями левые должны
иметь арифметический тип.

     7.15 Операция запятая

  запятая_выражение:
      выражение , выражение

  Пара выражений,  разделенных запятой,  вычисляется слева направо,
значение левого  выражения  теряется.  Тип  и  значение  результата
являются  типом   и  значением   правого  операнда.   Эта  операция
группирует  слева   направо.  В   контексте,  где   запятая   имеет
специальное значение,  как например в списке фактических параметров
функции  (#7.1)    и  в  списке  инициализаторов  (#8.6),  операция
запятая, как  она описана в этом разделе, может появляться только в
скобках; например,

  f (a,(t=3,t+2),c)

имеет три параметра, вторым из которых является значение 5.

                             - стр 273 -

     7.16 Перегруженные операции

  Большинство операций  может быть  перегружено, то  есть,  описано
так, чтобы  они получали  в качестве операндов объекты классов (см.
#8.5.11).  Изменить   приоритет  операций   невозможно.  Невозможно
изменить смысл  операций при  применении их к неклассовым объектам.
Предопределенный смысл операций = и & (унарной) при применении их к
объектам классов может быть изменен.
  Эквивалентность операций, применяемых к основным типам (например,
++a эквивалентно  a+=1), не  обязательно выполняется  для операций,
применяемых  к   классовым  типам.  Некоторые  операции,  например,
присваивание, в  случае применения  к основным типам требуют, чтобы
операнд был  lvalue; это  не требуется  для операций, описанных для
классовых типов.

     7.16.1 Унарные операции

  Унарная  операция,   префиксная  или   постфиксная,  может   быть
определена или  с помощью функции члена (см. #8.5.4), не получающей
параметров, или  с помощью  функции друга (см. #8.5.10), получающей
один параметр,  но не  двумя способами одновременно. Так, для любой
унарной  операции   @,  x@   и  @x   могут  интерпретироваться  как
x.операция@() или  операция@(x). При  перегрузке операций  ++ и  --
невозможно различить префиксное и постфиксное использование.

     7.16.2 Бинарные операции

  Бинарная операция  может быть  определена или  с помощью  функции
члена (см. #8.5.4), получающей один параметр, или с помощью функции
друга (см. #8.5.9), получающей два параметра, но не двумя способами
одновременно. Так,  для любой  бинарной операции  @, x@y может быть
проинтерпретировано как x.операция@(y) или операция@(x,y).

     7.16.3 Особые операции

  Вызов функции

  первичное_выражение ( список_выражений opt )

и индексирование

  первичное_выражение [ выражение ]

считаются  бинарными   операциями.  Именами   определяющей  функции
являются соответсвенно  operator()   и operator[]. Обращение x(arg)
интерпретируется как  x.operator()(arg) для  классового объекта  x.
Индексирование x[y] интерпретируется как x.operator[](y).

                             - стр 274 -


                         8. ОПИСАНИЯ

  Описания используются  для  определения  интерпретации,  даваемой
каждому идентификатору;  они  не  обязательно  резервируют  память,
связанную с идентификатором. Описания имеют вид:

  описание:
      спецификаторы_описания opt список_описателей opt ;
      описание_имени
      asm_описание

  Описатели в списке_описателей содержат идентификаторы, подлежащие
описанию. Спецификаторы_описания    могут  быть  опущены  только  в
определениях  внешних  функций  (#10)    или  в  описаниях  внешних
функций. Список  описателей может  быть пустым  только при описании
класса  (#8.5)   или   перечисления   (#8.10),   то   есть,   когда
спецификаторы_описания     -     это     class_спецификатор     или
enum_спецификатор. Описания   имен описываются в #8.8; описания asm
описаны в #8.11.

  спецификатор_описания:
      sc_спецификатор
      спецификатор_типа
      фнк_спецификатор
      friend
      typedef

  спецификаторы_описания:
      спецификатор_описания спецификатор_описания opt

  Список должен  быть внутренне  непротиворечив в  описываемом ниже
смысле.

     8.1 Спецификаторы класса памяти

  Спецификаторы "класса памяти" (sc-спецификатор) это:

  sc-спецификатор:
      auto
      static
      extern
      register

  Описания, использующие  спецификаторы  auto,  static  и  register
также служат  определениями тем,  что они  вызывают  резервирование
соответствующего объема  памяти. Если  описание extern  не является
определением (#4.2),  то где-то  еще должно  быть  определение  для
данных идентификаторов.
  Описание register  лучше  всего  представить  как  описание  auto
(автоматический) с подсказкой компилятору, что описанные переменные
усиленно используются.  Подсказка может быть проигнорирована. К ним
не может применяться операция получения адреса &.
  Спецификаторы  auto  или  register  могут  применяться  только  к
именам, описанным  в блоке,  или к  формальным  параметрам.  Внутри

                             - стр 275 -

блока не может быть описаний ни статических функций, ни статических
формальных параметров.
  В описании может быть задан максимум один sc_спецификатор. Если в
описании отсутсвует  sc_спецификатор, то  класс памяти  принимается
автоматическим  внутри   функции  и  статическим  вне.  Исключение:
функции не могут быть автоматическими.
  Спецификаторы static  и extern  могут использоваться  только  для
имен объектов и функций.
  Некоторые спецификаторы  могут использоваться  только в описаниях
функций:

  фнк-спецификатор:
      overload
      inline
      virtual

  Спецификатор перегрузки  overload делает  возможным использование
одного имени для обозначения нескольких функций; см. #8.9.
  Спецификатор inline  является только  подсказкой компилятору,  не
влияет  на   смысл  программы   и  может  быть  проигнорирован.  Он
используется, чтобы  указать на  то, что при вызове функции inline-
подстановка тела функции предпочтительнее обычной реализацци вызова
функции. Функция  (#8.5.2 и  #8.5.10), определенная внутри описания
класса, является inline по умолчанию.
  Спецификатор virtual  может  использоваться  только  в  описаниях
членов класса; см. #8.5.4.
  Спецификатор friend  используется для отмены правил скрытия имени
для членов  класса и  может использоваться  только внутри  описаний
классов; см. #8.5.9.
  С помощью спецификатора typedef вводится имя для типа; см. #8.8.

     8.2 Спецификаторы Типа

  Спецификаторами типов (спецификатор_типа) являются:

  спецификатор_типа:
      простое_имя_типа
      class_спецификатор
      enum-спецификатор
      сложный_спецификатор_типа
      const

  Слово   const    можно    добавлять    к    любому    допустимому
спецификатору_типа. В  остальных случаях в описании может быть дано
не более  одного спецификатора_типа.  Объект типа const не является
lvalue. Если  в описании  опущен спецификатор  типа, он принимается
int.

                             - стр 276 -

  простое_имя_типа:
      char
      short
      int
      long
      unsigned
      float
      double
      const
      void

  Слова  long,   short   и   unsigned   можно   рассматривать   как
прилагательные. Они  могут применяться  к типу  int; unsigned может
также применяться к типам char, short и long.
  Спецификаторы класса  и перечисления  обсуждаются в  #8.5 и #8.10
соответственно.

  сложный_спецификатор_типа:
      ключ typedef-имя
      ключ идентификатор

  ключ:
      class
      struct
      union
      enum

  Сложный спецификатор  типа можно  использовать для  ссылки на имя
класса или  перечисления там,  где имя  может быть скрыто локальным
именем. Например:

  class x { ... };

  void f(int x)
  {
      class x a;
      // ...
  }

  Если  имя   класса  или   перечисления  ранее  описано  не  было,
сложный_спецификатор_типа работает как описание_имени; см. #8.8.

     8.3 Описатели

  Список_описателей,  появляющийся  в  описании,  есть  разделенная
запятыми последовательность  описателей, каждый  из  которых  может
иметь инициализатор.

  список_описателей:
      иниц_описатель
      иниц_описатель  ,  список_описателей

                             - стр 277 -

  иниц_описатель:
      описатель  инициализатор opt

  Инициализаторы  обсуждаются   в  #8.6.  Спецификатор  в  описании
указывает  тип   и  класс  памяти  объектов,  к  которым  относятся
описатели. Описатели имеют синтаксис:

  описатель:
      оп_имя
      ( описатель )
      * const opt  описатель
      & const opt  описатель
      описатель   ( список_описаний_параметров )
      описатель     [ константное_выражение opt ]

  оп-имя:
      простое_оп_имя
      typedef-имя  ::  простое_оп_имя

  простое_оп_имя:
      идентификатор
      typedef-имя
      ~  typedef-имя
      имя_функции_операции
      имя_функции_преобразования

Группировка та же, что и в выражениях.

     8.4 Смысл описателей

  Каждый  описатель   считается  утверждением   того,  что  если  в
выражении возникает  конструкция,  имеющаяя  ту  же  форму,  что  и
описатель, то  она дает  объект указанного  типа и  класса  памяти.
Каждый  описатель   содержит  ровно  одно  оп_имя;  оно  определяет
описываемый  идентификатор.   За  исключеним   описаний   некоторых
специальных  функций   (см.  #8.5.2)   ,   оп_имя   будет   простым
идентификатором.
  Если  в   качестве  описателя  возникает  ничем  не    снабженный
идентификатор,  то   он  имеет   тип,   указанный   спецификатором,
возглавляющим описание.
  Описатель в  скобках эквивалентен описателю без скобок, но связку
сложных описателей скобки могут изменять.
  Теперь представим себе описание

  T D1

где T  - спецификатор  типа (как  int и  т.д.), а  D1 -  описатель.
Допустим, что  это описание заставляет идентификатор иметь тип "...
T", где  "..." пусто,  если идентификатор  D1  есть  просто  обычый
идентификатор (так  что тип  x в  "int x"  есть просто int). Тогда,
если  D1  имеет вид

  *D

                             - стр 278 -

то тип содержащегося идентификатора есть "... указатель на T."
  Если D1 имеет вид

  * const D

то тип содержащегося идентификатора есть "... константный указатель
на T", то есть, того же типа, что и *D, но не lvalue.
  Если D1 имеет вид

  &D

или

  & const D

то  тип  содержащегося  идентификатора  есть  "...  ссылка  на  T."
Поскольку ссылка по определению не может быть lvalue, использование
const излишне. Невозможно иметь ссылку на void (void&).
  Если D1 имеет вид

  D (список_описаний_параметров)

то содержащийся  идентификатор имеет тип  "... функция, принимающая
параметр типа список_описаний_параметров и возвращающая T."

  список_описаний_параметров:
      список_описаний_парам opt ... opt

  список_описаний_парам:
      список_описаний_парам  ,  описание_параметра
      описание_параметра

  описание_параметра:
      спецификаторы_описания  описатель
      спецификаторы_описания  описатель  = выражение
      спецификаторы_описания  абстракт_описатель
      спецификаторы_описания  абстракт_описатель  =  выражение

  Если список_описаний_параметров   заканчивается многоточием, то о
числе параметров  известно лишь,  что оно  равно или  больше  числа
специфицированных типов  параметров; если  он пуст,  то функция  не
получает  ниодного  параметра.  Все  описания  для  функции  должны
согласовываться и  в типе возвращаемого значения, а также в числе и
типе параметров.
  Список_описаний_параметров   используется    для    проверки    и
преобразования фактических  параметров и  для контроля присваивания
указателю на  функцию. Если  в описании  параметра  специфицировано
выражение, то это выражение используется как параметр по умолчанию.
Параметры по  умолчанию будут использоваться в вызовах, где опущены
стоящие  в   хвосте  параметры.  Параметр  по  умолчанию  не  может
переопределяться более  поздними описаниями. Однако, описание может
добавлять    параметры  по  умолчанию,  не  заданные  в  предыдущих
описаниях.

                             - стр 279 -

  Идентификатор может по желанию быть задан как имя параметра. Если
он  присутствует  в  описании  функции,  его  использовать  нельзя,
поскольку  он   сразу  выходит   из  области   видимости.  Если  он
присутствует в  определении функции (#10), то он именует фармальный
параметр.
  Если D1 имеет вид

  D[ константное_выражение]

или

  D[]

то тип  содержащегося идентификатора есть "... массив объектов типа
T". В  первом случае константное_выражение есть выражение, значение
которого может  быть определено во время компиляции, и тип которого
int.   (Константные выражения  определены в  #12.) Если подряд идут
несколько  спецификаций   "массив  из",  то  создается  многомерный
массив; константное  выражение, определяющее границы массива, может
быть опущено  только для  первого  члена  последовательности.  Этот
пропуск  полезен,   когда  массив  является  внешним,  и  настоящее
определение, которое  резервирует память, находится в другом месте.
Первое константное  выражение может  также быть  опущено, когда  за
описателем  следует   инициализация.  В  этом  случае  используется
размер, вычисленный исходя из числа начальных элементов.
  Массив может  быть построен  из  одного  из  основных  типов,  из
указателей, из  структуры или  объединения или  из другого  массива
(для получения многомерного массива).
  Не все возможности, которые позволяет приведенный выше синтаксис,
допустимы.  Ограничения  следующие:  функция  не  может  возвращать
массив или  функцию, хотя  она может  возвращать указатели  на  эти
объекты; не  существует массивов  функций, хотя  могут быть массивы
указателей на функции.

     8.4.1 Примеры

  В качестве примера, описание

                             - стр 280 -

  int i;
  int *ip;
  int f ();
  int *fip ();
  int (*pfi) ();

описывает целое  i, указатель  ip на целое, функцию f, возвращающую
целое, функцию  fip ,  возвращающую указатель на целое, и указатель
pfi на  функцию,  возвращающую  целое.  Особенно  полезно  сравнить
последние две. Цепочка *fip()  есть *(fip()),  как предполагается в
описании, и  та же конструкция требуется в выражении, вызов функции
fip, и  затем косвенное  использование результата через (указатель)
для  получения   целого.  В   описателе  (*pfi)()   внешние  скобки
необходимы, поскольку  они также  входят в  выражение, для указания
того, что  функция получается  косвенно через  указатель на фунцию,
которая затем  вызывается; это  возвращает целое.  Функции f  и fip
описаны как  не получающие  параметров, и  fip   как указывающая на
функцию, не получающую параметров.
  Описание

  const a = 10, *pc = &a, *const cpc = pc;
  int b, *const cp = &b;

описывает a:  целую константу,  pc: указатель  на целую  константу,
cpc: константный  указатель на  целую константу,  b:  целое  и  cp:
константный указатель  на целое. Значения a, cpc и cp не могут быть
изменены после  инициализации. Значение pc может быть изменено, как
и объект, указываемый cp. Примеры недопустимых выражений :

  a = 1;
  a++;
  *pc = 2;
  cp = &a;
  cpc++;

  Примеры допустимых выражений :

  b = a;
  *cp = a;
  pc++;
  pc = cpc;

  Описание

  fseek (FILE*,long,int);

описывает функцию,  получающую  три  параметра  специальных  типов.
Поскольку тип возвращаемого значения не определен, принимается, что
он int (#8.2). Описание

  point (int = 0,int = 0);

описывает функцию,  которая может  быть вызвана  без параметров,  с
одним или двумя параметрами типа int. Например

                             - стр 281 -

  point (1,2);
  point (1)             /* имеет смысл point (1,0); */
  point ()              /* имеет смысл point (0,0); */

  Описание

  printf (char* ... );

описывает функцию,  которая  может  быть  вызываться  с  различными
числом и типами параметров. Например

  printf ("hello, world");
  printf ("a=%d b=%d",a,b);
  printf ("string=%s",st);

Однако, она всегда должна иметь своим первым параметром char*.
  В качестве другого примера,

  float fa[17], *afp[17];

описывает массив  чисел с  плавающей точкой  и массив указателей на
числа с плавающей точкой. И, наконец,
  static int x3d[3][5][7];
описывает  массив  целых,  размером  3x6x7.  Совсем  подробно:  x3d
является массивом  из трех  элементов; каждый из элементов является
массивом из  пяти элементов; каждый из последних элементов является
массивом из  семи целых. Появление каждое из выражений x3d, x3d[i],
x3d[i][j], x3d[i][j][k]  может быть приемлемо. Первые три имеют тип
"массив", последний имеет тип int.

     8.5 Описания классов

  Класс специфицирует  тип. Его  имя  становится  typedef-имя  (см.
#8.8),  которое   может  быть   использовано  даже   внутри  самого
спецификатора класса.  Объекты класса состоят из последовательности
членов.
     спецификатор_класса:
          заголовок_класса     {      список_членов      opt      }
          заголовок_класса         {  список_членов  opt  public  :
     список_членов                      opt                       }

     заголовок_класса:
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     агрег:
          class
          struct
          union
  Структура является  классом,  все    члены  которого  общие;  см.
#8.5.8. Объединение  является классом,  содержащим в  каждый момент
только один член; см. #8.5.12.  Список членов может описывать члены
вида: данные,  функция, класс,  определение  типа,  перечисление  и
поле.  Поля  обсуждаются  в  #8.5.13.  Список  членов  может  также
содержать описания, регулирующие видимость имен членов; см. #8.5.8.

                             - стр 282 -

     список_членов:
          описание_члена  список_членов opt
     описание_члена:
          спецификаторы_описания        opt        описатель_члена;
     описатель_члена:
          описатель                         идентификатор   opt   :
     константное_выражение
  Члены, являющиеся  классовыми объектами,  должны  быть  объектами
предварительно полностью  описанных классов.  В частности, класс cl
не  может  содержать  объект  класса  cl,  но  он  может  содержать
указатель на объект класса cl.
  Имена обектов  в различных классах не конфликтуют между собой и с
обычными переменными.
  Вот простой пример описания структуры:

  struct tnode
      {
        char tword[20];
        int count;
        tnode *left;
        tnode *right;
      };

содержащей массив из 20 символов, целое и два указателя на такие же
структуры. Если было дано такое описание, то описание

  tnode s, *sp

описывает s  как структуру  данного сорта  и sp  как  указатель  на
структуру данного сорта. При наличии этих описаний выражение

  sp->count

ссылается на поле count структуры, на которую указывает sp;

  s.left

ссылается на указатель левого поддерва структуры s; а

   s.right->tword[0]

ссылается на  первый символ члена tword  правого поддерва структуры
s.

     8.5.1 Статические члены

  Член-данные класса  может быть  static; члены-функции  не  могут.
Члены не  могут быть  auto, register  или extern. Есть единственная
копия статического  члена,  совместно  используемая  всеми  членами
класса в  программе. На  статический член  mem   класса cl    можно
ссылаться cl:mem, то есть без ссылки на объект. Он существует, даже
если не было создано ниодного объекта класса cl.

                             - стр 283 -

     8.5.2 Функции члены

  Функция, описанная  как член, (без спецификатора friend (#8.5.9))
называется функцией  членом и вызывается с помощью синтаксиса члена
класса (#7.1). Например:

  struct tnode
    {
      char tword[20];
      int count;
      tnode *left;
      tnode *right;
      void set (char* w,tnode* l,tnode* r);
    };

  tnode n1, n2;

  n1.set ("asdf",&n2,0);
  n2.set ("ghjk",0,0);

  Определение  функции  члена  рассматривается  как  находящееся  в
области  видимости   ее  класса.   Это  значит,   что   она   может
непосредственно использовать  имена  ее  класса.  Если  определение
функции члена  находится вне  описания класса, то имя функции члена
должно быть уточнено именем класса с помощью записи
     typedef-имя . простое_оп_имя
см. 3.3. Определения функций обсуждаются в #10.1. Например:

  void tnode.set (char* w,tnode* l,tnode* r)
    {
      count = strlen (w);
      if (sizeof (tword) <= count) error ("tnode string too long");
      strcpy (tword,w);
      left = l;
      right = r;
    }

  Имя  функции  tnode.set  определяет  то,  что  множество  функций
является членом  класса tnode.  Это  позволяет  использовать  имена
членов word,  count, left  и  right.  В  функции  члене  имя  члена
ссылается на  объект, для  которого была  вызвана функция.  Так,  в
вызове  n1.set(...)   tword  ссылается  на  n1.tword,  а  в  вызове
n2.set(...)     он  ссылается   на   n2.tword.   В   этом   примере
предполагается, что функции strlen, error и strcpy описаны где-то в
другом месте как внешние функции (см. #10.1).
  В члене  функции ключевое  слово this  указывает на  объект,  для
которого вызвана  функция. Типом  this в  функции, которая является
членом класса  cl, является cl*. Если mem - член класса cl,то mem и
this->mem -  синонимы в  функции члене  класса cl  (если mem не был
использован в  качестве имени  локальной переменной в промежуточной
области видимости).
  Функция член  может быть  определена (#10.1)  в описании  класса.
Помещение определения  функции члена  в  описание  класса  является
кратким видом  записи  описания  ее  в  описанииИ  класса  и  затем
определднип ее  как inhinе  (#8.1)  сразу  после  описания  класса.
Например:-

                             - ртр 284 -
 $int b;
  struct!x
    {      int f () { return b; }
      int f () { return b; }
      int b;
    };

 означает
Љ  int b;
  struct x
   ${
      int f ();
      int b;    };
  inline"x.f () { ruturn b; }

  Для фінкций 0членов членов  не нужно  использование спецификатора
overload (#8.2): если имя описывается как означающее mескольво`имен
в клвссе, то оно перегружено (см. #8.9).
  Применение операции получения адтеса к функциям цленаи допустамо.
Тип параметра  °езульуирующей0функциh  указатель на  есть (...*, то
есть,  неизвестен!  (":.4)>     Любое  ис­Ользование `его  является
зависим»м от  реализации, поскольку  способ инициализации указателя
для вызова функциа члена неопределен.

     8.5.3 Производные классы

 !В конструкции
     агрег идентификатор:pu`lic mpt typedef-имя
typedef-имя !должно  озназать  ранее  описанный  класс,  называемый
базовым классом  для класса,  пюдлежащег® описанйю.  Говорится, что
последнйй выводится  из пшедшестгующего.  На чле­ы  базового класса
можно ссылвт|ся, "как если бы они были улена¬и производного класса,
за  исключением   тех  слсчаев,   когдд  имя  базового  членд  былоJпереопределено b  производном классЕ9 0в этом  qлучае для ссылки на
скрытое имя  мnжеъ испюльзоваться такая запис| (#7.1):
 !   typedef-имя :: идентификауор
  Например:

        (       `            - стр 285"-
  strqct base
    {
   !  int a;
      int b;
 !  };

  struct derived :$public base
    {
      int b3
      int c;    };

  derived d;

  d.a = 1;
a d.base::в = 2;
  d."$= 3;
  d.c = 4;

охуществлянт присваивание четыРем членам dn  Производный тиo Сам может использпваться как базовый.

     8.5.4 Вирцуальные функции

  Если базовый  класс(base  содержит  виртуаkьную)  vArtwal  (#8.1)
функцию Vf,  а пРоизводн»й класс derived также содержит фупъцию vf,
то жъзов  6f  для  объекта  класса  derived  вызывает  dеrived::vf.
Ќапрhмер:

  struct base
    {
      virtual void vf ();
      void f ();
    };

 ` strugt derivdd : public base
    {
      void vf ();
      void f ();
    };

  debived d;
  base* bp = &d;

  bp->vb ();
  bp->f ();

  Вызовы вызытают,  соответственно,    derived:zvf (и  ra{e::f  для
объекта jласса  derived,  именовинного  d.  Так  что  интерпретацияKвызова виртуапьной  функции з`ўисит  от типа  осъекта, для которого
она вызвана,  в то  время как  иНтерпретаvия  жызова( эевиртуальной
функции здвисит только от типа укапателя, обозначающебо объект.
  Из  этог®  следует,  что  тип  объектОв  классок  с  виртуагьными
функциями и  объекrов классов,  выведенных из  таких классов, могув
быть оптеделены во вшбмю выполнения.
                     $       - стр$286 -

  Если прюазводный  класс имееr  член с  тем же  именем,  что  и  у
виртуальной функции  в базовом  классе, то  оба члена  должны иметь
одинаКокый!тип.  ВиртУальная функция  Не можзт бЫтэ другом (friend)
(#8.5.9). Фунjция  f в  классе, выведенном из клабса, который имеет
виртуальную  функцию   f,  ±бма  рассматрикается  как  киртуалмния.
Виртуальная  функцйя  в  базовом  классе  должна  быть  определена.
Виртуальная фуекцЁя$  которая бЫла  опреде«ена в бизмвом классб, не
нуждается  в  определении  в  пр®изводном  классе.  В  этом  случае
функюия, определенная  для базового  кл`сса используется  во  вхех
вызовах.

     8.5.5 Конхтрукторы
M
  Член функткя с имеНем, совпааающим с именем ее класса, называетсяЉконструкъором. Конструктор не имееш типа возвращаемпго`значения; оН
исполэзуется дkя  конструироваеия значзний  с типом  егк$класса.  С
помощью  констшУктора  можно0 создавать  новяе $огъекты  его  типв,
исполшзуя синтаксис
     typeeef-имя ( список_параметров opt )
! Эапример,

  complex zz = complex (1,2.3);

  cprint08compleh (7.8,1.2));

  Объеъты,  созданные   т`ким  образом,   не  имеют   имени`  (если
конструктор0не  шспользован кдк  инициализатnрl как  это было  с zz-
выше), и  их время  жизни ограничено  областью вмдймости, в которойЌ
онh созданы.  Они не  могsт Рассмаъриваться  као константы их типа.
Если класс  имеет конструктор, то он вызывается для каждого0объекта
этого Єласса`перед тенl как эчот объекц будет как-либо!использован;
см. #8.6.
  Консруктор может быть overload, но не virt5al или f2iend.
  Если класс  имеет базовый  клас±  с лонструктором,(то кон±труктор
для  базового   класса  вызывается ` до  вызовв   конструктора  для
производногО класса. Конструкторы дЛя объектов членов,!если таоовые
есть,  в»полНяются   после  констрултора   базового  класса ( и (до
конструктора объектаl  содержащего их.  Объясеение того,  оак могут
бывь спетифицированы параметры для базового класса, см. в #8.6.2, а
того,  как   конструкт®ры  могут   Использоваться  для   управлемия
свободной памяцью, см. в"#17.

 !$  8.5.6 Пшеобразования
  Конструктр, получающИй  один параметр,  определяет преобразование
из Іипа  своево оараметра`в тип своего класса. Такие преобразования
неявно   применяются   дополнительйо   ъ   обычным   арифметияеским
пробразоввниям/ Поэтомс присваивание0объеКту из класса X0допустимо,
еслй или  прихваиваемое значЕние  является  Xl  или `если  X  имеетJЄонструктор,  который  получает  присваиваемое  значение  как  свой
еди­ственнлй параметр.  Аналогиуно  конструлторы  испокьзуютqя  для
преобразоврния параметров $функции (#7.1) и инициализатороа (#8.6).
Например:
         " $                 - стр 287 -

  c|ass X i ... X (inp); };
  f (X arg)
    {
      X a = 1;    0    0/* a = X (1) */
      a < 2;            /* a(= X (2) */
      f (1){            /* f (X (3!) */
    }
  Если для  класса H  не  найден  ниодин  конструктор,  птинимающий
присваиваемый  Іип,   то  не   делается  нЁкакшх  попыток  отъскать
конструктор для  преобтазования пршсваивдемого  типа в тип, который
моз бы быть приемлем`для конструкторов оласса  X. НапримеР:

 "class X { ... X!(int); };J  claуs H { .., Y (X); };

  Y a = 1;     $     0  /* недопустимо: X (X (1)) не пробуетсЯ */
     <.5.7 Дестpукторы

 !Функжия член  классА cl$ с имзнем  ~cl  называется  деструктофом.Деструктор не  возвращает никакого  значения И  не полуяает никакhх
параметров; 0он  использгется  для  уничтожения  значений  уипа  clнепосредственэо  перед   уничтоженинм   содержащего   их   объеота.
ДеСтрукто° не мюжет быть overload< virtual или friend.
  Десуруктор для  базового  кпасса  выполняется $после  деструктора
произвоаного( оц  него  класса.  Как  деструкторы  используютя0 для
управления свободной памятью, см, объясннние в #17.

     ё.5.8 Видимость имен членов

  Члены``класса,   описрнные  с  ключевым  слnвом  class,  явля~тся
закрытыои, это  значит, зто  их Имена  могут использоваться  толЬко
фунъциями члендми  (#8n5.2)   и друзьымк (сн. #8.5.10), пока они не
появятся пксле   метки public:  В этом случае они являются общими.
Общий член  может использпв ться любой функцией. Структура является
классом, все ч«ены которого оещие; см. #8.5.11.
  Если перед0 именем aазового класса в описании производного класса
стоит  ключевое !слово  qublic,  то  общие  члены  базового  клахса
являются охщими  для пфоизводного  класа; еслй нет, то они являются
закрытыми. Общий члҐн mem закрытого базового власса base может быть
описан кpк общий для производного класса с пюмощью опиисания вида
     typedef-имя . идентЁфикатор;
в котором $typedef-имя означает базовый класс, а иментихикатор естш
имы ч«ена `сазовогn класса. Такое описание может появлыться в общей
чбсти производноло класса.
  Рассмотрим
*   !          !        ` `   - стр 288 m

! class base
(   {
$     i~t a;
  public:
      int b,c;
      iNt bf(();
    };
	
  clcss dеrived 2 base
    {
      int d;
  publhc:
      cas%.c;
      iot e;
      int df ();
$   };

  int ef (ferived&);

  Анешняя функция  ef можер  использовать тольjо  имена c,  e и df.
Являясь членом  deRived, функция df может испокьзоватю имена b,  c,
bfl d,  e    и " df, но не a. Являясь члемом base,Ёфункция bf можнтиспользовать члеmы"al b, c  и( bfо

"    8.µ.9 Друзья (friends)

  Другом   класса°  являеІся   функция   нх-член,   котnрая   может
испольжов ть имен   закрытыс чгенов.  Спедующин зриМер иллюстрирунІ
различия межфу чле­амш и друзьэми:

  class privatе
 !  {
      int a;
      friend void friend_set (pryvate*,inT);	
0public:
      void member_set (int);
    };

  void frieоd_set (priv`te* p,int i) { P->a=i; }

  void private.member_set (int i) { a = i;0}

  private obj;

  friend_set (&obj,10);

  obj.member_set"(1°);

  Если  описание   frie~d  отностися  к  перегруженному  имени  или
операции, то( другом становится" только функция с описаннлми тилами
парамзрров. Все! функции класса  cl1 могут  быть  сделаны  друзьями
классд cl2 б помощью одного оoисания

  !        $      ! $      ` - стр "8= -

  class cl2
  ` {
      friend cl1      . . .M
    };

     8.5.10 Функцияоперацмя

   Большинстжо  операжйй могуц 0быць перегружены  с тем,  чтобы они
мозли поЛучать$в качестве операндов объекты класси.
      имя_фуекции_операции:$  operator  kp
 ! $op:            +`  - $ *   /   %   ^`(    | $ ~
        $          Ў   =   <   .   +=  -=  *=  /=  %=
  !                ^=  &=  |=  <<  >>  <<= >>= ==  !=
 "       `         <=  >=  &&  || `++  -,  ()  []
Последние две  операции  -! это  вызов$ функции  и  индексирование.
Функвия опердция  мооет или  быть"функцией  членом, шыа получать по
меньшей мере один па°амевр класса. См. ракже #7.16.

     8.5.1 Структуры

  Структура есть класс, все члену которого общиµ. Это значиц, что
Ќ
  rtruct s { ... };

ьквивалентно
  class s { public: ...$};

  структура моfет  иметь  фумкции  члены  (включая  конструкторы  и
дхструкторы)*

     8.5.12 Объединения
  Объединение можно  считать$структурой,  все объевты члнны котор®й
ничинаются  со   смещения  0,   и  размер  которой  доскаточбн  для
содержания ыюбого  Ёз$ее оЎъектов членов. В каждый момент времени$в
объединеии может  хранить±я`не  больше одного  из объектов  членов.ЉЮбъединение может  иметь  фунлции 0члены  (включая  конструкторы  и
деутрукторы).

!    8.5.13 Поля бит

  Описатель члена вида
     идентифакатор opt:  ъпнстантное_выражение
олределяет поле;  его длина  отделяется от  имени поля  двоеточием.
Поля упаковываюrся !в маъинные целые; они не явлчются альтернативой
слов. Поле  , не Влезающее в оставшeеся в целом место$ помесается в
следующее(±лово.  Oоле не  может  быть  шире  слова. 0Mа  некоторых
машинах  они  размещаются $справа0 налево,  а  на  некоторых  слева
направо; см. #2.6.

                    ((       - стр 290 -
-J  Неименованные поля полезны при заполненми для согласования внешне
предписанных размещений  (форматов). В особых случаях$неименованные
поля длины  0 задают выравниванЁе следующего поля по границе слова.
Не требуется  аппасатной подднржкш  люеых полей, кркме целых. Более*того, даже! целые поля  могут рассматриваться как unsigned. По этим
приуинам рекомендуется  онисывать поля  как qnsigned.  К  полям  не
может! применяцься   nпЕрация  получхния   адреса  &  поэтому  нет
указатзлей на лоля.
  Поля не могут быть членами объефиннния.
    08.5.14 Вложенные классы

  Класс может  быть ®писан  внутри другоГо  класса. В  этом  случае
область 0вшдимnсти   иlен  внутреннего  власса  его  и  общих  имен
ограничивается   охватывАющим"  классом.   За   исключением   этого
ограничения допустимп,  чтобл внутренний  класс!уже  был описан вне
охватываю№его класса.  Описание одного  класса  внутри  другого  не
влкяет на  правила доступа к закрытым членам и не помещаеТ фінкции
члены внутреннегм  класса в обласrь видиМости охватывающего клАсса.
Например:
J  int x3

  class enclose`  /* охватывающий */
 (  {
      int x;
     $clacs ynner
      " {
      (   inu y;
      $   f () { z=1 }
          .*.
 $      u;
 `    g (inner*);
      ...    };

  int inner;  /* вложенный */
M
  enclose.g (inneR* p) { ... }-

  В этом  примере x  в`f" ссылается на  x- описанный  перед классомMЉencloтen Поскольку  щ являдтся  закрытым членом  inner,  g$не может
его использовать.  Поскольку g   является  членом  enclose, `амена,
мсполэзованные в  g, эчитаются  находящиМися  в  области  видимостш
класса enclse.   Поэтому inner в описании параметров g относится о
охвачбнному типу inner, а не к int.

     8.6 Инициалмзация

  Описание   может " задрвать `!начальное   значение   описываемог®
идентификатора. Инициализстору  оседШествует =, $и  оэ  состоит  из
выражения или списка зназений, заключенного в фигуаные скобки.

        $   `!               - стр 291 m

  $0 инициализатор:
          =                          (          !        expRession
         д=          {           бписок_инициалмзаторов 2         }
          =       {    "   список_иницивлизаторов   "  ( , !      }
          ( `                 список_Выражений       "            i

     сgисок_инициализаторов                        (  (           :
          выражение
          список_инициализаторов      ,(     список_инициализатжров
         ({ список_инициализауоров }
  Все выравания в инициалиеаторе статическоб или внешней переменной
должны быть  константными вырржениями,  которые описан{ в #15,  или
выражениями, которые сводятся ъ адресвм ранее описанных переменных,
возможно со  смещением на  константное выражение.  Автоматические и
регистровые переменные могут инациализироваться любыми выражнниями,
включащимй константы, ранее описанные переменные а функvии.
  Гарамтируется, что  неиниЦиализированняе  сратические  и  внешние
переоенные  получают  (в  качзстве   началмноуо  значения   "пустое
значенкe"*. Когда" инициалмзатор применяется  к скаляру  (ук зательили объект  арифмерИческого тина),  он состоат0из оеного выражхния,Љвозможнм, заключенного  в 0фигурные  скобки.  Начальное  $ значенке
осъхкта находится  из выразбниэ;  выполняются те же преобразования,
что$и при присваивании.
  Заметьте, что  поскмльку ()  не являхтся)0инициализатором, то  "X*a();" явлїется  нб ®зисанием объекта класса X, а$описанинм функции,
не получаъщей значений и возвращающел P.

     0.6.1 Список инициализаторов

  Когда описанная переменная является соСъавнпй (класс или мбссшв),
то иницирлизатор  может спстоять из заключенного в фигурные скобКи,
разделеннобо запятыми  списка иеициализаторов"для членов составного
объеъта, в  потядке возрасвания иmДекСа йли но порядъу ялемпв. Если
марсив содерхит  составные подобъекты,  то это (правило  рекурсивно
применяется к  членам составного подобъdкта. Если инициализаторов в
Спискe$меньше,  чем членов  В боставmом  пnдобъекте,  то  составной
подобъект дозолняется нулями.
  Фигурные  скобки(  моггт  опускаться!  следующим  об°азом.   Еслиинициализатор начинается  с лев®й фигурной сиобки, то следующий  за
ней спискк инициализаторов инкциализирует`членъ составного объекта;
наличие  чмсла   иэициализаторов,  боЛьшего,   чем  число   членов,
считаетбя ошибочным.  Если, однако,  инициализатпр не  начинается с
певой фигурной  скобки, !то  из  списка  берутся  только  элементы<
достАточные для  ропоставлемия членам  составного  объекта,  частьь
которого является текущий составной объект>
  Например,

  int x[] = { 1, 3, 5"}»

описывает и  анициализирует x  как одномерный  массив, ИмеющИй (триЌ
члена, посколмку размер"не б»л указан и дано три шниЦиаличатора.
____________________
  * В  бнгйкйском "'arBЎge",  озн`чающех затертое  место  [памяти],
т.е. если  перемен­ая  целая,  то  0,  если  char,  то  '\0',  еслиЉуказатель на Т-(то (Т*) NULL.

            $                - стр 292 -

  fdoat y[4][3] =
      {
        { 1, 3, 5 },
     `  { 2, 4, 6 }<
    `   { 3, 5, 7 }
$     };

является полноутьъ$ снабженной квадратными скюбками инициализацией:
1,3 и 5 инициализируют  первый ряд массива y[ }, а именно, y[0][2].
Аналпбично, скедующие  аве строки  инициализируют    y[1]  и  y[2].
ИнициализаТор заканчивантсї  раньше, пОэтому  y[3] инициализируецся-
значенИем    0.  В$точноcти 0тот жн  эффект может  быть достигнут с
помощью

  float y[4][3] =
    {
      1, 3, 5, 2, 4, 6, 3, 5, 7
    };

  Инициализатор для  y начинается  с левой  фигурной скобки,  но не
начинается с  нее инициализатор  для y[0], поэтому используется три
значения из  списка. Аналогично, следующие три успешно используются
для y[1] и следующие три для y[2].

  float y[4][3] = { { 1 }, { 2 }, { 3 }, { 4 } };

инициализирует   первый столбец  y (рассматриваемого  как двумерный
массив) и оставляет остальные элементы нулями.

     8.6.2 Классовые объекты

  Объект с  закрытыми членами  не может быть инициализован с помщью
простого присваивания, как это описывалось выше; это же относится к
объекту объединение.  Если класс  имеет конструктор,  не получающий
значений, то  этот конструктор  используется для  объектов, которые
явно не инициализированы.
  Параметры для  конструктора могут  также быть представлены в виде
заключенного в круглые скобки списка. Например:

  struct complex
    {
      float re;
      float im;
      complex (float r,float i) { re=r; im=i; }
      complex (float r) { re=r; im=0; }
    };

  complex zz (1,2.3);
  complex* zp = new co-plex (1,2.1);
  Иеициализация  может   быть  также  выпол­ена  р  помощью  явного
присваивания; прҐкбразования птоизводятся. Например,

                 !           - сІр 293`-

  complex zz1 = complex (1<2.3);
  cпmplex zz2 = complex (123);
  complex zz3 = 123;
  gomplex zz4 = zz3;

  Если конструктор  ссылается на объект своего собственного класса,
то он  будет вызыватЬся  при инициализации  обънкта другим объеjтом
этого класса, но не при инициализации объект` конструктором.
  Обюект  класса,   имеющего  конструкторы,   может   быть   членом
составного объекта  тnлько если  он сам  не имеет$ конструктора или
если его  конструкторы не! имеют( параметров.  В  последнем  случае
конструктор вызывается  при создании  составногп объекта. Если член
составногж объекта  является членом класса с деструкторами, то этот
десъруктор вщзывается oри іничтожении составного объекта.

     8.6.3 Ссылки

  Когда песеменНая  описана как T&, что естј &ссылка на тип T", она
может быть   инициализирована или указацелем на тип T,0или объектом
типа T.  В последнем  случае бчдет неявно применена операция взятия
адреса &. Например:

  int i;
  int& r1 = i;
  int& r2 = &i;J
И r1 и r2 будут указывать на i.
  Обработка инициализации  ссылки очень сильно зависит от того, что
нй  присваивается.   Как  опибывалось   в   #7.1,   ссылка   неявно
перхадресуется при ее использовании. Например

  r1 = r2;

означает копирование  целого, на  которое указывает r2, в целое, наЉкоторое указывает r1.
  Ссылка должна  быть инициализованб.  Таким образом,  ссылку можносчитать именем объекта.
  Чтобы погучить указатель pp, обозначающий тот обект, что$и ссылка
rr, можно  написать `p=&br.    Это  будет  проинтерпретировдно  как
pp=&*rr.
  Если инициализатор  для ссылки  на тип  t  не  являерся  адрещным
аыражением, то "будет  создан  и  инициализован  с  поиощью  правил
иэицмализации объект  типа T.  ТогдА значением  ссылки стаmет адрес
объекІа. Время  жизни объекта,  созданнозо таким  способом, гудет в
той области видиМости, в которой он создан."Напрiмер:

  double& rR = 1;

допустимо, и  rr будет` уоазывать на  объект типа doublg, в котором
храницся значение 1.0.
  Ссылки особенно полезны в качестве типов параметров.

                `    (   "   - стр 294 -

     8.6.4 Массивы символов

  Последняя сокращеэная  запись позволяет  инициализировать строКой
массив данных  типа char.  В этом  случае последовательные  символы
строки инициализируют"члены массива. Нрпример:

  char msg[] = "Syntax error on line %d\n";

демонстрирует  массив  символов,  члепы  которого  иеициализированы
щтрокой.

     8.7 Иоена типов

$ Иногда (для  неявного задания  преобразования типов  и в качестве
параметра sizeof  или new)  нужно использовать имя типа ¤анных. Это
выполняется при  помощи  "имени  типа"  которое  по  Сути  является
описанием для объекта этого типа, в котором опущено имя объекта.
     имя_типа:
          спецификатжр_типа абстрактный_описатель
     абстрактный_описатель                        $         !     :
          пустой
          Є            1             $        абстрактный_описатель
          абстрактный_описатель    (  списоко_писателей_пдраметрок)
          абстрактный_кписатель    {  константное_выражение  opt !]
  (       * абстрактный_описатель )
  Является     возможным      идентифицировать     положенИе      в
абхтрактноМ_описателе, где dолжен был бы появляться идентификатор в
случае, если  бы конструкция  была  описателем  в  описании.  Тогда
именованный  тип   является  тем  же,  что  и  тип  предпол`гаемжго
Ёдентификатора. Напримхр:

  int
  int *
( int *[3]
  int *()
  int (*)()
M
имепует,  соответсвенно,   типы  &целое",   2укрзатепь  на  целое",
"указатель  на   массив  из  трех `целых",  "функция,  возвращающая
указатель ­а функжиюl возврасающую целое" и "указатель на целое".
  Простое  имя   типа  е±ть   имя   типа,   состоящее   из   одного
идентификатора или ключевого спова.
     простое_имя_типа:
        ( typedef-имя
          char
          short
         $int
          long
          uNsigned
          float
          double
  Они используются (в альтерн тивмом  синтакуисе для преобразования
типов. НапрИмЕр:

                  $          - хтр 295 -

  (double) a

может быть также записано как

  double (a)

     8.8 Определение типа typedef

  Описания, содержащие  сяетификатор_описания  typedef,  определяют
йдентификаторы, которы  позднее могуъ  использоваться так, как если
бы  мни   aыли  ключевыми  словами  типа,  именующее  основные  или
производные типы.
     typedef-имю:
          идентификатор
  Внутри области  видимобти описания,  содержащего typedef,  каждый
ифентификатор,  возникающий  (как  часть   какого-либо   описателя,
становится в этом месте синтаосически эквивалентным ключевому слоbу
тмпа, которое  именует тип, ассоциироввнный с идентификатором таким
обрахом, как  описывается в #8.4. Имя класуа или перечисления также
является typedef-именем. Например, после

  vypedef int MILES, *KLICKSP;
0 struct complex { double re, im; };

каждая из конструлций

  MILES distance;
  extern KLICKSP metrkcp;
  complex z, *zp;

является фопустимым  описанием; dispanbe  имеет  тип  int,  metricp
имеет тип "указатель на int".
  typedef   не"вводит  новых типов,  нж только  синонимы для типов,
которые могли  бы быть  опремелены другим  путем. Тик в приведенном
выше примере  distance рассматривАется  как имеющаяя в точности тот
же тип. что и любой другой int объект.
  Но описание класса вводит новый тип. Например:

  struct X { int a; };
  struct Y { int a; };
  X a1;
  Y`a2;
  int a3;M

юписывает три переменных трҐх различных типов.
  Описание вида
     описание_имени:
    $     агфег                   идентификатор            0      ;
       $  enum  идентификатюр ;
определяет  то,0  что  идентификатор   является  именем  некоторого
(возможно, еще 0не определенного)  класса или  перечмсления.  Такие
описания по§воляют  описывать классы,  ссылающихся друг  на  друга.
Например:

                   0         - стр 296 -

  class vector;
  klass matrix
    {
      ...
      friend matrix operator* (matrix&,vector&);
    };

  class vect/r
    {
  (   ...
  $  0friend matrix operator* (matrix&,vector&);
    };

     8.9 Перегруженные имена функЦий

  В тех  случаях,  когд   для  одного  имgни  определенм  несколько
(различных) описаний функций, это имя назывбется перегруженным* При
использовании этого  имени прввильная  фуэкция выбирается`с помощьюсравнения  типов  факІическиэ  параметров  с$ типами  параметров  в
описаниях функций.  К  перегруженным  именам  неприменима  операция
получения адреса &.
  Из пбычных  аридметичЕских преобразований,  определенных в  #6.6,
для    вызова     перегРуженной    фунлции    выполняются    только
char->short->int, int->douвle, int->long и float->double. Для того,
чтобы перегрузить  имя функции  не-члена описание  /verload  должно
предшествовать любому описанию функции; см. #:.2.
  Например:

  overload abs;Ќ
  int abs (ift);
  double abs (double);

  Когда  вызывается  перегруженное  hмя,  по  поряДку  производитсї
сканирование списка  функций для нахождения!той, котория модет быть
вызвана. Эапример,  ab{(12) выgывает  abs(int), а  abs(12.0)  будет
вызывать Abs(double). Если бы был зарезервИрован порядок вызова, то
оба обращения вызвали бы abs(double).
  Если   в   случае   вызова   перегруженного   имени   с   помощью
вышеуказанного метода  не найдемо $ниодной функции,  и если функция
получает параметр ципа класса, то констукторы классов параметров (в
этом случае существует единственный  набор преобразований. дела~щиб
вызов дОпустимым) применяются неявным образом. Например:

  class X { ... X (int); };
  class Y { ... Y (int);$};
  class Z { ... Z (char*); };

  overload int f (X), f (Y)
  overload int g (X), g (Y);

  f (1);        /* неверно: неоднозначность f(X,1)) или f(Y(1)) *'
  g (1);        /* g(X(1))                              (/
  з ("asdf");   /* g(Z("asdf"))                         */

                    0        - стр 297 -

$ Все    имена  $ функций    операций    являются    автомаатически
перегруженными.

     8.10 Описание перечисления

  Перечисления являются int с именованными констаптами.
     enum_сwецификатор:
          enum    шдентификатор     opt   " {     enum_уписок     }

     enum_список:
          перечислитель
          enum_список,                                перечислитель

     перечислктель:
 !      ! идентификатор
          идентификатор = константное_выражение
  Идентификаторы  в  enum-сПиске  описаны  как  константы  и  могут
появлятьуя  во  ўсех  местах,  где  требыются  константы.  Если  не
пжявляется  ни   одного  пеpечислителя   с  =,   то  значения  всех
соответствуюших кжнстант  начИнаются с  0 и возрастают на 1 по мере
чцения   описания   слхва 0 нарпаво.   Пеаечислитель   с   =   дает
ассоциированному   с   ним   идентификатору   указанное   значение;
последующие идентификаторы  продолжают прогрессию  от присвоеннного
зеначения.
  Имена  перечислителей  должны  быть  отличными  от  имен  обычных
переменных. Значения  перечислителей  не  обязательно  должны  быть
различными.
  Роль     идентификатора      в     спецификаторе     перечисления
enum_спецификатор  полностью   аналогична  роли  имени  класса;  он
именует определенный нутератор. Например:

  enum color { chartreuse, burgundy, claret=20, winedark };
    ...
    color *cp, col;
    ...
    col = claret;
    cp = &col;
    ...
    if (*cp == burgundy) ...

делает color  именем типа,описывающего  различные  цвета,  и  затем
описывает cp как указатель на объект этого типа. Возможные значения
извлекаются из множества { 0, 1, 20, 21 }.

     8.11 Описание Asm

  Описание Asm имеет вид
    asm (строка);
  Смысл описания  asm  неопределен.  Обычно  оно  используется  для
передачи информации ассемблеру через компилятор.

  $   0                  !   - стр 298 -

	
                        9. ОПЕРАТОРЫ

  Операторы выполняются последовательно во всех случаях кроме особо
оговоренных.

     9.1 Оператор выражение

  Большинство операторов  является опефаторами  вырижение,  котоаые
имеют вид     выражение ;
  Обыхно операторы  выражение являются  присваивания¬и  и  вызовами
функций.

     9.2 Составной оператор, или блок

  Составной оператор  (называемый ракже  "блок", что  эквивалентно)
дает вкзможнорть использовать несколько операторов в том месте, где
предполагается использование одного:
     составной_оператор:
  $       { список_описаний opt список_операторов kpt }
     список_описаний:
          описание
        0 описиние список_описаний
     список_озераторов:
          оператор
          оператор список_операторов
  Если квкой-кибо  шз идентификито°ов  в списке_описаний  был р`нее
описан, то  внешенее описание  выталкивается $на  время  выполнения
блока, и снова входит в силу по егм окюнчании.
  Каждая инициаkизиция  auto или   register переменmых производится
всякий раз при входе в болову блока. В$блок делать передачу; в этом
случае  инициализации  не  выпопняются.  Инициакизации  переменных
имеющих класс памяти static (#4.2) осsществляются только один раз в
начале выполнения программы.
Ќ
     9.3 Условный оператор
  Есть два вида условных операторовЌ
     if ( выражение ) оператор
     if ( выражение ) оператор else оператор
  В обоих  щлучаях вычисляется  выражение, и  Если оно  не ноль, то
выполняется первый"подоператор. Во врором случае второй подоператор
выполняется, если  выражение есть  0. Как  обычно,  не¦днозначность
"else"  разрешается   пксредством  того,  что  else  связывается  с-
последнио встречнным if, не имеющим else.

     9.4 Оператор while

  Оператор while имеет вид
     while ( выражение ) оператор

!           $                -`стр 299 -

  Выполнение   подоператора повторяется,  пока  значение  выражения
остается ненулевым.  Проверка выполняется  передкаждым  выполнениеи
оператора.

     9.5 Оператор do

  Оператор do имеет виd
     do операІор whkle (выражение);
   Выполнение   подоператора  повторяется до тех пор, пока значениевыражҐния не  станет  нулем.  Проверка" выполэяется  после  каждого
въполнения оператора.
Ќ
     9.6 ОпербтоР for

  Оператор dor имЕет вид
     for (  выражение_1 opt  ; выражение_2  opt ; выражение_3 kpt )
          оператор
   Этот опбратор эквиваленуен следующему:

                             - стр 309 -

     выражение_1;
     while               (                            (выражение_2)
      !                                0                          {
    0            (                                         операт®р
                        "  $                           выражение_3;
       }
  Первое выражение  задает инЁциализацию  цмкла;  второе  выражение
задает осуществляемую  перед каждой  итерацией псоверку, по которой
производится выход  из  цикла,  если  выражение! становится  нулем;
третье выражениe  часто зддает приращение, выпогняeмое после каждой
итерации.
  Каждое  или   ксе  выражения   могут  быть   опущены.  Отсутствие
тыражения_2 делает  подразумеваемое while-предложение  эквивалентымwhile(1);  остильные  опущенные  выражейия  просто  пропускаются  в
описанном выше расширении.

     9.7$Оператор switch-

  Оператор  switch   вызывает  передачу   управления  на   один "из
нескольких операторов в!зависимости от значения выражения. Он имеет
видJ     switch ( выражение ) оператор
   Выражение  должно быть  целого тип   или типа  указателя.  Любой
оператор внутри  оператора  может  быть (помечен  одним  или  более
префикхом case следующим образом:
     case      константное_выражение :
где константное  выражение должно иметь Іот же тип что и выоажение-
переключатель; производятся  обычные арифметичещкие преобразования.JВ одном операторе {witch никакие две константы, помечбнные!case, не
могут  иметь   одинаковое  значение.  Константные  выражениЯ  рохно
определяются в #15.
  Моцет также бытш не более чем один префикс оператора вида
     default :
  Когда  выполнен   оператор  switch,   проведено  вычисление   его
выражения и  сравне­ие его  с каждой (case константой. Если одна из
констант равни  зеачению выражения,  то  управление  передается  на
ўыраженйе,(следующее  за помошедшим  префиксом case.  Если  никакая
case константа  не сонтветствует выражению, И есть прхфикс default,
то управление  передается на  выражение, котороач  он предшҐствует.
Если нет  соответсвующих вариантов  case  и default`отсутствует, то
никакой из операторов в операворе swatch не выполняется.Ќ
  префиксы  case    и  default  саlи  по  себе! не  изменяют  поток
управления, который  после задерки  идет дальше, перескакивая через
щти пфефиксы. Для выхода из switch см. break, #9.8.
$ Обычно зависящий  от swatch оператор является составным. В голове
этого   оператора   могут   стоЯть   оoисания,   но   инициализации
автоматкческих и регистровых переменных являются безрезультатными.

     9.8 Оператор break

  Оператор
     break ;

                             - стр 301 -

прекращает выполнение  ближайшего охватывающего while,  do, for или
switch   оператора; управление передается на оператор, следующий за
законченным.

     9.9 Оператор continue

  Оператор
  continue ;
вызывает передачу  управления  на  управляющую  продолжением  цикла
часть наименьшего  охватывающего оператора  while, do  или for;  то
есть на конец петли цикла. Точнее, в каждом из операторов

  while (...)         do                  for (...)
    {                   {                   {
      ...                 ...                 ...
      contin:;            contin:;            contin:;
    }                   }                   }
                      while (...);

continue эквивалентно  goto  contin.  (За  contin:  следует  пустой
оператор, #9.13.)

     9.10 Оператор return

  Возврат из  функции  в  вызывающеую  программу  осуществляется  с
помощью оператора return, имеющего один из двух видов:
      return ;
      return выражение ;
   Первый  может использоваться  только в функциях, не возвращающих
значения, т.е.  в функциях  с типом  возвращаемого  значения  void.
Вторая  форма   может  использоваться   только   в   функциях,   не
возвращающих значение;  вызывающей функцию  программе  возвращается
значение выражения.  Если необходимо,  то выражение  преобразуется,
как это  делается при  присваивании, к  типу функции, в которой оно
возникло. Обход  конца функции  эквивалентен  возврату  return  без
возвращаемого значения.

     9.11 Оператор goto

  Можно  осуществлять  безусловную  передачу  упраления  с  помощью
оператора
      goto идентификатор ;
  Идентификатор  должен  быть  меткой    (#9.12),  расположенной  в
текущей функции.

     9.12 Помеченные операторы

  Перед любым оперотором может стоять префикс метка, имеющий вид
     идентификатор :
который  служит   для  описания  идентификатора  как  метки.  Метка
используется только  как объект  для goto. Областью видимости метки

                             - стр 302 -

является текущая  функция, исключая  любой подблок,  в котором  был
переописан такой же идентияикатор. См. #4.1.

     9.13 Пустой оператор

  Пустой оператор имеет вид
     ;
  Пустой оператор  используется для помещения метки непосредственно
перед  }  составного  оператора  или  того,  чтобы  снабдить  такие
операторы, как while, пустым телом.

     9.14 Оператор delete

  Оператор delete имеет вид
     delete выражение ;
  Результатом выражения  должен быть  указатель. Объект, на который
он  указывает,   уничтожается.  Это  значит,  что  после  оператора
уничтожения  delete   нельзя  гарантировать,   что   объект   имеет
определенное значение;  см. #17.  Эффект от  применеия  delete    к
указателю, не  полученному из  операции new   (#7.1),  неопределен.
Однако, уничтожение указателя с нулевым значением безопасно.

     9.15 Оператор asm

  Оператор asm имеет вид
     asm ( строка) ;
  Смысл оператора  asm  неопределен.  Обычно  он  используется  для
передачи информации черз компилятор ассемблеру.

                   10. ВНЕШНИЕ ОПРЕДЕЛЕНИЯ

  Программа  на   C++   состоит   из   последовательности   внешних
определений.  Внешенее   определение  описывает  идентификатор  как
имеющий класс памяти static и определяет его тип. Спецификатор типа
(#8.2) может  также быть  пустым, и  в этом случае принимается  тип
int. Область  видимости внешних  определений простирается  до конца
файла, в  котором  они  описаны,  так  же,  как  действие  описаний
сохраняется до  конца блока.  Синтаксис внешних определений тот же,
что и  у описаний, за исключением того, что только на этом уровне и
внутри описаний  классов может  быть задан  код  (текст  программы)
функции.

     10.1  Определения функций

  Определения функций имеют вид
     определение_функции:
          спецификаторы_описания описатель_функции  opt инициализа-
     тор_базового_класса                                        opt
          тело_функции
  Единственными cпецификаторами класса памяти (sc-cпецификаторами),
допустимыми  среди   спецификаторов  описания,   являются   extern,

                             - стр 303 -

static, overload,   inline  и virtual.   Описатель функции похож на
описатель "функции,  возвращающей ...", за исключением того, что он
включает в  себя имена  формальных параметров определяемой функции.
Описатель функции имеет вид
     описатель_функции:
          описатель ( список_описаний_параметров )
  Форма списка описаний параметров определена в #8.4.  Единственный
класс памяти,  который может  быть  задан,  это  тот,  при  котором
соответствующий фактический  параметр будет  скопирован,  если  это
возможно,  в   регистр  при   входе  в  функцию.  Если  в  качестве
инициализатора для  параметра задано  константное выражение, то это
значение используется как значение параметра по умолчанию.
  Тело функции имеет вид
     тело_функции:
          составной_оператор
  Вот простой пример полного определения функции:

  int max (int a,int b,int c)
    {
      int m = (a > b) ? a : b;
      return  (m > c) ? m : c;
    }

  Здесь int  является спецификатором  типа ; max (int a, int b, int
c) является  описателем функции  ; {  ... }  - блок, задающий текст
программы (код) оператора.
  Поскольку в  контексте выражения  имя (точнее, имя как формальный
параметр) считается означающим указатель на первый элемент массива,
то описания  формальных параметров,  описанных как "массив из ...",
корректируются так, чтобы читалось "указатель на ...".
  Инициализатор базового класса имеет вид
     инициализатор_базового_класса:
          : ( список_параметров opt )
 Он  используется  для  задания  параметров  конструктора  базового
класса в конструкторе производного класса. Например:

  struct base { base (int); ... };
  struct derived : base { derived (int); ... };

  derived.derived (int a) : (a+1) { ... }

  derived d (10);

Конструктор базового  класса вызывается  для объекта d с параметром
11.

     10.2 Определения внешних данных

  Определения внешних данных имеют вид
     определение_данных:
          описание
  Класс памяти таких данных статический.
  Если есть  более одного определения внешних данных одного именеи,
то определения  должны  точно  согласовываться  по  типу  и  классу

                             - стр 304 -

памяти, и  инициализаторы (если  они есть), должны иметь одинаковое
значение.

                11. ПРАВИЛА ОБЛАСТИ ВИДИМОСТИ

  См. #4.1.

              12. КОМАНДНЫЕ СТРОКИ КОМПИЛЯТОРА

  Компилятор языка  C++ содержит  препроцессор, способный выполнять
макроподстановки,  условную   компиляцию  и  включение  именованных
файлов. Строки,  начинающиеся с  #, относятся  к препроцессору. Эти
строки имеют  независимый от  остального языка синтаксис; они могут
появляться   в    любом   месте    оказывать    влияние,    которое
распространяется  (независимо   от  области   видимости)  до  конца
исходного файла программы.
  Заметьте, что  определения const  и inline  дают альтернативы для
большинства использований #define.

     12.1 Замена идентификаторов

  Командная строка компилятора имеет вид
     #define идент строка_символов
вызывает    замену     препроцессором     последующих     вхождений
идентификатора, заданного  строкой символов. Точка с запятой внутри
(или в конце) строки символов является частью этой строки.
  Строка вида
     #define идент( идент , ..., идент ) строка_символов
где отсутсвует  пробел между  первым идентификатором  и (, является
макроопределением  с  параметрами.  Последующие  вхождения  первого
идентификатора с  идущими за  ним (,  последовательностью символов,
разграниченной запятыми, и ), заменяются строкой символов, заданной
в определении.  Каждое местоположение идентификатора, замеченного в
списке параметров  определения, заменяется  соответствующей строкой
из  вызова.   Фактическими  параметрами   вызова  являются   строки
символов,  разделенные   запятыми;   однако   запятые   в   строке,
заключенной  в   кавычки,  или   в  круглых   скобках  не  являются
разделителями параметров. Число формальных и фактических параметров
должно совпадать. Строки и символьные константы в символьной строке
сканируются в поисках формальных параметров, но строки и символьные
константы  в   остальной  программе   не  сканируются   в   поисках
определенных (с помощью define) идентификаторов.
  В обоих  случаях строка  замещения еще  раз сканируется в поисках
других  определнных   идентификаторов.  В   обоих  случаях  длинное
определение может быть продолжено на другой строке с помощью записи
\ в конце продолжаемой строки.
  Командная строка вида
     #undef идент
влечет отмену препроцессорного определения идентификатора.

                             - стр 305 -

     12.2 Включение файлов

  Командная строка компилятора вида
     #include "имя_файла"
вызывает замену  этой строки  полным  содержимым  файла  имя_файла.
Сначала  именованный   файл  ищется  в  директории  первоначального
исходного  файла,  а  затем  в  стандартных  или  заданных  местах.
Альтернативный вариант, командная строка вида
      #include <имя_файла>
производит поиск только в стандартном или заданном месте, и не ищет
в директории  первоначального исходного  файла. (То,  как эти места
задаются, не является частью языка.)
  Включения с помощью #include могут быть вложенными.

     12.3 Условная компиляция

  Командная строка компилятора вида
     #if выражение
проверяет, является  ли результатом  вычисления выражения  не-ноль.
Выражение должно быть константным выражением, которые обсуждаются в
#15;  применительно   к   использованию   данной   директивы   есть
дополнительные  ограничения:   константное   выражение   не   может
содержать sizeof или перечислимые константы. Кроме обычных операций
C     может  использоваться  унарная  операция  defined.  В  случае
применения к  идентификатору она  дает значение  не-ноль, если этот
идентификатор был  ранее определен  с помощью #define и после этого
не было отмены определения с помощью #undef; иначе ее значение 0.
  Командная строка вида
     #ifdef идент
проверяет, определен  ли идентификатор  в  препроцессоре  в  данный
момент; то есть, был ли он объектом командной строки #define.
  Командная строка вида
     #ifndef идент
проверяет, является ли идентификатор неопределенным в препроцессоре
в данный момент.
  После строки  каждого из  трех видов  может  стоять  произвольное
количество строк, возможно, содержащих командную строку
     #else
и далее до командной строки
     #endif
  Если проверенное  условие истинно,  то все  строки между #else  и
#endif игнорируются.  Если проверенное условие ложно, то все строки
между проверкой  и #else  или, в  случае отсутствия  #else, #endif,
игнорируются.
  Эти конструкции могут быть вложенными.

     12.4 Управление строкой

  Для помощи  другим препроцессорам,  генерирующим программы  на C,
строка вида
     #line константа "имя_файла"
заставляет  компилятор   считать,  например,  в  целях  диагностики
ошибок, что константа задает номер следущей строки исходного файла,

                             - стр 306 -

и   текущий    входной   файл   именуется   идентификатором.   Есло
идентификатор отсутствует, то запомненное имя файла не изменяется.

                    13. НЕЯВНЫЕ ОПИСАНИЯ

  См. #8.1.

                       14. ОБЗОР ТИПОВ

  В этом  разделе кратко  собрано описание  действий, которые могут
совершаться над объектами различных типов.

     14.1 Классы

  Классовые объекты  могут присваиваться, передаваться функциям как
параметры и возвращаться функциями. Другие возможные операции, как,
например, проверка  равенства, могут быть определены пользователем;
см. #8.5.10.

     14.2 Функции

  Есть только  две вещи,  которые  можно  проделывать  с  функцией:
вызывать ее  и  брать  ее  адрес.  Если  в  выражении  имя  функции
возникает не  в положении  имени функции  в вызове, то генерируется
указатель на  функцию. Так, для передачи одной функции другой можно
написать

  typedef int (*PF) ();
  extern g (PF);
  extern f ();
  ...
  g (f);

  Тогда определение g может иметь следующий вид:

  g (PF funcp)
    {
      ...
      (*funcp) ();
      ...
    }

  Заметьте, что  f должна быть описана явно в вызывающей программе,
поскольку ее появление в g(f) не сопровождалось (.

     14.3 Массивы, указатели и индексирование

  Всякий раз,  когда  в  выражении  появляется  идентификатор  типа
массива, он преобразуется в указатель на первый член массива. Из-за
преобразований  массивы   не  являются   адресами.  По  определению
операция индексирования  []  интерпретируется  таким  образом,  что

                             - стр 307 -

E1[E2]  идентично   *((E1)+(E2)).  В  силу  правил  преобразования,
применяемых к  +, если E1 массив и E2 целое, то E1[E2] отностится к
E2-ому члену  E1. Поэтому, несмотря на такое проявление асимметрии,
индексирование является коммутативной операцией.
  Это правило  сообразным образом применяется в случае многомерного
массива. Если  E является  n-мерным массивом  ранга i*j*...*k,   то
возникающее в выражении E преобразуется в указатель на (n-1)-мерный
массив ранга j*...*k.  Если к этому указателю, явно или неявно, как
результат индексирования,  применяется операция  *, ее  результатом
является (n-1)-мерный  массив, на  который указывалось, который сам
тут же преобразуется в указатель.
  Рассмотрим, например,

  int x[3][5];

  Здесь x  -  массив  целых  размером  3*5.  Когда  x  возникает  в
выражении, он  преобразуется в указатель на (первый из трех) массив
из 5  целых. В  выражении  x[i],  которое  эквивалентно  *(x+1),  x
сначала  преобразуется,   как  описано,   в  указатель,   затем   1
преобразуется к  типу x,  что включает  в себя умножение 1 на длину
объекта, на  который указывает  указатель, а  именно  объект  из  5
целых. Результаты  складываются, и используется косвенная адресация
для  получения  массива  (из  5  целых),  который  в  свою  очередь
преобразуется в  указатель на  первое из  целых. Если есть еще один
индекс, снова  используется  тот же параметр; на этот раз результат
является целым.
  Именно из всего этого проистекает то, что массивы в C хранятся по
строкам (быстрее  всего  изменяется  последний  индекс),  и  что  в
описании     первый  индекс   помогает  определить   объем  памяти,
поглощаемый  массивом,   но  не   играет  никакой   другой  роли  в
вычислениях индекса.

     14.4 Явные преобразования указателей

  Определенные преобразования,  включающие массивы, выполняются, но
имеют зависящие  от реализации  аспекты. Все они задаются с помощью
явной операции преобразования типов, см. ##7.2 и 8.7.
  Указатель иожет  быть  преобразован  к  любому  из  целых  типов,
достаточно больших  для его  хранения. То,  какой  из  int  и  long
требуется, является  машинно зависимым. Преобразующая функция также
является машинно  зависимой, но предполагается, что она не содержит
сюрпризов  для  того,  кто  знает  структуру  адресации  в  машине.
Подробности для некоторых конкретных машин были даны в #2.6.
  Объект целого  типа может  быть явно  преобразован  в  указатель.
Преобразующая  функция   всегда  превращает  целое,  полученное  из
указателя, обратно  в тот  же указатель,  но  в  остальных  случаях
является машинно зависимой.
  Указатель на  один тип  может быть  преобразован в  указатель  на
другой тип.  Использование результирующего указателя может вызывать
особые ситуации,  если исходный  указатель не  указывает на объект,
соответствующим образом  выравненный в  памяти. Гарантируется,  что
указатель на  объект данного  размера  может  быть  преобразован  в
указатель на объект меньшего размера и обратно без изменений.

                             - стр 308 -

  Например, программа,  выделяющая память, может получать размер (в
байтах) размещаемого  объекта и  возвращать указатель  на char; это
можно использовать следующим образом.

  extern void* alloc ();
  double* dp;

  dp = (double*) alloc (sizeof (double));
  *dp= 22.0 / 7.0;

alloc   должна обеспечивать  (машинно зависимым  образом)  то,  что
возвращаемое ею значение подходит для преобразования в указатель на
double;   в этом  случае использование  функции мобильно. Различные
машины различаются  по числу  бит  в  указателях  и  требованиям  к
выравниванию объектов.  Составные объекты  выравниваются  по  самой
строгой границе, требуемой каким-либо из его составляющих.

                  15. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ

  В нескольких  местах C++  требует выражения,  вычисление  которых
дает  константу:   в  качестве   границы  массива  (#8.3),  в  case
выражениях  (#9.7),   в  качестве   значений  параметров   функции,
присваиваемых по  умолчанию, (#8.3),  и в инициализаторах (#8.6). В
первом случае  выражение может  включать  только  целые  константы,
символьные константы,  константы, описанные  как  имена,  и  sizeof
выражения, возможно, связанные бинарными операциями

   + - * / % & | ^ << >> == != < > <= >= && ||

 или унарными операциями

  - ~ !

или тернарными операциями

  ? :

  Скобки могут  использоваться для  группирования, но не для вызова
функций.
  Большая   широта    допустима   для    остальных   трех   случаев
использования; помимо  константных выражений,  обсуждавшихся  выше,
допускаются константы  с плавающей  точкой, и можно также применять
унарную операцию  & к  внешним  или  статическим  объектам,  или  к
внешним  или   статическим  массивам,  индексированным  константным
выражением. Унарная  операция & может также быть применена неявно с
помощью употребления неиндексированных массивов и функций. Основное
правило состоит  в том,  что инициализаторы  должны при  вычислении
давать  константу   или  адрес   ранее  описанного   внешнего   или
статического обйекта плюс или минус константа.
  Меньшая широта  допустима для  константных выражений  после  #if:
константы, описанные  как имена,  sizeof выражения  и  перечислимые
константы недопустимы.

                             - стр 309 -

                 16. СООБРАЖЕНИЯ МОБИЛЬНОСТИ

  Определенные части C++ являются машинно зависимыми по своей сути.
Следующий ниже  список мест  возможных затруднений не претендует на
полноту, но может указать на основные из них.
  Как показала  практика, характеристики  аппаратуры в чистом виде,
такие, как  размер слова,  свойства плавающей  арифметики и  целого
деления, не  создают  особых  проблем.  Другие  аппаратные  аспекты
отражаются на  различных программных разработках. Некоторые из них,
особенно знаковое расширение (преобразование отрицательного символа
в отрицательное  целое) и  порядок  расположения  байтов  в  слове,
являются досадными  помехами, за  которыми надо  тщательно следить.
Большинство других являются всего лишь мелкими сложностями.
  Число  регистровых  переменных,  которые  фактически  могут  быть
помещены  в  регистры,  различается  от  машины  к  машине,  как  и
множество фактических  типов. Тем  не  менее,  все  компиляторы  на
"своей" машине  все делают  правильно; избыточные или недействующие
описания register игнорируются.
  Некоторые сложности  возникают  при  использовании  двусмысленной
манеры программирования.  Писать программы, зависящие от какой-либо
из этих особенностей, райне неблагоразумно.
  В языке  неопределен порядок  вычисления параметров  функции.  На
некоторых машинах  он слева  направо, а на некоторых справо налево.
Порядок    появления     некотрых    побочных     эффектов    также
недетерминирован.
  Поскольку  символьные   константы  в   действительности  являются
объектами  типа   int,  то  могут  быть  допустимы  многосимвольные
константы. Однако  конкретная реализация  очень сильно  зависит  от
машины, поскольку  порядок, в  котором символы присваиваются слову,
различается от  машины к  машине. На некоторых машинах поля в слове
присваиваются слева направо, на других справо налево.
  Эти различия  невидны для отдельных программ, не позволяющих себе
каламбуров с  типами (например, преобразования int указателя в char
указатель и  просмотр памяти,  на которую  указывает указатель), но
должны приниматься во внимание при согласовании внешне предписанных
форматов памяти.

                    17. СВОБОДНАЯ ПАМЯТЬ

  Операция new (#7.2) вызывает функцию

  extern void* _new (long);

для получения  памяти.  Параметр  задает  число  требуемых  байтов.
Память будет  инициализирована. Если  _new не может найти требуемое
количество памяти, то она возвращает ноль.
  Операция delete вызывает функцию

   extern void _delete (void*);

чтобы  освободить  память,  указанную  указателем,  для  повторного
использования. Результат  вызова _delete()   для указателя, который
не был  получен из  _new(),  неопределен,  это  же  относится  и  к
повторному вызову  _delete() для одного и того же указателя. Однако
уничтожение с помощью delete указателя со значением ноль безвредно.

                             - стр 310 -

  Предоставляются  стандартные   версии  _new()   и  _delete(),  но
пользователь  может   применять  другие,   более   подходящие   для
конкретных приложений.
  Когда с  помощью операции  new создается классовый объект, то для
получения   необходимой    памяти   конструктор    будет   (неявно)
использовать new.  Конструктор может  осуществить свое  собственное
резервирование памяти  посредством присваивания  указателю this  до
каких-либо использований. С помощью присваивания this значения ноль
деструктор может  избежать  стандартной  операции  дерезервирования
памяти для объекта его класса. Например:

  class cl
    {
      int v[10];
      cl () { this = my_own_allocator (sizeof (cl)); }
      ~cl () { my_own_deallocator (this); this = 0; }
    }

  На  входе   в   конструктор   this   являеется   не-нулем,   если
резервирование памяти  уже имело  место (как  это имеет  место  для
автоматических объектов), и нулем в остальных случаях.
  Если производный  класс осуществляет  присваивание this, то вызов
конструктора (если он есть) базового класса будет иметь место после
присваивания, так  что конструктор  базового  класса  ссылаться  на
объект   посредством   конструктора   производного   класса.   Если
конструктор базового  класса  осуществляет  присваивание  this,  то
значение также  будет использоваться  конструктором  (если  таковой
есть)  производного класса.

              18. КРАТКОЕ ИЗЛОЖЕНИЕ СИНТАКСИСА

  Мы надеемся,  что эта  краткая сводка  синтаксиса    C++  поможет
пониманию. Она не является точным изложением языка.

     18.1 Выражения

     выражение:
          терм
          выражение           бинарная_операция           выражение
          выражение       ?       выражение       :       выражение
          список_выражений
     терм:
          первичный
          *                                                    терм
          &                                                    терм
          -                                                    терм
          !                                                    терм
          ~                                                    терм
          ++терм
          --терм
          терм++
          терм--
          (                   имя_типа)                   выражение
          имя_простого_типа           (           список_выражений)

                             - стр 311 -

          sizeof                                          выражение
          sizeof             (              имя_типа              )
          new                                              имя_типа
          new ( имя_типа )
     первичный:
          id
          ::                                          идентификатор
          константа
          строка
          this
          (                       выражение                       )
          первичный[                  выражение                   ]
          первичный      (       список_выражений       opt       )
          первичный.id
          первичный->id
     id:
          идентификатор
          typedef-имя :: идентификатор
     список_выражений:
          выражение
          список_выражений, выражение
     операция:
          унарная_операция
          бинарная_операция
          специальная_операция
  Бинарные операции имеют приоритет, убывающий в указанном порядке:
     бинарная_операция:
          *                          /                            %
          +                                                       -
          <<                                                     >>
          <                                                       >
          ==                                                     !=
          &
          ^
          |
          &&
          ||
          =   +=  -=  *=  /=  %=  ^=  &=  |=  >>=  <<=
                                                  унарная_операция:
           *   &   -   ~   !   ++   --
     специальная_операция:
          ()       []
     имя_типа:
          спецификаторы_описания абстрактный_описатель
     абстрактный_описатель:
          пустой
          *                                   абстрактный_описатель
          абстрактный_описатель  (   список_описаний_параметров   )
          абстрактный_описатель  [   константное_выражение  opt   ]
          ( абстрактный_описатель )
     простое_имя_типа:
          typedef-имя
          char
          short
          int
          long

                             - стр 312 -

          unsigned
          float
          double
     typedef-имя:
          идентификатор

     18.2 Описания

     описание:
          спецификаторы_описания  opt   список_описателей   opt   ;
          описание_имени
          asm-описание
     описание_имени:
          агрег                   идентификатор                   ;
          enum  идентификатор ;
     агрег:
          class
          struct
          union
     asm-описание:
          asm ( строка );
     спецификаторы_описания:
          спецификатор_описания спецификатор_описания opt
     спецификатор_описания:
          имя_простого_типа
          спецификатор_класса
          enum_спецификатор
          sc_спецификатор
          фнк_спецификатор
          typedef
          friend
          const
          void
     sc_спецификатор:
          auto
          extern
          register
          static
     фнк-спецификатор:
          inline
          overload
          virtual
     список_описателей:
          иниц-описатель
          иниц-описатель , список_описателей
     иниц-описатель:
          описатель инициализатор opt
     описатель:
          оп_имя
          (                       описатель                       )
          *             const             opt             описатель
          &             const             opt             описатель
          описатель      (       список_описаний_параметров       )
          описатель [ константное_выражение opt ]

                             - стр 313 -

     оп_имя:
          простое_оп_имя
          typedef-имя . простое_оп_имя
     простое_оп_имя:
          идентификатор
          typedef-имя
          -                                             typedef-имя
          имя_функции_операции
     имя_функции_операции:
          операция операция

                             - стр 314 -

     список_описаний_параметров:
          список_описаний_прм opt ... opt
     список_описаний_прм                                          :
          список_описаний_прм         ,          описание_параметра
          описание_параметра
     описание_параметра:
          спецификаторы_описания                          описатель
          спецификаторы_описания описатель = константное_выражение
     спецификатор_класса:
          заголовок_класса       {список_членов        opt        }
          заголовок_класса    {список_членов     opt    public    :
     список_членов opt }
     заголовок_класса                                             :
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     список_членов                                                :
          описание_члена список_членов opt
     описание_члена:
          спецификаторы_описания opt описатель_члена ;
     описатель_члена:
          описатель
          идентификатор opt : константное_выражение
     инициализатор:
          =                                               выражение
          =                {                список_инициализаторов}
          =       {        список_инициализаторов,                }
          (список_выражений )
     список_инициализаторов                                       :
          выражение
          список_инициализаторов        ,    список_инициализаторов
          { список_инициализаторов }
     enum-спецификатор:
          enum идентификатор opt { enum-список }
     enum-список:
          перечислитель
          enum-список , перечислитель
     перечислитель:
          идентификатор
          идентификатор = константное_выражение

     18.3 Операторы

     составной_оператор:
          { список_описаний opt список_операторов opt }
     список_описаний:
          описание
          описание список_описаний
     список_операторов:
          оператор
          оператор список_операторов
     оператор:
          выражение                                               ;
          if         (         выражение         )         оператор
          if    (    выражение    )    оператор    else    оператор
          while        (         выражение        )        оператор

                             - стр 315 -

          do     оператор     while     (     выражение     )     ;
          for (  выражение opt  ; выражение  opt ;  выражение opt )
               оператор
          switch        (        выражение        )        оператор
          case      константное      выражение      :      оператор
          default                    :                     оператор
          break;
          continue;
          return            выражение             opt             ;
          goto                   идентификатор                    ;
          идентификатор                 :                  оператор
          delete                    выражение                     ;
          asm           (            строка           )           ;
          ;

     18.4 Внешние определения

     программа:
          внешнее_определение
          внешнее_определение программа
     внешнее_определение:
          определение_функции
          описание
     определение_функции:
          спецификаторы_описания       opt        описатель_функции
     инициализатор_базового_класса opt тело_функции
     описатель_функции:
          описатель ( список_описаний_параметров)
     тело_функции:
          составной_оператор
     инициализатор_базового_класса:
          : ( список_параметров opt )

     18.5 Препроцессор

     #define идент строка_символов
     #define идент( идент,...,идент ) строка символов
     #else
     #endif
     #if выражение
     #ifdef идент
     #ifndef идент
     #include "имя_файла"
     #include <имя_файла>
     #line константа "имя_файла"
     #undef идент

                             - стр 316 -

                 19. ОТЛИЧИЯ ОТ "СТАРОГО C"

     19.1 Расширения

  Типы  параметров   функции  могут  быть  заданы  (#8.4)  и  будут
проверяться (#7.1). Могут выполняться преобразования типов.
  Для выражений  с числами  с плавающей точкой может использоваться
плавающая арифметика одинарной точности; #6.2.
  Имена функций могут быть перегружены; #8.6
  Операции могут быть перегружены; 7.16, #8.5.10.
  Может осуществляться inline-подстановка функций; #8.1.
  Объекты данных могут быть константными (const); #8.3.
  Могут быть описаны объекты ссылочного типа; #8.3, #8.6.3
  Операции new  и delete  обеспечивают свободное хранение в памяти;
#17.
  Класс может обеспечивать скрытые данные (#8.5.8), гарантированную
инициализацию (#8.6.2),  оперделяемые  пользователем  преобразвания
(#8.5.6),  и (74лeдЮКз`пЄНU@$§джўН‰зѕ‚#гc«ев((’фрщҐ0y ­жЌкшЁ&kрxПмД/рЎК“jЛэ¤kхµл+lґИ¦#и+5< j. Ѕјdv‚и»eбиt NдиsБТУ“А©$¤Eн¬2юmП@KaH|*ч­Њ
!$ЂяЭЏ‰!a"вdчЂ2енXCб йкДЇp!$m0ДшІґкИ‚б„Рz "1›кдfъЫейЮg`"|gмж*` ·vзКярыMm†µй *цаЁ~к:‹j1107	