                      Мюррэй Хилл, Нью Джерси      Бьярн Страустрап
			Язык C++

     Содержание                                         1

Предисловие                                                8
        Благодарности                                      8
Заметки для читателя                                      10
        Структура этой книги                              10
        Замечания по реализации                           11
        Упражнения                                        11
        Замечания по проекту языка                        11
        Исторические замечания                            12
        Эффективность и структура                         13
        Философские замечания                             15
        Размышления о программировании на C++             15
        Правила правой руки                               17
        Замечания для программистов на C                  17
Глава 1
        Турне по C++                                      18
    1.1 Введение                                          18
        1.1.1 Вывод                                       18
        1.1.2 Компиляция                                  19
        1.1.3 Ввод                                        20
         1.2 Комментарии                                  21
    1.3 Типы и Описания                                   21
        1.3.1 Основные Tипы                               21
        1.3.2 Производные Типы                            23
    1.4 Выражения и Операторы                             23
        1.4.1 Выражения                                   23
        1.4.2 Операторы Выражения                         24
        1.4.3 Пустой оператор                             24
        1.4.4 Блоки                                       24
        1.4.5 Операторы if                                25
        1.4.6 Операторы switch                            25
        1.4.7 Оператор while                              26
        1.4.8 Оператор for                                26
        1.4.9 Описания                                    27
    1.5 Функции                                           27
    1.6 Структура программы                               28
    1.7 Классы                                            30
    1.8 Перегрузка операций                               31
    1.9 Ссылки                                            32
    1.10 Конструкторы                                     33
    1.11 Вектора                                          34
    1.12 Inline-подстановка                               35
    1.13 Производные  классы                              36
    1.14 Еще об операциях                                 37
    1.15 Друзья (friend)                                  39
    1.16 Обобщенные Вектора                               40
    1.17 Полиморфные Вектора                              40
    1.18 Виртуальные функции                              42
Глава 2
        Описания и Константы                              43
    2.1 Описания                                          43
        2.1.1 Область Видимости                           44
        2.1.2 Объекты и Адреса (Lvalue)                   46

        2.1.3 Время Жизни                                 46
    2.2 Имена                                             47
    2.3 Типы                                              47
        2.3.1 Основные Типы                               48
        2.3.2 Неявное Преобразование Типа                 49
        2.3.3 Производные Типы                            50
        2.3.4 Тип void                                    51
        2.3.5 Указатели                                   51
        2.3.6 Вектора                                     52
        2.3.7 Указатели и Вектора                         54
        2.3.8 Структуры                                   55
        2.3.9 Эквивалентность типов                       57
        2.3.10 Ссылки                                     58
        2.3.11 Регистры                                   60
    2.4 Константы                                         61
        2.4.1 Целые Константы                             61
        2.4.2 Константы с Плавающей Точкой                62
        2.4.3 Символьные Константы                        62
        2.4.4 Строки                                      63
        2.4.5 Ноль                                        64
        2.4.6 Const                                       64
        2.4.7 Перечисления                                65
    2.5 Экономия Пространства                             66
        2.5.1 Поля                                        66
        2.5.2 Объединения                                 67
    2.6 Упражнения                                        69
Глава 3
        Выражения и операторы                             71
    3.1 Настольный калькулятор                            71
        3.1.1 Программа синтаксического разбора           71
        3.1.2 Функция ввода                               76
        3.1.3 Таблица имен                                78
        3.1.4 Обработка ошибок                            80
        3.1.5 Драйвер                                     81
        3.1.6 Параметры командной строки                  82
    3.2 Краткая сводка операций                           83
        3.2.1 Круглые скобки                              85
        3.2.2 Порядок вычисления                          85
        3.2.2 Увеличение и уменьшение*                    86
        3.2.4 Побитовые логические операции               87
        3.2.5 Преобразование типа                         88
        3.2.6 Свободная память                            89
    3.3 Сводка операторов                                 92
        3.3.1 Проверки                                    93
        3.3.2 Goto                                        95
    3.4 Комментарии и Выравнивание                        96
    3.5 Упражнения                                        97
Глава 4
        Функции и Файлы                                  100
    4.1 Введение                                         100
    4.2 Компоновка                                       101
    4.3 Заголовочные Файлы                               102
        4.3.1 Один Заголовочный Файл                     104
        4.3.2 Множественные Заголовочные Файлы           107
        4.3.3 Скрытие Данных                             109
        4.4 Файлы как Модули                             110
    4.5 Как Создать Библиотеку                           111
    4.6 Функции                                          112
        4.6.1 Описания Функций                           112
        4.6.2 Определения Функций                        112
        4.6.3 Передача Параметров                        113
        4.6.4 Возврат Значения                           114
        4.6.5 Векторные Параметры                        115
        4.6.6 Параметры по Умолчанию                     116
        4.6.7 Перегрузка Имен Функций                    117
        4.6.8 Незаданное Число Параметров                119
        4.6.9 Указатель на Функцию                       120
    4.7 Макросы                                          124
    4.8 Упражнения                                       125
Глава 5
        Классы                                           128
    5.1 Знакомство и краткий обзор                       128
    5.2 Классы и Члены                                   129
        5.2.1 Функции Члены                              129
        5.2.2 Классы                                     130
        5.2.3 Ссылки на Себя                             131
        5.2.4 Инициализация                              132
        5.2.5 Очистка                                    134
        5.2.6  Inline                                    135
    5.3 Интерфейсы и Реализации                          135
        5.3.1 Альтернативные Реализации                  136
        5.3.2 Законченный Класс                          139
    5.4 Друзья и Объединения                             142
        5.4.1 Друзья                                     142
        5.4.2 Уточнение* Имени Члена                     144
        5.4.3 Вложенные Классы                           144
        5.4.4 Статические Члены                          145
        5.4.5 Указатели на Члены                         146
        5.4.6 Структуры и Объединения                    147
    5.5 Конструкторы и Деструкторы                       149
        5.5.1 Предостережение                            150
        5.5.2 Статическая Память                         150
        5.5.3 Свободная Память                           152
        5.5.4 Объекты Класса и Члены                     152
        5.5.5 Вектора Объектов Класса                    154
        5.5.6 Небольшие Объекты                          155
        5.5.7 Предостережение                            156
        5.5.8 Объекты Переменного Размера                157
    5.6 Упражнения                                       158
Глава 6
        Перегрузка Операций                              160
    6.1 Введение                                         160
    6.2 Функции Операции                                 161
        6.2.1 Бинарные и Унарные Онерации                161
        6.2.2 Предопределенные Значения Операций         162
        6.2.3 Операции и Определяемые Пользователем Типы 162
    6.3 Определяемое Преобразование Типа                 163
        6.3.1 Конструкторы                               164
        6.3.2 Операции Преобразования                    164
        6.3.3 Неоднозначности                            166
    6.4 Константы                                        167
    6.5 Большие Объеты                                   167
    6.6 Присваивание и Инициализация                     168
    6.7 Индексирование                                   170
    6.8 Вызов Функции                                    172
    6.9 Класс Строка                                     173
    6.10 Друзья и Члены                                  177
    6.11 Предостережение                                 177
    6.12 Упражнения                                      178
Глава 7
        Производные Классы                               181
    7.1 Введение                                         181
    7.2 Производные Классы                               182
        7.2.1 Построение Производного Класса             182
        7.2.2 Функции Члены                              183
        7.2.3 Видимость                                  184
        7.2.4 Указатели                                  186
        7.2.5 Иерархия Типов                             187
        7.2.6 Конструкторы и Деструкторы                 187
        7.2.7 Поля Типа                                  188
        7.2.8 Виртуальные Функции                        190
    7.3 Альтернативные Интерфейсы                        192
        7.3.1 Интерфейс                                  192
        7.3.2 Реализация                                 193
        7.3.3 Как Этим Пользоваться                      194
        7.3.4 Обработка Ошибок                           196
        7.3.5 Обобщенные Классы                          197
        7.3.6 Ограниченные Интерфейсы                    199
    7.4 Добавление к Классу                              199
    7.5 Неоднородные Списки                              201
    7.6 Законченна Программа                             201
        7.6.1 Администратор Экрана                       201
        7.6.2 Библиотека Фигур                           203
        7.6.3 Прикладная Программа                       207
    7.7 Свободная Память                                 209
    7.8 Упражнения                                       210
Глава 8
        Потоки                                           212
    8.1 Введение                                         212
    8.2 Вывод                                            213
        8.2.1 Вывод Встроенных Типов                     213
        8.2.2 Вывод Типов, Определяемых Пользователем    214
        8.2.3 Некоторые Подробности Разработки           214
        8.2.4 Форматированный Вывод                      216
        8.2.5 Виртуальная Функция Вывода                 218
    8.3 Файлы и Потоки                                   219
        8.3.1 Инициализация Потоков Вывода               219
        8.3.2 Закрытие Потоков Вывода                    220
        8.3.3 Открытие Файлов                            220
        8.3.4 Копирование Потоков                        221
    8.4 Ввод                                             221
        8.4.1 Ввод Встроенных Типов                      221
        8.4.2 Состояния Потока                           223
        8.4.3 Ввод Типов, Определяемых Пользователем     224
        8.4.4 Инициализация Потоков Ввода                225
    8.5 Работа со Строками                               226
    8.6 Буферизация                                      226
    8.7 Эффективность                                    228
    8.8 Упражнения                                       228
1. ВВЕДЕНИЕ                                              230
2. ДОГОВОРЕННОСТИ О ЛЕКСИКЕ                              230
    2.1 Комментарии                                      230
    2.2 Идентификаторы (имена)                           230
    2.3 Ключевые слова                                   230
    2.4 Константы                                        231
        2.4.1 Целые константы                            231
        2.4.2 Явно заданные длинные константы            231
        2.4.3 Символьные константы                       231
        2.4.4 Константы с плавающей точкой               232
        2.4.5 Перечислимые константы                     232
        2.4.6 Описанные константы                        232
    2.5 Строки                                           232
    2.6 Харктеристики аппаратного обеспечения            232
3. ЗАПИСЬ СИНТАКСИСА                                     233
4. ИМЕНА И ТИПЫ                                          233
    4.1 Область видимости                                234
    4.2 Определения                                      234
    4.3 Компоновка                                       234
    4.4  Классы памяти                                   235
    4.5 Основные типы                                    236
    4.4 Производные типы                                 236
5.  ОБЪЕКТЫ И LVALUE(АДРЕСА)                             237
6.  ПРЕОБРАЗОВАНИЯ                                       237
    6.1 Символы и целые                                  237
    6.2 Float и double                                   237
    6.3 Плавающие и целые                                237
    6.4 Указатели и целые                                238
    6.5 Unsigned                                         238
    6.6 Арифметические преобразования                    238
    6.7 Преобразования указателей                        239
    6.8 Преобразования ссылок                            239
7. ВЫРАЖЕНИЯ                                             239
    7.1 Основные выражения                               240
    7.2 Унарные операции                                 241
        7.2.1 Увеличение и Уменьшение                    242
        7.2.2 Sizeof                                     242
        7.2.3 Явное Преобразование Типа                  243
        7.2.4 Свободная Память                           243
    7.3 Мультипликативные операции                       244
    7.4 Аддитивные операции                              244
    7.5 Операции сдвига                                  245
    7.6 Операции отношения                               245
    7.7 Операции равенства                               246
    7.8 Операция побитовое И                             246
    7.9 Операция побитовое исключающее ИЛИ               246
    7.10 Операция побитовое включающее ИЛИ               246
    7.11 Операция логическое И                           246
    7.12 Операция логическое ИЛИ                         246
    7.13 Условная операция                               247
    7.14 Операции присваивания                           247
    7.15 Операция запятая                                247
    7.16 Перегруженные операции                          248
        7.16.1 Унарные операции                          248
        7.16.2 Бинарные операции                         248
        7.16.3 Особые операции                           248
8. ОПИСАНИЯ                                              249
    8.1 Спецификаторы класса памяти                      249
    8.2 Спецификаторы Типа                               250
    8.3 Описатели                                        251
    8.4 Смысл описателей                                 252
        8.4.1 Примеры                                    254
    8.5 Описания классов                                 256
        8.5.1 Статические члены                          257
        8.5.2 Функции члены                              257
        8.5.3 Производные классы                         259
        8.5.4 Виртуальные функции                        259
        8.5.5 Конструкторы                               260
        8.5.6 Преобразования                             261
        8.5.7 Деструкторы                                261
        8.5.8 Видимость имен членов                      261
        8.5.9 Друзья (friends)                           262
        8.5.10 Функция операция                          263
        8.5.11 Структуры                                 263
        8.5.12 Объединения                               263
        8.5.13 Поля бит                                  263
        8.5.14 Вложенные классы                          264
    8.6 Инициализация                                    264
        8.6.1 Список инициализаторов                     265
        8.6.2 Классовые объекты                          266
        8.6.3 Ссылки                                     266
        8.6.4 Массивы символов                           267
    8.7 Имена типов                                      267
    8.8 Определение типа typedef                         268
    8.9 Перегруженные имена функций                      269
    8.10 Описание перечисления                           270
    8.11 Описание Asm                                    270
9. ОПЕРАТОРЫ                                             271
    9.1 Оператор выражение                               271
    9.2 Составной оператор, или блок                     271
    9.3 Условный оператор                                271
    9.4 Оператор while                                   271
    9.5 Оператор do                                      272
    9.6 Оператор for                                     272
    9.7 Оператор switch                                  273
    9.8 Оператор break                                   273
    9.9 Оператор continue                                274
    9.10 Оператор return                                 274
    9.11 Оператор goto                                   274
    9.12 Помеченные операторы                            274
    9.13 Пустой оператор                                 274
    9.14 Оператор delete                                 275
    9.15 Оператор asm                                    275
10. ВНЕШНИЕ ОПРЕДЕЛЕНИЯ                                  275
    10.1  Определения функций                            275
    10.2 Определения внешних данных                      276
11. ПРАВИЛА ОБЛАСТИ ВИДИМОСТИ                            276
12. КОМАНДНЫЕ СТРОКИ КОМПИЛЯТОРА                         276
    12.1 Замена идентификаторов                          277
    12.2 Включение файлов                                277
    12.3 Условная компиляция                             277
    12.4 Управление строкой                              278
13. НЕЯВНЫЕ ОПИСАНИЯ                                     278
14. ОБЗОР ТИПОВ                                          278
    14.1 Классы                                          278
    14.2 Функции                                         278
    14.3 Массивы, указатели и индексирование             279
    14.4 Явные преобразования указателей                 279
15. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ                                280
16. СООБРАЖЕНИЯ МОБИЛЬНОСТИ                              281
17. СВОБОДНАЯ ПАМЯТЬ                                     281
18. КРАТКОЕ ИЗЛОЖЕНИЕ СИНТАКСИСА                         282
    18.1 Выражения                                       282
    18.2 Описания                                        283
    18.3 Операторы                                       285
    18.4 Внешние определения                             286
    18.5 Препроцессор                                    286
19. ОТЛИЧИЯ ОТ "СТАРОГО C"                               286
    19.1 Расширения                                      286

                         Предисловие

                                 Язык формирует наш способ мышления
                              и определяет, о чем мы можем мыслить.

                                                          Б.Л. Ворф

  C++ -  универсальный язык программирования, задуманный так, чтобы
сделать   программирование    более   приятным    для    серьезного
программиста. За  исключением второстепенных  деталей C++  является
надмножеством  языка   программирования  C.   Помимо  возможностей,
которые дает  C, C++  предоставляет гибкие  и эффективные  средства
определения новых  типов. Используя  определения новых типов, точно
отвечающих  концепциям   приложения,  программист  может  разделять
разрабатываемую программу  на  легко  поддающиеся  контролю  части.
Такой метод  построения программ часто называют абстракцией данных.
Информация  о   типах  содержится   в  некоторых   объектах  типов,
определенных  пользователем.  Такие  объекты  просты  и  надежны  в
использовании в  тех ситуациях,  когда их  тип нельзя установить на
стадии компиляции.  Программирование с  применением таких  объектов
часто    называют    объектно-ориентированным.    При    правильном
использовании этот  метод дает  более короткие,  проще понимаемые и
легче контролируемые программы.
  Ключевым  понятием   C++  является   класс.  Класс   -  это  тип,
определяемый пользователем.  Классы  обеспечивают  скрытие  данных,
гарантированную инициализацию  данных, неявное преобразование типов
для типов,  определенных пользователем,  динамическое задание типа,
контролируемое  пользователем   управление  памятью   и   механизмы
перегрузки операций.  C++ предоставляет  гораздо лучшие,  чем в  C,
средства выражнения модульности программы и проверки типов. В языке
есть  также  усовершенствования,  не  связанные  непосредственно  с
классами,  включающие   в  себя  символические  константы,  inline-
подстановку функций,  параметры функции по умолчанию, перегруженные
имена функций,  операции управления  свободной памятью  и ссылочный
тип. В  C++ сохранены  возможности языка  C по  работе с  основными
объектами аппаратного  обеспечения (биты,  байты, слова,  адреса  и
т.п.).  Это   позволяет  весьма   эффективно  реализовывать   типы,
определяемые пользователем.
  C++  и  его  стандартные  библиотеки  спроектированы  так,  чтобы
обеспечивать переносимость.  Имеющаяся на текущий момент реализация
языка будет  идти в  большинстве систем,  поддерживающих C.  Из C++
программ  можно   использовать  C   библиотеки,  и   с  C++   можно
использовать большую часть инструментальных средств, поддерживающих
программирование на C.
  Эта книга  предназначена главным  образом для  того, чтобы помочь
серьезным  программистам   изучить   язык   и   применять   его   в
нетривиальных проектах.  В ней  дано  полное  описание  C++,  много
примеров и еще больше фрагментов программ.

     Благодарности

  C++  никогда   бы   не   созрел  без  постоянного  использования,
предложений и  конструктивной критики  со стороны  многих друзей  и
                              - стр 9 -

коллег. Том  Карджил, Джим Коплин, Сту Фельдман, Сэнди Фрэзер, Стив
Джонсон, Брайэн Керниган, Барт Локанти, Дуг МакИлрой, Дэннис Риччи,
Лэрри Рослер, Джерри Шварц и Джон Шопиро подали важные для развития
языка идеи.  Дэйв Пресотто  написал текущую  реализацию  библиотеки
потоков ввода/вывода.
  Кроме того, в развитие C++ внесли свой вклад сотни людей, которые
присылали   мне   предложения   по   усовершенствованию,   описания
трудностей, с  которыми они  сталкивались,  и  ошибки  компилятора.
Здесь я  могу упомянуть  лишь немногих  из них:  Гэри Бишоп,  Эндрю
Хьюм, Том Карцес, Виктор Миленкович, Роб Мюррэй, Леони Росс, Брайэн
Шмальт и Гарри Уокер.

  В издании этой книги мне помогли многие люди, в частности, Джон
Бентли, Лаура Ивс, Брайэн Керниган, Тэд Ковальски, Стив Махани,
Джон Шопиро и участники семинара по C++, который проводился в Bell
Labs, Колумбия, Огайо, 26-27 июня 1985 года.

                      Мюррэй Хилл, Нью Джерси      Бьярн Страустрап

                       Заметки для читателя

                                   "О многом,"-молвил Морж,-"Пришла
                                                  пора поговорить."

                                                          Л. Кэррол

  В этой  главе содержится  обзор книги,  список  библиографических
ссылок и  некоторые замечания  по C++  вспомогательного  характера.
Замечания  касаются   истории  C++,   идей,  оказавших  влияние  на
разработку C++,  и мыслей  по поводу  программирования на  C++. Эта
глава  не   является  введением:  замечания  не    обязательны  для
понимания последующих  глав, и некоторые из них предполагают знание
C++.

     Структура этой книги

  Глава 1  - это  короткое  турне  по  основным  особенностям  C++,
предназначенное для  того, чтобы  дать читателю почувствовать язык.
Программисты на  C первую  половину  главы  могут  прочитать  очень
быстро; она охватывает главным образом черты, общие для C и C++. Во
второй главе  описаны  средства  определения  новых  типов  в  C++;
начинающие могут  отложить более  подробное изучение этого до того,
как прочтут Главы 2, 3 и 4.
  В Главах  2, 3  и 4  описываются средства  C++, не  включенные  в
определение новых  типов:  основные  типы,  выражения  и  структуры
управления в  C++ программах.  Другими словами,  в них  описывается
подмножество  C++,   которое  по   существу  является   языком   C.
Рассмотрение  в   них  проводится   гораздо  подробнее,  но  полную
информацию можно найти только в справочном руководстве.
  В Главах  5, 6  и 7  описываются средства  C++ по  описанию новых
типов, особенности  языка, не  имеющие эквивалента  в C.  В Главе 5
приводится понятие  базового  класса,  и  показывается,  как  можно
инициализировать   объекты   типа,   определенного   пользователем,
обращаться к ним и, наконец, убирать их. В Главе 6 объясняется, как
для определенного  пользователем типа определять унарные и бинарные
операции, как  задавать преобразования  между типами, определенными
пользователем,  и   как  как  задавать  то,  каким  образом  должно
обрабатываться каждое  создание, уничтожение и копирование значения
определенного  пользователем  типа.  Глава  7  описывает  концепцию
производных классов,  которая позволяет  программисту строить более
сложные  классы   из  более  простых,  обеспечивать  альтернативные
интерфейсы класса  и работать с объектами безопасным и не требующим
беспокоиться о  типе способом  в тех ситуациях, когда типы объектов
не могут быть известны на стадии компиляции.
  В Главе  8 представлены классы ostream и istream, предоставляемые
стандартной библиотекой  для осуществления  ввода-вывода. Эта глава
имеет двоякую  цель: в  ней  представлены  полезные  средства,  что
одновременно является реальным примером использования C++.
  И, наконец, в книгу включено справочное руководство по C++.
  Ссылки на различные части этой книги даются в форме #2.3.4 (Глава
2 подраздел  3.4). Глава  с - это справочное руководство; например,
#с.8.5.5.
                             - стр 11 -

     Замечания по реализации

  Во время  написания этой  книги все  реализации C++  использовали
версии единственного интерфейсного компилятора#. Он используется на
многих   архитектурах,    включая   действующие    версии   системы
операционной системы  UNIX на AT&T 3B, DEC VAX, IBM 370 и Motorolla
68000. Фрагменты  программ, которые  приводятся в этой книге, взяты
непосредственно  из  исходных файлов, которые компилировались на 3B
в UNIX  System V  версии 2  [15], VAX11/750 под 8-ой Редакцией UNIX
[16] и  CCI Power 6/32 под BSD4.2 UNIX [17]. Язык, описанный в этой
книге,  -   это  "чистый  C++",  но  имеющиеся  на  текущий  момент
компиляторы реализуют  большое число  "анахронизмов"  (описанных  в
#с.15.3), которые должны способствовать переходу от C к C++.

     Упражнения

  Упражнения находятся в конце глав. Все упражнения главным образом
типа напишите-программу. Для решения всегда пишите такую прогармму,
которая  будет  компилироваться  и  работать  по  меньшей  мере  на
нескольких тестовых  случаях. Упражнения  различаются в основном по
сложности, поэтому  они помечены  оценкой степени  сложности. Шкала
экспоненциальная, так  что если на упражение (*1) вам потребовалось
пять минут,  то упражнение  (*2) вам может  потребоваться час, а на
(*3) -  день. Время,  которое требуется  на то,  чтобы  написать  и
оттестировать программу,  зависит больше  от опыта читателя, нежели
от самого  упражения. Упражнение  (*1) может  отнять день, если для
того, чтобы запустить ее,  читателю сначала  придется знакомиться с
новой вычислительной  системой. С  другой стороны,  тот, у кого под
рукой окажется нужный набор программ, может сделать упражнение (*5)
за  час.  В  качестве  источника  упражнений  к  Главам  2-4  можно
использовать любую  книгу по  C. У  Ахо и др. [1] приведено большое
количество общих структур данных и алгоритмов втерминах абстрактных
типов данных. Эту книгу также может служить источником упражнений к
Главам 5-7.  Однако языку,  который  в  этой  книге  использовался,
недостает как  функций членов,  так и  производных классов. Поэтому
определенные  пользователем  типы часто  можно выражать в C++ более
элегантно.

     Замечания по проекту языка

  Существенным критерием  при разработке  языка была простота; там,
где возникал  выбор между  упрощением руководства по языку и другой
документации и  упрощением компилятора, выбиралось первое. Огромное
значение также  придавалось совместимости с C; это помешало удалить
синтаксис C.
  В C++  нет типов  данных высокого уровня и нет первичных операций
высокого уровня.  В нем  нет, например, матричного типа с операцией
обращения  или   типа  строка   с  операцией   конкатенации.   Если
пользователю понадобятся подобные типы, их можно определить в самом
____________________
# C++  можно купить  в AT&T,  Software Sales  and Marketing, PO Box
25000, Greensboro, NC 27420, USA (телефон 800-828-UNIX) или в ваших
местных организациях,  осуществляющих продажу  Системы UNIX. (прим.
автора)

                             - стр 12 -

языке. По  сути дела,  основное, чем занимается программирование на
C++, - это определение универсальных и специально-прикладных типов.
Хорошо разработанный тип, определенный пользователем, отличается от
встроенного  типа  только  способом  определения,  но  не  способом
использования.
  Исключались те  черты, которые  могли бы  повлечь  дополнительные
расходы памяти или времени выполнения. Например, мысли о том, чтобы
сделать  необходимым   храние  в   каждом  объекте  "хозяйственной"
информации, были отвергнуты; если пользователь описывает структуру,
состоящую из двух 16-битовых величин, то структура поместится в 32-
битовый регистр.
  C++ проектировался  для  использования  в  довольно  традиционной
среде компиляции  и  выполнения,  среде  программирования  на  C  в
системе UNIX.  Средства обработки  особых ситуаций  и параллельного
программирования, требующие  нетривиальной загрузки  и поддержки  в
процессе выполнения,  не были  включены  в  C++.  Вследствие  этого
реализация C++ очень легко переносима. Однако есть полные основания
использовать C++  в среде,  где имеется  гораздо более существенная
поддержка. Такие  средства, как  динамическая  загрузка,  пошаговая
трансляция  и   база  данных  определений  типов  могут  с  пользой
применяться без воздействия на язык.
  Типы и  средства скрытия  данных в C++ опираются на проводимый во
время компиляции  анализ программ с целью предотвращения случайного
искажения данных.  Они не  обеспечивают секретности  или защиты  от
умышленного  нарушения   правил.  Однако     эти   средства   можно
использовать без  ограничений, что  не  приводит  к  дополнительным
расходам времени на выполнение или пространства памяти.

     Исторические замечания

  Безусловно, C++ восходит главным образом к C [7]. C сохранено как
подможество, поэтому  сделанного в  C акцента  на средствах низкого
уровня достаточно,  чтобы справляться  с самыми  насущными задачами
системного программирования.  C, в  свою  очередь,  многим  обязано
своему предшественнику  BCPL [9];  на самом  деле,  комментарии  //
(заново) введены  в C++  из  BCPL.  Если  вы  знаете  BCPL,  то  вы
заметите,  что  в  C++  по-прежнему  нет  VALOF  блока.  Еще  одним
источником вдохновения  послужил язык  Simula67 [2,3]; из него была
позаимствована концепция  класса (вместе  с производными классами и
функциями  членами).   Это  было   сделано,  чтобы   способствовать
модульности через  использование виртуальных  функций.  Возможности
C++ по перегрузке операций и свобода в расположении описаний везде,
где может встречаться оператор, похожи на Алгол68 [14].
  Название C++  - изобретение совсем недавнее (лета 1983его). Более
ранние  версии  языка  использовались  начиная  с  1980ого  и  были
известны как  "C  с  Классами".  Первоначально  язык  был  придуман
потому, что  автор хотел написать модели, управляемые прерываниями,
для чего  был бы  идеален Simula67,  если не  принимать во внимание
эффективность. "C  с Классами" использовался  для  крупных проектов
моделирования,  в   которых    строго   тестировались   возможности
написания программ,  требующих минимального  (только)  пространства
памяти и  времени на  выполнение.  В  "C  с  Классами"  не  хватало
перегрузки операций,  ссылок, виртуальных функций и многих деталей.
C++ был впервые введен за пределами исследовательской группы автора

                             - стр 13 -

в июле  1983его; однако  тогда многие  особенности C++  были еще не
придуманы.
  Название  C++   выдумал  Рик   Масситти.  Название  указывает  на
эволюционную природу  перехода к  нему от  C. "++"  - это  операция
приращения в  C. Чуть более короткое имя C+ является синтаксической
ошибкой; кроме  того, оно  уже было использовано как совсем другого
языка. Знатоки семантики C находят, что C++ хуже, чем ++C. Названия
D язык  не получил,  поскольку он является расширением C и в нем не
делается  попыток   исцеляться  от   проблем   путем   выбрасывания
различных особенностей.  Еще одну  интерпретацию названия C++ можно
найти в приложении к Оруэллу [8].
  Изначально C++  был разработан,  чтобы автору  и его  друзьям  не
приходилось программировать на ассемблере, C или других современных
языках высокого  уровня. Основным  его предназначением было сделать
написание хороших  программ более простым и приятным для отдельного
программиста. Плана  разработки C++  на  бумаге  никогда  не  было;
проект,   документация   и   реализация   двигались   одновременно.
Разумется, внешний  интерфейс C++  был написан  на C++.  Никогда не
существовало "Проекта  C++" и "Комитета по разработке C++". Поэтому
C++ развивался  и продолжает развиваться во всех направлениях чтобы
справляться со сложностями, с которыми сталкиваются пользователи, а
также в процессе дискуссий автора с его друзьями и коллегами.
  В качестве базового языка для C++ был выбран C, потому что он (1)
многоцелевой,  лаконичный   и  относительно   низкого  уровня;  (2)
отвечает большинству  задач системного  программирования; (3)  идет
везде и  на всем; и (4) пригоден в среде программирования UNIX. В C
есть свои  сложности, но  в наспех спроектированном языке тоже были
бы свои,  а сложности  C нам  известны. Самое  главное, работа  с C
позволила  "C   с  Классами"   быть  полезным  (правда,  неудобным)
инструментом в  ходе первых  месяцев  раздумий  о  добавлении  к  C
Simula-образных классов.
  C++ стал  использоваться шире,  и по  мере того, как возможности,
предоставляемые им  помимо возможностей  C, становились  все  более
существенными, вновь  и вновь поднимался вопрос о том, сохранять ли
совместимость с  C. Ясно,  что отказавшись  от  определенной  части
наследия C  можно было  бы избежать  ряда проблем   (см., например,
Сэти [12]). Это не было сделано, потому что (1) есть миллионы строк
на C, которые могли бы принести пользу в C++ при условии, что их не
нужно было  бы полностью  переписывать с  C на  C++; (2) есть сотни
тысяч строк  библиотечных функций  и сервисных программ, написанных
на C, которые можно было бы использовать из или на C++ при условии,
что C++  полностью совместим  с C по загрузке и синтаксически очень
похож на  C; (3) есть десятки тысяч программистов, которые знают C,
и которым,  поэтому,  нужно  только  научиться  использовать  новые
особенности C++,  а не  заново изучать его основы; и (4), поскольку
C++ и  C будут  использоваться на  одних и тех же системах одними и
теми же людьми, отличия должны быть либо очень большими, либо очень
маленькими, чтобы свести к минимуму ошибки и недоразумения. Позднее
была проведена  проверка определения  C++, чтобы  удостовериться  в
том,  что   любая  конструкциия,   допустимая  и   в  C  и  в  C++,
действительно означает в обоих языках одно и то же.
  Язык C  сам эволюционировал  за последние несколько лет, частично
под влиянием  развития  C++  (см.  Ростлер  [11]).  Предварительный
грубый ANSI  стандарт C  [10] содержит  синтаксис описаний функций,
заимствованный из  "C с  Классами". Заимствование  идей идет  в обе
стороны; например,  указатель void*  был  придуман  для  ANSI  C  и

                             - стр 14 -

впервые реализован  в C++. Когда ANSI стандарт разовьется несколько
дальше, придет время пересмотреть C++, чтобы удалить необоснованную
несовместимость.  Будет,   например,  модернизирован   препроцессор
(#с.11),  и   нужно   будет,   вероятно,   отрегулировать   правила
осуществления  плавающей   арифметики.  Это   не  должно  оказаться
болезненным, и  C и  ANSI C   очень  близки  к  тому,  чтобы  стать
подмножествами C++ (см. #с.11).

     Эффективность и структура

  C++ был  развит из  языка программирования C и за очень немногими
исключениями  сохраняет   C  как   подмножество.  Базовый  язык,  C
подмножество C++,  спроектирован так,  что  имеется  очень  близкое
соответствие  между   его  типами,   операциями  и   операторами  и
компьютерными  объектами,  с  которыми  непосредственно  приходится
иметь дело:  числами, символами и адресами. За исключением операций
свободной памяти  new и delete, отдельные выражения и операторы C++
обычно не  нуждаются в  скрытой поддержке  во время  выполнения или
подпрограммах.
  В C++  используются те же последовательности вызова и возврата из
функций, что  и в  C. В  тех  случаях,  когда  даже  этот  довольно
эффективный механизм  является слишком  дорогим, C++  функция может
быть подставлена  inline, удовлетворяя, таким образом, соглашению о
записи функций без дополнительных расходов времени выполнения.
  Одним из  первоначальных предназначений  C  было  применение  его
вместо программирования  на ассемблере  в  самых  насущных  задачах
системного программирования. Когда проектировался C++, были приняты
меры, чтобы  не ставить  под угрозу успехи в этой области. Различие
между C  и  C++  состоит  в  первую  очередь  в  степени  внимания,
уделяемого типам  и структурам.  C выразителен и снисходителен. C++
еще более  выразителен,  но  чтобы  достичь  этой  выразительности,
программист должен  уделить больше  внимания типам  объектов. Когда
известны типы  объектов, компилятор  может  правильно  обрабатывать
выражения, тогда  как в  противном случае  программисту пришлось бы
задавать  действия   с  мучительными  подробностями.  Знание  типов
объектов также позволяет компилятору обнаруживать ошибки, которые в
противном  случае   остались  бы  до  тестирования.  Заметьте,  что
использование системы  типов  для  того,  чтобы  получить  проверку
параметров функций, защитить данные от случайного искажения, задать
новые операции  и т.д.,  само по  себе не  увеличивает расходов  по
времени выполнения и памяти.
  Особое  внимание,   уделенное  при   разработке  C++   структуре,
отразилось на  возрастании масштаба программ, написанных со времени
разработки C.  Маленькую программу  (меньше 1000  строк) вы  можете
заставить работать  с помощью грубой силы, даже нарушая все правила
хорошего стиля.  Для программ  больших размеров  это не совсем так.
Если программа  в  10 000  строк  имеет  плохую  структуру,  то  вы
обнаружите,  что   новые  ошибки  появляются  так  же  быстро,  как
удаляются старые.  C++ был  разработан так,  чтобы дать возможность
разумным образом  структурировать большие  программы таким образом,
чтобы  для   одного  человека  не  было  непомерным  справляться  с
программами в  25 000 строк.  Существуют программы  гораздо больших
размеров, однако  те, которые  работают, в  целом, как оказывается,
состоят из  большого числа  почти  независимых  частей,  каждая  из
которых намного  ниже указанных  пределов.  Естественно,  сложность

                             - стр 15 -

написания и  поддержки программы зависит от сложности разработки, а
не просто  от числа строк текста программы, так что точные цифры, с
помощью которых  были выражены  предыдущие соображения,  не следует
воспринимать слишком серьезно.
  Не  каждая   часть   программы,   однако,   может   быть   хорошо
структурирована,  независима   от  аппаратного  обеспечения,  легко
читаема и  т.п. C++  обладает  возможностями,  предназначенные  для
того, чтобы  непосредственно и  эффективно работать  с  аппаратными
средствами, не беспокоясь о безопасности или простоте понимания. Он
также имеет  возможности, позволяющие  скрывать такие  программы за
элегантными и надежными интерфейсами.
  В  этой  книге  особый  акцент  делается    на  методах  создания
универсальных  средств,   полезных  типов,  библиотек  и  т.д.  Эти
средства пригодятся  как тем программистам, которые пишут небольшие
программы, так  и тем, которые пишут большие. Кроме того, поскольку
все   нетривиальные    программы   состоят    из   большого   числа
полунезависимых частей,  методы написания таких частей пригодятся и
системным, и прикладным программистам.
  У кого-то  может появиться подозрение, что спецификация программы
с помощью  более подробной  системы  типов  приведет  к  увеличению
исходных текстов  программы. В  C++  это  не  так;  C++  программа,
описывающая типы  параметров функций,  использующая классы  и т.д.,
обычно немного  короче эквивалентной  C программы,  в  которой  эти
средства не используются.

     Философские замечания

  Язык программирования служит двум связанным между собой целям: он
дает программисту аппарат для задания действий, которые должны быть
выполнены, и  формирует концепции, которыми пользуется программист,
размышляя о  том, что  делать. Первой  цели идеально отвечает язык,
который настолько  "близок к машине", что всеми основными машинными
аспектами можно легко и просто оперировать достаточно очевидным для
программиста образом.  С таким умыслом первоначально задумывался C.
Второй цели  идеально отвечает  язык, который  настолько "близок  к
решаемой задаче",  чтобы концепции  ее решения  можно было выражать
прямо  и  коротко.  С  таким  умыслом  предварительно  задумывались
средства, добавленные к C для создания C++.
  Связь  между   языком,  на  котором  мы  думаем/программируем,  и
задачами  и  решениями,  которые  мы  можем  представлять  в  своем
воображении, очень  близка. По  этой причине  ограничивать свойства
языка только  целями исключения ошибок программиста в лучшем случае
опасно. Как  и в  случае с  естественными  языками,  есть  огромная
польза  быть   по  крайней   мере  двуязычным.  Язык  предоставляет
программисту  набор   концептуальных  инструментов;   если  они  не
отвечают задаче,  то  их  просто  игнорируют.  Например,  серьезные
ограничения концепции  указателя заставляют  программиста применять
вектора и  целую арифметику, чтобы реализовать структуры, указатели
и  т.п.   Хорошее  проектирование  и  отсутствие  ошибок  не  может
гарантироваться чисто за счет языковых средств.
  Система  типов  должна  быть  особенно  полезна  в  нетривиальных
задачах. Действительно,  концепция  классов  в  C++  показала  себя
мощным концептуальным средством.

                             - стр 16 -

     Размышления о программировании на C++

  В идеальном  случае подход  к разработке программы делится на три
части: вначале  получить ясное  понимание  задачи,  потом  выделить
ключевые идеи,  входящие в ее решение, и наконец выразить решение в
виде программы.  Однако подробности  задачи и  идеи решения   часто
становятся ясны  только в   результате  попытки выразить  их в виде
программы -  именно  в  этом  случае  имеет  значение  выбор  языка
программирования.
  В  большинстве   разработок  имеются   понятия,  которые   трудно
представить в  программе в  виде одного  из основных  типов или как
функцию без  ассоциированных с ней статических данных. Если имеется
подобное понятие,  опишите класс,  представляющий его  в программе.
Класс -  это тип;  это значит, что он задает поведение объектов его
класса: как  они создаются, как может осуществляться работа с ними,
и как  они уничтожаются.  Класс также  задает способ  представления
объектов; но на ранних стадиях разработки программы это не является
(не должно  являться) главной  заботой. Ключом  к написанию хорошей
программы является  разработка таких  классов, чтобы  каждый из них
представлял  одно   основное  понятие.  Обычно  это  означает,  что
программист  должен  сосредоточиться  на  вопросах:  Как  создаются
объекты этого  класса? Могут  ли  эти  объекты  копироваться  и/или
уничтожаться? Какие действия можно производить над этими объектами?
Если на такие вопросы нет удовлетворительных ответов, то во-первых,
скорее всего,   понятие  не было  "ясно", и  может быть неплохо еще
немного подумать  над задачей  и предлагаемым решением вместо того,
чтобы сразу начинать "программировать вокруг" сложностей.
  Проще  всего   иметь  дело  с  такими  понятиями,  которые  имеют
традиционную математическую  форму: числа  всех  видов,  множества,
геометрические фигуры  и т.п.  На самом  деле, следовало  бы  иметь
стандартные библиотеки  классов, представляющих такие понятия, но к
моменту написания  это  не  имело  места.  C++  еще  молод,  и  его
библиотеки не развились еще до той же степени, что и сам язык.
  Понятие не  существует в  пустоте, всегда  есть группы  связанных
между собой понятий. Организовать в программе взаимоотношения между
классами, то  есть определить  точную взаимосвязь  между различными
понятиями,  часто   труднее,  чем  сначала  спланировать  отдельные
классы. Лучше, чтобы  не получилось неразберихи, когда каждый класс
(понятие) зависит  от всех остальных. Рассмотрим два класса, A и B.
Взаимосвязи вроде  "A вызывает функции из B", "A создает объекты B"
и "A имеет члены B" редко вызывают большие сложности, а взаимосвязь
вроде "A  использует данные из B" обычно можно исключить (просто не
используйте  открытые   данные-члены).  Неприятными,  как  правило,
являются взаимосвязи,  которые по своей природе имеют вид "A есть B
и ...".
  Одним из  наиболее мощных  интеллектуальных средств,  позволяющих
справляться со  сложностью, является иерархическое упорядочение, то
есть  организация  связанных  между  собой  понятий  в  древовидную
структуру с  самым общим  понятием в  корне. В  C++ такие структуры
представляются  производными  классами.  Часто  можно  организавать
программу как  множество  деревьев  (лес?).  То  есть,  программист
задает  набор   базовых  классов,  каждый  из  которых  имеет  свое
собственное множество  производных классов.  Для определения набора
действий для  самой общей  интерпретации понятия  (базового класса)
часто   можно    использовать   виртуальные    функции    (#7.2.8).
Интерпретацию  этих   действий  можно,   в  случае   необходимости,

                             - стр 17 -

усовершенствовать для  отдельных специальных  классов  (производных
классов).
  Естественно,  такая   организация  имеет   свои  ограничения.   В
частности, множество  понятий  иногда  лучше  организуется  в  виде
ациклического  графа,   в  котором  понятие  может  непосредственно
зависеть от более чем одного другого понятия; например, "A есть B и
C и  ...". В  C++ нет непосредственной поддержки этого, но подобные
связи можно  представить, немного  потеряв в  элегантности и сделав
малость дополнительной работы (#7.2.5).
  Иногда для  организации понятий  некоторой программы  оказывается
непригоден даже  ациклический граф;  некоторые понятия  оказываются
взаимозависимыми по  своей природе.  Если множество взаимозависимых
классов  настолько   мало,  что  его  легко  себе  представить,  то
циклические  зависимости   не  должны   вызвать   сложностей.   Для
представления  множеств   взаимозависимых  классов   с  C++   можно
использовать идею friend классов (#5.4.1).
  Если вы можете организовать понятия программы только в виде обще-
го графа (не дерева или ациклического направленного графа), и  если
вы  не можете локализовать взаимные зависимости, то вы, по всей ви-
димости, попали в затруднительное положение, из которого вас не вы-
ручит ни один язык программирования. Если вы не можете  представить
какой-либо просто формулируемой зависимости между основными поняти-
ями, то скорее всего справиться с программой не удастся.
  Напомню,  что   большую  часть  программирования  можно  легко  и
очевидно  выполнять,   используя  только  простые  типы,  структуры
данных, обычные  функции и  небольшое число  классов из стандартной
библиотеки. Весь  аппарат, входящий  в определение  новых типов, не
следует  использовать   за  исключением   тех  случаев,   когда  он
действительно нужен.
  Вопрос "Как пишут хорошие программы на C++" очень похож на вопрос
"Как пишут  хорошую  английскую  прозу?"  Есть  два  вида  ответов:
"Знайте,  что  вы  хотите  сказать"  и  "Практикуйтесь.  Подражайте
хорошему языку."  Оба совета оказываются подходящими к C++ в той же
мере, сколь и для английского - и им столь же трудно следовать.

     Правила Правой Руки (*)

  Здесь  приводится   набор   правил,   которых   вам   хорошо   бы
придерживаться изучая C++. Когда вы станете более опытны, вы можете
превратить  их   в  то,   что  будет   подходить  для  вашего  рода
деятельности и вашего стиля программирования. Они умышленно сделаны
очень простыми, поэтому подробности в них опущены. Не воспринимайте
их чересчур  буквально. Написание  хороших  программ  требует  ума,
вкуса и терпения. Вы не собираетесь как следует понять это с самого
начала; поэкспериментируйте!
  [1]     Когда   вы   программируете,   вы   создаете   конкретное
     представление идей  вашего  решения  некоторой  задачи.  Пусть
     структура отражает  эти идеи  настолько  явно,  насколько  это
     возможно:
     [a]  Если вы  считате  "это"  отдельным понятием, сделайте его
          классом.

____________________
 (*)  Некоторые  легко запоминаемые эмпирические правила, "Правила-
помошники." (прим. перев.)

                             - стр 18 -

     [b]  Если вы  считате  "это"  отдельным объектом, сделайте его
          объектом некоторого класса.
     [c]  Если два  класса имеют общим нечто существенное, сделайте
          его базовым  классом. Почти  все классы в вашей программе
          будут иметь  нечто общее;  заведите (почти) универсальный
          базовый класс, и разработайте его наиболее тщательно.
  [2]     Когда  вы   определяете  класс,   который  не   реализует
     некоторый   математический    объект,   вроде    матрицы   или
     комплексного числа,  или тип  низкого уровня, вроде связанного
     списка, то:
     [a]  Не используйте глобальные данные.
     [b]  Не используйте глобальные функции (не члены).
     [c]  Не используйте открытые данные-члены.
     [d]  Не используйте  друзей, кроме как чтобы избежать [a], [b]
          или [c].
     [e]  Не  обращайтесь   к  данным-членам  или  другим  объектам
          непосредственно.
     [f]  Не помещайте в класс "поле типа"; используйте виртуальные
          функции.
     [g]  Не  используйте   inline-функции,  кроме   как   средство
          существенной оптимизации.

     Замечания для программистов на C

  Чем лучше  кто-нибудь знает  C,  тем  труднее  окажется  избежать
писания на  C++ в  стиле C,  теряя, тем  самым, некоторые возможные
выгоды C++. Поэтому проглядите, пожалуйста, раздел "Отличия от C" в
справочном руководстве  (#с.15).  Там  указывается  на  области,  в
которых C++ позволяет делать что-то лучше, чем C. Макросы (#define)
в  C++   почти  никогда  не  бывают  необходимы;  чтобы  определять
провозглашаемые константы,  используйте  const  (#2.4.6)  или  enum
(#2.4.7), и  inline (#1.12)  - чтобы  избежать лишних  расходов  на
вызов  функции.  Старайтесь  описывать  все  функции  и  типы  всех
параметров -  есть  очень  мало  веских  причин  этого  не  делать.
Аналогично, практически  нет причин  описывать локальную переменную
не инициализируя ее, поскольку описание может появляться везде, где
может стоять  оператор, - не описывайте переменную, пока она вам не
нужна. Не используйте malloc() - операция new (#3.2.6) делает ту же
работу лучше. Многие объединения не нуждаются в имени - используйте
безымянные объединения (#2.5.2).


                           Глава 1

                           Турне по C++

                             Единственный способ изучать новый язык
                        программирования - писать на нем программы.
                                                  - Брайэн Керниган

  Эта глава  представляет собой  краткий обзор  основных черт языка
программирования C++.  Сначала приводится  программа на  C++, затем
показано, как ее откомпилировать и запустить, и как такая программа
может выводить  выходные данные и считывать входные. В первой трети
этой главы  после введения  описаны  наиболее  обычные  черты  C++:
основные типы,  описания, выражения, операторы, функции и структура
программы. Оставшаяся  часть главы  посвящена возможностям  C++  по
определению новых  типов, скрытию  данных, операциям,  определяемым
пользователем, и иерархии определяемых пользователем типов.

     1.1 Введение

  Это турне  проведет вас  через ряд  программ и частей программ на
C++. К концу у вас должно сложиться общее представление об основных
особенностях C++,  и  будет  достаточно  информации,  чтобы  писать
простые  программы.  Для  точного  и  полного  объяснения  понятий,
затронутых   даже    в   самом   маленьком   законченном   примере,
потребовалось бы несколько страниц определений. Чтобы не превращать
эту главу  в описание  или  в  обсуждение  общих  понятий,  примеры
снабжены  только   самыми  короткими   определениями   используемых
терминов.  Термины   рассматриваются  позже,   когда  будет  больше
примеров, способствующих обсуждению.

     1.1.1 Вывод

      Прежде  всего, давайте  напишем программу,  выводящую  строку
выдачи:

  #include

  main()
  {
      cout << "Hello, world\n";
  }

  Строка #include  сообщает компилятору, чтобы он включил
стандартные возможности  потока ввода и вывода, находящиеся в файле
stream.h. Без  этих описаний  выражеине cout << "Hello, world\n" не
имело бы  смысла. Операция  << ("поместить  в"*) пишет  свой первый
аргумент во  второй (в  данном случае,  строку "Hello,  world\n"  в
____________________
* Программирующим  на C  << известно  как операция сдвига влево для
целых. Такое  использование <<  не утеряно;  просто в дальнейшем <<
было определено  для  случая,  когда  его  левый  операнд  является
потоком вывода. Как это делается, описано в #1.8. (прим. автора)

                             - стр 20 -

стандартный поток  вывода cout).  Строка -  это  последовательность
символов, заключенная  в двойные  кавычки. В строке символ обратной
косой  \,   за  которым  следует  другой  символ,  обозначает  один
специальный символ;  в данном  случае, \n  является символом  новой
строки. Таким  образом выводимые  символы состоят из Hello, world и
перевода строки.
  Остальная часть программы

  main() { ... }

определяет  функцию,   названную  main.   Каждая  программа  должна
содержать функцию  с именем  main, и  работа программы начинается с
выполнения этой функции.

     1.1.2 Компиляция

  Откуда появились  выходной поток cout и код, реализующий операцию
вывода <<?  Для  получения  выполняемого  кода  написанная  на  C++
программа  должна   быть  скомпилирована;  по  своей  сути  процесс
компляции такой  же, как  и для  С, и в нем участвует большая часть
входящих в  последний программ. Производится чтение и анализ текста
программы, и  если не обнаружены ошибки, то генерируется код. Затем
программа  проверяется   на  наличие   имен  и   операций,  которые
использовались, но  не были  определены (в  нашем случае это cout и
<<). Если  это возможно,  то программа  делается полной посредством
дополнения недостающих  определений из библиотеки (есть стандартные
библиотеки, и  пользователи могут  создавать свои  собственные).  В
нашем случае  cout и  << были  описаны в  stream.h, то  есть,  были
указаны их  типы, но не было дано никаких подробностей относительно
их реализации.  В стандартной  библиотеке  содержится  спецификация
пространства и инициализирующий код для cout и <<. На самом деле, в
этой библиотеке  содержится и  много других вещей, часть из которых
описана в  stream.h, однако  к скомпилированной  версии добавляется
только подмножество библиотеки, необходимое для того, чтобы сделать
нашу программу полной.
  Команда компиляции  в C++  обычно называется CC. Она используется
так же,  как команда  cc для  программ на  C; подробности вы можете
найти в  вашем руководстве.  Предположим, что  программа с  "Hello,
world"        хранится        в        файле        с        именем

                             - стр 21 -

hello.c, тогда вы можете ее скомпилировать и запустить примерно так
($ - системное приглашение):

  $ CC hello.c
  $ a.out
  Hello,world
  $

a.out -  это принимаемое  по умолчанию  имя исполняемого результата
компиляции. Если  вы  хотите  назвать  свою  программу,  вы  можете
сделать это с помощью опции -o:

  $ CC hello.c -o hello
  $ hello
  Hello,world
  $

     1.1.3 Ввод

  Следующая (довольно многословная) программа предлагает вам ввести
число дюймов.  После того,  как вы  это  сделаете,  она  напечатает
соответствующее число сантиметров.

  #include

  main()
  {
      int inch = 0;         // inch - дюйм
      cout << "inches";
      cin >> inch;
      cout << inch;
      cout << " in = ";
      cout << inch*2.54;
      cout << " cm\n";
  }

Первая строка  функции main()  описывает целую  переменную inch. Ее
значение  считывается  с  помощью  операции  >>  ("взять  из")  над
стандартным потоком  ввода cin.  Описания cin  и  >>,  конечно  же,
находятся  в  .  После  ее  запуска  ваш  терминал  может
выглядеть примерно так:

  $ a.out
  inches=12
  12 in = 30.48 cm
  $

В этом  примере на  каждую команду вывода приходится один оператор;
это слишком  длинно.  Операцию  вывода  <<  можно  применять  к  ее
собственному результату,  так что  последние четыре  команды вывода
можно было записать одним оператором:

  cout << inch << " in = " << inch*2.54 << " cm\n";

                             - стр 22 -

  В последующих  разделах ввод  и вывод будут описаны гораздо более
подробно.  Вся  эта  глава  фактически  может  рассматриваться  как
объяснение того,  как можно написать предыдущие программы на языке,
который не  обеспечивает  операции  ввода-вывода.  На  самом  деле,
приведенные  выше   программы  написаны   на   C++,   "расширенном"
операциями  ввода-вывода   посредством  использования  библиотек  и
включения файлов  с помощью  #include. Другими  словами, язык C++ в
том  виде,  в  котором  он  описан  в  справочном  руководстве,  не
определяет  средств  ввода-вывода;  вместо  этого  исключительно  с
помощью средств, доступных любому программисту, определены операции
<< и >>.

     1.2 Комментарии

  Часто  бывает   полезно  вставлять  в  программу  текст,  который
предназначается  в   качестве  комментария   только  для  читающего
программу человека  и игнорируется  компилятором в программе. В C++
это можно сделать одним из двух способов.
  Символы /*  начинают комментарий,  заканчивающийся символами  */.
Вся эта  последовательность символов  эквивалентна символу пропуска
(например, символу пробела). Это наиболее полезно для многострочных
комментариев и  изъятия частей программы при редактировании, однако
следует помнить, что комментарии /* */ не могут быть вложенными.
  Символы //  начинают комментарий,  который заканчивается  в конце
строки, на  которой они  появились. Опять,  вся  последовательность
символов эквивалентна  пропуску. Этот  способ наиболее  полезен для
коротких комментариев.  Символы //  можно  использовать  для  того,
чтобы закомментировать  символы /*  или */,  а символами  /*  можно
закомментировать //.

     1.3 Типы и Описания

  Каждое имя  и каждое  выражение имеет тип, определяющий операции,
которые могут над ними производиться. Например, описание

  int inch;

определяет, что  inch имеет  тип int, то есть,  inch является целой
переменной.
  Описание - это оператор, который вводит имя в программе. Описание
задает тип  этого имени.  Тип определяет   правильное использование
имени или выражения. Для целых определены такие операции, как +, -,
* и /. После того, как включен файл stream.h, объект типа int может
также быть вторым операндом <<, когда первый операнд ostream.
  Тип объекта  определяет не только то, какие операции могут к нему
применяться, но и смысл этих операций. Например, оператор

  cout << inch << " in = " << inch*2.54 << " cm\n";

правильно обрабатывает  четыре входных  значения различным образом.
Строки печатаются  буквально, тогда  как целое  inch и  значение  с
плавающей  точкой   inch*2.54  преобразуются   из  их   внутреннего
представлениия в  подходящее  для  человеческого  глаза  символьное
представление.

                             - стр 23 -

  В  C++   есть  несколько  основных  типов  и  несколько  способов
создавать новые.  Простейшие виды типов C++ описываются в следующих
разделах, а более интересные оставлены на потом.

     1.3.1 Основные Tипы

  Основные  типы,  наиболее  непосредственно  отвечающие  средствам
аппаратного обеспечения, такие:

  char  short  int  long  float  double

Первые четыре  типа используются для представления целых, последние
два -  для представления  чисел с плавающей точкой. Переменная типа
char имеет  размер, естественный  для хранения  символа  на  данной
машине  (обычно,   байт),  а  переменная  типа  int  имеет  размер,
соответствующий целой арифметике на  данной машине (обычно, слово).
Диапазон  целых  чисел,  которые  могут  быть  представлены  типом,
зависит от его размера. В C++ размеры измеряются в единицах размера
данных типа char, поэтому char по определению имеет размер единица.
Соотношение между основными типами можно записать так:

  1 = sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long)
  sizeof(float) <= sizeof(double)

В целом,  предполагать что-либо  еще  относительно  основных  типов
неразумно. В  частности, то,  что  целое  достаточно  для  хранения
указателя, верно не для всех машин.
  К основному  типу можно  применять прилагательное const. Это дает
тип, имеющий  те же  свойства, что  и исходный  тип, за исключением
того, что значение переменных типа const  не может изменяться после
инициалиизации.

  const float pi = 3.14;
  const char plus = '+';

  Символ, заключенный  в  одинарные  кавычки,  является  символьной
константой.  Заметьте,  что  часто  константа,  определенная  таким
образом, не занимает память; просто там, где требуется, ее значение
может    использоваться     непосредственно.    Константа    должна
инициализироваться  при   описании.  Для  переменных  инициализация
необязательна,  но   настоятельно  рекомендуется.   Оснований   для
введения локальнной переменной без ее инициализации очень немного.
  К любой  комбинации этих  типов могут  применяться арифметические
операции:

  +   (плюс, унарный и бинарный)
  -   (минус, унарный и бинарный)
  *   (умножение)
  /   (деление)

А также операции сравнения:

                             - стр 24 -

  ==  (равно)
  !=  (не равно)
  <   (меньше)
  >   (больше)
  <=  (меньше или равно)
  >=  (больше или равно)

Заметьте, что  целое деление  дает целый результат: 7/2 есть 3. Над
целыми может выполняться операция % получения остатка: 7%2 равно 1.
   При  присваивании и  арифметических операциях  C++ выполняет все
осмысленнные преобразования  между основными типами, чтобы их можно
было сочетать без ограничений:

  double d = 1;
  int i = 1;
  d = d + i;
  i = d + i;

     1.3.2 Производные Типы

  Вот операции, создающие из основных типов новые типы:

  *        указатель на
  *const   константный указатель на
  &        ссылка на
  []       вектор*
  ()       функция, возвращающая

  Например:

  char* p        // указатель на символ
  char *const q  // константный указатель на символ
  char v[10]     // вектор из 10 символов

Все вектора в качестве нижней границы индекса имеют ноль, поэтому в
v десять  элементов:v[0] ...  v[9].  Функции  объясняются  в  #1.5,
ссылки в  #1.9. Переменная  указатель может содержать адрес объекта
соответствующего типа:

  char c;
  // ...
  p = &c; // p указывает на c

Унарное & является операцией взятия адреса.

     1.4 Выражения и Операторы

  В C++  имеется  богатый  набор  операций,  с  помощью  которых  в
выражениях  образуются   новые  значения    и  изменяются  значения
____________________
*  одномерный   массив.  Это  принятый  термин  (например,  вектора
прерываний), и  мы сочли,  что стандартный перевод его как "массив"
затуманит изложение. (прим. перев.)

                             - стр 25 -

переменных.  Поток   управления  в  программе  задается  с  помощью
операторов , а описания используются для введения  в программе имен
переменных,  констант   и  т.д.  Заметьте,  что  описания  являются
операторами,  поэтому  они  свободно  могут  сочетаться  с  другими
операторами.

     1.4.1 Выражения

  В C++  имеется большое  число операций,  и они  будут объясняться
там, где (и если) это потребуется. Следует учесть, что операции

  ~    (дополнение)
  &    (И)
  ^    (исключающее ИЛИ)
  |    (включающее ИЛИ)
  <<   (логический сдвиг влево)
  >>   (логический сдвиг вправо)

применяются  к   целым,  и  что  нет  отдельного  типа  данных  для
логических действий.
  Смысл операции  зависит от  числа операндов;  унарное &  является
операцией взятия адреса, а бинарное & - это операция логического И.
Смысл операции  зависит также  от типа  ее операндов: + в выражении
a+b означает  сложение с  плавающей точкой, если операнды имеют тип
float, но  целое сложение,  если они  типа int. В #1.8 объясняется,
как   можно    определить   операцию    для   типа,   определяемого
пользователем,  без   потери  ее  значения,  предопределенного  для
основных и производных типов.
  В C++  есть операция  присваивания =, а не оператор присваивания,
как  в   некоторых  языках.   Таким  образом,   присваивание  может
встречаться в  неожиданном контексте;  например, x=sqrt(a=3*x). Это
бывает полезно.  a=b=c означает  присвоение c  объекту   b, а затем
объекту  a. Другим свойством операции присваивания является то, что
она может  совмещаться с  большинством бинарных операций. Например,
x[i+3]*=4 означает  x[i+3]=x[i+3]*4, за исключением того факта, что
выражение  x[i+3]   вычисляется   только   один   раз.   Это   дает
привлекательную степень эффективности без необходимости обращения к
оптимизирующим компиляторам. К тому же это более кратко.
  В большинстве  программ  н░ $C+*  шиЁоко  зриденяются  указатзли>
Унарная онераци╦ $*0разыменовывает* указатель,!т.е."+p$естьаобъдътЕ
на кот.рый  уъазывает(p.  Эта мпе`ация  такое начываетхя  косвенн╛й
адрнчрцибй> Нап@имер,  если иМеется  chAR* p, то *p есть символ, на
лоторый уиа╖ывает p.  Часто при работ┤ с указатекями$сывают пол%зны
опердция$увейичения  ++ и( операция уменьшен╕я  --> Предполооид, 0p
укапывабт нв  элеме-т вчктора" vд вогди p++ дейает p указывающим на
следующий элемент.

     1.4n2 ОПераторы Выраже-ия

  Рамый обычный( вид озефатора` - оператор`выражение. Он состоит из
вяражения, за коъорым(следует точка с запютой.!нвпример:
__W__[^__▀_[________J*  англ.  dereferхnce  - !поъучить  знацение  объекта,  на` коуофыйукажывабт финный указатЕль. (прим.`перев.)
     $        а     !!   `   - стр 26 -
  a = b*2+c;
 $cout << "go go 'o";
  lseek(fd-0,2	;	

     14.3 Пустой оперртос

и Пажстелшей формой оперртори являе┬ся пчстой операто└:

  ;-*
Он не  делиет ничего.  Однакк$он  ьожет быть полечен в теэ случаях,
когда хинтаКсйс требубт0нрличие"м┐ераbора, а вам кпнраткр не нужен.
    `1.4.4 Блови	
J  Блкк -  этм возможно  пустой  снисок  ояераторов,  закщюченныйа в	
фигурные хкобки:

  !a5b+2; b++╗ }
M
Блок пкзволяет рассматривать ╜есколько мп%раторов как один. О▒ластэ
видимосъи имени,  описаннжго в  блоке, простираетхя до конца блока.
Имя можно  сфелать невидимыи  с0по╝ощью .пираниЙ такого же имени вп
внытренних(блоках.	
   а 0.4.5 Операт╛`ы if

  Прогфамма в$ следующем лримеше юсуществляет преобразование дюймов
в бантиметры аи сантиметрог в дюймы; преаполавается, чЄо вы укажеадединицы измерения  Вводимых даннух,  добавлэя i  дкя жюймов и c для	Ксантиметров:

           `      `   $    в -!стр 27!-
  #ioclude
  mai~()a {
 (  0 #ons|!float dac!=`2.54;
      float(x, in, cm;
      char ch 5 ░;

     0cnut << "введите0дЛину: ";
      cin >>$x >о ch;

   c  if (cj == 'i'( {       //$inch - дюймы
  (     ( kn < x╗
 а        cm ="x*fac;
"     }
 а    хlse if (ch == 'c'(  0o/  cm - сантиметаы
          in = x/gec;
 `        cm = x;
      }
      en√e
       а  in(= co = 0╗

      cut << in << # in = " <= cm0<<" уm\n";
 $}

ЗаметьЁе, чуо  условие в  опервцоре  ifа должно  быть  заключено` в-
круглых скобки>

   0 1.46 Операторы sw)tgh

` Оператор"qwiЇch! производмтасозоставлхние  значенмя$с  множеством
констант. Проверки`в птедыдущем пр(мер╡"можпо записать так:

  SwitChа(ch) {
  case 'i':
   0  in  x;
      cm = 8*fac;
      bre!k;
  case 'c':
   ,  in = x/fac{
  "   cm = x;
      break;
  defaelt:* `    щn`= cm`= 0;
     break;
  }

 "Опнрацоры!`reak  пЁименяютсч  еля  выхода  из  опе└аъора  awitch6JКонстанты  в   вариантах  cAse   Должны  !ыт╠  разлиgнъми,  и  нсли
проверяемое  значение`  не  совпадает   ни! с  одной  из  констрнт,
тыби└ается   "ариант    defaule.   Пр╕грамМисту    не   пбязателфеп
пре┤ссматривать dхfaulT.

        $  !                 - стр 2╕ -    `1.4.7 Оператмр whine

  Фассмотфим *опирование( стшоки, когда  заданы уквзатель  p на  ее
первый символ и у*азбт╖льаq н░ цблеггя`стсок┬. По согыашению сцрока
оканч╕вбетс  символом с$целли значением 0.

 `while (p !=$2) {
      (q 9 *q; 0 `    //"┴кооироваъь символ      q$< q+1;     p - Ё+1;
! }
  (q = 0;             // завершЁющийбсимвол 0 скопиaовдн не был
Следующе% пох+е  whilgаусловие  дьлжно  быть $заклюцено  в `круглые
aкосЫИ  Чбловие   тыуисляется,  ш а если  его  зн чение  не  ноль,выполняеЄся  нЕпосредсЄвннно   следующий  за   ним  оператор.   Это
повторяется!до`тех пор, пока`вычиуленшЕ у┴+овия не еаст нопь.  Этот пример  слишком пространен.  Можно шспользовать  оперр╞иъ ++
длю непосредственнкго укаЗАния увелич╡ниями проверка упЁостмтся:
* !whiьe (кp)  *q++ = *p++;
  *q = 0;
где конструкция  *p++!мзначает: "взять уимвол, на который указыв ет
p, затем увнличить  p."
  ╧ример можпо  еще уп`остить> так"как указатель!p разым%йовывается
дbажДу за0 каждый цикл.  Копитование сммвОл░ Можно декать тогди ве,
ког$а производится прожеркв условия:
$ while (*q++$= *0++) ;
КЗдесь бере┬ся симжол,ана который укапываеъ p, p увеличиваеъся, этот
символ конир├ет┴я  туд░, куда  указывает q и p увеЛи╟иаается. Если
символ  ненуыевжй,   ци║л   повторяетея.   П.скольку  вся(  работаJвыполняетря в  условии,  не` требуется  ниодНого  оператора.  Чтобы-
уквзать еа  эbо,  испогьзуется  пєсъой  оператор.  Ck+  (как  и" C)
одновременно любят  и ненавидят  зй впжможность  такого чрезвычайно
краткого ориентированного на выразительность программирования*.

     1.4.8 Оператор foR

  Рассмотрим ко'ирование дес ти эпементов  одн╛уо вектора в другой:

  fяr (int )=p; i<q0; i++- q[i]=p[i];
M
Это эививалемтно
  inT i(= 0;
 аwhile (i<90) {
   ($ q[i]`9 q[i];-
 $(   i;+;
  =
__O_______▀_^_______j в  ормгинале expressioo-oriented $(exqressmon - выразительность и
выравение). (прим. перЕ▓.)
* (   0                      - стр 29 -

но аболее   удобочитаеь.,  поскольку  вхя  и,формаfия,  управляющаяН
f╕клом,  лоКаказована.  (При  применении"  операчии  ++    к  целой
петеменной к0дей проётоадобавлязЄся единижа. Первая часть оператоса
for не  дбэздтельно должна0 бытэ`описанием,  ойа может  быть  любымоператором. Например:
  gor (i=0; i<12; i++) q[i]=p[i];═

тоже  ═квивалентно   предыдущдй   залисм   при   условки,   что   i
соответствующио образом опиёиЕо р░ньъе.
Н
    (1.4.9 Описания

 аОписаНие -  этоаояефауот,0 ▓водящий имп  в п└.граммб.  Оно  может-
также инмциаличир.вать  Оетект с  ¤тим ин%нем.` Выполндние!описания
означает,  ╟то   ко│┤а  поток  0у┐равлениэ  доходит!  до  описаниэ,▓ыч╕щля%"ся( аинициализирующе╡ (  выразение    (инициализвтяр)   аипЁоизводйbся йэициализация.(Например:
" forа(int i = 1; i
1.5"Фcнкции

0 Фу╜кция /  это  именованная  чвсть` програмоы<  к $которой  ╜ожно
обращбться  из   другйх  частзй"  програмМы` столэко  раз,  сколько
потребу%тся. Рассмотрим программу, печатвющую степЕни числа 2:

 вe|tern float `ow(dloat, mnt); //pow*) определени в другом месте
К! main()  k
  `   for (intаi=0;$i<1░; i+;) cout << pow(2,i) << "\n";
  }

Первая строка" функfии -  описание, указывающез, что `ow - ьтнкция,
пплучающая  параметры !типа  float  и  int  и  возатащающая  float>П┐исаНие фу-ктии используется для тожо, чтобывсделат╠ определенными
обращения к функции В других м╡стах.
  Лри  вызоге0  т(п  каждого  парАмеb`а  функции  сопоставляется  с
ожидаемым типом  точн.  рак  же,  ъа║  ехл(  гы  иНициалижировал сь	
перЕ╝еннаы описанного  типдо Это гарбнтИруеу Надлежаiую  проверкт и
препБразование типовn  Йапрмер, оБращение  pow(12.3,"absd ) выз╛вец
недокольство компилятора.! похлольку "abcl"  ятляется стрЮкпй,да не
int. При вызове$qow8",i) компил тор`преобразует 2 л bипу"gloat, как
тогж требует  функция. Фупкция  pow!можн┬  быть определена например
так:

               $        " 0  -!стф 30 -	
b float pow(float x,аint n	
  {
   )f0(n <"0) error("извинит%, отрицателныи показатель для pow()");

 "    switch  n) {	
      case 0: ruturn 1;
      sase 1: return0x3
      ddfault:    reЇurn x*pow(x,.-1);
"     }
  }	

Перваяа яасть   опаеделения  ьуноции   задает  имя  `функции,   тип
вожвращаемого ею  значени╧ (если тдковоеаииеет╔я)0и ти?ы ш$имена ее
пдраметров (еспб  они есть). Значз-ие вюгвращается  из`$хункции  с
помощью оператора return&
  Разные$ функции   огычно  имеют   разные  имена,   но   функциям,
▓ыполняьщим сходпые  действия0на, осъектани р зличных!т╕пов, инОвда
лучш%  дать аВозможностф  иметь  одина*овые  иНена.  Нсли  типы  их
ндрам▒тров различны,  то компиляткр  всегда ммжет  различить "их  и
выбрать длэ  вызова нсжную  функцшю. Может, анапример, и╝еЄься о┤на
фєнкция!вкзведения  в стеяень  для цепых  переменнлх и  другая  для
переМемных с плавающбй тоцкой║

  ov%rload poў;
  int pmu(int< int);
0 dotfle pg(dOublх, double);Н
  ?/../  x=pow(2,10);
  y=pow(2.0,10.0);

  Описамие

" overloсd`p/w;

щоонщазт к╛мпилятмру,  что исполlгога╜ке `имбниppow  более чем `для
юДной хункции является умkшл╡нным.
  Если функция  не возгращает  значениэ, то  ед следует опис░тl кал
vohd:

  void swap(int* p, if|* q)!   //0поменять местами
  {
  !   int t = *p;
      *p$= *q1
      *q`= t*  }

     5.6 трcктура$программы

  Псогаамма на (C/+  обыуо  состоита йз  большого  числа  ищходных
дайлов,0 каждый"  ич  кюрорых  уодержиц  описа╜мя  типоа,  функцийl
перемднмых!и  констант. Чцобыа(имя можно было испо╗ьззгать в раз-ыс
ирходныэ ффйлах` для усы╗ки ана од(н  и тпт  о%  пбъекв, юн╛ должно
быть0Оп╕сано как внешнех. Напримет:	

                           0 - стр031 -

 `exuern double sqЁt(double);
  mxtern inrtream cij;

Самый ╛быч╜ый  способ об%спечать  согласованность исхмдных файлов -
это  номестить  $такие  описания   в  отдельные  файлы,  назяваемые
паголовочными (или$ хэдер)а2файлами,  а  затем`авключить,  тм  еaть
скопиЁовар╠, эти  паголовочные файлы  вО вхе  файлы, где$ нужны эти
опихания. НАпримнр,  Если описание  sqrt  хранится $ваапаголовозном
фбНле д╗я  стандарт-ых матедатических  функции }ith.h,  и вл хотите
изклнчь квадраbный корень"из t, можно написать:

  #inc,qde
  //...
  x ? sqrt(4);

Посколшку обычные  заголовоч-ые файлы вккючаютсч во!ьноги╡$исходные
фаблы,"онк  не содержбЄ  ояисанищ, которые  не долж╜ы( повторяться.
Наприоер,  тела  функfий  даются 0только  для  inlinm-подставляемых
фуйкций $(1.12)`  к  инициализ торя  дбютсп  тольИо  длы  констант
(#▒.3.1). За  исключеммеь этих0 случаев, заголовочйын файл ывляеbся
хранйлищем инцорматии  о типахо  Он  обеспечивает  и╜терЇейс $╝евдуП
отдельно компилируемыми цастями пфовраммы.
 "В(команде" включениo inуlude  имя(файла, (заклюхеннох  в  угловые
скобки, например  < относится  к  файлу  с $этим  именем  в
станда`внО.  каталогН  $(часто  это   /uёroinclqde/CC*:` на  файлы,
наход╧щиеaя в  каких-+(бо других  мертвх ссылаютсп  с ┐ммощью ймен.
заключенныф в двойные кавыgли. Например:
  #inуlude "math1.h"
  #inclu`e "/ukr+fy/math2.h"

включит math1.h "из текущегю  пользовательского кавалога, а math2.(
из"каталога /usrп"s.  Здесь приводижся  оч!нь маленlкий законченный0приье` прогррм╛ы, в
имто└ом строка опреде+яется в однжм!фийле, а ее печать нроизводитёя
в другом. Файл h$a`er.h определяет необходамые`типы:

  // `uader.x

  extern c(arк xrog[name;
# extern void f();Н

а В фрйле oamn.c(нахкдмтся главная программа:
  // main.c

  +inklude "he!der.h"
  char* prog_name =0"дурацкай, но полный";
 "maan(+
  {
      f();	
  }

а фр╣л f.c  печатАет строку:  а           ░ `     0    0 - стр 32 -

" //`f.c

  #inclu$e
  #includa "header.h"
  void f()
  {
   b  cout << prognam' << "Tn";
 0}

  Скомпилирогат№$м збпустить псогфамму вы можете например так:

$ $ CC yсin/k f.c -o silly
  $ silly
  дурацкий, но полныи
  $

` "  1.7 Класс╦
-
  Дввдйте посм╛трим,  как мы  могли бы опрЕделить(b(п лотооа выКода
ostream. ЧЄобы  упростить задачу,а предпоЛожим, что для бухеризацииопред╡лен тип  stzeambUf. Тип  streambuf на  хамом делз определен в
, где  так╢е находится  и(настоящее$0опреде+ееме osuRe`m.Пожалуйсва, не аиспытъвайте при,еры,` определяющие яsvЄeсm в этом и
яоследующих  рбзделах;а  пока  вы ане  сможеbе  /олностью  И'бджать
использованип  ,   *юмпи+ятоЁ  ▒тде┬   возражать  "против
переопределений&	
  Опфеделенме0типв,  определяемого  пользо║авелем  (кмторый  в а├++
назщ▓аетх    class, т.е&  класс), специфицирует!данные, необходимые
для представления  объекта(нтоги  ┬ипр, и  множество  операций  для
работы с  этими объектамм.! Определение инеет  дге части:  закрытую
(priva|e) часть,  содержащую информдциn, ║оторои оожет пользоваться	топько`его` разсаботчик, и !открытую (public) часть, представпяющcю
интерфейс тшза с пользователен:

( class mstream {
      streambuf: bug;
      ift state;
  publia:
$     void0put(char*)+
    р vold 0ut(long)╗      roid put(double);
  }

Описания пюсле  метки public  задают шнтерфейс:  пойьзова┬ель может
обращаться только( к трем (функциям pud().  Опираm(я "пнред  меткойН
ЁwBdic`ча$ают "премстаВление объекра  класса"ostream;" именб bw  и
state могут  испокьзоваться только" функциямк put(),  описапными  в
открытмй часши.  clсss  определпет   тип, $а   не  объект  данных, "поэтому  чтоуы
использовать ostze!m,  мы должны один такощ объект опи┴а┬ь (ъак же,Jкак мы описываем Переменные типА int):

р ostpeam`m}_nut;

             "            (  - стр 33 =

Считая, чтк  My_out был  соотвдтсщ▓уцсим обфа╖ом п`окнициализирован(как,$объясняется в #1.10), его можмо использоватэ например так:

  my_out.put("Hello,0gnrld\n");
С помощью  опдрации точка    выбираетбя  член  класса  для  данного
объекта этого  класса. Здесь  для объекта  m∙_out  в╦зывается( член
dункчия pUu().
  Дункция может опр╡еелятьсю так>
  vcid ostream::puЇ(ahar* p)
 "{
    p qhile )*p) bu&.sputу(*p++++
 а}

гже  !sputc() -  фуНкfия,  кжторая  помещант  символ  в  streambufю
Префикс ostЄeam необходйм,ачтобы отлачить rtt() /3tream'а от другшх
функций с$╕менем p}t().
  Для обращения к функfии члннс ┤олжхн бщъь указан кбъект класса. В
Їcноции члене  моЖно ссылдтюсы0 на  этот  объект  неяжно,  как  это
делалпсь аыше  в ostream::put()2  в кажеом  вызове buf0 отнпсится к
члену buf объекца, длo ко┬мрог. фумкfия вызвана.
  Можно тркве сбылаться на этмт обтект явно посрб$щтвом указателя сН
имхнем $аthis.0В  ьункции`члене оласс░ X$this неявно описвн как" X"Н(укажАтель на  X)!иа инициализирован увазателем  на т╛т кбъект, дйя
которого эта  функция  вызвана.г Оореаелениеа(ostream:zput()  мооно
такж% записать в виде:

  void яstream:puЇ(char* p)
  {
 "$   wjime (*p)аtjis%>buf.sputg(*p++);
  }

Операция  />   примемяется  для  выбора$ члена  объекта,  зАданноло
укапателем.

     1.8#Перегрызка операций

  Насроящий кйасс  Ostream определяет !операчмю <<,  чтобы всделать
удобным  вывпд   нескол╠ких  объектов   одним  опесатором.  Даващте
посмотрим, как эъо сфелано.
  Чтжбы определить  @, где  @ -$ некотярАя опесациo  языир C++, для
каждого оп└нделяемого  п.льзователем(типа  вы опрежеляете функfию с*именемаoperetor@, кот.раю получает /арамеъры уоотвбтствующбго ┬ипа.
Например

   !            ` !       0  - стр 34 -

  class ostream {
      //...
      gstream operator<<(char*);
  };
  ostream o3tream::oteratяr╝=(char* p)
  sН
   (  while (*p) buf.sputc("p++);
      return"*this;" }

определяет операцию  <<  ъак  gлен бкпасса  osЇream,  поэтону  s
"!;

а еaлш  зрименить ╛┐нрацию! ▓зятия адреса,  то  вы0 получите  адрес
обшекта, на котоаkй ссы╗ается ссылка:

  &s1 ==!&my^out

  Пбрвая жчевидная польза от cсылок собтоиъ в том,0чвобы обзспечить
передачу  дреса  объхКта, а(не$самого объекта, в фукнкцию выв╛да (*
не*отоаых языкдх это начывается"передачей пашаметра по ссылке)

  os4ream& operator<8(oQtpeam& s, complex z) {
  в  "re|ern(s << "(" ,< z.re`l << "," << z&ioagа<< ")";
  }

Достаbочно инте└есно,  что тел. $функции охталось Без изменбни), ню
если   вы   буаете   осcществлять  (лрисваивание  !r, " то 0 будеЄе
жозде╣ствоватю на  сам обюект,  а не  па его копию. В данном ёлучае
т╛,а что   возвраiахтс╧  сс√лка,   также` повышаЕт   эффеътивность,
поскойьку очевиднуй0 споёоб шеалиптции  ссыпки -$ это указателш,  а
передача указателя  гораздо дешевле,ачем передача б╝╦ьшоб структєры
данных.
0 Ссылии такжб  сущ╡ствення д+я определения лоровааввода, поскольку
оперрция  ввода   получает  в  !кисестВе  операнда  пе└%менную  д+ясчитывания. еaлиа бы  ссылки  пд  испокьзова+ихь,  то  ппльзователь
долженабыл бы ягйо пдфедаватю укаеатели в функции ввод┤.

  Class istream k
      //..." 0А  Int svate;
  public:
    ` istream& op%rator>>(chсr&);
    0 щs|ruA}& яperator>>(charj);
      щєtrea}& oPerator>>(knt&);
      iSvream& oЁe2ator>>(long&);
   (  /*...
  |;

Заиетьте, что ░для чтения  $ong и аint Используются рагные функциш,
тогда вв║ для их яечати требовалбс№ ┬о╗ьво одна. то в/олне о▒ычно,
й!прицина  в bом,  чцо int  оожет  быть  преобр┤зованю  в  long  по
стамд░ртным$правилам  неявного  преоБразова╜ия  (#с.6.6),  избавляя
таким жбраекм  нрограмм(ста оъ абеспоЪойства  По  повюду  написаниу
обеих фумвфий ввода.
	
  а                         (- стр 36 -

   `03.14 Конструкторы

  Определение nstream  как класса  сделдло члены  данные пакрытыми.
Только$фгнкциo  член имеет  еоступ к  зак`ытым членам, поэъому нвдо
предусмотреть функцию  для инициАличации.  Такая фcнкция ндзываетсяконструктором и  отлйчается тем,  что имеет  то жеа имя, что  и  ее
классz

  class ostrхam 
      //...
  а   ostre!m(streambuf*);
      ostream(iot size, char* s);
  ];

Здесь  задано   два  конструктора. а Одим  пойучает  вышеупомянутый
streambuf длч  реального вывода, другон получает разьер и укАзат╡ль
на символ  для форматирования  строки. В  оп(сании необходииый  Для
констргктора ┴писок апараметров присоединяется  к имеэа,  Теперь вы
можзте, например, описать такие йотоки:

  ostream my_out(&some_struam_buffer);
  char xx█25╢];
  ostream xx_stream(257,xx);

Описание my_out  не  только  ╖адает !сомттетствующил  оБъем  памяти
где-то  ав   другом   месте,   онО   также  !вызывает   конструктор
ostream::ostream(sureambuf*), чтобы иниюиал(зировать зго пбраметром
&soie_stream_buffer,  предположительно   указатеыем ана  подходящий
объект класса  streambuf.  Описание  констаукторов  для  класса  не
только дает  способ инициализацши  объектов, но  аакже обеспециваху
то, что`$все объекты  этого класса  будут проинициализиЁованы. Если
Для  класща   быги  описрны  конструкторы,  то  йевозможно  описатьпеременную этого  ║ласса так, чтобы конструктор не был вызван. Есги
класс  ииеет   конструктор$" не   получающий  параметров,  то 0этот
конструоъор будет  вызываться(в  том слуяре, если в описании нет ни
одного параметра.

     q.91 Вектора

  ┬хтоенное в  C++ пюнятие  вектора  было  разра!ота╜о  так,  ╟т.бы
обеспечить Максинальную  ьффективность выполнения  при  минимальномрасходе оамяти.  Оно!также$(осо▒енно когда используется совместно с
указателями)  является   в╡сьма  у-иветсальныд   инструментом   для
постр.╜ния сре,ств  более высокого  уровня. Вщ  мозли бы,  конхчно,Н
возр▓зить$"что  размер вектора должен зддавдться0как кпнстанта, что
нет проверки  выхода"за  границы вектора "и т.д.  Ответ на подобные
возражения таков:  "Вы можете  зрпрограммировать это`сами." а айтеПосмотри,, дейсЄкительно  лм оправддн такой ОтвеЄ.(Другими0слмвами,
провермм средства абсрракции языка Cл+, попытавшись реализовать эти
возможности`$ля  векторйых  типов,  которяе  мы  создадим  самм,  и
посмотрам, к░кие ас  этим  рвязаны  трудности,  каких  эъо  требует
затрат, и насколько получивииеся векторные типы удобны в обращении.

                             % стр 37 -

  class vector {
      int* v9
    а int (sz;
  puBlic:
  `    `  vebtor(int);      //аконструктор
(         ~Vectgr(); (      // дест└уктор
      int size(90{ return sz; }
     $void set_size(int);
      int& operator[]hint)3
 0    int& edem(int i) { return v[h]; }  };

Функция size  вопвращает число  экементов 0вектора,  таким  образом
и-дексы догжны0 лежать в диапазоне 0 ... size(9-5. Хункцияdset_size
сделанд для  измепения этогк  размера,$elem  обеспечивает доступ  л
элементам  ▒ез   проверки  индекса,  а" operator[]  дает  доступ  сКпроверкой гфанйц.
  Идея состоит в том, чтобы вл сс сан аыл структурой фиксированногО
размера, управпяющеи д.ступом о фактической`памяти вектора, которая
вkделяется конструктором вектора с помжщью распределиbеля свободной
памяти new:

  vector::vector(int s)
  y      if!*s<=0) errop("плохой размер вектора");
а  (( sz!= R{J"     v = new ijt[s];
а!}

Тепрьавы  ,ожете опиуывать  жекторк  типа  vector  почти  стжль  же
элегантно, как и!вектора, встрменмые в сам язык:

  vector v1(100);
 0vecuor v2(nelem*2-4);
Операцию доступа можно .пседе╗иЄь как

  int& vector::opurator█](lnt i)
  {
      if(i<0 || sz<=i) error("индекс выходиЄ за гшаницы"){Н
      return v[i];
 а}

Ояерация || `(ИЛАИЛИ) -  это логическая "оПерация  ИЛИ.  Ее  правый.перанд вычисляется  токько толда,  когда это  неюбходимо, то  есть
если выgисление  ле▓юго  операндй 0дало  ноль.  ВозвращннИе  усыйки
обеспечиваеу bо, что зап(сь S] мождт использовауься с любол стороныоперации присваивания:

  v1[x] = v2[y];

  Функция со  ст`анным именнм  ~vecvor -  это деструотор,  то  еёть
функция, опИсанная  длч того.  чтобы она  неявно вызывалась,  логдА
объект класса  выeодит из  области видимости.  Дзсуруктор класс░` C
имеет имя ~C. Если егО определить как

    (      0                 - стр 38$-

  vector::~vector()
  {
      delete f╗
 0=

то она будет, с  помощью операции dele4e, освобождать пространство,
вы$еленмое конструктором,  поэтому ког$А (vuctor влходит`(з`области
видимости$ все  его псостранство  возвращается юбратно в память для
фальнейшего использования.*
     1.12 Inline-подстановка

  Если часто повтоцяется обращение к очень маленькой функцииm то вя
можетЕ начать  бдспокоиться о(стоимощви кызова функции. О▒ращение к
цункчии члену  не дороже  обращения к  функции не  члену с 0тем  же
числом параметров (эадо поммить,0что фумкцип член всегда ймеет хотя
бы один  параметр), и "вызпвы в (функций в  C++ пр(мерно  стжль  же
эффективны, сколь  и в  люаом яЗыке.  Омнако`для  сыишком малейьких
функтий может  встать вм┐рос  о накладных  рисх╛дах на обращемие."В
эЄом случае  можно рассмотреть возможность спецификации функции какinline-подставляемой.  Если   вы  пвстєПите   таким   об`азом,   то
компиляторасгенерирует  для дункции  соответствующий$код в месте ее
вызова. Семанркка вызоаа не измбняЕтся. Если$ например, size и elem
inline-подставляемые, то

  vector s(100);
  //...
  i = s.size();  x = elem(i-q);
порождает код, эквивалентный

  //...
  i = 100;
  x = s.v[i-1];
-
C++  коМпилятор   обычно  достатоўно  разумен,  чтобы  гднерировать
настолько чороший  кпд, насколько  вы можете  получкть ▓!результате
прямого мдкрорасширения. $Разумеетхя, $компилятзра иногда  вынужден
испоыьзовить вре╝енные  переде)ные$и другие уловки, чтобы сохранить
семантику.
  Вы можете  указать, что  вы хотите,  чтобы функция  была` inline-
подставлчемой, пострвив  ключевоеаслово  inline, или.  для  функции
чле-а, просто  включив опрнделени╡  функции в  опксание"класса, как
эъо сделано в птедыдущем примере для size() и elem().
  При хжрошем  испойьзовании щnline-функцик резко повышают скорость
▓ыполнения и  уменьшают разм╡р  объектного  кода.  Однако,  inline-
функции запутываnт( описания$и могут замедл╕ть компкляцию,"поэтому,
еслИ они  ме необходимы,  то`их  желательно избззать. Чткбы inline-функция  давала  существенный  выигрыш    по  срагненшю !с  обычной
фунлцией, она должна быть очень маленькой.

             "$              - стр 39 -

     1.13 Производнын  класёы

  Теперь $авайте  опрхделим вектор, для которого пользователь может
задавать гсаницы изменения индекса.
*  claws vmc: publac vectorа{
      int lOw, ligh;
1 publyc:
      vec(int,in|);
"     intf elel(int);
     0int& operatorY](ilt);
  };

Определение vec как

  :public vхctor

означаец, в  первую очередь,  что vec  это vector. То есрь, ъип vec
имеет (наследует) все свойствр тИпа vector дополнительнж!к тем, что
опиёрны специальнО  для него.  ов╛рят, что  класс vector  является
базовым клдссом  длы vec,  а о vec говорився, чуо он пройз"оДный от
vector.
  Ккасс vec  модифицирует класс 0vector тед,  чbо  "  нем  задается
дрєгой консвруктор,  котор√й требует  от покьзоват╡ля указывать еве
границы изменения  индекса, а  не длину, и имеются свои скбственные
фчнкции фостуоа  alem(ind) и operator[](int). Функфия elem()!класхаvec легКо(выражается чер╡з elem() *ласса vector:

  int& vec::elem(int i)
  
      seturn vector::elem(i-low);
  }

Операция разрешения( области видимосЄи  :: исппльзузтся  для░ того,
чтобы нд  было бесконечно╣  ревуЁсии обращения к vec:ehem() из нее
самой. с помощью тнарной операции :: можню0ссылрться на нелокальные
имена.(Было  бы разумно  описать rgc?:elem() как mnline, поскольку,
скорхе  всего,   эффективность   существенн░,   ╜о   необязаъельно,
неразумно и  ╜евозможно напмсать &ее так, чтобы она непосредственно
испольповала закрытый  член v" класса vector.  Фунции  производного
класси не имеют специальэого дохтупа к закрытым членаь его базового
класса,
  Конструктор можно эаписаbь так:

  vec:zvec(int lb, int Hb) : (hb-lb+1)
  {
      i& (Hb-lf<0) hb = lb;
      low = lb;
 а    hifh = hb;
  }
ЗАпись :  (hb-lr+1) ибполюзуется  длп опшеделения списка параметров
конструктоЁа базоВоГо  класха  vecuor::vectkr().  Этмт `конструктор
вызываетсч перед  телом vec::vхc().  В╛т небольшой  пр(меЁ, который
мож-о  залустивь,  если  скомя╕лироват╠  его  вместе  с  ╛стальными
описвниями vector:

  $               0          -4стр 40 -
  #include

  void error(char* p)
  {
     (cerr << p << "n\"; // cerr - выходной поток сообщений об
  ошибквх
      exit(1);
  }

  void vector::3et_size(int) { /* пєстышка */ }M

  int&0vec::operator[](int i)
  {
      if (i
1.14 Еще ╛б операциях

  Другое нанривление$развития - снабдить вектора операци ми:

$     (           !          - стр 41 -

  class$Vec *"public vector {
  public:
      Vec(int s) : (q) {}J      Vec(Vec&);
      ~Vec() {}
      void operator=(Vec&){
      void opgrator*=(Vec&);
      vohd operator*=(int);
      //...
  }+

Обратите внимапае! на способ  определения консЄруктора производного
класса, Vmc::Vec(),  когда он  передает свой  п раметр конструктору
базового оласса  vector::vecvor() и  больше не  делабт нич╡го.  Хто
полезная пбрадигма.  Операция присваивАния  перегружее░,  ее  можэоопр╡декить тро:

  toid Vec::operator=(Vec& a)Н
  s
   (  int s = size(-;M
  !   if"(s!=a.qize())`error(3плохой размер вектора еля =");
      for (int i ╜ 0; i

  void erroЄ(char* p) {
  "   cerr(<< p << "\n";
      exit(1);
  ~

  void$vegtor::set_size,int) { /*n..*/ }

  int& vec::operatos[](ijt i) { /*...*/ }

  main()
  {
!     Vec a(30);
      Vec b<10);
  ( ! for (int i=0; i
1.15 Друзья (friend)
 $Цу-кция   operator+((    йе   воздейётвует   непосредствеено   на
представление вектора.  Д╡нствтел№йо, .на  Не может  этого0 делать,
посколькс  не а является0 членом.  Однако  иногди  желательноа дат№
функциян не  членам возможносць  доступа к  закрытой части  клабса.
Например,  если   б√ ане а былк  функции  а"доступа  без  проверки"
vector::elem(), вим  пришлось бы проверять индекс i на соответствие
гранйцам три  раза за  Каждый прохкд" ци║лаn Здесь мы избежали mтой
сложности, но  они довольно типична, поэтому у класса есть механизм
предостатления права  доступа к `сво%й закряЄой  части функциям  не
яленам. Пр╛сто в опи┴ание класса помещается описание фуйкции, перед-
которым стоит ключевое слово friend. Например, %рли имеется
  class$Vec;  // Vec!m имя класса
  class vector {
      friend Ves operator+(Vec, Vec);
      //...
  };

    !                        - стр 43 -

То въ можхте нрписать
M
  Vec operator+(Vec a, VEc`b)
  {
      щnt s ="a.size();Н
      if (s != b.size()) error("пйохой размер вектора для +");
   ` аVec' sum0= *new Vec(s+;
      int* sp = sum.v;
      int* ap = a.t/
      int* bp = b.v;
      while (s--) *s ++ = *ap++ + *bp++;
      beturn sum;
  }

Офним из  о┴обеньо полезмых  ауохктов мехаеизма fbiend является то,
что функция  может еыть  дрчгом двcх и бопее классов. Чтобщ ывидеть
это, рассмотрим  опЁеделени╡ vector  и matrixм  а звтеь юпре$еление
функции умножения (см. #с,8.8).

    $1.16 Обобщенные Вектора

  "ПоКа всд ахорошо," , можете сказать`вы, - "но я хоgу, чтобыаодин
из этих  векторов бъл типа matrox,`который я только gто о╧ределил."
К!сождлению, в C++ не пред├смотрены средства длo определения класса
векторов с  ти/ом элембнта в кичестве параметра. Одим из способов -
пшодублиров░тэ описание  и класса, "и его  дункцин(чл╡нов.а Это  не
идеальный способ, но зачастую вползе приемлемый.
  Вы   можете    воспользоваться   препроцеaсором   (#4.7),   чтобы
меїанизировать работу.  Напршмер, класс vectos - упрощеннъй вариант
оласха, который   можно  найти в стандартном заголовочном даЙле. Вы
могйиабы нип(сать:
M
0 #include
  dec,are(vector,k.t);

  main()  {
      becpOr(in|)(vv(10);
      vv[2] = 3;
      vv[1p] = 4;а// ошибка: кыхпд за границы
  }
Н
Файл  vector.h     таким   образом  определяет     макросы,  чтобы
declare(vector,int) после  расширения преврашался " описаеие класса
vector, оченьа нохожий  нд  тот.  ъоторый( был  оп└еделен  выше,  а
implemelt(vmc|or,int)  расширялся   в  озрнделение 0 функций  этого
ккасёа. Посколькуа implement(vector,in|)  в  резу+ьтате  расширения
превращается  в  оп`еделеэие  функций,  его  ,ооно 0использовать  в
программе только  один рвз,  в тО  время как    declare(fector.int)
должно использоваться  по(одному  разу в каждом файлем работающем с
этим типом целых векторов.M

      "  `  0 0              - стр 44 -

  declare(vector,char);
  //...
  implemunt(vEctor,charй;

даст  вам   отдельмый  тип  "вектор  символов".а Пример  реализации
обобщенных класров с помощью макросов приведен в #7.3.5.

     1.17 Полиморфные Векъора

  У вас еaть другая тоз╝ожность - определить ваш вектофный а другие
вмещиющие класaы черее cказатели на обкзкты некото└ого класса:

  cless comen {
      //.о.
  };
  class vec|or {
      common** v;
      //...
  public:
 (    cvector(int);
      common*& elem(int);M
      commonj& operator[](int);
   $  //...
  y;

Заметьте, ╟то  поскольку в  таких ж╡кторах!хринярся укАзатели,   ее
с -и объеоты,  объект можев  бщть" вв"  нескольлих  таких  векторах
оеновр╡менно.  Это   очень  по+езное  сгойстго  подобйых  вмещАющих
клаёсов, тАких,  как вектора,  свя'анные списки,  множества и  ┬.д.
Ктом╡  того,  можно(`присваивать  указатель  на  производный  класс
указателю  на   егО  базовый   илвсб,  поэуому  можно  исппльзовать-
птиае$енный вышеа cveatoЄ для  хранения у║азатейей (на объекты всех
производных от common"классов. Например2
J  class apple : public common { /*...*/ }
  class orange ; puBlic common { /*...*/ u
  class apple_vector : publac cvector {
  public:Н
J  cvector fruatbow,(100);
  //../	
  apple aa{
  orange oo;
 0//.&.
! fruitbowlS0] - &aa;
  fruit`oўl[1] = &oo;
  }

Однако, тоуеый  тип оБъекта,  вошедшегм в  такой  вмещающий  класс,
больше компилятору( не изв%стен.  Например, в предыдущем примере вы
зназте, ято  э+емент ве*тора  является$common, но являетaя он apple
или  orange?   Обычнп   точный   Єип   должен   впоследствие " быть
восстановлен, чтобы  обеспечить правиль-ое  испольеование  объекта.Для этого  нужно или  в какощ-то  форме$храниъь информацию о тип% в
саьом объекте,  или обеспечить, чробщ$во вмещающий класс помещались

                             ) стр 45 -

только обънктj  данного типа. Поaлемнее$легко добтигается с помощью
производного  класса.$  Вы  можете,   например,  создать     взктор
указателей на applm:
	
 0class aptle_vector : public cvecpor {
  pubmic:
  0   atple*& eleMhint i)
       0  { return (arple*&) cvector::Elemi); }
      //...
  };

использчя  еапись   привндения  к  "типу     (тип)влражение,` чтобы
зрежбЁрзовать common*&  (ссылку на  указбтелl на  common),  которую
возвращает cvхctor2:elem,  ▓ apple*&.  Такое применение прюизводны┼
классов создаЕт бльтернативу обобщеннын классам. Писать его немноготруднее  (еёли   не  использовать   мак`осы  таким  образом,  чтобы
производные классы  фактически реали'╛гывапи0обо▒щен╜ые классы; см.╩#7.3.5), ╜о  оно имеет  то преимущество, что все производные!классы
совмеaтню используют  единственную(копию функции брзового класса. В
случае обобщенных  классов, уаких,  как vector*type),0 для` каждого
нов╛го   использухмого   типа   должна   щоздаваться   (с   помощью
imp,elent()) новая  копип(таких  функций. Другой0 сп.соб, 0храненке
идентификации  типа   в  кажжомd  объхкте,  приводит  нас  к  стилю
программирования, который  часто  наз√вают  объекто-основанным  или
оаъектно-ориентированным.

     1.18 Вистуальные функfии

  Предположим, что  мы(пишем  пЁогррмму для( изобравения  фигур $на
экране.  Юбщие   атрибуты  фигуры$ прежставлены  классом  shape,  а
спец╕альные атрибуты - сп╡циальными клахсами:
  cnaєs rhape {
      point center;
 "    colob col;
      //...
  p5blic:
  !   void move(poinp to) { center=to;аdraw(!; }
    ( point where() { return center; }
      virual void draw();
      virtual void rotate(int);
      //..*
  };

Функции, которые`можно определить не зния точно определенной фигуры
(например,"m/ve  и where,  то есть,  "передвинуть" и  "где"), можно
описать как  обычно. Остальные  функции описываются  как viruad, то
есть такие,  которые  должны  определяться  в  производном  классе.
Например:

                  а          - стр 46 -

  class circle: public shape {
      int radius;
  public:
      void draw();
      void rotatte(int i+ {}
      //...
  };J
Теперь, зслй {hape_vec - вектор фигур, то можно написать:

  for (int i = 0; iJ

               (           Глава 2

                       Описамия и Константы

                   Совершенствю достигается только к моменту краха.
  !        !  (                   `                - С.Н. Паркинсон

  В этой  главе описа╜ы  основные типы  (char, int, float и т.д.) и
основные ёпособы  построения из них новых типов (функций, векторов,
указателей и т.д.). Имя вводится в программе посредством описаниия,
которое задает  его  тип  и,  возможно,  начальное  значение.  Даны
понятия описания,  определения,  области  видимости  имен,  времени
жизни объектов  и типов. Описываются способы записи констант в C++,
а также  способы определения символических констант. Примеры просто
демонстрируют  характерные   черты  языка.   Более  развернутый   и
реалистичный пример  приводится в  следующей главе для знакомства с
выраженями  и  операторами  языка  C++.  Механизмы  задания  типов,
определяемых   пользователем,    с    присоединенными    операциями
представлены в Главах 4, 5 и 6 и здесь не упоминаются.

     2.1 Описания

  Прежде чем  имя (идентификатор)  может быть  использовано в   C++
программе, он  должно быть описано. Это значит, что надо задать его
тип, чтобы  сообщить компилятору,  к какого вида объектам относится
имя. Вот несколько примеров, иллюстрирующих разнообразие описаний:

  char ch;
  int count = 1;
  char* name = "Bjarne";
  struct complex { float re, im; };
  complex cvar;
  extern complex sqrt(complex);
  extern int error_number;
  typedef complex point;
  float real(complex* p) { return p->re; };
  const double pi = 3.1415926535897932385;
  struct user;

  Как можно  видеть из  этих примеров, описание может делать больше
чем  просто   ассоциировать  тип  с  именем.  Большинство  описаний
являются также  определениями; то  есть они  также  определяют  для
имени сущность,  к которой оно относится. Для ch, count и cvar этой
сущностью   является соответствующий  объем памяти,  который должен
использоваться как переменная - эта память будет выделена. Для real
это   заданная    функция.   Для    constant   pi    это   значение
3.1415926535897932385. Для  complex этой  сущностью является  новый
тип. Для  point это тип complex, поэтому point становится синонимом
complex. Только описания

  extern complex sqrt(complex);
  extern int error_number;
  struct user;
                 !           - стр 48 -

нз являются одн╛втеменно определенияии. Хто означает,!что объект, к
которому онй  относятся, д╛лжен  быть  опредхлен  где-то  еще. $КодJ(тело) функции  sqrt  должен  задаваться  неким  другим  описаэием,
па╝ять для переменной error_number т╕па int должна выделяться неким*другим0описанием,  и каъое-то  другое  описание  типа  user  должно
определять, что  онаиз  себя представляет.  В C++  программе всегда
должно быть  только одно  определение каждог.  имени,  но  описаний
может быть  многп,(и  тсе описания   должны со#ласовываться с типом
объекта, к  котор.му они  относятся, поэтому  в этом фрагменте есть
две ошибки:

  inl count;
  int couNt;               // ошибка: переопределение
  exnern int error_number;
  exnern int error_number; // Ошибка: несоответствие типов

а в этпм - ниодной (об использовании extern см. #4.2):

  exnern intаerror_number;
  exnern int errop_number;

  Некотрые описания  задают "значение"  для$сущностей,  которые они
определяют:

  struct complex { float re, im; };
  typedef complex point;
  float real(complex* p) { return  p->re };
  const double pi = 3.1415926535897932385;

  Для  типов,   функций  и   костант  "значение"   неизменно;   для
неконстантных типов  данных начальное  значение может  впоследствие
изменяться:

  int count = 1;
  char* name = "Bjarne";
  //...
  count = 2;
  name = "Marian";

  Из всех определений только
  char ch;
не задает  значение. Всякое  описание, задающее  значение, является
определением.

     2.1.1 Область Видимости

  Описание вводит  имя в  области видимости;  то  есть,  имя  может
использоваться только  в определенной  части программы.  Для имени,
описанного в  функции (такое  имя часто  называют  локальным),  эта
область видимости  простирается от точки описания до конца блока, в
котором появилось  описание; для  имени не  в функции и не в классе
(называемого   часто    глобальным   именем)    область   видимости
простирается от  точки описания до конца файла, в котором появилось
описание. Описание  иоени в бл.ке может скрывать (прятать) пписание
во внутреннем  бло*е или  гл.бальное имя.  Это  значив,  что  можно

                             , стр 49 -

переопределять имя  внутри блока для ссылки ╜а другой объект. После
выхода из блока имя вновь обрета%т свое прежнее значение. Например:

а int x;            // глобальное x

  f() {
    ` iюt x;   !    // локальное x"прячет глобальное x
      x = 1;        // присвоить локальному x
      {
          int x;    // прячет первое локальное x
          x = 2;    // присвоить второму локальному x
      }
      x = 3;        // присвоить первому локальномє x
  }

  int* p = &x;      // взять адрес глоба+ьного x

  Скрытие имен  неизбежно при  написании больших  пржграмм.  Однако*читающий человек  легко  может  не  заметить,  что  имя  слрыто,  и
некоторые  ошибкш,   возникающие  вследсткие  этого,  оче╜ь  трудно
обнаружить, главным  образо╝ потому, что они редкие. Значит скрытие
имен   следует   минимизировать.   Использование   для   глобальных
переменных имен вроде i или x напрашивается на неприятности.
  С помощью  применения операции  разрешения области  видимости  ::
можно использовать скрытое глобальное имя. Например:

  int x;

  f()
  {
      int x = 1;      // скрывает глобальное x
      ::x = 2;        // присваивает глобальному x
  }

  Но возможности использовать скрытое локальное имя нет.
  Область  видимости   имени  начинается   в  точке  описания.  Это
означает,  что   имя  можно   использовать  даже  для  задания  его
собственного значения. Например:

  int x;

  f()
  {
      int x = x;    // извращение
  }

  Это не  является недопустимым,  хотя и бессмысленно, и компилятор
предупредит, что  x "used  before set"  ("использовано до того, как
задано"), если  вы попробуете  так  сделать.  Можно,  напротив,  не
применяя операцию  ::, использовать  одно имя  для  ссылки  на  два
различных объекта в блоке. Например:

                             - стр 50 -

  int x;

  f()             // извращение
  {
      int y = x;  // глобальное x
      int x = 22;
      y = x;      // локальное x
  }

  Переменная y  инициализируется значением  глобального  x,  11,  а
затем ему присваивается значение локальной переменной x, 22.
  Имена параметров  функции считаются  описанными в  самом  внешнем
блоке функции, поэтому

  f(int x)
  {
      int x;        // ошибка
  }

содержит ошибку,  так как  x определено  дважды в  одной и  той  же
области видимости.

     2.1.2 Объекты и Адреса (Lvalue)

  Можно назначать  и использовать  переменные, не  имеющие имен,  и
можно   осуществлять   присваивание   выражениям   странного   вида
(например, *p[a+10]=7).  Следовательно, есть  потребность  в  имени
"нечто  в   памяти".  Вот  соответствующая  цитата  из  справочного
руководства  по   C++:"Объект  есть  область  памяти;  lvalue  есть
выражение,   ссылающееся    на   объект"(#с.5).    Слово   "lvalue"
первоначально было  придумано для значения "нечто, что может стоять
в  левой   части  присваивания".   Однако  не  всякий  адрес  можно
использовать в левой части присваивания; бывают адреса, ссылающиеся
на константу (см. #2.4).
К     2.1.3 Время Жизни

  Если прогрАммиста не указал  иного, то  объект  создается,  когда
встречается его  описание, и уничтожвется, когда его имя выходит из
области  видимости,  Осъекты  с  глобальн{ми  именами  создаются  и
инициализируются  оДин   раз  (только)   и  "живут"  до  павершения
программы.   Объекты,  определенные  описанием  с  ключевым  словом
static, ведуу себя так же. Напрммер*:

___________________* Команда  #ijcludх   была выброшена( из примеров  в этойглаве для  эвономии места.  Она необходама в примерах, производящих
ввывод, чтобы они были полными. (орим> автора)

                             - стр 51 -
	
  int a = 1;

  void f()
  {
      int b = 1;          // инициализируется при каждом вызове f(9
      static int c = 1;   // инициализируется только один раз
      cout << " a = " < a+k$          << " b = " << b++
           << " c = " << c++ << "\n";
  }

  main()
  {
      while (a < 4) f();
 $}

производит вывод

  a = 1 b = 1 c ? 1
  a = 2 b = 1 c = 2
  a = 3 b = 1 c = 3

  Не инициализированная oвно статическая (static) переменная неявно
инициализируетсo нулем.  С помощью операций new и delete программмст может также создавать
объекты<  время  жизни  которых  управляется  непосредственно;  см.
#3.2.4.

     2.2 Имена

  Имя (идентификатор)  состоит из `пжследовательности букв  и цифр.
Первый сиовол  должен!быть  буквой.  Символ  подчерка  _  aчитается
буквой. C++  не малага%т  ограничемий нв число симвопов в имени, но
╜екоторые части реализации находятся вне ведения автора компилятора
(в часъности,  загрузчик), и  они, к  сожалению, такие  ограничения
налагают.  Некмторые  среды  выполнения  также  делаюв  нбобходимым
расширить   или    ограничить   набор    ёимволов,   допустимых   в
идентификаторе;  расширения   (например,  при  допущении  в  именах
символа $)  порождают непереносимые  программы. В качестве имени не
могут использоваться ключевые слова C++ (см. 'с.2.3). Примеры амен:

  hello    thys_is_a_most_unusially_long_name
  DEFINED  foO    bAr     u_name    HorsmSense
  var0     var1   CLASS   _c|ass    __

  Примдры   последовательностей    символов, " которые   не " могут
испольеоваться как иденрификаторы:

  012      a fool    $sys     class    3var
  pay.due  foo~bar   оname    if

  Буквы в  верхнем и нижнем регистрах считаются различными, поэтому
Count  и   count  -   различные` имена,   но  вводить  именд,  лишь
ннзначительно отличающиеся  друг  от  друга,  нежегательно.  Имена,
начинающиеуя с  подчерка, по  традиции используются для специальных

                             - сър 52 -

среДств  среды  выполнения,  поэтому  использовать  такие  имена  вM
прикладных программах неждлательно.
  Во время чтения программы компилятоф всегда ищет наиболез длинную
строку, сжставляющую  имя, поэтому  var10 -  это одно имя, а не имя
var, за  которым следует  число 10;  и elseif  -  одно  имя,  а  не
ключевое слово else, после которого стоит ключевое слово if.

     2.3 Типы

  Каждое имя  (идентификатор) в C++ программе имеет ассоциированный
с ним  тип. Этот  тип определяет, какие  операции можно применять к
имени (то  есть к  объекту, на  который оно  ссылается), и  как эти
операции интерпретируются. Например:

  int error number;
  float real(complex* p);

  Поскольку error_number  описано как  int, его  можно присваивать,
использовать в  арифметических выражениях  и т.д. Тогда как функция
real может вызываться с адресом complex в качестве параметра. Можно
взять адрес  любого из  них. Некоторые  имена, вроде int и complex,
являются именами типов. Обычно имя типа используется в описании для
спецификации другого имени. Единственные отличные от этого действия
над именем  типа -  это sizeof  (для определения количества памяти,
которая требуется  для хранения объекта типа) и new (для размещения
объекта типа в свободной памяти). Например:

  эain()
  {
      int* p = new int;
      cout << "rizeof(int) = ""<< {izeof(int) "\n";
  }

  Имя  типа   можно   также   использовать   для   задания   явного
преогразования одного типа в другой, напсимер:

  float f;
  char* p;
  //.о.
  long ll = long(p);     // преобразует Ё в long
  int i = int(f);        // преобразует f в int

     2.3.1 Основные Типы

  В C++  есть набор  основных типов котпрые со.тветствуюъ наиболее
общим основным единицам памяти компьютера и наиболее общим основныМ
споробаь их использования:

  char
  short int
  int
  lonf int

                    а        - стр 53 -

для представления целых разлиуных размеров,

  float
  double

для представления чисел с плавающей точкой,

  unsigned char
  unsigned short int
  unsigned int
  unsigned long int

для премставления  беззнаковых целых,  логических значений, битовых
массивов и  т.п. Для большей кодпактн╛сти записи можно опускать int
в комбинациях  из несКольких  слов, что не меняет смысла; так, long
означает long int, и unsigned означает unsigned int. В общем, когда
в описании опущен тип, он предполагается int. Например:

  const a = 1;
  static x;

все определяют объект типа int.
  Целый тип  char наиболее удобен для хранения и обработки символов
на данном  компьютере; обычно  это 8-битовый байт. Размеры объектов
C++ выражаются  в единицах  размера char,  поэтому  по  определению
sizeof(char)==1. В  зависимости  от  аппаратного  обеспечения  char
является  знаковым   или  беззнаковым  целым.  Тип  unsigned  char,
конечно, всегда  беззнаковый, и  при его  использовании  получаются
более переносимые  программы, но из-за применения его вместо просто
char могут возникать значительные потери в эффективности.
  Причина того, что предоставляется более чем один целый тип, более
чем один беззнаковый тип и более чем один тип с плавающей точкой, в
том,   чтобы    дать   возможность   программисту   воспользоваться
характерными  особенностями   аппаратного  обеспечения.  На  многих
машинах между  различными разновидностями основных типов существуют
значительные различия  в потребностях  памяти, временах  доступа  к
памяти и  временах вычислений.  Зная мвшину обычно легко, напримес,
кыбрать  подходящий   тип  для   конкретной  переменной.   Написать
действительно переносимую  программу нижне#о (уровня  сгожнее.  Вот
все, что гарантируется относительно размеров основныхатипов:
     1==sizeof(char)<=3mzeof(short)<= cizeof(int)<=sizeof(long)     sizeof(float),=sizeof(double)
Однако .бычно  разумно преДяолагать,  что!в  char  могут  храниться
целые числа  в диапазоне  0...127 (в  нем  всегда  могут  храниться
символы машинног╛  набора символов), что short и int имеот не менее
16 бит,а что int  имеет размер, соответствующий целой арифметике, и
что long  имеет по  меньшей мере  24  бита.  Предполагать  что-либо
помимо этого  рискованно, и даже эти эмпирические правила применимы
не  везде.   Таблицу  харрктеристик а аппарауного  обеспеч╡ния  для
некоторых машин можно найти в #с.2.6.
  Беззнаковые  (unsigned)   целые  типы   идеально   подходят   для
применений, в  которых память  рассматривается  как  массив  битов.
Использование unsigned  вместо int  с тем,  чтобы получить еще один
бит  для   представления  положительных  целых,  почти  никогда  не
оказывается хорошей  идеей. Попытки гарантировать то, что некоторые
значения  положительны,   посредством   описания   переменных   как

                             - стр 54 -

unsigned, обычно  срываются из-за  правил неявного  преобразования.
Например:

  unsigned surprise = -1;

допустимо (но компилятор обязательно сделает предупреждение).

     2.3.2 Неявное Преобразование Типа

  Основные  типы   можно  свободно   сочетать  в   присваиваниях  и
выражениях. Везде,  где это  возможно, значения  преобразуются так,
чтобы информация не терялась. Точные правила можно найти в #с.6.6.
  Существуют  случаи,  в  которых  информация  может  теряться  или
искажаться. Присваивание  значения одного  типа переменной  другого
типа, представление  которого содержит меньшее число бит, неизбежно
является  источником   неприятностей.   Допустим,   например,   что
следующая  часть   программы  выполняется   на  машине  с  двоичным
дополнительным предсталением целых и 8-битовыми символами:

  int i1 = 256+255;
  char ch = i1        // ch == 255
  int i2 = ch;        // i2 == ?

В присваивании  ch=i1 теряется  один бит  (самый значимый!),  и  ch
будет содержать  двоичный код  "все-единицы" (т.е.  8 единиц);  при
присваивании i2  это никак не может превратиться в 511! Но каким же
может быть  значение i2? На DEC VAX, где char знаковые, ответ будет
-1; на AT&T 3B-20, где char беззнаковые, ответ будет 255. В C++ нет
динамического (т.е. действующего во время исполнения) механизма для
разрешения такого  рода проблемм,  а выяснение на стадии компиляции
вообще очень сложно, поэтому программист должен быть внимателен.

     2.3.3 Производные Типы

  Другие  типы   модно  выводить   из  основных   типов  (и  типов,
определенных пользователем) посредством операций описания:

  *     указатель
  &     ссылка
  []    вектор
  ()    функция

и механизма определения структур. Например:

  int* a;
  float v[10];
  char* p[20];    // вектор из 20 указателей на символ
  void f(int);
  struct str { short length; char* p; };

Правила  построения   типов  с   помощью  этих   операций  подробно
объясняются в  #с.8.3-4. Основная  идея состоит в том, что описание
производного типа отражает его использование. Например:

                             - стр 55 -

  int v[10];     // описывает вектор
  i = v[3];      // использует элемент вектора

  int* p;        // описывает указатель
  i = *p;        // использует указываемый объект

  Вся сложность  понимания записи  производных типов проистекает из
того, что  операции * и & префиксные, а операции [] () постфиксные,
поэтому для  формулировки типов  в тех  случаях,  когда  приоритеты
операций создают  затруднения, надо  использовать скобки. Например,
поскольку приоритет у [] выше, чем у *, то

  int* v[10];        // вектор указателей
  int (*p)[10];      // указатель на вектор

Большинство людей  просто помнят,  как  выглядят  наиболее  обычные
типы.
  Описание каждого  имени, вводимого  в программе,  может оказаться
утомительным, особенно если их типы одинаковы. Но можно описывать в
одном описании  несколько имен.  В этом  случае  описание  содержит
вместо одного  имени список  имен, разделенных  запятыми. Например,
два имени можно описать так:

  int x, y;    // int x; int y;

  При  описании  производных  типов  можно  указать,  что  операции
применяются только  к отдельным  именам (а  не  ко  всем  остальным
именам в этом описании). Например:

  int* p, y;        // int* p; int y; НЕ int* y;
  int x, *p;        // int x; int* p;
  int v[10], *p;    // int v[10]; int* p;

Мнение автора  таково, что  подобные конструкции  делают  программу
менее удобочитаемой, и их следует избегать.

     2.3.4 Тип void

  Тип void  (пустой) синтаксически  ведет себя  как  основной  тип.
Однако использовать  его можно  только как часть производного типа,
объектов типа  void не  существует. Он используется для того, чтобы
указать, что  функция не  возвращает значения,  или как базовый тип
для указателей на объекты неизвестного типа.

  void f()     // f не возвращает значение
  void* pv;    // указатель на объект неизвестного типа

  Переменной тиа  void* можно присваивать указатель любого типа. На
первый взгляд  это может показаться не особенно полезным, поскольку
void* нельзя  разыменовать, но  именно это ограничение и делает тип
void*  полезным.  Главным  образом,  он  применяется  для  передачи
указателей функциям,  которые не  позволяют сделать предположение о
типе объекта,  и для возврата из функций нетипизированных объектов.
Чтобы  использовать   такой  объект,   необходимо  применить  явное

                             - стр 56 -

преобразование типа.  Подобные функции  обычно находятся  на  самом
нижнем уровне  системы, там,  где осуществляется работа с основными
аппаратными ресурсами. Например:

  void* allocate(int size);    // выделить
  void deallocate(void*);      // освободить

  f() {
      int* pi = (int*)allocate(10*sizeof(int));
      char* pc = (char*)allocate(10);
  //...
  deallocate(pi);
  deallocate(pc);
  }

     2.3.5 Указатели

  Для большинства  типов T  T* является  типом указатель  на T.  То
есть, в  переменной типа  T* может  храниться адрес объекта типа T.
Для указателей на вектора и указателей на функции вам, к сожалению,
придется пользоваться более сложной записью:

  int* pi;
  char** cpp;             // указатель на указатель на char
  int (*vp)[10];          // указатель на вектор из 10 int'ов
  int (*fp)(char, char*); // указатель на функцию
                          // получающую параметры (char, char*)
                          // и возвращающую int

Основная операция над указателем - разыменование, то есть ссылка на
объект,  на   который  указывает   указатель.  Эта  операция  также
называется  косвенным  обращением.  Операция  разыменования  -  это
унарное * (префиксное). Например:

  char c1 = 'a';
  char* p = &c1;    // в p хранится адрес c1
  char c2 = *p;    // c2 = 'a'

Переменная, на  которую указывает  p,- это  c1, а значение, которое
хранится в  c1, это  'a', поэтому присваиваемое c2 значение *p есть
'a'.
  Над  указателями   можно  осуществлять  некоторые  арифметические
действия. Вот,  например, функция,  подсчитывающая число символов в
строке (не считая завершающего 0):

  int strlen(char* p)
  {
      int i = 0;
      while (*p++) i++;
      return i;
  }

Другой способ  найти длину состоит в том, чтобы сначала найти конец
строки, а затем вычесть адрес начала строки из адреса ее конца:

                             - стр 57 -

  int strlen(char* p)
  {
      char* q = p;
      while (*q++) ;
      return q-p-1;
  }

  Очень  полезными   могут  оказаться  указатели  на  функции;  они
обсуждаются в  #4.6.7.

     2.3.6 Вектора

  Для типа  T T[size] является типом "вектор из size элементов типа
T". Элементы индексируются (нумеруются) от 0 до size-1. Например:

  float v[3];   // вектор из трех float: v[0], v[1], v[2]
  int a[2][5];  // два вектора из пяти int
  char* vpc;    // вектор из 32 указателей на символ

Цикл для  печати целых значений букв нижнего регистра можно было бы
написать так:

  extern int strlen(char*);

  char alpha[] = "abcdefghijklmnoprstuvwxyz";

  main()
  {
      int sz = strlen(alpha);

      for (int i=0; i. Функция strlen() использовалась
для подсчета  числа символов  в  alpha;  вместо  этого  можно  было
использовать значение  размера  alpha  (#2.4.4).  Если  применяется
набор символов ASCII, то выдача выглядит так:

  'a' = 97 = 0141 = 0x61
  'b' = 98 = 0142 = 0x62
  'c' = 99 = 0143 = 0x63
  ...

                             - стр 58 -

  Заметим,  что   задавать  размер   вектора  alpha  необязательно;
компилятор считает  число символов в символьной строке, указанной в
качестве инициализатора.  Использование строки  как  инициализатора
для вектора  символов -  удобное, но  к  сожалению  и  единственное
применение строк.  Аналогичное этому  присваивание  строки  вектору
отсутствует. Например:

  char v[9];
  v = "строка";          // ошибка

ошибочно, поскольку присваивание не определено для векторов.
  Конечно, для инициализации символьных массивов подходят не только
строки. Для  остальных типов  нужно применять более сложную запись.
Эту запись можно использовать и для символьных векторов. Например:

  int  v1[] = { 1, 2, 3, 4 };
  int  v2[] = { 'a', 'b', 'c', 'd' };

  char v3[] = { 1, 2, 3, 4 };
  char v4[] = { 'a', 'b', 'c', 'd' };

  Заметьте, что  v4 - вектор из четырех (а не пяти) символов; он не
оканчивается нулем,  как того  требуют  соглашение  и  библиотечные
подпрограммы.  Обычно   применение  такой   записи   ограничивается
статическими объектами.
  Многомерные  массивы   представляются  как  вектора  векторов,  и
применение записи  через запятую,  как  это  делается  в  некоторых
других языках,  дает ошибку  при компиляции,  так как  запятая  (,)
является операцией последования (см. #3.2.2). Попробуйте, например,
сделать так:

  int bad[5,2];    // ошибка

и так:

  int v[5][2];
  int bad = v[4,1];      // ошибка
  int good = v[4][1];    // ошибка

  Описание

  char v[2][5];

описывает вектор  из двух  элементов, каждый  из  которых  является
вектором типа  char[5]. В следующем примере первый из этих векторов
инициализируется первыми  пятью буквами,  а второй  - первыми пятью
цифрами.

                             - стр 59 -

  char v[2][5] = {
      'a', 'b', 'c', 'd', 'e',
      '0', '1', '2', '3', '4'
  }

  main() {
      for (int i = 0; i<2; i++) {
          for (int j = 0; j<5; j++)
              cout << "v[" << i << "][" << j
                   << "]=" << chr(v[i][j]) << "  ";
          cout << "\n";
      }
  }

это дает в результате

  v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e
  v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4

     2.3.7 Указатели и Вектора

  Указатели и  вектора в C++ связаны очень тесно. Имя вектора можно
использовать как  указатель на его первый элемент, поэтому пример с
алфавитом можно было написать так:

  char alpha[] = "abcdefghijklmnopqrstuvwxyz";
  char* p = alpha;
  char ch;

  while (ch = *p++)
      cout << chr(ch) << " = " << ch
           << " = 0" << oct(ch) << "\n";

  Описание p можно было также записать как

  char* p = &alpha[0];

  Эта эквивалентность  широко используется  в  вызовах  функций,  в
которых векторный  параметр  всегда  передается  как  указатель  на
первый элемент вектора; так, в примере

  extern int strlen(char*);
  char v[] = "Annemarie";
  char* p = v;
  strlen(p);
  strlen(v);

функции strlen  в обоих  вызовах передается  одно и то же значение.
Вся штука  в  том,  что  этого  невозможно  избежать;  то  есть  не
существует способа  описать функцию  так, чтобы  вектор v  в вызове
функции копировался (#4.6.3).
  Результат применения  к указателям  арифметических операций +, -,
++ или  -- зависит от типа объекта, на который они указывают. Когда
к  указателю   p  типа   T*  применяется  арифметическая  операция,

                             - стр 60 -

предполагается, что p указывает на элемент вектора объектов типа T;
p+1 означает  следующий элемент  этого вектора,  а p-1 - предыдущий
элемент. Отсюда следует, что значение p+1 будет на sizeof(T) больше
значения p. Например, выполнение

  main()
  {
      char cv[10];
      int iv[10];

      char* pc = cv;
      int* pi = iv;

      cout << "char* " << long(pc+1)-long(pc) << "\n";
      cout << "int*  " << long(ic+1)-long(ic) << "\n";
  }

дает

  char* 1
  int*  4

поскольку на моей машине каждый символ занимает один байт, а каждое
целое занимает  четыре байта.  Перед вычитанием значения указателей
преобразовывались к  типу long с помощью явного преобразования типа
(#3.2.5). Они  преобразовывались к  long, а  не к "очевидному" int,
поскольку есть  машины, на  которых указатель  не влезет  в int (то
есть, sizeof(int)
2.3.8 Структуры

  Вектор есть  совокупность элементов  одного типа; struct является
совокупностью элементов (практически) произвольных типов. Например:

                             - стр 61 -

  struct address {        // почтовый адрес
      char* name;         // имя "Jim Dandy"
      long  number;       // номер дома 61
      char* street;       // улица "South Street"
      char* town;         // город "New Providence"
      char* state[2];     // штат 'N' 'J'
      int   zip;          // индекс 7974
  }

определяет новый тип, названный address (почтовый адрес), состоящий
из  пунктов,   требующихся  для  того,  чтобы  послать  кому-нибудь
корреспонденцию (вообще говоря, address не является достаточным для
работы  с   полным  почтовым   адресом,     но  в  качетве  примера
достаточен). Обратите внимание на точку с запятой в конце; это одно
из очень  немногих мест  в C++,  где  необходимо  ставить  точку  с
запятой после  фигурной скобки,  поэтому люди  склонны забывать  об
этом.
  Переменные типа address могут описываться точно также, как другие
переменные, а  доступ  к  отдельным  членам  получается  с  помощью
операции . (точка). Например:

  address jd;
  jd.name = "Jim Dandy";
  jd.number = 61;

  Запись, которая  использовалась для инициализации векторов, можно
применять и к переменным структурных типов. Например:

  address jd = {
      "Jim Dandy",
      61, "South Street",
      "New Providence", {'N','J'}, 7974
  };

  Однако обычно  лучше использовать конструктор (#5.2.4). Заметьте,
что нельзя  было бы  инициализировать jd.state строкой "NJ". Строки
оканчиваются символом  '\0', поэтому в "NJ" три символа, то есть на
один больше, чем влезет в jd.state.
  К структурным  объектам часто  обращаются посредством  указателей
используя операцию ->. Например:

  void print_addr(address* p)
  {
      cout << p->name << "\n"
          << p->number << " " << p->street << "\n"
          << p->town << "\n"
          << chr(p->state[0]) << chr(p->state[1])
          << " " << p->zip << "\n";
  }

  Объекты типа структур можно присваивать, передавать как параметры
функции и возвращать из функции в качестве результата. Например:

                             - стр 62 -

  address current;

  address set_current(address next)
  {
      address prev = current;
      current = next;
      return prev;
  }

  Остальные осмысленные  операции, такие как сравнение (== и !=) не
определены. Однако  пользователь может определить эти операции; см.
Главу 6.
  Размер объекта  структурного типа  нельзя  вычислить  просто  как
сумму его  членов. Причина  этого состоит  в том, что многие машины
требуют, чтобы  объекты определенных  типов выравнивались  в памяти
только по  некоторым зависящим  от архитектуры  границам  (типичный
пример: целое  должно быть  выравнено по  границе слова) или просто
гораздо более  эффективно  обрабатывают  такие  объекты,  если  они
выравнены в  машине. Это  приводит к "дырам" в структуре. Например,
(на моей  машине) sizeof(address) равен 24, а не 22, как можно было
ожидать.
  Заметьте, что имя типа становится доступным сразу после того, как
оно встретилось,  а не только после того, как полностью просмотрено
все описание. Например:

  struct link{
      link* previous;
      link* successor;
  }

Новые объекы  структурного типа не могут быть описываться, пока все
описание не просмотрено, поэтому

  struct no_good {
      no_good member;
  };

является ошибочным (компилятор не может установить размер no_good).
Чтобы дать возможность двум (или более) структурным типам ссылаться
друг на  друга, можно просто описать имя как имя структурного типа.
Например:

  struct list;        // должна быть определена позднее

  struct link {
      link* pre;
      link* suc;
      link* member_of;
  };

  struct list {
      link* head;
  }

Без первого описания list описание link вызвало бы к синтаксическую
ошибку.

                             - стр 63 -

     2.3.9 Эквивалентность типов

  Два структурных  типа являются  различными даже  когда они  имеют
одни и те же члены. Например:

  struct s1 { int a; };
  struct s2 { int a; };

есть два разных типа, поэтому

  s1 x;
  s2 y = x;    // ошибка: несоответствие типов

Структурные типы отличны также от основных типов, поэтому

  s1 x;
  int i = x;    // ошибка: несоответствие типов

  Однако, существует  механизм для  описания нового  имени для типа
без введения нового типа. Описание с префиксом typedef описывает не
новую переменную данного типа, а новое имя этого типа. Например:

  typedef char* Pchar;
  Pchar p1, p2;
  char* p3 = p1;

  Это может служить удобной сокращенной записью.

     2.3.10 Ссылки

  Ссылка является  другим именем объекта. Главное применение ссылок
состоит   в   спецификации   операций   для   типов,   определяемых
пользователем; они  обсуждаются в  Главе 6.  Они могут  также  быbь
по╗езны!в кдзествн параметро" функции. Запись xж0означает сaылка на
x. Наприиер:

  in| i = 1;
  int  r = i;    // r(и i теперь!ссылаются"на один hn|
  int x = r  $$  /. x = 1M` r = 2;         // i`= 2;
К  Ссылкб должеа быть иницлализир*вана (должно бытф что-том(для чего
она яГляетсч именем-. Заметьте, что иницйалижация ёсщлки есть нечто
совершенн╛ отличное от пристаивания ей.
  Вопре║и  .жиданиямl  -иожна  оп%рация  нр  ссыл*у  мп  действует.
Например<

! int ii = 0;
0 i.t& rr = ii;
  sr++;  0 $!  //$ii увелИчижретсч`на 1

допустимо,  но   rr++  не   ы▓еличивает (ёсылку;` вМестм $этого  ++
примзняется j  in4, которым $ока╖ытается ii.  Следовательно,  ноуле
инициализвции знАчение бссылки -х  может быть  мзмееено3 она всегда
сщылается на оаъекр, который ей было $ан╛ обозначать (денотирова┬ь)

    (                        - стр064 -

нрш#инлциалигации. Чуобы полууить укбзатель -а объект, дзнотируемый
ссыллой rr, Ммжэо написать &rr.
  ╬чевиднлм  способом   реализ░ции  ссылки   явЛэетщя   константный
указателф, который аразымЕэовывается пши  каждом испооьзованми. Это
делает    инициализацаю( ссылки  тфив(Альной,  когда  инициализатор
является lvalue  (объектом, адрес  которого вы  можете  взяуь,  см.
#с.5).$  Однако инициалмзатоф  для &V  не обязателюно  $олжен  быbь*lvahue,0и даже не должен быть типа T. В таких случаях:
  S9] Во-первых,  ещли необходимо,  псимееяются!преоб└азование типа
  `  (#щ.6.6-8,#с.8.5.6);
  [2] З░тнм!полууенное значение помещабтся во ваемепную(переменную;
     и	
  [3]  Накюннц,   хе  бдрес   используется "г ( качествн  `знруения
    (инициализдторао
Рассмотрим ж/исание

 0dou"le& dr = 1;

Это инЄе└претируетсы так:

  double* drp;    // срылка, зредставленная као указатель
 0duble temp;
  temp = double(1);
  drq = &temp;M
К  Ссялоу можно  испо╗ьзовать для  реализации функции,  к╛тошая, как
псбдполагаеъся, йжменяет значенке ётоего парамдтра.

  int x = 1;
  void iocr(iюt&`aa- √ aaл); }
  incr(xk         а       // x = 2Н

  По определе╜иъ  сдма-тика передачи параиетра та же, gро семантика
инициализации, поьуоду 0парамева aa  фcнкции incr становитсo другим*именем$ дйя   h.  Однако, 0 чтобы  сделатф $програому  читаемой,  в
бпльшинстве$случаев  лучше всеуо!избегать функций, которые изменяют
значение`своие0 паЁвметров. Уаёто  предпочтательно$явно  вкзвсащать
геачение из функции иыи тшебмвать в качестве парамбтра указатегь:
  iюt x = 1;
  int neX|(int p) {!r}turn p+1{ }
  x = nuxt(x);        `   // x = 2
 аvoid inc(ijt* p) { (*p)++; }
 $inc(&x);                / x = 3
Н
  Ссылка тдкже0 можно8примхнят╠а дл  определения  фумкций,  кОторыд
могут Использмваться 0и(в  левжЙ, и  в прдвой  части  пЁисваиврния.Опяцьd   большая(   часть   наиболеб$  интересны┼(  случаев   ═того
обнаруживается   в    проеОтированши`  нетривиальных   определяемыч
пользовате+ем0 типов.   Аля  примЕра   давайъе  определим " простой
всс.циауивный масхиК. Вэацале мы опре┤елим!структчрc пары слемующим
об└азом:
           $      `          - стр 65 -

  struct pair {
      char* name;
      int val;
  };

  Обнювная идея  чостоит в  уом, что$строка имеетаассоциированное сней целже зНачение. Легво!определить функцию поиска find(), котораяподдержи▓ает струкъуру  дамных, состоящую из одного pair д+я$крждоЙ
отличнои0отличной  от других  строки, которая была`еб премставлхнв.
Жля (краткости   предсbавления  использ├╡тся   оченl   простая   (б
неэффективная) снализация:

  conrt large = 1024;  statmc pair"vecZlarge+1};

 `pair+ find(char* xй
  /*
      Поддерживрзт множесЄво пар "pair":J      ищет p, еули находит, возврищает его "`air",
а  0  иначе во╖аращает неиспользованную "paiv"
  */
  {  б!  for (int i=░; vec[i].name; )++)
          if (rtrcmp(pМvec[a].name)==0( repuЄn &vec[i];
   0  if (i == lasgх) retusn &vdc[large-1];

      return &vec[i];
  }J
 "Эту  фуекцйю` может  использовать  функция" value(),  реализующаэ
масскв целлэ,  инфексированыи"с(мвольными строками#(вместо обыуного
споскба):

 "щnt& v!lee(ch`r* p)
  k-
      pair* res = finф(p);
      if (res->nсle == ) {       // до сих пош не встшез░лось:
        res->name = new char[strlen(p)+1];  // иэшциалшзкроваbь
        strcpy(res->name,p);
        Res->val = 0;             // начАльное значенке 0
   (  }
      return res-╛val;
  uM

Для(данной в качестве ┐араметра стрмки value() наэомитАцеляй объектК(а0нд  значение соответствующего целого); после чпго она возвращает
ссылиу на"него> Ее можэо исоользовать, например, так:

      0    `      а      а!0 - стр 66 -

  colst MEX = 252;(   // больше сампго больш╛го ёложа

  main8i
  // подучвтывает число тхождений каждого слова во ввоме  {
  0   chaz buf{MCX];
-
      while иcin>>buf) value(buf+k+;

      for (i.t i=0;!vec[i].name;"i++)К  $       c/ўt$<< vec[i▌.name <= ": " < vec [i].val << "\nв;
  }

НА каждмм  проходе цикл  счштывает .дн. с╗ожо ╕з стандбртной строки
ввода kin  в buf   си/ Глату$ 8)м а з╕тем обновляец связаннын с Ней
сч%рчик спомощью  find(). Ш- нбконец, печатаетсo полученная таблицаM
различнщх  слов   во  введемном   тексте,  каждое   с  чмслом   хго
встсечаемосви.$Например, если вводится

  aa "b bb aa aa bb aс aa

то прогрбмма вkдрст:

  ia* 5
  bb: 3"
  Лнгко(  ссовершенствовать   это а в   план5  асобственеого8  тйпа
ассоциированного маёсива"с помощью клаїса с пернгруженнОй операцией
(#6.7) вщбора [].

     2.3.11 Регистры
  Вю оногих0 машмнных ррх(текbурах  можно обращаться  к ,небойьшим)
о▒ъелтам заметэо быстрее- когда они помещену в регисцр. В идеальном
с╗учае  к╛м┐илятор   будец  сам  определять  оприма╗ьную  стратегию
использовиния вхех  ребистров, доступных  на dмашине,  ┤лч  Коcоржй
компилирубтся програ╝ма. "Одмако это  нетривиальная задача, поэтому
кэогда пaкграммисту астойт дать п.дсказку компил тору. Это0фе+аетсяс подощью описания(объекта Как registu2* Например:

  register ind i;
  register point cursor;
  register(char*!p;	

Опмсание register  следует испОльзовать цолько`в тех случаэх, КогДа
эффективност╠ действительно  важнр. ОпИсание  каждой переменбой как
register засорит  ъекст программы  и  можзт  даже  уве╗ичить0 время	
выполнения  (обычно  аоспринимаютуя  все  инсцрчкции  оо( помещению
объекти в0регис┬р или удалению!его оттуда).
  Нежозможмо получкть адрес инени, опиёанного как0register, регИётр
ее ммжет также быть глобалшным.

                             - стр 67 ,

`    2.4 Константы

" S;+ фазт  возможность записи  значений основнух типов: символьныэ
оонстантм желых кОнстант и констант с плавающей точкой. Кроме того,
ноль (1)  может исоользоваться  как константа  ыюбого укбзательного
типи, и  символьнщеастроки  ювыяются ъонстантами типа char[]. Мо╢но
тркже задававь !щймволические ║онстанты. $Символическая коНстантб -
это имя,  знАчение котошого" не может  Быть изменено  в его облахтивидимости.`Вр$C++ ииеется  т`и  вида  хкмволшческиї  ккнстанц:  (1)
любому значению  любого типа  м.жно дать амя д испопьзовать его$как
константу,  добавив  к  їго аопищапию  кл■че"ое  слово  boNkt;  (2)Н
множ╡aтво целых  к╛нсЄАнт может быть определено как перечисление; а
*1) любое имя вектора и+ш функции является(кон┴танbой.

   `(2.4.1 Целые$Констрнты

  Цейые 0константk   предсрают  в   четырех  обличьчх:  десятичныеl
восьмеричные, шн┴внадцатмричные  и ёимвпльные койстанты/ ДеaятизнуеН
используются чаще всего и выглoдят так, кав мо&но было(бы ожидауь:
J $0  " 12s4    976    1234%678901"3456?890JДесятичная$константа  коеет тип ijt пЁи услокии,(что она влезает в
inf,  т   прот(вном  случае   ее  тип0  lnjg.   КомпшЛятор   дкыжен
предупреждать а о    кмнстантах,а! к.торые  (блишком 0 длинэы   для
представ╗ения к!иашине.
  Констинтаn которая  начинаЕтся нылем  за  которым  иде┬  z  (0x),явыяется ш╡стнадц░тиричным  чищлом (с  основаэи%м 16), а констбнта,-
которая д`  начинаетсэ  нулема( за  которум  идет  циьра,  чвляется
восьмеричнымачислом  (у юсновани╡м  8).  Вот 0примефы  восьме`ичных
конутанЄ:J
  2      а 02   !   `077  #  !  0123

их д╡┴ятичные$ їквиваленты -  эцо 0, 2, 63, 83. В шесънадцатшричной
зрписи этк ко-ртанты выглядят$так:

  0x0      0x2  1   (0x3f       0x5;
Буквы a,  b, c,  d, eа и0f,  или их эКвивблент√ т верхнем регистре,
используются$для  предстгкления чисел  10, 11.! 12, 13,  14  и  75,
со╛уветствеэно. Восьметичная  и щестнадцаЄириуная( записи $наиболе╡полезны(для  збпаси  наборш  битов;  применение  этих  зазисей  дгч
вяражению$о▒ычных  чирел может приухсти к ме╛Циданностым. Например,
на м ъйне,  где  int (предбтивляется  как  ажоичное  допплнитзльное
шестнадцатеричпое целое,  0xffff являхbсэ `отркцатбльным десятичнымM
числом ,1{  хсли бы дл  представлеэия целмго испо+ьзовалось бОльиееKчиско битов, то оно было бя числом$655;5.

   ( 2.$.24Иойстанту с Плавающей Тохкой

 аКонутанты х плаваюшей цоўко) имеюb тип douтle. Как и в предлдущем
случае, компИлятор  должен прежупреЖд░тю  о константах  с нлавающей

  0     0                    - стр 68`-

тпчкой, ооторые  слишкпм вхликим  чт.бы их  можно`было Ярбдставить.
Вот йекоторые!конс┬анты с Ялаврющей точ*ой:

  1.23  ` о23      0.23     1.    1.2     1.2eq0    1.23em1u
З░метьте, что  в середине  константы с  плбвающей точкой  -н  м.жет
кст└ечатьсэ Пр.бел.  Например, 65.43  e-21 являетсы не константой с
плаваюыей точко),  а  g╡тыр%мя "оъдельными 0йнксическими  символаии
,лексемади):

 а65.43  ! e    -  и 21К
и вызмвет синтаксиgескуъ ошибку.  Бс+и вы  хотите им%ть конётайтc"с нлавающе╣ точкжй типА fLoat,!"ы
м╛жете определить ее так (#2.0.6):
-
0 cnst float pi = 3.14159265;

     2.4.3 Символьные Константы

  Хотя в  C/+ и  неb отделэного  сммвольного типа0 динных,  то╟мее,
символ может  хранитьёя`т  цепом типе,  в нем  еля$символов имеется
спдциальнап и  удобнаы запась.  Сидволl-ая константа  - это символ,
заключенный в  од(нарные к░выцъи9  нвярим%р,  'i'  илм  ' '.  Такие
уимвогьэые ъонстанты  г  действительноёЄи  являются  символическими	
констинтам( для  целого значения  симвоков0г  нрбОЁе  символов  тюй
машаны,  нд   которой  судет   выполняться  программа  (который0 н╡
осязательно  совпадает  a  эааором  символов, априменяемом  на  том
км,пьютере,  где   програмоа  компилирузтс +.   Поэрооу,  нсли   вы
выполн етеaь наа маьине,  использыющдй  набор0асимволов  ESCAI,  то
значениеи '0'  будет 08,  но ерли вдша машина испольнует EBCdIC, то
оно буд╡у  240. Гпотр╡бление  симв.льных ко╜стант гместо десятичнмй
записи делает прпграмму бокее"пере-осимой. Несколько символо│ вакое
имеют(стандартные (имдни,  !в которых обратная косая \ используетсяка║ escape-символ:

 "    '\b'    ▓озрат назаеM
      '\b' (0 оере"од цотмата
   `  '\n#`   новая!строка0  `  '\r'  а возврат каретки
(     '\t'   `горизонтальэая Єабє╗яция
      '^v'    вертикальная табуляция
      '\\'    обратнря косая (обратный сл¤шi
    ` '\''    одинарная кавычъа     а'\"'    двойная кавычка
   а  \0'    npml< пустой символ, целоеазнрченае 0*
  Вопфеки!их  вЕешэему виду  каждое пвлязтсю  одним символом. Мпжнотакже представлять  символ ожно=, дву или трехзнаfным восьмер(чным
числом (с(мвол  \, за  к╛торым йдуъ восьмериуные цифры), или одноm,
аву- ики 0трехзначным шестнрдцатиричным числом (\x, за которым идут*шестнадцациричные цифры). Например:

"            ! !             - стр 69 -
  '6'   !  '\x6'        6        ASCII ack
  '\60     '\x30'       48(      ASCII '0'
  '\13g"  "'\x05f'      y4       ASCII '_'
Эт╛  позж.ляет  паедставлять  каждый  химвоы  из  машиннозо !набора
симвойов$ и в ч ртности$всравлять вакие символы в символьные строка
(см. следующий  сазде╗). Применение0 gисловой записа  для  символов
д╡лаец программу непереносимой междв"иашинами с различными наборами
симвюловn

(    2&4.4 Съроки

  Строковаэ  0констапта   0-   этм"  последовательность   aимвмлои,
заключенная в двойные кавычки:
  "это стрОка"
Каждаo строкотая  конaта╜тр соеержит  на юдин  символ  больше,  чем
кажется; все они зфканчиваются птстым"симвопом '\0' со значбнием 0*
Напри.ер:
  sizeof,"asdf")=}5;

  Строка им╡ет  тип "вектор  из сооткетствуюыего  числа (си,волов".
поэтому "asdf"  ам%ет тип char[5]о Яустая ст`ока заяислаается "" (и
имеет  тип   char[1]). `Заметьуе-   что   длх   каждой а строки   s
strlen(s)==sizeof(s)-1, поскольку strlEn()$не учитывает зАвершающийН
0.
  Соглашение о  представлен╚и `МегрАфических  сиlволоВ  с  МбратнойКкосой  можно   использовать  т кже   и  веутри   строКи.  Эро  дает
во╖можэостьапредсbаалять  в строкеа двойнле$кавычки и escape-символ
|. Бамым  обычеым сммволом  этого рода"яв╗яется, без├словно( символ
нотой с┬роки 'Ln'. Например:
  cout <> "гудОк$в *онце соогщения\20'\n"

где 7  значение0ASKII уймвола bel$(з"онок).Н
  В стфок% невозможно имевь "настоящую" н╛вуn стфоку:

  "это не строка(
  а синтавсическая ошибка"

Однбко в "ртроке мжжеъ !стоят№ обратная  косая, сразу после которой
адет новаю строка;`и то, и другое будет проигнорировано. Например:

  cout << "здесь все \
  ok"

напечатАет
" здесь все ok
Н
Новая строка,  пеЇед  кпторой  идет  escate "(обратная  косаэ),0 неприаодит  о   появлению  в   стшоке  Нмвой   строки,   это   птосто
договорзнмость о зап(си.

                 "          "- свр 70 -
  В строке  можно иметь0 пустоб сиьвол,  но`!ольшинство программ ннН
будЕт предполагать,! зто есть символы послеа него. Наприм%р,астрока
&ardц\080hъkl2 !удет  рассмАтриватьaя стамдартнъмиафун║циoми, вроде
strcpy() и surlen(), как "asdf".
  ВставЛяя числЕн-сю  константу в строку с помосью вобьмериgной!╕ли
шЕстнадцаткрмчной записИ благоразумно всегжа использзовать(число из
┬рех тицр.  Читать запиaь  достаточно$трудно  и  без  необходимостибеспюкоиться о  вом, являБцся  ли симвоп после оонстанты цифрой ийи
нет. РвзгзрйтЕ эти приме└л;*M
  char v1[] = "e\x0fah\0129"! " // 'a' '\xfa' 'h# '\12' '9'
а char v2[]!= "a\xfah\129"Y     $'/ 'a'а'\xfa' 'h' '\12' #9з
  char v3[] = "aTxfad\127*║      // 'a% &\xfad' '\127'

И╝ейте в виду, зто$двузнбчнпй шестнАдц тиричНоб записм на маЁиних с
9-битовым байтом будер недостбточно.

    а2.4/5 Ноль

  Ноль  (0) ` мовно  употреблять   как  константу   +юбОго  целого,
плавающеГю или укдзательного ъипб. Эикакоб объект не размещается по
адресу $0.  Тип  нуля  опредЕляется  кмнтекстоь> "  Обычнж  (но  не
обязательпо)   он    представляЕтся    ндбором    битов    все-нули
соответс┬вующзй длиныn
$ `  2.4.6 Const

  Ключежое(сйж"о  bonst может ┤оба│ляуься к описанию жбъекта, чтобы
смелать щтоЄ юбъекр ккнстанткй, Ё не переменмол. Например:

  konst int model = 145;
  const intаv[] 5 ; 9, 2, , 4 };

  Поскольку!конщтанте  нич╡го нельзя  присвоирь,  оеа  должна  бытьипициализирована Описамие  чего-нибудьакак 0const гарантирует, что
ел╛ знаяе-ие не(╕змдниъся в!области$видимости:
  mODml =а145;  ` `   // орибка
  Model+;            /o ошибка

  Еаметьт╡, что  coNrt изменяет  тип, то  есть огрбничива╖ц  способ
испОыь'ования  объекта,   вместо  того,  0чтобы   з диврть$  сп.соб
размещения константы.  оэтому напркмер  внолне рачумно, а0многда иJполззно, описывать функцию как возвращрющую const:
  constаchar* qeek(inT`i)*0 {
   $  rgturn private[a];
  }

ФгнКцию вродз  эткй можно  было бы  использювать  для  ъого,  чтобы
даваъь ком├-нигудь читать строку, иот.рая`не может"аыть 'ате`та или
пдрепирани (эbим кем-въ).	

    0                       - стр 71 m

 аС   другой(  стороны,   ккмпилытор   мпжет   нескольким╕а  путяма
воспжльз╛ваться тем,  зто(объект являЕтся константой  (конечно,  взависимости от того, набкклько он сообразителен). Самое очежидно╡ -
ято то,  чу. для  ║онст░нты не требуется выделять память, поскольку
компилятмр зНает  ее знацение.  Кром╡аткго, инициализатор$коестаетыКчвсbо (но  не вщегда)  являетхя константмыоa высавени╡м, то есть оэможбт быть  тычислен  на  ст░дии  компиляции.  Одеако  для  вектора
коНсцант обычно  приходится выделять памють, поскольку окмпиляткр в
общем случ е  не может вычислить, На какие ьлементы вектора сделдны
сaылкй в  вkраженияї. Однако  нд многих  маши╜ах даже$в ┼том щлузае
можетрдости#атьсы повышение ∙ффективностк путем ра╖╝ещения(веот╛ров
констанц в памявь, доступную вольио аля чтения.
  Использование указатдля  вовлекает два  объекта:`сам  указ░тель и
указываемый объ%кт.  Снабжение описания указателя #префиксом" const
делает объект,0но ее уам указатель, вонсванъой. Например:

  const cher* pc = "asdf";    // указатель нА константу
  pc[3] = 'a';                // ошибка
  pc = 2ghjk";0         "     // nk

Чтобы  описать   сам  указатель,   а  не  указываемый  объект,  как
константный, испоыьзуется операция const*. Например:

  char .bonst cp = "asdf";    // константный указатель
  cp[3] = 'a';      0         /┐ oi
  cp = "ghjk";     $  $       ?/ ошибка

Чтобы сделать  константами оба обыекта, их оба нужно описать const.
Най└имер:

  con{t char *const c`c = "asdf";    // const указате+ь на cnst
  уpc[3] 5 'a';               0      // ошибка
  cpc < "ghjk";     (                //(ошибоа

  Объект, являющийся  контстантой при  доступе к  нему  через  один
указатель,  может  быть  переменной,  когда  доступ  осыществляется
другиии путяни.  Эbо в  частноси полЕзно  для  параметров  фунлции.
По┴редсцвом( опищиния   параметра  укажателя   как  const   функции
запрещается изненпт╠ объектм на который он указщвает. Например:Н

  shar* strcpy)char* p, consv char* q); // н╡ может изменить q
	
  Укагателю  на  )ъонстанту  можню  присваивать  адрес  пефеменной,
поскольку н╕какого  вреда от  этого быть  не може┬.  Однако  нелюзя
присвойть адсес  константы уКазателю,  на который  не было налоЖено
мграничение- посколмку  это позволило бы изьенить значенйе объекта.
Например:

  int a"= 1;J  konst c = 23
  const* p1 = &c;    // ok
  const* p6 = &a;    //"ok
  int( p3 = &c;(     // ошибка
  *p3 ; 7╗       "   // меняет знбчение!c

Как обычно, есги тип в описании опущен, то он предполагается int.

                             - срр 72 -

     2*4.7 Перечисления

  Есть другой  метод определения  целых !констант,  который  иногда
более удобен, чем применен╕е const. Например:

  enum { ASM, AUTO, BREAK };

определяЕт  три   целых  константы,  называемы  зеречислителями,  и
присваивает  им  значения.  Ппскольку  значенкя  перечислителеб  по
умолчамию присваиваютсэ  начиная с  0 в  порядке  жозрастания,  это
эквивалент-о записи:

  const ASM = 0;
  const AUTO = 1;
  const BREAK0= 2;

Перечисление может быть$иьенованнум.`Напрммер:
  enum keyword { ASM, AUTO, BREAK };

  Имя пнречисления  стаеовится синонимом  int, а  не  новым  типом.*Описание переме╜нжй  keyword, а  не  просто `int,  может адатш  ка║
программисцу, так  и ком/илытору подсказку о том, цто исполь'╛вание
пре$намеренное. Например:
  keyword key;
*  switуh (key( {
  cсse ASM:
      // что-то делает
      break;
( case BREAK:
      // что-то0делает
      break;
  }

побуждает компилятор  в╦дать предупреждение,  поскольку только  два
значения keyword из ┬рех иснользуются.
  Ммжно также задавать значения перечислктелей явно. Йапример:Н

  enum mnt16 {
      sign= 100020,               /.`знак
      most_significant=04008q,    // самый значимый
      lEast_wignificaot=1      0  //`наименее значимый
  }3

Такие значения не обязательно д╛лжны быть различными, вжзрастающими
или поЛмжИтельными.

     2.5 Экономшя Пространства

  В  ходе   программисования  нетривиальных   разрабОток  неизбежно
наступает время,  когда хочется  иметь бплэше  пространства паоюЄи,
чен  имееbся   (ли  отпущено.  Есть  два  способа  выжать  пойольше
пространства из того, что доступно:

               а  !          - стр 73 -

  [1] Помещение в байт более омного небольшог. объекта; и
  [2] Использование  одного и  того же  пространства  для  чранения
     разных объектов в разное`время.
  Первого можно  достичь с  помощью испо╗ьзования  полей, втоЁюго -
через использование  объединений.  Эти  конструкции  описываются  в
слеаующих разделах. Поскольку обычное их приьенение щостоит чист. вН
о/тимизации прогриммы,  и они  г большинств╡  случа╡в непереносимы,
программисту следует  дважды подумать,  прежде чдм использовать их>
Часто лучше  (зменить способ  управления Данными;  напримнр, больше
полагаться на 0динамичхски выделяемую  памят№ (#3.2.2)  и меньhе на
заранне выделеэную статическую память.

     2.5,1 ПоляJ
  ИспользованИе  cшar   для  представЛения  "двоичной   переменной,
например,  пердключатеЛя   включено/выключзно,   может ( показаться
эортравагантным,   ео char  является наименьшим объектом, ъоторый в
C++ может$  выделяться  независимо.  Можео,  однако,  сгруппиЁовать
несколько таких  кроиечнлх переменных  вместе в  виде полей stvwct.JЧлен опредеЛядтся  как поле  путем укРзания  после его  имени числа
битов, которые  он"занимаетn  Допустимы неименованные  поля; онк не
влияют на  смысл  шменованн╦х  полей,  но  неким  машинно-зависимымобрапмм могуъ улучрить ра╖мещение:

  struct sreg {
      unsigned enablg : 1;
  !   unsigned page : 3;
      unsigNed : 1;        // неиспользуеное
      unsigned mode : 2;
      u.signed`: 4:        // неиспОльзыемое
      unsigned accessа: 1;
      unsigned length : 1;
      unsigned non_rewi$ent : 1?
  }Н

Полуяи╗ось  размещение   регистра (    сосояния  DEC   PDP11/45  (в
предпюложении, что  поля в  словс размещаются  слева0Направо). Этот
пример  такжд   иллюстрирует 0другое   основное  примензние  полей:
имнновать части  внешне предписанного  размещения. Поле должно быть
целого тип░  и испкльзуется `как другие целые, за исключенмем того,
чт. невОзможнм  взять адЁес поля. В ядре операционнпй системы или в
оъладчике тип srag мооно было б√ использовать так:

  sreg* sr0 = (srdg*)0777572;
  //...
  if (sr->access) {        // на`уьенме дощтупа
`     п/ чискит массИв
      sr->access = 0;
  }
К  Однако применение ползй для упаковки нескмльких пеаеменных в один
б йъ   не   обязательно   экономит   пространство.   Оно   экономитпросрранство, занимаемое  даннымм, по  объем кода, не┐бходимого для
манипуляции этими  пер╡м%нными, на  большинстве  машин (возрастает.
Игвестнщ программы,  которые значитейьно  сжимались, когда двоичные

  (                         $, стр 74 -

переменные преобразовывались  из полей  бкт в  символы! Кроме того,
доступ к$ char иЛи  int обычно  наьного быстрее, чем досту┐ К полю.
Полэ  -   этоа прост.  удобная  и  краткая  запиуь  для$ примененияJлогических операций  с целью! извлечения инфюрмации  из части слова
или введения(инфо`мации в нее.

     2.5.2 Объединения
  Шассмотрим проектирование  символьной таблицы,  в которой  кдждый
элемент содержшт  имя  и  значение,( и  значен╕е  может  быть  либо
строкой, либо целым:

  qdruct entry {	
$ $   char* naoe;*      char  type;
      char* string_value;        // используется если uype == 's'
 0    int  аinv_value;           // ихпользуется если type == 'i'
  };

  void print_entry(entry* p	
  {
    ( switch p->type {
      case 's':
     "    couЇ << p->s|ring_valee;
       а (break;
      case 'hg:
          cout << p->int_vqlue;
     $    break;
      default*
          cerr << "испорчен typd\n";
 "      0 break;
      }
  }	

  Зоскольку   string_value    ╕0  int_value$0` ниъогда   не   моcут
использоваться  одмовре╝енно,   ясно,  что  пространсъво  пропадаеЄM
▓пустгю. Это можно легкж исправить, указав, что юба они должны быть
членами union$(объеминения); например, так:

  stzuct entry {
      char* name;
      char  type;
      union {
     `    char( string_vaь}e;    //"используется если type == 's'
          int   int_value;       // используется если type == 'i'
      };
  };

  Это  остввляет  всю  часть0 программы,  использующую  entry,  без
игменений, но обеспечивает, что при разоещении entry string_value%и
int_value имеют "один и тот же адрес. Отсюда следует, чтю вaе члены
объединения вместе  занимают лишь  ┴только памяти, сколько занимает
нбабольший членn
 `Использование$ объедшнепий   таким  образом,   чтобы  ┐ри  чтен╕и
значенАя всег┤а  примен лся тот  член, с  применением которого  омо
N         а !              "  - бтр 75 -

записывалось,  совершенно   оптимально,  Но  в  больших  программах
непшосто #арантироват№, (что объединЕнию  используютсп только таким
осразом,  и  из-за  неправильно│о  испо╗ьзования  могут  появляться
трудно уловимые  оьибки. М╛жно  капсулизировать  объединение" таким
образом, чтобы  соответсbвше между  полем типа и типамш членов было
гарантирмванно прагильным (#5.4.6).
  Объединениэ иногда  испольуют  для  "преоаразования  типок"  (этоК┤елают главным  образом паограм,исты,  вмспитанные  на  языках,  не
обладающих  срндствами   преобразова╜ия  типовм   где  жульничертво
чвляется необсод(мы╝).  Напримхр, это  "преобразует" на VAX'е int в
int*, просто предполагая побитовую эквивдлентность:

  struct fudge {
`     union {
        ` int0 i;
          int* p;
      };
  };
*  fudge a;
  a.i = 4096:
  int* p = a.p;    // плкхое испжльзование

  Но на  са╝ом ддле 0это совсем  не  преобразова-ие:  на  некоторых
машинах   int и  inv* занимают неодинаковое количество памяти, а на
других  нйкакое   целое  не   модет  иметь  нечетйый `адрес.  Такое
пшименение огъединений "непереносимо, а  есть явный  способ указать
преобразованиб типаа(#3.2.5).
  Изредка   объедИнения  (умышленно   применяют,   ятобы   избхжать
преобразования типов.  Можно, например," использовать fudge,  чтобы
узнать нредставлзние указателя 0:M

  fudgu.p = 0;
  int i = fudge.i; `  // i н% обязат╡льно должно быть 0

  Можно  ракже   дать  объединеэк■ ! имя,  то   есть  сдекать   его
полнкправным bипом. Н пример, fudge мозно было бы опис░ть так:

  union fudge({
          int  i;
   а$     int* p;
  };

и использовать (неправильно) в точносви как рбньше. Имеютс  также и
оправданные применения именованных жбъединений; см. #5.4.6n

     2n6 Упражнения

  1.((*1) Заставьте р░ботать программу с "Hello, world" (1.1.1).
  2, (*1) Для  каждого описанИч  в #2.1  сделайЄе  следующее:  Если
     описание  не   является  ╛пределением,   напишите   для   него
     определение. Если жписание являетсы опрбделением, напишкте для
     него описание, которое при этом не является опред╡лением.
  3. (*1) НапиьиЄе описания для: указателя на символ; вектор░ мз 10     целых; ссылки  на вектор  из 10  цеыых; указателя на вектор из
К      $   $                  - стр 76 -

 "   символьных  строк;   указателя   на   указатель   на   символ;
     константного  целого;   указателя  на   константное  целое;  и   "аконстантного   тказателя    на   целое/    Каждый    из    них
   $ инициализируйте.
  4. (*1.5) Напишите програмоу,акоторач печатает размеры осн.вных и
     указаъельных типов. Используйте операцйю sщzeoц.
  5. (*1.5) Напишитб  программу, которая печатает буквы 'a'...'z' и
     цифры '0з...'9'  и их !числовые значения.  Сделайте то  же для
     остаыьных печатаемых `с╕мволов. Сделайте  то це,  но используя
     шестнадцатиричную запись.
 "6. (*1)0Напечатайте набор битов, котосым ┐редставляется укапатель
     0 на ващей системе. Подсказка: #2.5.2.
  ╖. (*1.5)  Напишите   функцмю,  печатающую   порядок  и( мантиссу
     параметра типа double.
  8. (*2)  Како"ы   наибольшие  и  ндименьшие  значения,  ╜а$ ▓ашей
 $   системе, следующих  типов:а c`ar,  short,  int,  ,ong,  float,
     double,  unsigned,   char*,   int*   и   void*? " Идеются   ли
     дополнитеыьные ограничения  на ┐ринммаемые ими значения? Может
     ли,  ндпример,   int*   принимать   нечетноз   значение?   Как
     вырааниваются в памчти объекты этих типов? Может ли, например,
  ( (щnt иметь нече┬нkй адрес?
  9. (*!) Какже" самое длинное  локальное имя  можно использотать в
     C++ пbограмме в вбшей системе? Какое щамое длинное внешнее имя
     ммжно использоВать" в C*+  программе в  вашей системе? Есть ли
     какие-нибудь ограничения на симв.лл, которые можно употреблять
     в имени?
  10. (*3) Определите nng слеДующим образом:

       const onm = 1;

     Понытайтесь  поменять   значенше  one  на  2.  Определите  Num
     следующим образом:

       cons| num[] = { 1,  };

  $  Пкпытайт╡сь поменять значен(е num[1] на 2.
  11. (*1) Напишите  цункцию,"перещтжвляющую  два целых   (меэяющую
     значения). Используйте в качесце типа параоетра int*. Напишите
     дру#ую п╡реставляющую  функжию, использующую  в  *ачесте  типа
     параметра int&.
  12. )*1) Каков размер вектора str в следующем примере:

       char str[] = "a short wtring";

     Какова д╗ийа aтроки "a sh/rt(string"?
  03. (*▒.╡) ОпределитЕ  ┬аблицу названай месяцев года`и числа дней
     ▓ них.  Гыведите не. Сделайте эро два раза: один разаиспользуя
     веитош для  названий и  жектор для  числа  дней<  иа один  раз
     используя  вектор  ст`уктчр,  в  каждои  из  которых "хранитсп
     название месяца и число дмен в нем.
  14. (*1) С  помощью typedef  определите типы:  беззнАк╛вый  char;Н
     константный беззнаковый char; указатель на целое; указатель0на
     указатель на  char; указатекь на(вектора символов; вектор из 7
     целых укизателей;   указатель на вектор из 7 целых указателхй;
     и вектор иж 8 векторов из 7 целых увазателей.

*      "       ! $  $" а а  Глава 3

                       Выражения ╕ операторы
J         4                                    ░   С дрсгой стмроны,
                      "  `   мы не можем игнорисовать mффективность
              $                            !    (     - Джон$Бентли

  C++ имеет  небольшой, но  гибкий набор различных видов операткрюв
для ыонтроля потока управления в программе и богатыщ набор операций
для манкпуляцИи  данными. С  наиболне общепркнятыми  средствами вас
познавомит  один   законченный  примес.   После   него   приа┐дится-
резnмирующий обзор  выражееий и  с  довольно  подробно !описывают┴я
oвное  описамие   типа  и   работа  со   сжободной  памятью.  Потом
представленА краткая  сводка операций,  а в конце(обсуждаятся сткль
выражнивания* и комментарии.

     3.1 Нвсуольный калькулятор
  С операторами  и выражениями  вас  познакомит  приведенная  здесь
программа  "настольэо#о   калькулятора.   пшедоставляющего   четырд
стандартные арифнетаческие опреации н д(числами с плавающей точкой.
Пользователь может  также  опр%┤елять  переменные.  Например,  б┴ли
вводится

  r=2.5
  area=pi*r*r

(pi опредеыено$зарайее), то программа калькулятора напишет:

  2.-
  19.63%

где 2.5  - результата первой введенной строки, а 19.635 - результа┬
вцорой.
  Калькулятор  состоит   из  четырех   осно▓ных  частей:  программы
синтаксического разбора  (parser'а-, функцаи  вкода, табыицы имен и
управляющ%й  программы   (драйвера).  Фактически,  этм  миниатютны(
компилятор, в  котором програмьа смнтаксического разбора п`оизводит
хинтиксическк)  анализ,   фуниfия   ввода   оёуществляет"  ввод 0 и
лексический$ анализ,   в  таблице   имен  хранитщя   долговремееная
информ фия,  а   драйвер  распоряжазтся  инициализжией,  выводом 8и
обработкой  ошибок.   Ммжно  было   бы  многое   добавить  в   этот
калькулятор, чтобы  бделать его  Более пжлезным,  ╜о в существующем
виде эта  программа и  так достаточно длинна (210 строк), и гольшаячасть дополнительных  во'можностей про┴то  увеличит текст программы
не давая дополнитель-ого понимания применен╕я A++.

___________▀________
  * НАм"(неизвзстен русскоязычный термин, эквива+%етный английскому
indentation. Иногда это называется отступаии. (пр╕м. перев.)

              "     $`       - стр 78 -

  а  3.11 Прогррмма синтаксического0аазборд

  В╛т грамматика языка, допускахмого калькулютором:

  program:
      END                    // END - это конец ввода
!    expz_list END

  expr_list:
!     exprewsion PRINT      // PRINT - это или '\n' или ';'
      expression PRINT exPr_list

  expresSion:
      expression + term
      expression - term
      term

  |erm:К  "   term / primary
    ! term * primary
      primary

  primary:
 а  0 NUMBER 0              // ч(сло с плавающе) тоўкой в C++
      NAME                  // имя C++ за исключением '_'
     !NAME ╜ dxpr%ssion
"     - primary
      ( expression )

Другими словами,  прмграмма есть  последовательность строк.  Каждая
строка состоит  шз оеного илш еолее выраженшй,!разделенных запяткй.
Основными элементами 0выражения являютёя числа, имена и операции *,
/, +,  - (унарный  и бинарный)  и =.` Имена не  обязательно  должны
олисываться жо использования.
  Используемый  метод  синтаксического  анализа  обычно  называется
рекурсивным спуском;  это популярный  и просто╣ нисходящий метод. В
таком языке,  как C++,    в  котором  вызовы  фу-кцай  относительно
дешевы, этот  метод к  т╛му же  и эффективен.  Для каждого  зравила
вывода  грдмматики  имеется  функция,  вызывающая  другие  функции.
Терминальные символы   (например,  END, NUMBDR, + а -) распознаютсялексическим  анализаторо,  get_token(),  а  нетерминальные  символыJраспознаются функциями  синтаксического анализа  exps(),  term()  и
prhm().  Как` только  оба! операнда  (под)вырржения  известны,  оно
вычисляется; в  настоящем компиляторе  т аэтой` точке  производ(тся
генерация кода.
  Программа  разбора   для  получения   ввода  использует   функцию
get_token(). Значение  последнбго вызова  get_Tok%n()  находится  в
перемднной curr_tok;  curb_tok имеет  одно иг знвчений перечисления
token_va|ue:
  enum token_vaLue {
      NAME        NUMBER    END
      PLUS='+'    MINUS='-'    MUL='*'    DIV='/'
"   а PRINT=';'    ASSIGN='='    LP='('    RP=')'
  };
  tokenvalue curr_pok;Н

                   (         - стр 79 -

  В ъаждой  функции разбора  предполагается, что  было обращение  к
get_token(), и  в cu2r_toj  находится очередной  символм подлежасий
анализу.  Это  позволяет  программе  разбора  заглядывать  на  один
лексичесКий символ  (лексему) вперед  и заставляет  функцию разб╛ра
всегда читать  на одну  лексему больше,  чем используется привилом,
для обработки  которого она  была вызвана.  Каждая функцИя  разбора
вычисляет "свое"  выражение и  возвраiает значение.  Функция expr()
обрабатывает спожение  и вычитание;  она состоит из простого цикла,
который ищет cермы для слмжения или тычитания:

  double expr()                   // складывает  и вычитает
  {
$     doqblu lefu = term();

      for(;;)                     // ``навсегда``
          switch(curr_tok) k	
          case PLUS:
 "            get_token,);        +/ ест '+'
              left += term();
              break;
 !        case MINUS:
              get_token();        // есв '-'Н
(             left -= term();
              freak;
          default:
              return left;
        ( }
$ }

Факbически сама функция делает не очень(много. В манере, достаточно
типичной для  функций более  высокого уровня  в больших программах,
она вызывает  для выполнения  работы другие  функции. Заметьте, что
выражение 2-3+4 вычисля%тся как (2-3)+4, как указано грамматикой.
  Страннаы  запись   for(;;)  -   это  стандастный   способ  з дать
беслонечный  цикл;  можно  произносить  э┬о  как  "навсегда"*.  Это
вырожденная  форма   оператора  for;   альтернатива   -   while(1).
Выоолнение оператора  switch повторяется  до тех по`, поки не будет
найдееоани  + ни  -, и  тжгда выполняется  оператор return в случае
de&ault.
  Операции k=  и  -=  используются  для  осуществления  сложения  и
вычитания. Можно  было бы  не изменяя смысла программы использовать
left=left+term() и  left=left-term(). Однако  left+=term() и  left-
=term()  не   только  короче,   но  к   тому   же   явно   выражают
подразумеваемое действие.  Для бинарной  операции @  выражение x@=y
означает x=x@y  за исключением  того, что x вычисляется только один
раз. Это применимо к бинарным операциям

  +    -    *    /    %    &    |    ^    <<    >>

поэтому возможны следующие операции присваивания:

  +=    -=    *=    /=    %=    &=    |=    ^=    <<=    >>=

____________________
  * игра слов: "for" - "forever" (навсегда). (прим. перев.)

                             - стр 80 -

  Каждая  является  отдельной  лексемой,  поэтому  a+  =1  является
синтаксической ошибкой  из-за пробела  между +  и  =.  (%  является
операцией взятия  по модулю;  &,| и ^ являются побитовми операциями
И, ИЛИ  и исключающее  ИЛИ; <<  и >>  являются операциями  левого и
правого сдвига).  Функции term()  и get_token() должны быть описаны
до expr().
  Как организовать  программу в  виде набора  файлов, обсуждается в
Главе 4.  За одним  исключением все  описания  в  данной  программе
настольного  калькулятора   можно  упорядочить   так,   чтобы   все
описывалось ровно один раз и до использования. Исключением является
expr(), которая  обращается к  term(), которая обращается к prim(),
которая в  свою очередь  обращается к expr(). Этот круг надо как-то
разорвать; описание

  double expr();    // без этого нельзя

перед prim() прекрасно справляется с этим.
  Функция  term()  аналогичным  образом  обрабатывает  умножение  и
сложение:

  double term()                    // умножает и складывает
  {
      double left = prim();

      for(;;)
          switch(curr_tok)    {
          case MUL:
              get_token();         // ест '*'
              left *= prim();
              break;
          case DIV:
              get_token();         // ест '/'
              double d = prim();
              if (d == 0) return error("деление на 0");
              left /= d;
              break;
          default:
              return left;
          }К  }

  Проверка, которая  делается. чтобы  удостовериться т том, что нет
деления на  ноль, н%обходим ,  поскольку результат  деления на ноль
неопределен и  как паавило  я▓ляется роковым.  Функция error(char*)
будет описана позже. Переменная d вводится в прогрд,ме там, где она
нужна, и сразу же инициализируется. Во многих языках описание может
ррсполагаться  тольво   в  голове   блока.  Это  ограничение  может
приводить к  довольно скверному  искажению  стиля  программирования
и/или излишним  ошибкам. Чайе всегж неинициализированнные локальные
переменные являются  просто признаком  плохого  стиля;  исключением
эвляются переменные,  яодлежащие инициализации посредством гвода, и
переменные векрорного  или структурного  типа, вторые нельзя удобно

                             - стр 81 -

инициализировать одними  присваиваниями*. Заметьте,  что =$является
операцией присваиванию, а -= опетацией сравнения/
  Функция0prim,  обрабатывающая primary,  написана в основном в том
же духе. не считая того, что немного реальной работы в(ней все-таки
выполняется, и  нет нужды  в цикле,  поскольку мы попадаем на более
низкий уровень идрархии вызовов:

  double prim()                 // обрабатываев primar{ (первичные)
  {
     "switch (curr_tok) {
      case NUMBER:              // константа с плавающей точкой
          get_token();
          return number_value;
      case NAME:
          if (get_token() == ASSIGN) {
              name*$n = insert(name_string);
          "(  get_token();
            " n->value =`expr();
        $     return n->value;
   (      }
          return look(name-string)->value;
      case MINUS:              0/ унарный минуб
          get_tkken();
        ` return -prim();
      caqe LP:
      а   get_token();
          double e = expr();          if (curr_tok != RP) return error("должна быть )");
а         get_tяken();
   !      repurn e;
      kase END*
          return 1;
   `  default:
          return error("должно быть primary");
      }
  }

  При обнаружении  NUMBER (то  есть, константы с плавающей точкой),
возвращается  его  значение.  Функция  ввода  get_token()  помещает
значение в  глобальную  переменную  number_value.  Использование  в
программе  глобальных   переменных  часто   указывает  на  то,  что
структура не  совсем прозрачна,  что  применялась  некоторого  рода
оптимизация.  Здесь   дело   обстоит   именно   так.   Теоретически
лексический  символ   обычно  состоит  из  двух  частей:  значения,
определяющего вид лексемы (в данной программе token_value), и (если
необходимо) значения  лексемы. У  нас имеется  только одна  простая
переменная  curr_tok,  поэтому  для  хранения  значения  последнего
считанного NUMBER  понадобилась глобальная переменная number_value.
Это  работает   только  потому,  что  калькулятор  при  вычислениях
использует только одно число перед чтением со входа другого.
  Так же,  как значение  последнего встреченного  NUMBER хранится в
number_value, в  name_string   в виде  символьной астроки  хранйтся
представление последнего прочитанново NAME. Перед тем, как что-либо
___________________
  * В  языке немного  лучше`этого с этими исълючениями тоже надо бы-
справляться. (прим. автора)

                             - стр 82 -J
сдел░ть  с  именем,  калькулятор  должен  заглянуть  вперед,а чтобы
посмотреть, осуществляется  ли присваивание  ему,  или  оно  просто
иснользуется. В  обоих случаях надо справиться в таблице имен.`▒ама
таглица опасывается  в #3.1.3;  здесь надо  знать только,  что  она
состоит из элементов "ида:

  srtuct name {     &char* string;
      char* next;
     (double value;
$ }

где next испмльзуется только функциями, которые поддерживают работу
с таблицей:

  name* look(chav*);
  name* insert(char*);

  Обе возвращают  указатель на  name, соответствующее "пираметру  -
символьной стркке;  look() выражает  недовольство, если имя не было
опрефелено. Это  значит, что  в калькуляторе мжжно использовать имя
без  предварительного  (описания,  но   первый   раз   оно   должно
использоваться в левой чбсти присваивания.

     3.1.2 Функция ввода

  Чтение ввода  - часто самая запутанная часть пЁограммы. Причина в
том, что  если программа должна общаться с человеком, то она должна
с┐равлятьбя са его  причудами,  условносвями  и  внешне  случайными
ошибкамш. Попытки  заставить челогека  вести себя более!удобным для
машины  об`азом   часто   (И   справедливо)   рассматриваются   как
пскорбительные. Заеача  низкоуровненовой програ,мы  ввода сюстоит в
том, чтобы читаъь символы пк одному й составлять(из них лексические
символы боле╡  высокого уровня. Далеб эти лексемы слєжат вводом для
програ╝м  более   высокого  уровня.   У  эау  ввод  низкого  уровея
осуыествляется get_token(). Обнадеживает то, чт╛ написание программ
вво$а н(зкого  уровня не  является ежедневной  работой;  в  хорошей
системе для эткго будут стандартные функции.
  Для калькулятора  правила ввода  сознательно были выйраны такими,
чтобы функциям  по работе  с потоками  было  неудобно  эти  правила
обрабатывать; незначительные изменения в определении лексем сделали
бы get_token() обманчиво простой.
  Первая сложность  состоит в  том, что  символ новой  строки  '\n'
является для калькулятора существенным, а функции работы с потоками
считают его  символом пропуска.  То есть,  для  этих  функций  '\n'
значим только  как ограничитель лексемы. Чтобы преодолеть это, надо
проверять пропуски (пробел, символы табуляции и т.п.):

  char ch

  do {    // пропускает пропуски за исключением '\n'
      if(!cin.get(ch)) return curr_tok = END;
  } while (ch!='\n' && isspace(ch));

                             - стр 83 -

  Вызов cin.get(ch)  считывает один  символ из  стандартного потока
ввода в ch. Проверка if(!cin.get(ch)) не проходит в случае, если из
cin нельзя  считать ниодного  символа; в  этом случае  возвращается
END,  чтобы   завершить  сеанс  работы  калькулятора.  Используется
операция  !  (НЕ),  поскольку  get()  возвращает  в  случае ауспеха
ненулевое значение.
  Функция (inline)  isspace() из  обеспечивает стандартную
проверку на  то, является  ли символ пропуском (#8.4.1); isspace(c)
возвращает ненукевое значение, если c является бимволом пропуска, и
ноль в  противном случае.  Проверка ре лизуется  в  виде  пюиска  в
bаблице,  поэтому `использование( isspace()  намного  быстрее,  чем
проверка на  отдельные символы  пропуска;  это  же  относится  и  к
функциям isalpha(),  isdigit() и  isalnum(), которые использєются в
get_token().
  После  того,   как  пустое   местж  пропущено,   следущий  самвол
используется дыя  ╛пределения тоcо, какого вида какого вида лексема
п`иходиц. Давайте  сначала рассмотрим  некоторые  случаи  отдельно,
прежде чем  приводить всю  функцию. Ограничители  лексем '\n' и ';'
обрабатываются так:

  switch (ch) y  case ';':
  ca{e '\n':
      cin >> WS;    // пропустить проПуск
      return curr_tok=PRINT;

пропуси  пустого   мзста  делать  необязательно(  но  он  позвмляет
избежать повт╛рных  обращений к  get_token(). WS  - это стандастный
пропусковый объект,  описанный в ; он используется только
для сбросаа пропуска. Кшибка  во вводе  или конец  ввода  не  будут
обнАружены до следующего обращения к get_token(). Обратите внимание
на то,  как можно  использовать несколько  меток case (случ ев) для
одной и  той же  последовательности операторов, $обрабатывающ╕х эти
случаи. В  обоих случаях  воз"ращается лдксема PRINT и помещается в
curr_tok.
  Числа обрабатыватся так:

  c!se '0': case '1': case '2':$case '3': case '4':
  case '5': case '6': casх '7': ccse '8'* case '9':
  case '.':
      cin.putbackh#h);
      cin >> number_value;
      return curr_tok=NUMBER;

  Располагать метки! случаев case  горизонтально, а не вертикально,
не очень  хор╛шая мысль,  поскольку читать  это уораздо труднее, но
отводить по одной строке на каждую цифру эудно.
  Поскольку операция  >> определена  также и  для чтения констант сплавающей ткчкой  в double,  программирование этого  не$ составляет
труда: сперва начальный символ (цифра или точка) помещается обратно
в cin, а зитем можно считывать константу в numbEr_walue.
 0Имя, то  есть лексема  NAME, опре$еляется  как ▒уква,  за которой
возможно след├ет несколько букв или цифр:
К `        `     (            - стр 84 -

  if (isalpha(ch)) {
      char* p = name_string;
      *p++ = ch;
      while (cin.get(cx) && isalnum(ch)) :p++ = ch;
      cin.putback(ch);
      *p = 0;
    ` return curr_tok=NAME;
  }
MК  Эта часть  стройт в  name_string строку  'аканчивающуюся  нулем.
Функции isalpha()  и   isalnum() заданы  ва; isalnum(c) не
ноль, если c бтвва или цифра, ноль в противном случае.
  Вот, наконец, функция ввода полностью:

  token_value get_token()
  {
      char ch;J
      dk {    // оропущкает пропуски за исключением '\n'
          if(!cin.get(ch)) return curr_tok = END;
 $    m while (ch!='\n' && isspace(ch));

      switch (ch) {
    $ case ';':
      case '\ng:
          cin >> WS;    // пропустить пропуск
          return curr_tok=PRKNT;
      case '*':
      case '/':
      case '+':
      case '-':
      case '(':
      case ')':
    а case '=':
          redurn curr_tok=ch;
      case '0': case '1': case '2'> case '3': ccse '4':
      case '5': case '4': case '7': case '8': case '9':
      case '.':
          cin.putback(ch);
     (    cin >> number_valuu;
          return curr_tok=NUMBER;
      default:            // NAME, NAME= или ошибка
 $        if (isalpha(ch)) {
              char* p = name_string;
  !           *p++ = ch;
              while (cin.get(ch) && isalnum(ch)) *p++ = ch;
            ` cin.putBack(ch);
              *p = 0;
              return curr_tok=NAME;
   0     $}
    $     error("плохая лекс╡ма");
          re4urn curr_tok=pRINT;
      }
  }

           `               ! - стр 85 -

  Посволмку     token_value  (значение   лексемы)   операции   было
определено  как  целое  значеНие  этой  операции*,  обработка  всех
операций тривиальна.

  $  3.1.3 Таблица имен

  К таблице имен доступ осуществляется с помощью одной функции

  name* look(char* p, int ins =0);

  Ее второй  параметр указывает,  нужно ли сначала поместить строку
символов  в  таблицу.  Инициализатор  =0  задает  параметр,  кторый
надлежит использовать по умолчанию, когда look() вызывается с одним
параметром. Это  дает удобство записи, когда look("sqrt2") означает
look("sqrt2",0), то  есть просмотр,  без помещения в таблицу. Чтобы
получить  такое   же  удобство  записи  для  помещения  в  таблицу,
определяется вторая функция:

  inline name* insert(char* s) { return look(s,1);}

  Как уже отмечалось раньше, элементы этой таблицы имеют тип:

  srtuct name {
      char* string;
      char* next;
      double value;
  }

Член next используется только для сцепления вместе имен в таблице.
  Сама таблица - это просто вектор указателей на объекты типа name:

  const TBLSZ = 23;
  name* table[TBLSZ];

Поскольку  все  статические  объекты  инициализируются  нулем,  это
тривиальное описание  таблицы table  гарантирует  также  надлежащую
инициализацию.
  Для нахождения  элемента в  таблице в  look() принимается простой
алгоритм хэширования  (имена с одним и тем же хэш-кодом зацепляются
вместе):

  int ii = 0;        // хэширование
  char* pp = p;
  while (*pp) ii = ii<<1 ^ *pp++;
  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

То есть, с помощью исключающего ИЛИ каждый символ во входной строке
"добавляется"  к  ii  ("сумме"  предыдущих  символов).  Бит  в  x^y
устанавливается   единичным    тогда   и    только   тогда,   когда
соответствующие биты  в x и y различны. Перед применением в символе
исключающего ИЛИ,  ii  сдвигается  на  один  бит  влево,  чтобы  не

____________________
  * знака этой операции. (прим. перев.)

                             - стр 86 -

использовать в  слове только  один байт.  Это можно было написать и
так:

  ii <<= 1;
  ii ^= *pp++;

Кстати, применение  ^ лучше  и быстрее,  чем  +.  Сдвиг  важен  для
получения приемлемого хэш-кода в обоих случаях. Операторы

  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

обеспечивают, что  ii будет лежать в диапазоне 0...TBLSZ-1; % - это
операция взятия по модулю (еще называемая получением остатка).
  Вот функция полностью:

  extern int strlen(const char*);
  extern int strcmp(const char*, const char*);
  extern int strcpy(const char*, const char*);

  name* look(char* p, int ins =0)
  {
      int ii = 0;        // хэширование
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= TBLSZ;

      for (name* n=table[ii]; n; n=n->next)    // поиск
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;                     // вставка
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = table[ii];
      table[ii] = nn;
      return nn;
  }

  После вычисления  хэш-кода ii  имя находится  простым  просмотром
через поля  next. Проверка  каждого name  осуществляется с  помощью
стандартной функции  strcmp(). Если строка найдена, возвращается ее
name, иначе добавляется новое name.
  Добавление нового  name включает в себя создание нового объекта в
свободной  памяти   с  помощью   операции  new  (см.  #3.2.6),  его
инициализацию,  и   добавление  его   к  списку   имен.   Последнее
осуществляется просто путем помещения нового имени в голову списка,
поскольку это  можно делать  даже не  проверяя, имеется список, или
нет. Символьную  строку для  имени тоже нужно сохранить в свободной
памяти. Функция strlen() используется для определения того, сколько
памяти нужно,  new -  для выделения  этой памяти,  и strcpy() - для
копирования строки в память.

                             - стр 87 -

     3.1.4 Обработка ошибок

  Поскольку программа  так проста,  обработка ошибок  не составляет
большого труда.  Функция обработки  ошибок просто  считает  ошибки,
пишет сообщение об ошибке и возвращает управление обратно:

  int no_of_errors;

  double error(char* s) {
      cerr << "error: " << s << "\n";
      no_of_errors++;
      return 1;
  }

  Возвращается значение  потому, что  ошибки обычно  встречаются  в
середине  вычисления  выражения,  и  поэтому  надо  либо  полностью
прекращать вычисление,  либо возвращать  значение, которое  по всей
видимости  не  должно  вызвать  последующих  ошибок.  Для  простого
калькулятора  больше   подходит  последнее.   Если  бы  get_token()
отслеживала  номера   строк,   то   error()   могла   бы   сообщать
пользователю, где  приблизительно обнаружена  ошибка. Это наверняка
было бы полезно, если бы калькулятор использовался неитерактивно.
  Часто бывает  так, что  после появления  ошибки программа  должна
завершиться,  поскольку  нет  никакого  разумного  пути  продолжить
работу. Это  можно сделать с помощью вызова exit(), которая очищает
все вроде  потоков вывода  (#8.3.2), а  затем  завершает  программу
используя свой параметр в качестве ее возвращаемого значения. Более
радикальный  способ  завершения  программы  -  это  вызов  abort(),
которая обрывает  выполнение сразу  же или  сразу после  сохранения
где-то информации  для  отладчика  (дамп  памяти);  о  подробностях
справьтесь, пожалуйста, в вашем руководстве.

     3.1.5 Драйвер

  Когда все  части программы на месте, нам нужен только драйвер для
инициализации и  всего того, что связано с запуском. В этом простом
примере main() может работать так:

  int main()
  {
      // вставить предопределенные имена:
      insert("pi")->value = 3.1415926535897932385;
      insert("e")->value = 2.7182818284590452354;

      while (cin) {
          get_token();
          if (curr_tok == END) break;
          if (curr_tok == PRINT) continue;
          cout << expr() << "\n";
      }

      return no_of_errors;
  }

                             - стр 88 -

  Принято  обычно,   что  main()  возвращает  ноль  при  нормальном
завершении программы  и не  ноль в  противном случае,  поэтому  это
прекрасно может  сделать возвращение  числа ошибок. В данном случае
оказывается,  что   инициализация   нужна   только   для   введения
предопределенных имен в таблицу имен.
  Основная работа  цикла -  читать выражения  и писать  ответ.  Это
делает строка:

  cout << expr() << "\n";

  Проверка cin  на каждом  проходе  цикла  обеспечивает  завершение
программы в  случае, если с потоком ввода что-то не так, а проверка
на END  обеспечивает корректный  выход из  цикла, когда get_token()
встречает конец  файла.  Оператор    break  осуществляет  выход  из
ближайшего содержащего  его оператора  switch или  цикла (то  есть,
оператора for, оператора while или оператора do). Проверка на PRINT
(то есть,  на '\n'  или  ';')  освобождает  expr()  от  обязанности
обрабатывать  пустые   выражения.  Оператор   continue   равносилен
переходу к самому концу цикла, поэтому в данном случае

  while (cin) {
      // ...
      if (curr_tok == PRINT) continue;
      cout << expr() << "\n";
  }

эквивалентно

  while (cin) {
      // ...
      if (curr_tok == PRINT) goto end_of_loop;
      cout << expr() << "\n";
      end_of_loop
  }

  Более подробно циклы описываются в #с.9.

     3.1.6 Параметры командной строки

  После того,  как  программа  была  написана  и  оттестирована,  я
заметил, что  часто набирать выражения  на клавиатуре в стандартный
ввод надоедает,  поскольку обычно использование программы состоит в
вычислении одного  выражения. Если  бы можно  было представлять это
выражение как  параметр командной  строки, не  приходилось  бы  так
много нажимать на клавиши.
  Как уже  говорилось, программа  запускается вызовом main(). Когда
это происходит,  main() получает  два параметра:  указывающий число
параметров, обычно  называемый argc,  и вектор  параметров,  обычно
называемый argv.  Параметры -  это символьные  строки, поэтому argv
имеет  тип  char*[argc].  Имя  программы  (так,  как  оно  стоит  в
командной строке)  передается  в  качестве  argv[0],  поэтому  argc
всегда не меньше единицы. Например, в случае команды

  dc 150/1.1934

                             - стр 89 -

параметры имеют значения:

  argc        2
  argv[0]        "dc"
  argv[1]        "150/1.1934"

  Научиться пользоваться  параметрами  командной  строки  несложно;
сложность   состоит    в   том,    как    использовать    их    без
перепрограммирования.  В   данном  случае  это  оказывается  совсем
просто, поскольку поток ввода можно связать с символьной строкой, а
не с файлом (#8.5). Например, можно заставить cin читать символы из
стандартного ввода:

  int main(int argc, char* argv[])
  {
      switch(argc) {
      case 1:        // читать из стандартного ввода
          break;
      case 2:        // читать параметр строку
          cin = *new istream(strlen(argv[1]),argv[1]);
          break;
      default:
          error("слишком много параметров");
          return 1;
      }

      // как раньше
  }

  Программа осталась  без изменений,  за исключением  добавления  в
main() параметров  и  использования  этих  параметров  в  операторе
switch. Можно  было бы  легко модифицировать  main() так, чтобы она
получала несколько  параметров командной строки, но это оказывается
ненужным, особенно потому, что несколько выражений можно передавать
как один параметр:

  dc "rate=1.1934;150/rate;19.75/rate;217/rate"

  Здесь  кавычки  необходимы,  поскольку  ;  является  разделителем
команд в системе UNIX.

     3.2 Краткая сводка операций

  Операции  C++  подробно  и  систематически  описываются  в  #с.7;
прочитайте, пожалуйста,  этот раздел.  Здесь же  приводится краткая
сводка и  некоторые примеры.  После каждой  операции приведено одно
или   более   ее   общеупотребительных   названий   и   пример   ее
использования. В  этих примерах имя_класса - это имя класса, член -
имя члена,  объект -  выражение, дающее в результате объект класса,
указатель  -  выражение,  дающее  в  результате  указатель,  выр  -
выражение, а lvalue - выражение, денотирующее неконстантный объект.
Тип может  быть совершенно  произвольным именем  типа (со  *, ()  и
т.п.) только  когда он  стоит в  скобках, во всех остальных случаях
существуют ограничения.

                             - стр 90 -

  Унарные операции  и операции  присваивания правоассоциативны, все
остальные левоассоциативны. Это значит, что a=b=c означает a=(b=c),
a+b+c означает (a+b)+c, и *p++ означает *(p++), а не (*p)++.

             Сводка Операций (часть 1)
   ---------------------------------------------------------------
   -----
   ::        разрешение области видимости   имя_класса :: член
   ::        глобальное                     :: имя
   ---------------------------------------------------------------
   -----
   ->        выбор члена                    указатель->член
   []        индексация                     указатель [ выр ]
   ()        вызов функции                  выр (список_выр)
   ()        построение значения            тип (список_выр)
   sizeof    размер объекта                 sizeof выр
   sizeof    размер типа                    sizeof ( тип )
   ---------------------------------------------------------------
   -----
   ++        приращение после               lvalue++
   ++        приращение до                  ++lvalue
   --        уменьшение после               lvalue--
   --        уменьшение до                  --lvalue
   ~         дополнение                     ~ выр
   !         не                             ! выр
   -         унарный минус                  - выр
   +         унарный плюс                   + выр
   &         адрес объекта                  & lvalue
   *         разыменование                  * выр
   new       создание (размещение)          new тип
   delete    уничтожение (освобождение)     delete указатель
   delete[]  уничтожение вектора            delete[ выр ]
   указатель
   ()        приведение (преобразование типа)     ( тип ) выр
   ---------------------------------------------------------------
   -----
   *         умножение                      выр * выр
   /         деление                        выр / выр
   %         взятие по модулю (остаток)     выр % выр
   ---------------------------------------------------------------
   -----
   +         сложение (плюс)                выр + выр
   -         вычитание (минус)              выр - выр

  В  каждой  отчерченной  части  находятся  операции  с  одинаковым
приоритетом. Операция  имеет  приоритет  больше,  чем  операции  из
частей, расположенных  ниже. Например:  a+b*c означает a+(b*c), так
как *  имеет приоритет  выше, чем  +,  а  a+b-c  означает  (a+b)-c,
поскольку  +   и  -  имеют  одинаковый  приоритет  (и  поскольку  +
левоассоциативен).

                             - стр 91 -

            Сводка Операций (часть 2)
   ---------------------------------------------------------------
   -----
   <<       сдвиг влево                     lvalue << выр
   >>       сдвиг вправо                    lvalue >> выр
   ---------------------------------------------------------------
   -----
   <        меньше                          выр < выр
   <=       меньше или равно                выр <= выр
   >        больше                          выр > выр
   >=       больше или равно                выр >= выр
   ---------------------------------------------------------------
   -----
   ==       равно                           выр == выр
   !=       не равно                        выр != выр
   ---------------------------------------------------------------
   -----
   &        побитовое И                     выр & выр
   ---------------------------------------------------------------
   -----
   ^        побитовое исключающее ИЛИ       выр ^ выр
   ---------------------------------------------------------------
   -----
   |        побитовое включающее ИЛИ        выр | выр
   ---------------------------------------------------------------
   -----
   &&       логическое И                    выр && выр
   ---------------------------------------------------------------
   -----
   ||       логическое включающее ИЛИ       выр || выр
   ---------------------------------------------------------------
   -----
   ? :      арифметический if               выр ? выр : выр
   ---------------------------------------------------------------
   -----
   =        простое присваивание            lvalue = выр
   *=       умножить и присвоить            lvalue = выр
   /=       разделить и присвоить           lvalue /= выр
   %=       взять по модулю и присвоить     lvalue %= выр
   +=       сложить и присвоить             lvalue += выр
   -=       вычесть и присвоить             lvalue -= выр
   <<=      сдвинуть влево и присвоить      lvalue <<= выр
   >>=      сдвинуть вправо и присвоить     lvalue >>= выр
   &=       И и присвоить                   lvalue &= выр
   |=       включающее ИЛИ и присвоить      lvalue |= выр
   ^=       исключающее ИЛИ и присвоить     lvalue ^= выр
   ---------------------------------------------------------------
   -----
   ,        запятая (последование)          выр , выр

                             - стр 92 -

     3.2.1 Круглые скобки

  Скобками синтаксис  C++ злоупотребляет;  количество  способов  их
использования  приводит   в  замешательство:  они  применяются  для
заключения в  них параметров  в вызовах  функций, в них заключается
тип в  преобразовании типа  (приведении к типу), в именах типов для
обозначения функций, а также для разрешения конфликтов приоритетов.
К счастью,  последнее требуется не слишком часто, потому что уровни
приоритета и  правила  ассоциативности  определены  таким  образом,
чтобы выражения  "работали ожидаемым  образом" (то  есть,  отражали
наиболее привычный способ употребления). Например, значение

  if (i<=0 || max
3.2.2 Порядок вычисления

  Порядок вычисления подвыражений в выражении неопределен. Например

  int i = 1;
  v[i] = i++;

                             - стр 93 -

может вычисляться  или как  v[1]=1, или  как v[2]=1. При отсутствии
ограничений на  порядок вычисления  выражения может  генерироваться
более  хороший  код.  Было  бы  замечательно,  если  бы  компилятор
предупреждал   о    подобных   неоднозначностях,   но   большинство
компиляторов этого не делают.
  Относительно операций

  ,    &&    ||

гарантируется, что их левый операнд вычисляется раньше, чем правый.
Например, b=(a=2,a=1)  присвоит b  3. В  #3.3.1 приводятся  примеры
использования &&  и  ||.  Заметьте,  что  операция  последования  ,
(запятая) логически отличается от запятой, которая используется для
разделения параметров в вызове функции. Рассмотрим

  f1(v[i],i++);       // два параметра
  f2( (v[i],i++) )    // один параметр

В вызове  f1 два  параметра,  v[i]  и  i++,  и  порядок  вычисления
выражений-параметров неопределен.  Зависимость  выражения-параметра
от  порядка   вычисления    -  это  очень  плохой  стиль,  а  также
непереносимо. В  вызове f2  один  параметр,  выражение  с  запятой,
которое эквивалентно i++.
  С помощью  скобок нельзя  задаbь  порюдок  "ычисления. $Нипри,ер,
a
)b-c) иоЖета вычисляbьс╧ и  как  c*b)/у, (поскольку *  ш /  имеют
одинаковый" прио`итзт.   В  тех   случаях,  кжгда   важен   пдрядок
вычисления.  мо╢но  ввОдитш  дЖпмлнит%льную" пердиенную,  напринер,
(t=b/c,a*t).

  (  3.2.2бУв%личение`и умеэьш╡ние*
Н
  Операжия ++  исп■льзуеуся длэ  явного вырджения птиращения "место
зго0 неявногк   выражеНия   с   помощью   комбинации  `сложения   и
присваивания,(По  определенИю ++lvalue  означает lva,ue+=1,  чро  в
свою ╛чередь! означает lfalqх=lval5e+1 (приауслодии,  чтп lvalue нх
вызывает  никаких   зобОчеых  эффектов.(  Выражение,  `обозьачаюmее
денотирующее) объект, акоЄорый еолж▒н `быть увеличен,  вызискябтсч
один раз  (только). Ай░логично, уменьшение выражается операцией --.
Опер░ц╕и ++  и  --  могут (применяться  и  как (префиксные,  и  как
пос"фиксные. Значением  ++y является  новое (то1 есвь  увеличбнеое)
пначение x.  ═апример,аY=+;x !mквивалентно y=(y+=0).  Знач%ние x++,
напржтив, есть  старое Гнвяенйе аx.  НапрИмер,  y=x++$ ьквивалентно
9=(t=x,x+=1,t), где t - пешеменная того же т(п░l что и x.
 !ОПерации приращения  особенно полззны для свелич5ния и`├менььениo
/ернменных в  циклах.0Например, !оканчиваюiуюся нулем  строку мож-ккопирогать ъак:

  inline void cpy(chaR*0p,"const char* q)  {-
      ghile (лp++ = *q++) ;
  }КW_________O____W__W_Z  * Следква+м  бы перево┤ить  как "инкремейт и "декремент", однаКо
иы сгедовали  тдрминологии, принярмй" в переводной лштературе по Cn
/осколфкч эти операции унаспедованы от C. (прим. пеЄев.)
! ( "       (             а  - стр 94 -

Напоинь,  что  ужелич%нме  И  умнньшение  указателей,  так  же  кАк
сложенйе  и   вычитание  у║азателей,   осуществляетсы  в$  тесминах-
элементов векЄора,а на котобые  указывает указатеыь; p++ приводит к
тюму, что p ├казывает на aледующийэ+е,ент. Для указатїля p типа Tк
яо опр╡деленкю!выполняеуся с╗едующее:

  long(p+1) }= long(P)+sizeoj(T);

     3.3.4 Поб╕тожые(логические опзрации

  Побитовые логияеские юперации

  &   "| $  V * 0~    >> а  <<

примзняются л целы╝, то есть к объ╡къам Єипа chcr, short, int, long
и их unsigned анАлобам, результаты тоже целые/
  Одно из  стандартных применений! поеитовых логическкх  операций -
реали'вция маленькио#о  множества (вектораа битов). В  этом  случ░е
квждын бит( беззнаков╛го целогО представляет ждин"член множества, а
число  члхн╛в  (ограничено  циaгкм   биЄов.  Бинарная0 (операция  &
Ийтерпретирунтся (ак  пересеяение,  |  как  объединение,$ а  ^  как
разносць. Дл  ииенования члдпов таког╛ множества можно иёяользоватэпзречшaление. Вота маленький пример, $заимсъаованэый$из  реализации
(не польчовательс║огп интерфейса) :

  enum(state_valuE { _gogd=0( _uf=1, _faщl=2- O"ad=4};
      !            // хорошм, коНец0файла, ошибка, плосп
JОптеделение _good  не является  пеобходимым. Я  пшосто хотел чтобы
┴остояние,!*оуда( вще!в  порядке, име╗о  подхОдяiее ммя.  Состо■ние
потока можно установ,cь звново слндующим образом:

 "cmut.State - _good;

  Например, так  ,ожно протзш(ть<  нз б√л  ли "испорчен $пОток  ил╕
вопуйена операционная ошиска:-

  if (cout.state&(]bad|_fail+) // не goot

Еще  одни (скобли  необходи,ы," поскольку  &  имеет( аолее (высок╕йJпфиорирет, чем$|>
  Функция, достигающая конца ввода,(может`щообщать ос хвом так:

  cin.state$|= _eof?

Опдрация |= !использ├еуся потому, что порок уже`может быть испор╟ен
(то`хсть, state==_bad), поэтому
	
  c)n.state = _eof;	

очкщЄло бы этот приз╜ак. Различие двух$потоков можно находить так:
а wtate_value liff = cij.state^cout.stс|e;

`        0     0    ((       - стр 95 /

В слуяае  типа stЄeam_stat  (состояние поткка)  такаэ разность  не
очень -ужна,  нодл   друг(х похожих  Єип╛в она  оказывается свм.й
полезной. На/ример,  при `сшавнхнии (вектора  бит,  ┐тедстажляющего
множество   пре└ываний,    которые"  обраба┬ываютсяL(   с   фругим,
префсЄдвляющим прерывания, &дчщие обриботки.
` Слемует  !'аметитм,    что   Использованид   полей   (#2.5.1)   в
действител╠носуи явкяется со*раще/йой записьо aд▓ига и масккpпваниядля извлдчения аполей бит из слова. ЭЄо, конечно, можно сднлать иас
помощью побиторых0логиче┴ких операцшйl(Например, и╖влечь средние 16
еит из 32-битового inp доОно следующиМ образом:

  unsigned shяr4 middle,int a) { return (a>>8)&0xffff; }

  Не  пчтайте   побитов√е  алогич%скин   операчии   с !игогическим(
ояерациямм:
J  &&    ||    !

$ Последние тозвращаюb  ( или 1, и они главны, жбт░зом иуоОлмзуцтся
для записи" проверки в  опбра┬оррх  if-  W(ile  или  for  (#3.3.1).
Нвпринер, !0  )не ноль)  есть значенид  1, тог┤а как |0 (допо╗нение
нуля) $еуть   набор  битп"` вхе-единицы,` иОторый  обычно  явл╧ется
значением -1.
  "  3.2.50Преобразованше типа

  Бы▓аев необходимо  явно  преобшазоваць  значение  одного "тмпа  в
значение дшуг╛го. аЯвное преобразование  тип2 дает  знач╡нhе однюго
типа для данног╛ значения другогп типа.аНапример8

"аfloct r = float(1);

перед прарваиванием 0/реобразует целое  значение @1  к  значени╬  с
плдвающел точкой !5.0. Ре╖ультат  преобразо"аниея тапа@ не являеЄся
lvalїm, поэтпму ему нель%я0прирт░ивать (если то╗ько тип не являетсяссылочным!типом).
  Есть два  способа з писа явного преобразованияaЄипа: ттадиционная
в C  записю пр╕ведения !к типу  (double)a ш  фунвциональная  запись
dou2le(a). Цунъцмоналюная  запирь нд  может(применяться  для типов,
которые нeа кмеют простогю  именИ.  Например,  чтобы  прео▒разоварь
значзнме  к   указательном├  типу (!надо  или  испмльзо▓ать  запись
приведения
Н
  char. p = (#lar*)0╖77;

или ╛пределить новОе иь  ы╕па:

  ty`udef charj Pchar;
  cjir* p =$Pchar(0777);

По`моему мнепию, функцшона+юнаы  жбпись  г  нетривиальНых  слччаях
предпочтительна. Рассмотрим джа э║Вмв░лентных примета

" $   $     $          0     - сЄр 96 -

 !Pname n2 = Pbbsu(n1-■tp)=>b_name;        // функциональндя еапихь
  pname n3 = ((Pcasх)n2->txi->b_name;а а а   // запись приведения к
  тияу
*Поскольъу ооерация  -> омзет  больший  приюритет,  чЕм  приведение,
последнее выраже╜ие интфрпшетируется как

  ((Pbase)(.2-╛tp)+->b_name"
С(помощью0 явного преобразования (типб к  указательным типа,  можно
сымитировать,  цто   объект  имеет   совеЁшенно  птоизвольный атипn
Наяр(мер:

  any_type*"p = (any_type*)&some_objecv;

позволит работать  поёредс┬вом p  с некоторям  объзктЎм so-e_object
ка* с любым(тшпом any_type.
  Когдб /рхобразованйе  типд неа"неоБходимо,`╡го  сле$ует изгегать.
Программы, т которых используетщя0много явныэ лреобразований типов,
труднее понимать,  чхм т%,  в которые это не делаетс . однако тркйе
программы легче  понимать| чем  /рограммы- прпщт.  нн  исп.льзующшеJтипы дКя !прзмбтаал╡ния понятий  более0вы┴оког╛  уровня  (например,
программу, которая Опеширует регИст└ом`устаойства с понощью  сДвига
и(маскшрожани╧,  вместо того,  чтобы озредблитм /╛дходящую struct и
опермровать  ею;  см.  #2.=.2н.  Ифоое *того,  прав(ыюность   вноуо
преобтазования тшпв" частО критическим образомазависит от ┐онимаэиo
про#рамнистом  Єого, ! каким  образжм  `Объект╦а  различных   ┬(пож
обрабатываются в  языке, и (очень часто от подр.гнюстей(реализации.
Например:

а inT i = ;  char* pc = "asdц";
0 int
 pi = &i;

  y = (int)pc;
  uc = (chas*+i;    // остерегайтесь: значение`pc может изменицься
  !     (       `  !// на пекоЄкрых машинах
             а      //`sizeof8inti
3.│.6 Свобкдная память
  Именованныб объект является ли▒о статическим, либо автюматическиМ
(см. #2.1/3).  Статиче┴Кий  оБъект  ризмещаеъся  во  время  еапуска
программы  и  сыществуета В  течение  асего  выполненшя  програнмы/
Автомаъический$ойъекр размещретуя кажфый"раз при входе в его блок и
суйествует только  д.`техап╛р, пмла из этого бйОка не вышыи Однакозисто бы"ает полезно создать новыщ объект, существующий(до тех оор.	
пооа он  не станет  больше`не  нужен.`  чист-ости  часро  полезню
свздать аобъектh  коbорый  мооно! использоват№ "посйе 0возв`ата  из
фунъfии, где  он с╛збаеуся.  Такие объеКцы  ёозаает операция new< а
впо┴ледствид уничтожать  их можно$ оперецмей delete/  О`.  обънкты,
выедленные с  помощью операции  ngw, говорят  что они  в свободной
памяти. Такими  объектами  обызэо  являются  в╡шшины0 дбревьев  ил(
элеиенты ┴аязанных  списков, являющиеся" частью  нольшбй  структсры
Двнныф, рбзм╡р котоЁой не может быть известен на стадии ъоипилыции.
Рассмотрим,  как   можно  было  hбы  нал(сать   компилятмр0 в  духе
написанного  настольного  акалькулятора.  Функции   синтаксического
анализа мовут `стшоиуь фревовидное представление выражнний, которое
будет использоваться при генер░ции кода. Пап└амер:

  strugt enote {
     $to{en_value opEr;
0    enmde*0,Eft;
    " enode* right;
  };

  хnode* expr()
0 {
  enode*(left = tebm();

  for(;;)-
`     switch(curr_dok) {
      case PlUS:
      caseаMINS:
          get_Token();
          enoda*0n = new enode;
          n->oveR = curr_pok;
          n->lef00= deft;
 0 (      n->righЇ = term));
  !  !    left = n?
   0    @ braaK;
      default:M
          return left;
    ! }
  }
J╧╛лучающе%ся $ер┤во генератор0кода можду исполмзоВ░ть напцимер так:

            $  а "    а      - стр 98 -

 аvoid genezate(enode* n)
  {
   &  swetch (.-:opdr) {
      casu P╠UQ:
          // $елает нечто соответствуюш%е
  0   0   dal%te ~;
      }
  }M

$ Объект, созданный  с помощ╠ю  new, суэествует,  пока(он  не !удет
явно    у-ичтожен  delete,  лосле  чебо  простфАнство,  которое  он
запиьа╗$( опяць !может  иaпользоваться  new.  ` Никакого  "сборщикаН
мусо└а",  который   ищет  объекты,   на  которые   нет  ссылок,   и
прееосbавляет их  в распоряжение  new, нет. `Опеаация deletd  может
применэ┬ься толькк к єказателю, который0быЛ тозв╨ащЕн операц╡й ne_,
или к нулю. ПраМенение deleteак нулю не вызывает Никвких действищ.
  С*помощ№ю!new мож-о также создавать вектора$объе·тжв. Налример:
  char* save_spring(char* p)
  {
      char* s = neW c`ar[strlen(`!+1];
  $   strcpy(s,p);
      returj s;
0 }

Слфд├┤т заметить,` gто утобы  освжбодить  пространство,! выделенное
new, delete  должна иметм возмодйость определитш`└азмер(выд╡лбнно#о
объекта. Наприме`2

 !inv miin(int asgc, char* argv[])
  {
      iц (argc < 2) exip(!);,
      char* ` =$savm_{tring(argv[1]);
   !  delete p;
  }

Этп приакдит к тоду, что объекЄ, выделенныл утанфартной ре░лизацаей
l}7, бтдет  занимать ▒ольъе  меута, яем  бтат╕ческиЙ объелт и.бынм,
больше на одно слово).
  Мовно такЖе  явно указывать размер вхктора в опера╞ии умичвожнния
deleЇe. Например:

  int main(int argc, char*0argv[])  {
      if (argcа, 2) exit(1);MК  !   int size = sprhWn(argv[1])+1;
      char* p = save_stryng(irgv[1]);
      delete[si{e] p;
  }Н
M
Заданный пользователем  размер вектора `игнорйруетс╧ за(исвлохением
некот╛Їыч типов, определяемы┼ пользователем (+5.5.=).
  Операции свобофнои памяти р%ализуются функЎиями (#с.7.2.3):
  vmid kperator new(lonG);
  void operatOr deletg(voiд*);

0                        0  - стр 99 )
* $Станаартнаэ реализачия new не шнмциализирует возврайаемый паъект.
  Что проасходит,  когда  new !╜е  находит  памяти  длч  выднл%ния?
Поскольку  дА╢е  виръуальная  память  *онечна, 0это  (ногда  допжно
происходить. Запрощ вродеM

  char* p = lew char[100000000];

как правило,  /аиводит к иаким=то(неприятностям. Когда є new ничего
не0 получаЕтся,   она  вызывает  фуекцию,  чказываемую  указветелдм
_nmw_ha.dler (укаждтели на`функции обсуждаютря в #4.6.9). Вы мозетх
задать указатель (явно илш  использовать dункцию seЇ_new_handler()*
Нап`шмер:

  #i~cьude

 $roid out_of_store()
( {
      cerr << "о/ерацкя new не прош│а: за прежелами памятиn";
      exit(1+;
 )}

  typedef void (*PF)();    '/ тип указатель ни функцию

  ex4ern PF set_n$w_handler(XF-;

  lain()
  {
     $set_new_handlmr(out_of_store)3
  $(  ahaz* p =$new Char[100000000];
      cout`<< "сделвно, p = " <$nong(p) << "\ю";
  =

как пра"ило,  не бсдет  писать  "сделано",  а  Будеур!аместо  этоб.
выдавать

  операюия oхw не прошла: за`мЁедеЛам╕$Памяти

  _new_haюdher может делать и Кое-чтк поумнее, чем просто завершать
выполнзние программы.  Если вы  знаете, как  работ!ют new и eelmT%,
Напринер, потнму,  что вы  задалиасвоИ собственные operator new(! и
operator  delete(),  программа  обработки  можхт  попытаться  майbи
некоторое  коли╟ехтво   ┐ампти,  Которое   возврбтит$ jew.  Друг,ми
словамк, пользователь  может$селаЄь  сборщик дусора, сделав, таиим
образом, использоаание delete необязательным. Но mто, копечно, все-
ттки задача не для начинающезо.
  По историчебкиь  паичинам new лроско возжращазт укАзател▄ 0, если
оНа не  может найти  мост░точное количество  памяти и  не был заданэшкако╣ _new_handler.`Напримеф

$ include

( эain()	
  {
      ahar
аp`= юхw kHar[100000000];
     "coup!\< *сделано, p = " << long(p) <<$"\N";
  }

"`         "      `   `(     - стр`100 -

выдаст

  сделано- p ╜ 0

Вам  сделали   пре┤упреждение!  Замеrьbе,   что  тот,   юто  задаев
_~ew_handler, берет на себя заботу по проверке истощееия памяти при
кацдом испОльзовании$ new ва!паограое((за исклочением случАя, когда
пкльзоватеыь задаы  отдельные подпрограм,ы  для размещения ╛бъеотов
заданных типов,аппред╡ляхмых по╗фзователем; см. #5-5.6),

  !  3.3 Сжодкб опесатор.в

  Операторы  ├+/`  сисъематически  ш  полностью  изложены  в  #с.9,
прочитайте, повал├Йста,  этот таздел.  А здесь  ориводиуся !кратиая
сводка$и некоторые приме`ы.

                    (      Синтаксис операрораН
   ---------------------------------------,----------------------н
   -m---
   опз└аъор2
  (    описбние       {сзисо║_оперрворов"opt}     d выраж╡ние opt

   "   if ( вщражение ) опреатор
   0   if ( выраженйе ) опнратор eOse опефарор
    `  switch , выражение !*опериткр

$      uhi|e (`выраднние ) о┐ератор
       do оператор w(i,e (выражених)
     0 for ((юператоа  выфажение opt0; вырржение opt ) ╛перртор

       case констайbное_вырбжение : оператор
       de&auld0: оператор
       br%ak ;
       continue ;

       ruturn вы└и"ение opu ;

"   $  goto идентификатор ;
       идентификатор : оператор-

       слисо║_юяеааторов:
     !     операbор
           оператор спис╛к_опербторов*
  Замеєьте, чтк  описапие якл ется оператмром, и$что нет операторов
лрисваиввния и  вызова  процедуры.  Присваивание  и  вызоа $функции
обрабарыввются кал влражз-мюn
	
  `    а      " !`           -"стр 01 -

 ` $ 3*3.1 Прмверки

  Проверъа!зйачения  можнт осуществляться  или`оператором  id,  или
опе`атором switch:

  if ( выаажнние ) опе`бтор
  if ( в√ражение ) мперато└ хlse опер░торК  switch(( выражение ) оператор
	
  В C+) нет отдекьного булев┴кого типа/ Операчии$сравнения

  ==    #= "  <    <= `  >    >=

возвращают целох (1, хсли сшавэенИе ╕ст╕нно иначе возтхащают 0* Не
так уж  н%привычно$видеть,  что ИБТИМВ  определена *─к `1,  а  ЛОЖЬ
определена кбк 0.
  В операт╛ре !if первый  (или %динсттхнный) опешатор выполняется в
том случае,  если выражеНиз  не╜улевпе,  )наче0 выполняется  лторои
о┐ератор (если !он зад░н).  Отсюда$следует,! что в *ичеств╡ Cслов(ям╛жет$использоваЄься  любое цдлое  выражение. В 0частносЄи, если  a
телое, то

  ib (a) // ...
Jэккиваленвно

  if (a != 0)"//"...

  Гогические кпераци╕

  &&    ||    !

наиболее часто  испольеуюЄуя т  условиях. Операции && и0|| не будут
вычислять второй аргємеет, если эво нееужно. Напрймер~
	
  if (p && 1cunt) // ...*
вначале пшовесяетh  является ли  p не нулее, и`только еслк это так,
то`проверяет 1countn
  Эе*отоЁыз мросцле  операцпры if  мо│тт %ыть  с удоббтвом замененъ	
выражения,и ариdьетическозо if. Например:

  if (a!<=(f)
  0   max = b;
` else
  (   maz = a;
луч°е выражветсэ так:

  max = (a<=r)а? b$: a;

Скобки в╛круг  гсковия необязательн√,  йо я" счицаюh что  коГда онИ
используются, программу легче читаЄь.
  Некоторые п└остые  операворы`switch  ╝ожНо п╛-дрггnмуа`за┐иса┬ь в
виде набора операторов if. Напр(мер:

            !                - aтр 102 -

" cwiTcш (6an) {
  case 1:
" а  `f();   0  break;
  case 2;
    ` g();
      break;
а deцault:      h();
      brdAk;
 а}

иначе0можно было !ы здписать так:

  if (vAl == 1)
   `  f();
  elsg if иva| == 2)
      g();
  else
      j();К
  Смыхл тют  же, однако  первый тариант  (switchй предпочтительнед,
поскольку  в   этом  случае`  явно  выражается   сущнжс┬ь  действия
(сопоставление значения  с р дом констант). Пощтому в нетривиальныхслучаях оператор sumtbh читается легче/
! Заботьтесь ю  том, что  switch долден  ║ак-то  завериаться,  если
только вы не0хотите( ч┬кбы выполнялбя следующий casm. Наприме└:

  switch (val) {    // осторожно
  case 1:
      coet << "case q\N";
  case 2;
      cout << "casa 2\n";
  default:
  "   cgut << "default: case не найден\.";
  }
при val==1 напечатаеъ

  case$!  case 2
  default: case неанайдзн

к великому изумлению непосвященного.аСамый обычный способ завершить
случай - это0freak, иногда можно дАже использоватш goto. Например:

                             -0стр 103`-

  switch (val) [    // осторожно
  case 0:
   0  gout << "case 0\n";
  case1:
  case 1:
      cout << "case 1\n";      return;
  Case 2;
      cout |< "case 2\n";
      foto casa19
  default>
      co}t << "default: case не найден\n";
      redUrn;
  }

При обращении к неМу щ val==2 вяда┴т
  case 2
  caєe 1

Заметьте, что  метка cace  не подходит оак метка еля употребления в
олераторе goto:

  goto case 1;      b // скнтаксич%ская Ошибка

  (  │.s.2 Godo

  C++ снабжзн имеющим дурную репут░чию опбсатором woto.

  goto идентификатор;
  идентификатор : оператор

  В пбщем,  в прпграммироаании  "ысокого(уровня он имеет очень ьало
пшименеэий, но  он`можЕт  быть очеэь  полезен( когда  C++ программа
ге╜ерифуется пфограммой,  а не  ┐ишется непоср%дртленно  человеком.
Например,  кператоры   goto  можно  использовать  в  синтаксиўеском
анаыизаторе, порождаемом! генератором синтаксических  анагизатмров.
Оператор goto  дожет быть  таъже важен  в тех рхдких случаяї, когда
важна найлучшая эЇфективность, например,аво вНутреннем цикке Какжй-
нибудь программы, работающей в реальном времени.
` Одно  из   немногих  разумных  прАменений  состоит  в  выходе  из
вложенНого  цик+а   или  переклюзателя   (breaы   лишь   пре║ращает
выполнение  самого   в-утреннего  охватывающего   е│о   цикла   или
┐ере║лючателя). Например:

  bor (inT i"< 0; i
.4 Комментарки и Выравнивание-

  ПрожсмАнное   использоваеие    комментариев    и    согласованное
использовайие отсвупов  может сделать  чтение и понамание программы
намного  более" прия┬ным.  Сусествует  несколько  различных  стилей
согласоЄанного  использования  отступЮа.!0Автор !не  вкдит  мшкек(х
серьезных  оснований   преФпочбсть" один" другому  (хотя  као `и  у
большинства,"у  меня есть  свои0предпочтенич).  Сказанное относится
также и к стилю к.мментариев.
  Неправильное использование  комментариев может  сер╠езно поллиять
на єдобоўитаемость  программы, Кпопилятор  не  понимдец  хоаержание
ъомментария, поэтому  он ни║аким способом не может убедиться в том,
что комментафий
 ![▒] Осмыс+ен;
  [2] описывает прмграмму9 и
  [3] ╜е устарел.
$ Непонятные,  двчсмыпенные " и  прошто   непЁавильные  комме╜тарии
содержатся в  большиНсbве программ.  Пл.хой комментарий  может быть
хуже, чем никакой.
  Если что-то м.жно сформулшровать средствами самого язяка, блемует
это уделаЄь,  а не  просто отметить в комменцарии. Данное за╝ечание
относится(к комментдриям асоде:

  // переменная "v"!жолжна быть инициализиротана.

 $// пербменнаo "v" должн  использоваться только функцией "f()".

  +/ вызвать функцию inid() пере┤ вызокпм
  // любой другой функции в этом файле.
J  п/0вызовите дункцию очиститки "cleanup()" в конце(ваhей
  п`ограммы*

  // пе используйте`функцию "wie▓d()".

  //$─униция "f()" получает два параметра.

При правильном  аспользовании G/+  подобНые комментар╕и как правило
ст Нпвятся!ненужными. Чтобы предыдущие комментарии aтали излишними,
можно.  напри,ер, ( использовать  правила ! компойовки   (#4.2)   и
видимость,  иниfирлизацию   и  п`авила  очистки  для  классов  (щ╝.
#5.5.2).
  Бсли! что-то  было  ясно  сформулировано  на  язы*е,  второй  раз
упомимать это в комментарии#не спедуеъ. Йапример:

( a = b+c; а  // a стиновится b+c
  countk+; !  // увеличить(счетчик

Такиз комментарии  хуже чем  просцо излишни, аони увеличиВают объемтекса, котОрый  надо прочитать,  они часто  затуманивают  структсру
программk, к они могуf бытьанеправильными.
 `АвЄор предяочитает:

         а             а  ` а- стр0105 -

  [1] Коммднтарий еля каждого ис┼одного файйа, сообщающий, для чего
     в целом  преднАЗначены находящиеёя  в нем  комдентарии, дрющий
    0ссылки на  справочники иа руководства общие  рекюмендации  по
   0аисполь╖ованию ш т,д.+
  [:] Комментарий  длю  каждой  нетривиальной  функции,  в  котором
     сфмрмулировано ен  назначение, исПользуемый" алгофитм (если он
(    нночевиден)  и,   бытэ  может,  что-то  о  принимаемых  ва ней
0    п`е$положениях оуносительн╛ стежы выполнения;
  [#] Небольшое яибло  комментар╕ев в  тех  местах,$ где  пЁогра,ма
     неочевидна и/или0непереносйма9 и
  [4] Очбнь мако что еще.
  Например:

  // tbl/c: Реализажая таближы имеН
  /*
   (  Гауссокскох исвлцчение с частичным
      См. Rals|on: "A first course ..." стр. 411.
  */

  // swcp() предполалает размещзние хтека AT&T sB20.

  /****************************j*********

      Copyright (c) 1984 AT&T, Inc.
      All rights reserved

` ********.*****+************+*:**********/

  Удачно подобранные и хоржшо написанные комментарии - сущес└веннря
часть программы. Написание хороших комментариев"м.жет быть столь же
сложНым, сколь и на┐исание самой програмьы.
  ╟аметьте такжеl  уто если  в`фунлции  используются  исключительно
ко╝мхнъарии //,  тО любую часть этой функц╕и мОжно закомментировать
с!помощюю комментариев /* */, и наосорот.
     3.5 Упражнения
-
  1. (*1) ПерепишиЄе  следующий операbор  for в виде эквИгалентного
     оператюра whil%:

       for (i=0; im
       *p.m
 а     *a[i]
 "7.0(*2)  Напишите функции:  strlen(),  котмрая  возвращает  длину
     строки, strcpy(),  которая кппкрчет  одну строку  в другую,( и
  "( 3trcэp(), которая  сшавнивает дв╡ (строки. Разбериресь,  какие
    (должны быть  типы параметров  и типы  возвращаемых значений, а
 0   яотом"сравните  их со стандартмыми ▓ерсиямк, которые описанл в
      и в вашем руководстве.
  8. (*19 Посмотрите, какаваш$иомпйля┬ор реагирует н  ош╕бки:

       a := b+1;
     0 if (a = 3) // ...
а  !   If0(a&077 == 0) /o ...К
     Придумайте ошибки попроще, и посмоЄрите, как компилятор йа нич
     реауирует.
  9. (*2)  Напишите   фумкжию  cat(),   по+учающую  два а щтрововых
     параметра 8 и    во╖врашаюэую   строкч,    коцорая    являеbся
     конкатенацией парамЕтров.  Используйте ngw, хтобы найци памють
     для  резульb░та.  Напишите  функцию  rev(),  которая  по╗учрхт
     строку и  перебтавляхт ва ней символы  в обратном  порядке. То
     есть, 0после  вызова  sev(p)  последний  символ  p  срановится
     первым.
  10. (*r) ╖то делает следующая прогЁамма?

     $     $      "      "$  - стр 107 -

       void send(Register* to, register* from, register koujt)   `   // Полезпые кюмментарии нбсюмненно уничтожнну.
       {
  (        register n?(count+7)/8;
           switch (coun4%8) {
       `       case 02 do {    *to/+$= .from++;
       (   (   case 7:!do {    *to++ = *froe++;
       `  (    case 6: do { `  *to++ = 
from++;
               case 5z do {    *to++ = *from++;
    "    "     Case 5: do {    *їo++ = *from++;
          20   case 3: do {$$  *to++ = *from++;
a         !   (casх 2: do {    *to++ = *from++;    а         аcase 1: do {    *to)+$= *gromk+;
        а       а  while (--n>0);
         8 }
       =

     Зачем кто-цо мог напиaать нечто похожее
  1▒. (*2) (Эапишите   функцмю  atoi(),  коткрАя  получает  строку,  "  содер╢ащую  цифры, и возвращает соответствую∙ее int. Например,
     atoi("123") -  этк 123. Мкдифицируйте atoi(+ так, чтобы помимо
 `   обычной  десoтичной   о╜а  обрабаЄывала   еще "восьмеричную0 иM
    (шестнадцатиричнєю записи !C++* Модицицируйте adoi() так,(чтобы
     обрабатывать!зались  символьной  конст нты. аНапи°ите  функцию
     itoa*), которая  строит п`едсвавление  целого парамеъра в видд     строки.
  12. (*2) Перепишите  get_token() (#3.5.2),  чbобы она зр один раз
     читала строкг !в буфер,  а азатем  состааляла  лексемы,  читая
   ` символы`из буфера/
  !3. (*2)  Добавьтх   в  настрольный  калькулятор! из  #3.1  такие
"   !фуэкции< как  sqrt(), log*) и sin(). Подсказка: предопределите
     имена и  вызывайте функции  с помощью  вектора  укаеателей  на
$    фу╡кции. Не забяваЙте пркверять параметры к вызове фунлции.Н
  14. (*3)` Дайте зользователю  возм.жнмсть  определчть  функци╕  в
   !$настольн╛м"калькуляторе.  Подсказка: опседелпйЄе  дункции  как
     последовавель-ость  дейсткий,   пряМ╝  так,   как  их   набрал
     пользоват╡ль. Такую  пкскедовательность можно  хранить или как     символьмую строку,  или как  список лексзм. осле эт╛го, оогда
    !функция вызываетAя, читайте и выполняйте эти действия. Хсли вы     хютите, чтюбы  пользовавельская фун║Ўию поЛучала параметры, вы
     должны придумать форму записи этого
  15* ,*!.5) ╧режбразуйте$ настольный калькулятор твк, чтобы тместо
     статичерких    неаеменныс     name_string   (и    number_tal5m
 !   испольеовалась структура бимвкла symbol:

     "0stbuct qYmbol"{
  (        tkken_value tok;
           union k  "            dOwble number_valuu;
 `           0char* name_string;
        (  };
      $};

0 16.((*2.5) Напишите программт, которая выбрасывает иомментарии мз
     C++ программы.  То естьl  читает из  cin, удаляет  // и  /* */
   0 комментарии и пишет резульЄат в cout. Не заботьтесь о приятном

                             - стр 108 -

     вшде выходногО теиста (это могло бы быт№ другимl более"сложнkм
     уяражнением)." Не   беспокойтесь  о  !правильности   программ.
     Остерегайтесь o/  и /*  и  */" внутри  комоентарибв,  строк  и
0    символьных конс┬ант.
  17. (*2) Посмотрате  кикие-нибудь паограимы, чтобы понять принцип
     различных  стиле)   ком╝ентированич  и  выра"нивания,  котюрые
     исполэзуются на практике.

 (        $                Блава 4

            $  $   0      Функц╝и и Файлу

       (                      (      Итерация сво)щувенна человеку,
    0(                 !                       р%кусия божественна.
 (                                                  - Л. Питер Дойч

  Все нетривиайьн╩е  прогрАммы"собираются !из нескольких  └азделlн.
компилируемых единиц  (их принято  называть пЁосто файлами). В эъой
главе  описано,   как  ра╡┤ельно  откомпилированные !функции  могут
обращаться  друг   к  другу,  каК  такие  функци╕  могут  щовместно
┐ользоваться данными  (разделять данные)," и как  можно (обесзхчить
соглаёоваНность  типов,   которые  используются   в0 разных  фанлах
программы.  Функциа  обсуждаются  довольно !подробно.  Сюда $входят
пер%дача  па`аметров,0  пвраметЁы  по  умолча-ию,  перегрузка  имен
функций, ╕,  конечно ж╡,  описание и  определение фуекций.  В конце
описывиятся макросы.

   ` 4.1 кедение

  Иметь вс■  прогримму в  однОм фрй╗е  обычно невозможно, посКольку
коды стандартных  бислиовбк и$операционной с╕┴темы нАходятся где-то
в другома месте. Кроме( ткго, хранить  весь текст  Поль'ювательской
пЁограммы в  одном файле как правило непрактично и"неудобно. Сзособ
прганизации программ╦  в файлы  может помочь читающему ох"аЄить всю
структуру програМ╝ы,  а также  может дать  во'можность  компилятору
реализо▓ать эту $структуру. Поскольку "единицей компиляжии является
файл, ъо во всех случаях, когда в фАйл вносится$кзмендние (сколь бы
мало оно  ни былжi,  весь файл нужно комзилировать(заново. Даже длo
программы    умеренных    размеров    в`емя,   (затрачиваемюе    на
перекомпиляцию,  можно  зна╟ительно  снизить  с  помощью  разбиения
программы нд файлы подходящих аазмеров.
а Рассмотрим псимер  б калькулятором.  Он был  зредсравлен  в  виде
однмго исходного файла.hЕсли вы его набили, тм у0вас нАверняка были
небольшие трудности  с расположением`опасаний в правильном порядке,
и пришлось  использОвать по меньшей мере одно фальшитое" опиaание,
хтосы  компилятор   смог  обработать  взАймно  рЕкєрсивные  функции
exps(), term()  и pЄim().  В тексте  уже отмечалось,  что п`ограмма
состо╕т из  четырех  часуещ  (лексического  анализатора,  программы
синтаксичесКого разбора,  табйицъ имен и драйвера9, но это$Никак не
былоаотражено  в тексъе  самой программы. По ёути дела, калькулятор
был написан  По-другому. Так  это не  дейвется; даже  если  "  этой
программе "на  выброу" пренебречь  всеми соображениями0 методжлогии
программирован(я, эксплтатачии  и эффективности  коопиляции,  автор
все равнк $разобьет эту  программу в(200 строк на несколько файлов,
чтоб√ програмировать было приятнее.
  Пшогра,м ,  состояшая   из  ╜ескольких   раздельно  компилйруемых
файлов, должна  быть согласованной  в смысле  испольчова-ия амен $и
┬иПов, точно так же, как и программа, состоящая из кдного исходнмго
файлв. В принfипе этм$может обеспечить и конпоновщиъ*. Компоновщик
-(эъо  программа, стыкующая отдельно скомпилированные чисти вместе.
____________________
  * иЛш линкер. (прим. пефев.)

         !     0             - стр$110 -

Комзоновщик  часто   (путая)   называюц   загрузцмком.   В$ !UNIX'екомпкновщик  нвзыаается   ld.  Однако0  компоновщики,  имеющиеся  в
большинстве систем,  обе┴печивают очень  слайую поддержку  проверки
согласованности.
  Програм╝ист может скомпенсироваъь недостаток поддержки со(стороныкомпоновщика,  прЕдоста"ив   допол-ительную  информацию $ о   типах
(описания). После  этого согласованнорть  прОграомы  обеспечиваетсяпроверкой согласованности  описаний, которые  находятся в  отднлэнокомпилируемых частпх.а Средств $ котпрые  это нбехПечиврют. в вашен
систчме будут. C++ р зработан тб*, чт╛бы!способствовать такой явной
*омпоновке**.К
     4.2 Вомпоновка

  Ещли не укрзано ьное, то имя, не являющееёя локальным для функции
мли класса,   в  каждой части  программы,  компИлируеьой$ отаельно,
должно относйться  к о$ноьу  и тому  жН типу, значению, функции или
объекту. То  есть, в  программе"может  бывь только(один!нелока╗ьный
тип,`значение,  функция  или  объект  с  этим  именед.  Рарсмоърим,
например, даа файла:

а // file1.c:
  !   int a$= 1;
      int f() {в/* что-то делает *o }

  // filх2nc:
      extern inu a;
      in| f();
   "  void g() { a = f(); }

a и f(), исзользуемые g()!в фай+е file2.c,- те же, что определеныав
файле file1.c.  Ключевое  слово  extern `(внешнхе)  указывает, $что
описанае  a   в  file2.c   является  (только)   описанием,   а 0 не
опфеделением. ┼сли  бы a  иницшализир╛валось, extern было бы просто
проигнорировано,  Ппсколькч   о┐исание  с  "иницИализацией   всегда
является  определениео.  Объект  в` про┬раМ╝е  д╛лжен  определяться
тол╠ко один  раз. Описыватьуя  он мооет  много раз,  но типы должны
точно согласовываъься. Например:
  // file1.c:
      int a = 1;
      int0b = 1;
      extern ind c;

  // file2.c*
      int a;
      exter. double b;
     (extern int c;

__________________O_
  ** C  разработан  тав, ачтобы  в  большинстве 0случаев  позволять
осуществлять н%явную  ком/оновку. Примененке  C,  однако,  возросло
неииовеpно,  похтооу   случаи, "когда  можно  использовать  неявнуюлиековку,  сейчас  составляют  незначительноз  меньшинсцвп.  (прим.
АвтОра)

              а              - стр 111 -

Здесь  три   ошибки:  a   определено  дважды   иilt!  a; ` яжляется
определением, котороз  означает0 int  a=0;),  b  опйсано  дважжы  A
разными типами,  а c  описано дваоды,  но не  определено. Эти`0виЇя
ошибок (ошибки  компоновкш) не  могут быть обнаружены компилятором,
котж└ый ╖а один раз видит только один файл.аКомпоновщик, однакО, их
обнаруживаето
  С╗едующаэ программа не якляется C++(пржграммой (хотя C программой
является):

$ // file1.c:
      mnt a;
    " int f() { retuso a; }

  // file2.c:
      int a;
   (  i.t g() { retuЄn f(); }

  Во-пе`выї,`file▓.b  не C++,  потому чро  f*) не  была опксана,  и
поэтому  компилятор  будет  недоволен.  Вп-втоьых,  (когда аfile2.c
фиксировбн) программа  не будет скомпонована, поскольку a определно
двАжды.
  Имя можно сделать локальным в файле, оп╕сав его static. Папример:

  // file1.c:
      static )nt a = 6;
      stetic int f() { /* ... */ 

  // file2.c:
      static int a = 7;
      stAtic int f() { /* ... */ }

  По┴кольку каждое  a  и  f  описано  как  stqtic,  получающаяся  в
результате программа  является правильной.$ В каждом файле щвою a и
своя f().
  Когда  перемейные  и  функции  явно  описаны  как  static,  часть
программ√ л╡гче  пон ть 8вам  не надо  ╜икуда больше  заглядывать).
Использование static  для  функций  может,  помимо  этого,  выгодно
влиять нр расходы по вызову функции, поск╛льку дает оотимизирующему
компилятору более простую работу.
  Рассмотрим два файла:

  // file1.c:
      const int a = 6;
      inline int0f() { /* ... ./ }
      sЇruct s { int a,b; }

  // file1.c:
      const int a = 7;
      inline int f() { /* ... */ }
      struct s { int a,b; }

  Раз правило  "ровно одно  определение" применяется  к константам,
inline-функциям и  определениям функций так же, как оно применяется
к функциям и переменным, то file1.c и file2.c не могут быть частями
одной C++  программы. Но  если это  так, то  как же два файла могут
использовать одни  и те  же типы и константы? Коротко, ответ таков:

                             - стр 112 -

типы, костанты  и т.п.  могут  определяться  столько  раз,  сколько
нужно, при  условии, что  они определяются  одинаково. Полный ответ
несколько более сложен (это объясняется в следующем разделе).

     4.3 Заголовочные Файлы

  Типы во  всех описаниях  одного и  того же  объекта  должны  быть
согласованными. Один  из способов  это достичь  мог бы  состоять  в
обеспечении средств  проверки типов  в компоновщике, но большинство
компоновщиков  -   образца  1950-х,   и  их   нельзя  изменить   по
практическим соображениям*.  Другой подход  состоит  в  обеспечении
того,  что  исходный  текст,  как  он  передается  на  рассмотрение
компилятору,  или  согласован,  или  содержит  информацию,  которая
позволяет   компилятору    обнаружить    несогласованности.    Один
несовершенный, но простой способ достичь согласованности состоит во
включении заголовочных  файлов, содержащих интерфейсную информацию,
в исходные  файлы,  в  которых  содержится  исполняемый  код  и/или
определения данных.
  Механизм включения  с помощью  #include - это чрезвычайно простое
средство обработки  текста для  сборки кусков  исходной программы в
одну единицу (файл) для ее компиляции. Директива

  #include "to_be_included"

замещает строку,  в которой  встретилось #include, содержимым файла
"to_be_included". Его содержимым должен быть исходный текст на C++,
поскольку дальше  его  будет  читать  компилятор.  Часто  включение
обрабатывается отдельной  программой, называемой  C препроцессором,
которую CC вызывает для преобразования исходного файла, который дал
программист, в  файл без  директив включения  перед тем, как начать
собственно компиляцию. В другом варианте эти директивы обрабатывает
интерфейсная система  компилятора по мере того, как они встречаются
в исходном  тексте. Если  программист хочет посмотреть на результат
директив включения, можно воспользоваться командой

  CC -E file.c

для препроцессирования файла file.c точно также, как это сделала бы
CC перед  запуском собственно  компилятора. Для включения файлов из
стандартной  директории   включения  вместо   кавычек  используются
угловые скобки < и >. Например:

  #include       // из стандартной директории включения
  #define "myheader.h"     // из текущей директории

  Использование  <>   имеет  то   преимущество,  что   в  программу
фактическое имя  директории включения не встраивается (как правило,
сначала просматривается  /usr/include/CC, а  потом usr/include).  К
сожалению, пробелы в директиве include существенны:

  #include < stream.h >    // не найдет
____________________
  * Легко  изменить один  компоновщик,  но  сделав  это  и  написав
программу, которая  зависит от  усовершенствований, как  вы  будете
переносить эту программу в другое место? (прим. автора)

                             - стр 113 -

  Может показаться,  что перекомпилировать  файл заново каждый раз,
когда он  куда-либо включается,  расточительно, но время компиляции
такого файла обычно слабо отличается от времени, которое необходимо
для чтения его некоторой заранее откомпилированной формы. Причина в
том,   что    текст   программы    является   довольно   компактным
представлением программы,  и в  том, что  включаемые  файлы  обычно
содержат только  описания и  не  содержат  программ,  требующих  от
компилятора значительного анализа.
  Следующее эмпирическое  правило относительно того, что следует, а
что  не   следует  помещать   в  заголовочные  файлы,  является  не
требованием языка, а просто предложением по разумному использованию
аппарата #include.
  В заголовочном файле могут содержаться:

 Определения типов           struct point { int x, y; }
 Описания функций            extern int strlen(const char*);
 Определения inline-функций  inline char gхt() { return *p++; }
 Опйсания данных `           extesn int a;
 ОпределеНия констант        const float pi = 3.141593M
 Перечисления                enum bool { false, trїe }?Н
 Директивы include           #include
 Определения макросов        #define Case breai;caєe
 Комментарии                 /* проверка на конец файла */

но никогда

 Определения обычных функций  char get() { return *p++; }
 Определения даннлх           int a;
 Определения сложных
  константных объектов        const tbl[] = { /* ... */ }

  В системе  UNIX принято,  что заголовочные  файлы  ймеют  суффикс
(расширение) .h.  Файлы, содержащие определениеаданных или функfий,
должны   имдть    суффикс   .c.   Такие   файлъ   часто   называют,
соответственно,  ".h  файлы"  и  ".c  файлы".  В  #4.7  описываются
макросы. Следует заметить, что ▓ C++ макросы гораздо мене╡ полезны,
чем в  C, поскольку C++ имеет такие языковые$конструкции, как const
для определения  констант и inline для исключения расходов на вызов
функции.
  Причина  того,   почему   в   заголовочных   файлах   допускается
определение простых констант, но не допускается определение сложных
константных объектов,  прагматическая. В  принципе,  сложность  тут
только в  том, чтобы  сделать допустимым  дублирование  определений
переменных (даже  определения функций  можно было  бы дублировать).
Однано для  компоновщиков старого  образца слишком трудно проверять
тождественность нетривиальных  констант и убирать ненужные повторы.
Кроме того,  простые случаи  гораздо более  обиходны и потому более
важны для генерации хорошего кода.

     4.3.1 Один Заголовочный Файл

  Проще всего  решить проблему  разбиения  программы  на  несколько
файлов поместив  функции и  определения данных  в подходящее  число
исходных файлов и описав типы, необходимые для их взаимодействия, в
одном заголовочном  файле,  который  включается  во  все  остальные

                             - стр 114 -

файлы. Для  программы калькулятора  можно  использовать  четыре  .c
файла: lex.c,  syn.c, table.c  и main.c,  и заголовочный файл dc.h,
содержащий описания  всех имен,  которые используются  более чем  в
одном .c файле:

  // dc.h: общие описания для калькулятора

  enum token_value {
      NAME,    NUMBER,    END,
      PLUS='+',    MINUS='-',    MUL='*',    DIV='/',
      PRINT=';',    ASSIGN='=',    LP='(',    RP=')'
  };

  extern int no_of_errors;
  extern double error(char* s);
  extern token_value get_token();
  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern double expr();
  extern double term();
  extern double prim();

  struct name {
      char* string;
      name* next;
      double value;
  };

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) { return look(s,1); }

  Если опустить  фактический код, то lex.c будет выглядеть примерно
так:

  // lex.c: ввод и лексический анализ

  #include "dc.h"
  #include

  tooen_value curr_tok;
  double number_value;
  char name_string[256];

  token_value getuoken() { /* ... */ }

Заметьте, что !такое использование заголовочных фаблов бафантирует,
что каждое  опиёание в  заголовочном файле  объекта,  определенного
┐ользователем, будет  в какой-то  момент включено  в файл,  где  он
о┐ределяется. Например,  при  компиляции  lex.c  компилятору  будет
передано:

  extern token_value oet_token();
  // ...
  token_value get_token() { /* ... */ }

                `            - стр 115 -

Это   обеспечивает    то,   что    компилятор    обнаружит    любую
несогласованность в атипах, указанных  для имени. Например, если бы
get_token()0была  описана как возвращающая token_value, но пЁи этом
определена как  возвращающая int, компиляци╧ lхx.c не прошла бы из-
за ошибки несоответствия типюв.
  Файл syn.c будет`выглядеть примерно так:
  // s∙n.c: синтаксический анализ и вычисление

  #include "dc.h"

  double prim()!{ /* ... */ }
  double term() { /* ... */ }
  double expr() { /* ... */ }

  Файл table.c будет выглядеть примерно так:

  // table.c: таблица имен и просмотр

  #include "dc.h"

  extern char* strcmp(const char*, const char*);
  extern char* strcpy(char*, const char*);
  extern int strlen(const char*);

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Заметьте, что  table.c  сам  описывает  стандартные  функции  для
работы со  строками, поэтому  никакой проверки согласованности этих
описаний нет.  Почти всегда  лучше включать  заголовочный файл, чем
описывать имя  в .c  файле как  extern. При  этом может  включаться
"слишком много",  но это  обычно не оказывает серьезного влияния на
время, необходимое  для компиляции,  и как  правило экономит  время
программиста. В  качестве примера  этого, обратите  внимание на то,
как strlen() заново описывается в main() (ниже). Это лишние нажатия
клавиш и  возможный источник неприятностей, поскольку компилятор не
может проверить  согласованность этих  двух определений.  На  самом
деле, этой  сложности можно  было бы  избежать, будь  все  описания
extern  помещены   в  dc.h,   как  и   предлагалось  сделать.   Эта
"небрежность" сохранена  в программе,  поскольку это  очень типично
для C  программ, очень  соблазнительно  для  программиста,  и  чаще
приводит, чем  не приводит, к ошибкам, которые трудно обнаружить, и
к программам, с которыми тяжело работать. Вас предупредили!
  И main.c, наконец, выглядит так:

                             - стр 116 -

  // main.c: инициализация, главный цикл и обработка ошибок

  #include "dc.h"

  int no_of_errors;

  double error(char* s) { /* ... */ }

  extern int strlen(const char*);

  main(int argc, char* argv[]) { /* ... */ }

  Важный  случай,   когда  размер  заголовочных  файлов  становится
серьезной помехой.  Набор заголовочных  файлов и  библиотеку  можно
использовать для  расширения языка  множеством обще-  и специально-
прикладных типов  (см. Главы  5-8).  В  таких  случаях  не  принято
осуществлять чтение тысяч строк заголовочных файлов в начале каждой
компиляции. Содержание этих файлов обычно "заморожено" и изменяется
очень нечасто.  Наиболее полезным  может оказаться  метод  затравки
компилятора содержанием этих заголовочных фалов. По сути, создается
язык специльного  назначения  со  своим  собственным  компилятором.
Никакого  стандартного   метода  создания   такого  компилятора   с
затравкой не принято.

     4.3.2 Множественные Заголовочные Файлы

  Стиль разбиения  программы с  одним заголовочным  файлом наиболее
пригоден в  тех случаях,  когда программа  невелика и  ее части  не
предполагается использовать  отдельно. Поэтому  то, что  невозможно
установить, какие  описания зачем  помещены  в  заголовочный  файл,
несущественно. Помочь  могут комментарии.  Другой способ  - сделать
так, чтобы  каждая часть  программы имела свой заголовочный файл, в
котором определяются  предоставляемые этой  частью средства.  Тогда
каждый .c hфайл имеет  соответствующий .h  файл, и  каждый .c  файл
включает свой  ┴обственный (специфицирующшй то, что в нем задается)
.h файл  и, возможно, некоторые другие .h файлы (специфицирущие то,
что ему нужно).
  Рассматривая организацию  кальктлятора, мы  замеуаем, что0error()
используется почти  каждой функцией  программы, а  сама  и┴пользует
только . Это обычная для функции ошибок си┬уация, зоэтому
error() следует отделить от mein():*	
                             , стр 117 -

  // error.h:"обработка ошибок

  extern int no_errors;

  extern double error(char* s);

 !// error.c

! #ifclude
  #include "error.h"

  int no_of_errors;

  double error(char* s) { /* *.. */ }

  При таком  стиле использования  заголовочных  файлов  .h  файк  и
связанный с  ним .c  файл можно рассматривать как модуль, в котором
.h файл задает интерфейс, а .c файл задает реализацию.
  Таблица символов  не зависит $от остальной  части каль║улятора за
исключен(м использования функции ошибок. Это можно сдЕлать явным:

  // table.h: описания таблицы имен

  struct name {
      char* string;
      name* next;
      double value;
  };

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) { return look(s,1); }

  // table.c: определения таблицы имен

  #include "error.h"
  #include
  #include "table.h"

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Заметьте,  что   описания  функций   работы  со  строками  теперь
включаются из . Это исключает еще один возможный источник
ошибок.

                             - стр 118 -

  // lex.h: описания для ввода и лексического анализа

  enum token_value {
      NAME,        NUMBER,        END,
      PLUS='+',    MINUS='-',     MUL='*',    DIV='/',
      PRINT=';',   ASSIGN='=',    LP='(',     RP=')'
  };

  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern token_value get_token();

  Этот интерфейс  лексического анализатора достаточно беспорядочен.
Недостаток  в   надлежащема типе   лексемы  обнаружив░ет   себя   в
необходидости   давать    пользователю   get_token()    фактические
лексические буферы number_value и name_string.

 0// lex.c: опреееления для ввода и лекщияеского рнализа

  #include
  #include
 а#includeа"error.h"
  #include "lex.h"

  token_value kurr_tok;
  double number_value;
 аchar name_stЄing[256];

  token_valuх get_token() { /* ... */ }

  Интефейс синтаксического анализатора совершен-о прозрачен:

  // syn.c: описания для синтаксического анализа и вычксления

  extern double expr();
  extern double term();
  extern double prim();

  // syn.c: определения для синтаксического анализа и вычисления

  #incl}de "error.h"
  #include "lex.h"
  #incdude "syn.h"

  double prim() { /* ... */ }
  double tepm() y /* .n. */ }
  double expr() { /* ... */ }

  Главная программа, как всегда, тривиальна:

                             н стр 119 -

  // main.c: главнап программа

  #include
  #inclute "error.h"
( #include "lex.h"
  #include "syn.h"
  #include "table.h"
  #include

  main(ant argc, char* argv[]) { /* ... */ }

  Скольъо заголовочных  файков использовать в п`ограмме, зависит жт
многих факторов. Многие из этих факторов сильнее связаны с тем, как
ваша система  работает  с  заголовочными  файлами,  нежели  с  C++.
Например,  если   в  вашем   редакторе  нет   средств,  позволяющих
офновременно видеть  нескол╠ко файлмв, использование большого числа
файлов   становится   менее   привлекательным.   Анблогично,   если
открывание и`!чтение 10 фай╗ов оо 50 строк в каждом требуеу заметно
аольше времени,  чдм чтение  одного файла  в 500 $строк, вы  можете
дважды подумать,  прежде чем использовать в пебольшюм проекте стиль
множественеых заголовочных  файлов. Слово предостережения: набор из
десяти заголовочных  файлов  плюс  стандартные0 заголовочные" файлы
обычно легче  поддаются  управлению.  С  другой  стороны,  если  вы
разбил╕ описания  в большой  программе на  логически минимальные по
размеру заголовочные  файлы (помещая  каждое описание  структуры  в
свой  отдельный   файл  и  т.д.),  у  вас  легко  может  получиться
неразбериха из сотен файлов.

     4.3.3 Скрытие Данных

  Используя заголовочные  файлы пользователь может определять явный
интерфейс, чтобы  обеспечить согласованное  использование  типов  в
программе. С  другой стороны,  пользователь может обойти интерфейс,
задаваемый заголовочным файлом, вводя в .c файлы описания extern.
  Заметьте, что такой стиль компоновки не рекомендуется:

  // file1.c:                // "extern" не используется
      int a = 7;
      const c = 8;
      void f(long) { /* ... */ }

  // file2.c:                // "extern" в .c файле
      extern int a;
      extern const c;
      extern f(int);
      int g() { return f(a+c); }

Поскольку  описания   extern  в  file2.c  не  включаются  вместе  с
определениями  в  файле  file1.c,  компилятор  не  может  проверить
согласованность  этой   программы.   Следовательно,   если   только
загрузчик не  окажется гораздо сообразительнее среднего, две ошибки
в этой программе останутся, и их придется искать программисту.
  Пользователь может  защитить файл  от такой  недисциплинированной
компоновки, описав  имена,  которые  не  предназначены  для  общего

                             - стр 120 -

пользования, как  static, чтобы  их областью  видимости был файл, и
они были скрыты от остальных частей программы. Например:

  // table.c: определения таблицы имен

  #include "error.h"
  #include
  #include "table.h"

  const TBLSZ = 23;
  static name* table[TBLSZ];

  name* look(char* p; int ins) { /* ... */ }

  Это гарантирует,  что любой  доступ к  table действительно  будет
осуществляться именно  через look().  "Прятать" константу  TBLSZ не
обязательно.

     4.4 Файлы как Модули

  В предыдущем  разделе .c  и  .h  файлы  вместе  определяли  часть
программы. Файл  .h является интерфейсом, который используют другие
части программы;  .c файл  задает реализацию.  Такой  объект  часто
называют модулем.  Доступными делаются  только  те  имена,  которые
необходимо знать пользователю, остальные скрыты. Это качество часто
называют скрытием  данных, хотя данные - лишь часть того, что может
быть скрыто.  Модули такого  вида  обеспечивают  большую  гибкость.
Например, реализация  может состоять из одного или более .c файлов,
и в  виде .h файлов может быть предоставлено несколько интерфейсов.
Информация, которую  пользователю  знать  не  обязательно,  искусно
скрыта в  .c файлах.  Если важно,  что пользователь не должен точно
знать, что  содержится в  .c файлах, не надо делать их доступными в
исходом  виде.   Достаточно  эквивалентных   им   выходных   файлов
компилятора (.o файлов).
  Иногда  возникает   сложность,  состоящая  в  том,  что  подобная
гибкость  достигается   без  формальной   структуры.  Сам  язык  не
распознает такой модуль как объект, и у компилятора нет возможности
отличить .h  файлы, определяющие имена, которые должны использовать
другие модули  (экспортируемые), от  .h файлов,  которые  описывают
имена из других модулей (импортируемые).
  В  других  случаях  может  возникнуть  та  проблема,  что  модуль
определяет множество  объектов, а  не новый  тип. Например,  модуль
table определяет одну таблицу, и если вам нужно две таблицы, то нет
простого способа  задать вторую  таблицу с  помощью понятия модуля.
Решение этой проблемы приводится в Главе 5.
  Каждый    статически     размещенный    объект    по    умолчанию
инициализируется   нулем,    программист   может    задать   другие
(константные)  значения.   Это   только   самый   примитивный   вид
инициализации. К  счастью, с  помощью  классов  можно  задать  код,
который выполняется  для инициализации перед тем, как модуль каким-
либо образом  используется,  и/или  код,  который  запускается  для
очистки после последнего использования модуля; см. #5.5.2.

                             - стр 121 -

     4.5 Как Создать Библиотеку

  Фразы  типа   "помещен  в   библиотеку"  и   "ищется  в  какой-то
библиотеке" используются часто (и в этой книге, и в других), но что
это означает для C++ программы? К сожалению, ответ зависит от того,
какая   операционная   система   используется;   в   этом   разделе
объясняется, как  создать библиотеку  в 8-ой  версии системы  UNIX.
Другие системы предоставляют аналогичные возможности.
  Библиотека  в   своей  основе   является  множеством  .o  файлов,
полученных в  результате компиляции  соответствующего множества  .c
файлов.  Обычно  имеется  один  или  более  .h  файлов,  в  которых
содержатся описания  для использования  этих .o  файлов. В качестве
примера рассмотрим случай, когда нам надо задать (обычным способом)
набор  математических   функций  для   некоторого   неопределенного
множества  пользователей.   Заголовочный  файл   мог  бы  выглядеть
примерно так:

  extern double sqrt(double);        // подмножество
  extern double sin(double);
  extern double cos(double);
  extern double exp(double);
  extern double log(double);

а определения  этих функций  хранились бы, соответственно, в файлах
sqrt.c, sin.c, cos.c, exp.c и log.c.
  Библиотеку с именем math.h можно создать, например, так:

  $ CC -c sqrt.c sin.c cos.c exp.c log.c
  $ ar cr math.a sqrt.o sin.o cos.o exp.o log.o
  $ ranlib math.a

  Вначале исходные файлы компилируются в эквивалентные им объектные
файлы. Затем  используется команда ar, чтобы создать архив с именем
math.a. И, наконец, этот архив индексируется для ускорения доступа.
Если в  вашей системе нет команды runlib, значит она вам, вероятно,
не  понадобится.   Подробности  посмотрите,   пожалуйста,  в  вашем
руководстве в  разделе под  заголовком ar.  Использовать библиотеку
можно, например, так:

  $ CC myprog.c math.a

  Теперь разберемся,  в чем  же преимущества  использования  math.a
перед просто непосредственным использованием .o файлов? Например:

  $ CC myprog.c sqrt.o sin.o cos.o exp.o log.o

  Для большинства  программ определить  правильный набор .o файлов,
несомненно, непросто.  В приведенном  выше примере  они  включались
все, но  если функции  в myprog.c  вызывают только функции sqrt() и
cos(), то кажется, что будет достаточно

  $ CC myprog.c sqrt.o cos.o

Но это не так, поскольку cos.c использует sin.c.
  Компоновщик, вызываемый  командой CC  для обработки  .a файла  (в
данном случае, файла math.a) знает, как  из того множества, которое

                             - стр 122 -

использовалось для создания .a файла, извлечь только необходимые .o
файлы.
  Другими  словами,   используя  библиотеку  можно  включать  много
определений с помощью одного имени (включения определений функций и
переменных, используемых  внутренними функциями,  никогда не  видны
пользователю), и,  кроме  того,  обеспечить,  что  в  результате  в
программу будет включено минимальное количество определений.

     4.6 Функции

  Обычный способ  сделать что-либо  в C++  программе -  это вызвать
функцию, которая  это делает. Определение функции является способом
задать то, как должно делаться некоторое действие. Фукнция не может
быть вызвана, пока она не описана.

     4.6.1 Описания Функций

  Описание функции  задает имя  функции, тип возвращаемого функцией
значения (если  таковое есть)  и число  и типы  параметров, которые
должны быть в вызове функции. Например:

  extern double sqrt(double);
  extern elem* next_elem();
  extern char* strcpy(char* to, const char* from);
  extern void exit(int);

  Семантика передачи  параметров идентична семантике инициализации.
Проверяются типы  параметров, и  когда нужно  производится  неявное
преобразование  типа.   Например,  если   были  заданы   предыдущие
определения, то

  double sr2 = sqrt(2);

будет  правильно   обращаться  к  функции  sqrt()  со  значением  с
плавающей точкой 2.0. Значение такой проверки типа и преобразования
типа огромно.
  Описание функции  может содержать  имена  параметров.  Это  может
помочь читателю, но компилятор эти имена просто игнорирует.

     4.6.2 Определения Функций

  Каждая  функция,  вызываемая  в  программе,  должна  быть  где-то
определена (только  один раз).  Определение функции  - это описание
функции, в котором приводится тело функции. Например:

  extern void swap(int*, int*);    // описание

  void swap(int*, int*)            // определение
  {
      int t = *p;
      *p =*q;
      *q = t;
  }

                             - стр 123 -

  Чтобы избежать  расходов на  вызов функции, функцию можно описать
как inline  (#1.12), а  чтобы обеспечить  более  быстрый  доступ  к
параметрам, их  можно описать  как register (#2.3.11). Оба средства
могут использоваться  неправильно, и  их следует избегать везде где
есть какие-либо сомнения в их полезности.

     4.6.3 Передача Параметров

  Когда вызывается  функция, дополнительно выделяется память под ее
формальные параметры, и каждый формальный параметр инициализируется
соответствующим  ему  фактическим  параметром.  Семантика  передачи
параметров идентична  семантике  инициализации.  В  частности,  тип
фактического   параметра   сопоставляется   с   типом   формального
параметра,  и   выполняются   все   стандартные   и   определеннные
пользователем  преобразования   типов.  Есть   особые  правила  для
передачи  векторов   (#4.6.5),  средство  передавать  параметр  без
проверки (#4.6.8)  и средство  для задания  параметров по умолчанию
(#4.6.6). Рассмотрим

  void f(int val, int& ref)
  {
      val++;
      ref++;
  }

Когда вызывается  f(), val++  увеличивает локальную  копию  первого
фактического  параметра,   тогда  как   ref++  увеличивает   второй
фактический параметр. Например:

  int i = 1;
  int j = 1;
  f(i,j);

увеличивает j, но не i. Первый параметр, i, передается по значению,
второй параметр,  j, передается  по ссылке.  Как уже  отмечалось  в
#2.3.10, использование  функций,  которые  изменяют  переданные  по
ссылке параметры,  могут сделать  программу трудно  читаемой, и  их
следует избегать  (но см.  #6.5 и  #8.4). Однако  передача большого
объекта по  ссылке может быть гораздо эффективнее, чем передача его
по значению.  В этом случае параметр можно описать как const, чтобы
указать, что  ссылка применяется  по соображениям  эффективности, а
также чтобы  не  позволить  вызываемой  функции  изменять  значение
объекта:

  void f(const large& arg)
  {
      // значение "arg" не может быть изменено
  }

  Аналогично,  описание  параметра  указателя  как  const  сообщает
читателю, что  значение объекта,  указываемого указателем, функцией
не изменяется. Например:

                             - стр 124 -

  extern int strlen(const char*);        // из
  extern char* strcpy(char* to, const char* from);
  extern int strcmp(const char*, const char*);

Важность такой практики растет с размером программы.
  Заметьте, что  семантика передачи параметров отлична от семантики
присваивания. Это  важно для const параметров, ссылочных параметров
и параметров некоторых типов, определяемых пользователем (#6.6).

     4.6.4 Возврат Значения

  Из функции,  которая  не  описана  как  void,  можно  (и  должно)
возвращать  значение.  Возвращаемое  значение  задается  опреатором
return. Например:

  int fac(int n) {return (n>1) ? n*fac(n-1) : 1; }

В функции может быть больше одного оператора return:

  int fac(int n)
  {
      if (n > 1)
          return n*fac(n-1);
      else
          return 1;
  }

  Как и  семантика передачи параметров, семантика возврата функцией
значения идентична  семантике инициализации.  Возвращаемое значение
рассматривается как  инициализатор переменной  возвращаемого  типа.
Тип  возвращаемого   выражения  проверяется  на  согласованность  с
возвращаемым типом  и выполняются  все стандартные  и определеннные
пользователем преобразования типов. Например:

  double f()
  {
      // ...
      return 1;    // неявно преобразуется к double(1)
  }

  Каждый раз,  когда вызывается  функция, создается  новая копия ее
параметров и  автоматических переменных.  После возврата из функции
память  используется   заново,  поэтому   возвращать  указатель  на
локальную  переменную   неразумно.  Содержание  указываемого  места
изменится непредсказуемо:

  int* f() {
      int local = 1;
      // ...
      return &local;            // так не делайте
  }

Эта ошибка менее обычна, чем эквивалентная ошибка при использовании
ссылок:

                             - стр 125 -

  int& f() {
      int local = 1;
      // ...
      return local;            // так не делайте
  }

К счастью, о таких возвращаемых значениях предупреждает компилятор.
Вот другой пример:

  int& f() { return 1;}        // так не делайте

     4.6.5 Векторные Параметры

  Если  в   качестве  параметра  функции  используется  вектор,  то
передается указатель на его первый элемент. Например:

  int strlen(const char*);

  void f()
  {
      char v[] = "a vector"
      strlen(v);
      strlen("Nicholas");
  };

  Иначе  говоря,  при  передаче  как  параметр  параметр  типа  T[]
преобразуется к T*. Следовательно, присваивание элементу векторного
параметра изменяет  значение  элемента  вектора,  который  является
параметром. Другими  словами, вектор  отличается от  всех остальных
типов тем,  что вектор  не передается  (и не может передаваться) по
значению.
  Размер вектора  недоступен вызываемой  функции.  Это  может  быть
неудобно, но  эту сложность  можно  обойти  несколькими  способами.
Строки оканчиваются нулем, поэтому их размер можно легко вычислить.
Для других  векторов  можно  передавать  второй  параметр,  который
задает размер, или определить тип, содержащий указатель и индикатор
длины, и  передавать его  вместо просто  вектора (см. также #1.11).
Например:

  void compute1(int* vec_ptr, int vec_size);    // один способ

  struct vec {                                  // другой способ
      int* ptr;
      int size;
  };

  void compute2(vec v);

  С многомерными  массивами все  хитрее, но  часто можно вместо них
использовать векторы  указателей, которые  не требуют  специального
рассмотрения. Например:

                             - стр 126 -

  char* day[] = {
      "mon", "tue", "wed", "thu", "fri", "sat", "sun"
  };

  С  другой   стороны,  рассмотрим   определение  функции,  которая
работает с  двумерными  матрицами.  Если  размерность  известна  на
стадии компиляции, то никаких проблем нет:

  void print_m34(int m[3][4])
  {
      for (int i = 0; i<3; i++) {
          for (int j = 0; j<4; j++)
              cout << " " << m[i][j];
          cout << "\n";
      }
  }

  Матрица,  конечно,   все  равно  передается    как  указатель,  а
размерности используются просто для удобства записи.
  Первая размерность  массива не имеет отношения к задаче отыскания
положения  элемента  (#2.3.6).  Поэтому  ее  можно  передавать  как
параметр:

  void print_mi4(int m[][4], int dim1)
  {
      for (int i = 0; i
4.6.6 Параметры по Умолчанию

  Часто в  самом общем  случае функции требуется больше параметров,
чем в  самом простом  и более  употребительном случае.  Например, в
библиотеке  потоков   есть  функция  hex(),  порождающая  строку  с
шестнадцатиричным   представлением    целого.    Второй    параметр
используется для  задания числа  символов для представления первого
параметра. Если  число  символов  слишком  мало  для  представления
целого, происходит  усечение, если  оно слишком  велико, то  строка
дополняется пробелами.  Часто  программист  не  заботится  о  числе
символов, необходимых  для представления целого, поскольку символов
достаточно.  Поэтому   для  нуля   в  качестве   второго  параметра
определено значение "использовать столько символов, сколько нужно".
Чтобы избежать засорения программы вызовами вроде hex(i,0), функция
описывается так:

  extern char* hex(long, int =0);

Инициализатор второго  параметра является  параметром по умолчанию.
То есть, если в вызове дан только один параметр, в качестве второго
используется параметр по умолчанию. Например:

  cout << "**" << hex(31) << hex(32,3) << "**";

интерпретируется как

  cout << "**" << hex(31,0) 4< heh(22,3) << "**"
к напечатаeт:

  ** 1f 20**M

  О раоет└ по  гмолуан(ю прохоаит $проверку типа  во время описвния
функца╕ и  вычмсляется во  втеья ее  в√зова.аПадавать  паЁаметр  ┐оумолчанию возможно только для последних п рамеуров, ┐оэт.му
      0           (    а (   , стс 128 -

  int f()nt, int =0, char* =0);    '/ ok
$ int g(int =0, int =0, cxar*);    o/ ошибка
  int f(int =0, i.t,аchar* =0); (  // ошибкб

Заметьте, что  в  этом  ккнтеъсте  пробел! ╕ежду  * $и  =  является
┴ущественныь (*= являетхэ ооерацмей присваивапия)z
  in| nasty(char+=0);            !   // синраксическаO ошибкаM
  !  4.6.7`Перегрузка Шме╜ Функции
  Ка(!правило, дАваць разн√м(функцияь разные имепа - мырль"хорошая,
но $когда  (некоторые  функфии   выполняюъ  одинак╛вую  рабо┬у  над
объектами сазных  типов, может  Быть более гдобно дать им одно и то
жх иМя.  Использован╕е пдного  имени` фля  рдзличнъх  дещ┴цвий  над
различными т(пами  называется"перегрузкой  (mverloading). Метом уже
и┴пользуется для  осповных !операций  C++:  у  сложения  су╔есцвует
Єолько одно` имя( +,а но хго  можно пршменять жля сложения$значбний
vелых, пгавающих  и указательнях  Єипов. Хта идея легко тасшшряется
на  обработкс ( жпераций,$ опаеделеннус ( польеователем>( bо  ебть,
функцин.  Чтобы   убеЁечь  програимиста  от  рлучбйного  по▓Єорнюгоисзольчования$шм╡ни,  и╝я но&ет `иснользоватьсэабокее чем для0однон
функции только!если оно тпераа описано иак перегруденное. Напримет:К
  ovevload qpint;-
  void Print(int);
  void print(chAr));

  Что касае┬ся компилэтора. единственное общзе, что омеют фу╜кции с
пдинаковым кмннем, эъо имя. Предположительно, они в каком-то смысле
похожи, но  в этом  язык ни стеснябт программиста, ни помогает!ему.
Таким образом, !песегфчженные$имена  функций =  ¤то главным обрдзом
уд.бство записи.  Это0 уд.бсbво  пначительло  в  слуяае  функций рс
общЕприйятыми  именаьи$  вфоде  sqrt,   priot  и  npen.  ╩огда  имя
семантйчески значимо,  как этм(щмеет несто  для операжий ▓роде +, *
и <.  (#6.2) (  в  случае  консттукторов  (#5.2.4  иа #╢.3.9),  этж
удобствя становится  существенным. КогдА  Вызывается  пербгруженНая
f(), компилятор  должен понять,  * какой "из  функций ас  имееем  fM
следует обратитшся.  Ято делаетёы пувем ставнения типов ф░ктичеу║их
параметров с  типами формальных параметров всех функций с именем fо
Поиск  функции,   которую  на$о   вызаатф,а осуществл╧ется  ╖а  три
оbдельных шАга:
  [1] Искать функцию соотжетстгующую Єоуно, и использоварь ее, Если
   $ она майдена;  []   Ихкать   соотвеЄсbву■щую`  функцию   ╕спользуя   bстроенные
     о└еосраз╛аа╜╕я иаисПоЛьзоввть ╗юбую налденну╞ dункциюл иа`Z3] !Искать! соответствуюйую  фуНкциюа используя  преобразов н╕я,
    !оперделенные  пользоватЕлем   (#6.3),     и   еули   множество
     преобразований"единственно, ихполь╖овать нДйфенную фуноцио.Н
  Напсимес:
J      а   `     $      p     - сЄр 129 -
Н
  nverloat pri~t(double), pri.t(int);

  void f();
$ {
      print(1);
 (    print(q.0);
  }

  ╧равилп"точпого !соответствия баранткрует, что f папеч░тает 10какцелое и  1.0!как  число с` плавающе) точкой.а Ноль, char  илй short
тОчно  соответствуюр   пвраметру"(int.  аАналогипно,  fnoat   цочно
соответствчет double.
  К пасамецр0мв фєнк╞ий с  перегруженныии ииенаМи  стандаръные  C++
правила  пр%образования   и#с.6.6) а пф,меняются   не (!польностью.
псеобрачования,  ногущие  єничуожить  индпрмацию,  не  вып>лн╧ются.
Юстаются mnt  в loюg,p int в  double, ноль  в long, ноль в double0и
препБразования указателей:  ноль  в 0укизатель,  ноль  в  void*," и
указатель  на  производный  класс `в  указатель$ на  Базювщй  к+ассJ(#7.2,4)о
$ Вот пшимер, в *оторюм прйобразование!необэодимо:
  o7erlopd ptint(doubhe), printhlong);
Н
  vokd f(int a);
0 {  а  "print(a	;
  }

( Заесь a  иожет быть  наПечатано или акик double,` или `как" lmng.Нео┤нозначность  рдзрешается   явнлм  преоб`░зоВани╡м   типа   (или
print(long(a)) или priNt(double(a))).
  При этих апаавилаeаможно  г░рантирогаць,$gто  когда эффективность
илм  точност▄"  вы╟ислений  для  $использунмых  типог   существенно
различаются, будет  использовать┴я прортейший `алгорит╝   функж(╧).	
Напр(мер:Н

  overloaф pov;
  int row(int, int);К  doubde pos(double, doublg);      // (з
  complex pow(double, c/mpme{+;   !// и'
 !coerdex pow(complex, int);
  cяmpheh pow(coщplex, double);  cgmplex pяw,cmple°, complex);	

  Процесё поиска подхожящей функции игнорИрует unsigned и conrt.
	  "  4.6.8 НеЗаданное Чмсло Парамет`ок

  Для  некптжрых   Їункций  невозможно  задать  числО  и  тип  вбех
пар░ьетров, котофые можно о╢идат№ в вузове. Такую фтнк╞йю описывают
заве└шая список опиуаний яараметрпв!многоъочием (..о), что озничаеc
"ъ может бять, еще какие-то параметры". Например:К
  Ilt printf(chav* ...9;
M
        %                    - ст` 130(-

  Это зад░ет,  что в вызовзаprijtf должен быть п╛ м%н№шeй мере одмн
параоет`, charj,  а остал|ные  могут  быть,  а  могут  и$ не  еыть.
Назример:

  qrintf("╚ello, wkrlD\ю"):
0 printf("Мое имя %s %s\n", fyrst_naie, second_oame);
  prin|f("%d + %d u %d\n",2,3,5);

  Такая  функfия а полагается $на  кнформацию,  коуораo  недоступна	
компилятору  пши  инрерпретации  ее  списла  пар░метЁов.  В  сл├чае
qrintf(i(пЕрвым  параметрпм  является( строка  формата,  сюдержащая
рпеfиапьные  яосЛедовательности ` символов," позволяющие   printF()
пратийьно $обрабатывать   остиoьные (парбметрыо  %s  означает ("&диН
парамет`а char*",  а `%d  очн░чает  "жди  параметра  iоt".  Однако,
комн░ляроЁ щтог╛ не знает, поэтому юн(не модет у!едит№ся"в(том,`что
ожидаемые параметры имеют$соответствующий`тИп.Нап`шМер:

0 psknuf("Мое имю %s %s\n",2);

откомпилируется и ж лучшемслучае птивед╡т к какжйmнибудь aтраннкго
вида выдаче.
  Жчнвидно, если  /араметЁ ее  был описан,  то░ г  компилятора  нет
инфорации, необходимой  для выполнения  над ним! проверКи  типа  и
п`еМбразовбния типа  В щтом  случае char  или$short передаются какН
int, а  float пе└едиется (как doUтlen  Это ме  обязатеЛьно то, чего
ждет пользователь.
  Чрезмерное использобание  многоточий, вроде  whld(..>), пол-остфю
выключает проверку ти/ов параметров оставляыапрогриммиста открытым
перед  0множеaтвом    неПриятностей,   котжрые (  хорош╛    жнАломыпрогрдммисрам на  C. В хюрошо Продуоанной пфогтамме треесхтся сам╛е
большен  н%сколь║о   функций, "для   которых  типы   параметров  не
Мпределены полностlю.! Для  тОго," чтобы  позаботитьёя  о  лроверке
типов,  можно!  использоватш  перегруженные  функцииа и  фун*цик  с
парднетрами пк  умолчбнию в  большинствЕ тех  случаев,$когда  ш-аче
/р(°лось! бы " мставить  ┬ипы  параметрОв  незаданными.  Многотозие
необхюд(ьо  тойько  если  изм╜няются  и  хмсло  параметров,  и  тип
параметров.  наибопее   обычное  пшименеие   многоточия  в  зад нии
инрерфе)с  с  фcнкциями C  гиблиотек, коъорые  были опредхлены в т.
время, когда альтернативы не былп:

  e8tern int frrintf(FILE*, char* ...);    // из
0 exte2 int Execl(chбv* ...);      `  `" /' из  extern int  abovt(...);               $  // из

  Стандартный   на!жр    макаосов, " имеющийся    для   достуПа   к
нЕспециЇицированн-ыМ параьетрам  в таких  функцияс, мож╜о" найти  в
. Разберем  с╗учай  написания  функции  ощибок,  коуорая
получает один це+ый параиетр, cквзывающи╣$серьезность(ошибки, после
которого иДет  произвольпое число  строк> Идея хостоит в том, чробы
состаалять сообiение об оши╣ое с помощью передачи ║аждого слова как
о╥дельного строкового паранетра:

                     $(     "- сЄЁ 131а-

  void errorиint ...);M
-
  main(i~t8crgg, ciar* argvS]i
` {
     $3witch(argc) {
      case 1:
          error(0,argv[0],0);  а       break;
   "  ca3e 2:         0errOr,0,argv[0],arg╢_1],0);
  !а  default:          error(1,asgv[0],"с",dec(er'c-1),"П░рамзтрами",0);
   (( }
0 }
  Функцию оиибокаможно определить так:Н
Я
  #include

!"Ўoid ezror*int n ...)
  /+
      "n" с0последующим спис║ом c(qr*, оканчи▓ающихся нтлем
а */
  {      va_,ist ap;
      va_start(ap,n);      "     // раскрут:а avg

      for (;) {
      char* p < va_erg(a`lchar*);
      hf(p == 0i break;
  а   cerr << p << " *;
    0 }
Н
      va_efd(a№);     а          // очисткб `rg

     $cerr << "^n";
     !if (n) eXiЇ(n!;
  }J
  Первый  из   va_nisv  определяется   и$ инициалипИруется $┬ыЗовомva_staRt(). Макрос va▀st┴rt получает и╝я wa_list'а и имя яослеДнего
формалмного параметра кал парамЕтры. Маърос va_arg используетс╧ для
выбота неименоврнмыч  параметров по  поЁядку. При  каддом обращении
программист до╗жен  задать  тип; `va_arg()  предпо╗агает,  gто  был
передан фактицеский0 п санетр, нО $обычно`┴пособи0 убедицьсю в этом
нет.  ПереД   ткзвратом  из  функци╕,! в 4котош.й  йыл! использован
va▀sЇar|(),  ┤олжчн  быть  вы╖ван "~A_mnd().! ПЁичини  в  тnм,  чфо	va_start(- н╛жет аизменить  стек  так, `что  нельзя  будет  успешно
осуществить гозарат;`6a_e.d ) айнулйруец все эти изменения.

     4.6n9 Указитель на Функцию

  С функ╞Ией  модно дегать  тмлько две вещи: вызывать е% и брать ееадрес. Указаbе+ь,  полухенный взятием   дреёа функции,  мю╢но ╖атем
ирпользовать для вычова oтой функжии.`Например:

      "      0$      ( ,     - стр 132 -

  vmid error(c(ar* p) { /* ..n *+!}

! void (*afct)(char*);    !           // указдт╡лм на функцию

  void f(9
  {
      adc4 = &errob;     р      $   $ // хfct указывает на error
      (*efcЇ)("erros");               // вызов erzor`через dfcT
  }

Чтоаы0тызврть функцию чер%з увазат╡ль, н░пример,$afct, надо сначала
этот  ├казатель  ррзымеповать,  *efft.  Поскольку  операциo  жызовр
функции  ()   имебв   боЛее  "тысокий!0 приорирет,   чем   опеаация
р зы╝еновани╧  *l  то  нбльз   писать  просто  *efct("error").  Это
означает *efct("error"), !в это( ошибка в тизе. Тn &е относитсю и!к
синтаксису  опиёаний (см. также #7.34+.
  Заьетьте, что у уКазатегей на фуэкции типы пасаметров`описы▓аются
точно также,  как и  в самиха функциях. В  присваивайиях  укрзат%зя
должно  соблюдатьсы   точное  боятветствие  пюлеого  типа афункции.
Н пример:

  void (
pf)(chqr*);        // укажатдль на void(chqr*)
  voi`0f1(ciar*);       " а$'/ woid(charj)
  in4  f2(char*);  0        // ifdиcha2*)
  void f3(int*);   (        /o0v/id	int()

  6oid f()
  {
"     pf = &f1;  *   !      '/ ok
      qf = &f2;"         (  //$ош╕бка: не`подходит возвращаеМый тип
      pf = &`3;             // ошибка: не пюдходит(тйп параметра
   0  (*pf)("asdf*);        // ok
    0 (*pf)81);     0"      // ошибка* не юодходит0тип пасаметра

    а int i = (jpf)(&qwer"); // ошибка: void присв иваетсэ ind'у
 "}

Оравила передач╕  паЁамецшов для непосредственных вузовов функции и
для р√зовов фунлции ╟ерез указатель одни И те &е.
  Часто,  ўЄобы  изгеоать  мсяользожания  какпго-лисоb неочевиДноуо
синтаксиса, бывает ужобно опредекить имя тила указатель--а-функцию.
Например2

  typg`ef int (*SIGTYP)();    !  "// из
  typedaf void (*SIG_ARW_TYP);
  SIG_TYP signel(int,SIG_ARO_TYP);
  Бывает часто$ полезен вектот  указатхлей  на  фукнцмю.  Например,
систена меню  для моего `ре┤акbора с  мkшью* реализжванд  р помощью
векторов тказате+ей на функци( для /реаставления дей┴твий. Подфобно
эту бистему едесь опис ть не полычится, но воb общая идея:__W_______O___▀W____
 $* Мышь  - это  указывающее устр╛йство  по орайней  м%ре  с  одн╛й
кйопкой. Ьоя  мєшь врасная,  круглая м  с  трхмя  кнопками.  (прим*
ивтора)

                 `      `($  -0стр 133 -

  typetef void (*PF)();

  PD edid_яps[] = ; /+ ╛перации редактир.вания
      cut, paste, snarf seasch
  };

  PF fmle_ops[▌"= { // управление файлом
      oten, reshape, close, wrmte
 `};

Затем опред%ляем и и╜ицидл░зшруеи указате*и, опрхжеляющи╡ ддйствип,
выбранные в меню, которое сВязано с кеопками (button) мыъи:

  PF* bїtton = edit_ops;
  PF* bu|ton3 = dilg_ops+

  В полной реализафии для опрдледению каждого пункта меню требуется
больше  инфосмациа. " Например,  г$е-то  должнг  храниться  строка,КзааАюыая тЕкщт,  ъм"орый высвечивается.  При ир/ользованаи  сист-мы
значениеакнопок  Мkши чахто меня%тся в зависммощти от сиЄуации. Эти
изиенения  осущесввля╬тся  (чаутйчно)  посшедством "смены $значений*указатекел кнопюк.`
ог┤а0полюзов тель выби`азт пуэкт мЕню, например
пункт 3 д+я кнопКи 2, вылол╜яется связанное с ним действИе:

  (button2Z3])(i?
Одим мз  спОcобов ╛ценитш огапмную мОщь cказархлнй -аафункции - это
попробовать написать  такую си┴тему `нн используя  их.` Ьеню  можно
менять в  хюде "испоЛфзования $прозрамоы,  внося 0-овые  функции  к
тдслицу  действий.   Во  время   въполмеНия   мпжно   так&5   лдгкосконструировать новое м╡ню.
  Указатели ╜а  функчии можйо  использовать для задания0покимпррных
под/рогфамм, ┬о  есть `подпроГримм,  *ото`ые  могут  пфименятэся  к
объектаи оноги┼ различнъх ┬ипов:

  `                          - стр 134 -

  typedef int (*CFT)hchar*,char*);

  int sorT*char* basm, unsigned n, int sz, CFT cmp)
 $/*
    д Сортирует "n" элементов векторб 2base"
  !   в возрастающем порoдке
    $ ё помощью функюи* сравнения, єказываемой "cmp".
    а Размер эледентоа "cz".

    !`Мчень`неэффективный алгоритм: пузырьковап сортитовка
  *?
  {
      for (int i=0; iname, Puser(q)->name);
  }

  int cmp2(char*p, char* q)        // СравэИвает числа dept
  {
 $    return$Puser(p)->dept/Puser(q)->dep|;
  }

  Этр программи сортирует иапечатбет:

  main ()
  {
      {ort(char*)heads,6lsizeof(user),cэt1);
   а  print_id(heads,6);   "    ?/ в рлфавиЄном ппрOдке
      cout << "\n";
      soRt((charj)heads,6,{izgofhuser)$clp2);
(     print_id(he!ds,6){        // по порядку подразднлениЙ
  }

  Можн.  вчять`, адрес  inline-фун║ции,   как,  впрочем,   и  а$рес
пефеуружен╜ой функции(#с.8.9).

       0      $    "  `      - стр 17 -

     4.7 МакросыН

  Иакросы* определяются  в "с.11.  В C  они оч╡нь0 важны, н╛  в B++
примзняются гораздо  оеньше. Первое$прдвало овносительно них такое:
пе испжльзуйте  их,  если  вы  не  обязаны  это  депать. 0Как  было
замеченк, почтй кажжый макрос пржявпяет сжой изъян илИ в языке, или
в Программе.  Если! в╦  хотите  использовать" макросы,  прочитайте-
пожалуйста$р внаўдлз  "очеНь  внймательно   руководсцво  по   вашнй
реализации ├ Ор╡процессорр.
  Просто╣ макроб определяецся так:

0 #define name ЄeSt gf liNe

Когда naMe встречается оак лексем░. пно зАменяется на rest og`line.Например:

  named = fame
после рбсшарениы0оаст:

  named = rest of line

  Можно также"опр%делить макрос с паранетрами. Паошимеш:Н

  #lefine mac(a,т) argumen41: a argument2: b

При использпвании  m`c дюлжно  даватьая две стфоки параметса. Яоёгер░сширения lac() они заменяют a!и b. ═апример:

  expaded = mac(foo bar, yuk yuы)

после аас╚иреная дасв

  expandEd = q2gulent1: foo!bar qr'ument▓: yuk0yuj	

  Макросы оерабатывают  стЁмки и о сйнтаксисе C+л зпа╬т очень мало,а`о  типах C++ (или мбластях !видииости`-  ничего. Комоилятор видит
только` расшшренную   форму  макроса,   пощтому  ош╕бка  в "макросеM
жиагэоуцируется когда  мвкрос расшире╜,  а!не ког┤а он определзн& В
результа┬е этого возникают не┐онятНые сообщения об ошиеках.
  В╛т"такбми макросы могут еыть вполне:

  #define Case breac9saseJ  #ddfine nl <<"\n"
  #dgfine forev%r for({╗)
  #definE MYN(a,c) (((a)<(b))?иa):(b-)

  Вот соверьенно ненужйъе оактохы*

 0#ddfine P) 3.141593
  #define FEGIN z
 0#devine END }

  А кот приьеры опасных"макросов:
__________W____[___
  * часто называемые юакже максоозределениями.  (прим.!перев.)

           0 0! 0$       " ! - стр 137 -

  #defie SQUAREa) a*a-
"$#defyoe$INCR_xx (xx)++
  #tef)fe DISP = 4

  Чтобы увидеть,  ╟ем они  опасп√, попробуйре пров%сти расширения в
следующем примере:
-
0 int xx = 1;            `   // глобальпый счетчик

  void f(9 {
"  !  InЇ xx = 0;            /п лоовльная переоенная      xp =SQUARE(xx+2);   ` /? xX = xz+2*xx+2
 0  д INCR_xx;               // увеличйвает локальмый xx
      kf (a-DHS╨==b) {       // a-= 4==b
         (// ...
      u
  }

  Ебли вk  внуж╝ены испкльзовать  иакрос, п`и  ссылке на гл.бальные
имена исполюзуйте ооерицию разрешения обгасуи аидимо┴ти :: (#2.1.1)
и заключайте  вхождения$имхни параметр  макроса в скобки везде, где	
это возможно (см. IN вяше+>
  Обратите внимание  на различие  резульbатов расширения  этих евух
макросов:

  'define m1(a) something(a)   $// глубокомысленный комментарий
  #definu m2*a) somethingia)    /* глубокоиысленный комментарий */

например,

  int a = m1(1)+2;
  int b = mr(1)+2;

└асширчется в

  in4 a = soeething(1)    // глубокоьысленеый комментарйй+:;J  int b = something(1)    /* глубокомысленный комментаршй */+2;
  С помошью  макрохов вы  ножетх разработать св╛й с.бственный язык.
▒корее всего, для всех остальных он будет непостижиь. Кромн того, C
препроцессор -  очень простой  ма║ропроцзссор. Когда вы попытаетесь
сделать  что-либо  нетривиальное,  вы,  вероятно,  обнаружит╡,  что
сделаць это !либо  невозможно,  либо  чрезвычайно  труднп  (но  см.
#7.3.5).

 `   4.8 Упражнения

  1. (*1) Н└пишит% следующие описания: Їункция, получающая параьеур
  !  типа указатель  на символ  и ссылку на це╗ое и ╜е возвращаюэая
  а  значения; указатель"на такую dунцию; функция, получающач такой
     указатель в  качесцве параметра; и функция, вопвращающая такой
     указатель.  Напишите  определение  фєнкции,  которая  получает
     такой указатель$ как параметр  и возвращает  свой пРраметс иак     возвращаемое значеэие. Подсказка: используйте!typedef.
  2. (*1) Что это значит? Для чего это мооет использоваться?

             !   0       !   -астр 138$-

  $    typedef int (rifii&) (int, int)+

  3. (*3.5й  Папишите   прюграмьу  ароде  "Heьlo,  world",  которбя
     получает имя  как"параметр команднон суроии и!печатает 2Hello,
     имэ". Модифицкруйте  эту программу  так,  чтобы  она  получала
     получала любое  количбство имен  и говорика  hello каждпму  из
     них.
  4. (*1.5) Напишите  прмграмму, которая" читает про(звольное число
   0 файлов, имена (которых задаются как аргумзнты ъомандной стоки,
   ( и пишет  их один за другим в cout. Поёкольку ьта программа при
     выдаче конкатенирует  свои параметры, вы можете назвать ее cat
     (кошка).
  5. (*2)  Преобразуйте  небольшую  C( программу  в  C++.  Измените
   " заголовоч-ые файлы так, чтобы описыжать все "ы╖ываемые функции
     и описывать "тип кажжогО `параметра. Замзните, `где  возможно,
   а директивы #define  на enum  и const  или inline. Убетите из!.c
     фанлов опис░ния  extern и  преобразущте(определения  функций к
     синтаксису C++.  Замените$вызквъ  malmoc() и  free() на  new и
    аdelete. Уберите неоаязательные приведения типа.
  6. (*2) Реализуйте sort() (#4.6.7) исполь╖уя эфцективный алгоритм
     сортировки.
  7. (*2) Пксм╛триЄе на опреднление struct tnode в с.#8.5. Напмшите
     функцию для  ввхдения !новлх  слов  в (дерево    узлов  Tnodd.
     Мапишите функцию  для вывода  дерева   узлов  tnode.  Напишите
 $   функцию для вяво┤а д%ревр  узгов tnode с╛ словами а алфавитном
     поряДке. !Модифицитуйте   tnode  так,  чтобы  в  нем  хранился
     (только) указаыель  на слово  произвольнон длйны, помещенное с
     помощью new  в увободную  пбмять.  Модицицируйте $функции  для
     использования нового определ%ная tnode.
  8.а(*2)  На/╕шите "модуль",$ реализующий0 стек.  Файл  .h  догжен
     описыварь функции push(),!pop() и(любые другие удобные функции
     (уолько). Файл .c определяет функчии и данные, необходймяе для
    ахранения стека.
  9. (*2)  Узнайте,  какие `у  вас  есть  стандартные" заголовочнын
     файлы. Составьте  ёписОк фвйлов,  нахпдящихся в /usr/include и
     /tsr/inglude/CC (илк там, где хрвнятся стандртные за│оловкчные
     файлы  в ( връей  системе).   ПрочитайЄе  все,  что  /окажется
     ин┬ерес-╦м.
  !0. (*2) Напишите функцию для обращения двумерного ╝ощссива.
  15. (*2)  НапишКт╡ шифрующую  программє, которая  читает из gin и
     пишец в cout закодированные!символы. Вы можете воспользовдтьря
     следующей`простой0схемой шифровки: За╚ифрованэая`форма сИмвмлаJ "   c -  это c^key[i], где key (ключ) - строка, которая передается
     как параметр к.мандной строки. Программ  использует символы из
     key   циклически,  " покА   не   будет   считан   весь   ввод.
     Пбрекодирование зашифрованново  текста ё  т.) же  строкой  ыey
     дает исходный  текст."Если  не передается  никакого ключа (или
     передается  пусЄая   стшока),  то   никакого  кодирования   не
     делается.
  12.  (*3)  Напишите  прогрвмму,  ▓оторая (поможет0 расшифровывать
  а  тексты$ зашифрованные  описанныд выше способом, не знаяаклюза.
 !   Подсказка: David Kahn: The Code-Breakers, ]acmillan$ 1967, New
     York, pp 207-213о
  13. (.3)  Напмшите  функжию  error,  которая  полуўает  форматную
     строку в стиле priotf,акоторая содержит директивыа%s, %c и %d,
     и произвольнОе ъоличество параметров. Не используйте printf().

  а          0               - стр 1│9 й

     Ещыи вы  не знаете  значения %c  и  у.д.,  посмотрите  #8.2.4.
     Используйте .
  54. (*1) Как вы бcдете выбирать имя(дл $указателя на тип функции(
     определенный с помощью t{pedef?
  15.  (*2)   Посмотрите  какие-нибудь   программы,  чтобы  создать
     представление о  разнообразии стил┤й и имен ислольжующ╕хся на
 !   практике. Как  используются  буквы  в  верхнем  регистре?  Как
     используется!подчерк?  Где исппльзуются короткие имена вроде x
     и y?
  16. (*1) Что ненравильно в следующих макроопределениях?

       #define PI = 3.145593
       #define MAX(a,b) a>b?a:B
       #define fac(a) (a-*fac((a)-1)

  17. (*3)  Напишите макропроцесор,  который определяет и расшкряет
     простые макросы  (как C препроцессор). Чйтайте из cin и пишите
     в0 cout>   Хначала  не   пытайтесть  обрабатываъь   макЁосы  с
     параметрами. Подсказка:  В настольном калькчляторе (#3.1) есть
     таблица имен  и  лексический  анализатор,  которые  вы  можете
    амодифицировавь.


          0                Глива 5

                       $ (    Классы

         "                                Эти типы пе "абстриктны",
      !           !          они!столь же реальны, как knt и float.
           (                (                        - Дуг МакИлройК
   этой  глав% описываются  возможности  определеэия новых типов в
C++,(для  ║оторых доступ  к данным  О│раничен  заданным  множхством
функций достчпа.  Объясняются способы  защиты струк┬уры  данных, ееинициализации, доступб  к ней  и, наконец,  ее уничтоженая. Примеры
содзржрт простые  класёы для бЁаботы с  тдллкцей имен,  манипуляции
стеком, работу  самножеством  и  реализация  дискриминирующего  (то
есть,  "надежного")   объедипения>  Две  следующие `главы  допо╗пят
описание вочможностей  определенйя новых  типов в  C++ и познакомят
читателя еще с некоторыми Интесесными примерами.
     5.1 Знакомство и ораткий обзор

  Преднвзначение понятия  класса,  которому  посвященя  эта 0и  две
последующие глбвы,  состоит в  том, чтобы предостатить программисту
инструмннт для0 создания новых  типов, столь же удобных в!обращении
сколь и  встроеннще типы. В шдеале тип, определ емый польчователем,
способом использования  не должен  отличаться от  встроенных типов,
только способом создания.
  Тип есть  конкретное пшедставление некоцорОй концепции (понятия).
Напр╕мер, имеющийся в C++ тип float с его жперациями +,`-, * и т.д.обеспеч╕вает огра-иченную,  но  конкретную  верси■` математического
понятия действительного  чирла. Новый тип создается длю того, чтобы
датш   специальное и конкретное определ╡ние п╛-╧тия, котоаому`михто
прямо и  очевидно срзди( встроенных типов  не отвечает. Например, в
проГрамме, котжрая  работает с телефоном, можно было бы создать тип
trunk_moduь% (элемднт линии),   в прогсаммд обааботки текстов = тип
list_of_paragraphs (список  пардграфов)* Как  правиго, программу, в
Кот╛рой создаются  т(пы.  хорошо  отвечающие  понятиям  прилкжения,
понять легч╡,  чем`программу,  в которой  это не  делается.  Хорощо
выбранные типы,  определяемые польгователем, делают программу более
четкой и! короткой. Это  та║же позволяет  компилявору  обнаруживать
недопустимые использования  объ%ктов, которые  в  противном  слузае
останутся необнаружейными до тестирования ┐рпграммы.
  В определении нового тияа основная идея - отделИтм0несущхственэые
подробности   реализации "  (например,   формат ` данных,   кото`ые
использ├ются для  х`анения объекта  типа) от  тех качеств,  которые
сущест▓енны длo  его правильного  аспользования  (например,  полный
список функций,  *оторые имеют  доступ к  дрнным). Такое раздел%ние
можно описать  тАк, что  работа со  структурой данных и внутренними
администрвтивнями нодпрограммами (осущестВляется через  специальный
интерфейс (канаыируецсэ).
  Эта глава смстжитаиз четырех практически"отдельных частей:
  #5.2 ЪлАхсы и  Члены. Этот араздел енакомит  с осэовным  понятием
  а  типа, определяемого  пользо▓аЄелем, который $низывается $класс
(     class). Доступ к объектам класса может ограеичиврться набором
`    функций, которъе описаны как часть этого класса. Таъие функции
                             - с┬р 141$-

 `   называютсы  функциями  членами.  Объекты  класса  создаътс   и
  $  инициализируются функциoми0 членами, специально  для этой цели
     описанными. Этш  дункции "называются  конструкторамк.  Фуниция
   $ чл%н может  быть специ льным  образом  описана  для  "очистки2
     каждого ккассового  жбъекта лри его уничрожении. Такая ьнукция
     назщвается деструквором.
  #5.3 Иптерфейсы и  ░еализации.  В  этом  разделе  привоеится (два
     примера $тюго,   кбъ  класс   проекти└уется,   реализуется $ и
     используется.
  #5.4 Друзья  и  Объединдния.  В `этом  разделе  приводится  много
     фополнштельных  подробностей.   касаюйихся  классовn   В   нем
     показано, как  предоставить достуо  к  закрытой  части  класса
     функции,  которая  не  являнтсo  членом  этого$!класса.  аъая
     функция нрзывается  друг (friend).  В  этом  разделе  показано
     также, как определить дискриминирующзе объздкн%ние.	
  #5.5 Конструктофы и  Деструкторы. Объдкт  может  создаваться  как
     автоматичесъий, статический или как объекb в щвоб╛дной памяти.
`    Объект может  также быть  чл%ном некоторой  совокупностм (випа
     вектора или  класса), которая в св.ю очередь мжжет размещатьсяM
    !офним из  ═тих трех  сооспбов.  Довольно  подробн╛  объсняется
     использованме конутрукторов и д%структоров.

     5.2 Классы и ЧлеНы

  Класс -  это определяемый пользмвателем тип. Этот раздел знакоьит
с основными средствами определения клаaса, создания объекта класса,
работы с  такими объект ми  и, нбконец,  уничтожения такмх объе*тов
после использоаания.

  `$ 5.2.1 Функции Члены

  Рассмотрим реализ░цию  понятия даты  с йснольчованием  struct $ля
тпго, чтобы  опреде+ить прддст░вление даты date и множества фунлций
для работы с переменными этого типа:

  struct date0{ int month, daq,аyear; };
     а// даца:     месяц, деню, год  }
  date today;
  void set_date(date*, ilt, ilt, int):
" void next_date(date*);
  void print_date(date*);
  // ...

а Никакой явноЙ  щвязи ,ежду( функциями и  типом данныч  нет. Такую
связь0можно установить, описав функции как члены:

  а                    0   0 - стр 142 -
  struct date {
 !    int month, day, qeap;

  void set(ant, inЇ, hnt);
  woid get(int*, int*, int*);
  void next();
  void print();
  };

Функции, описан═ые  цаким образом,  называются функфиями  членами и
могут вызываться только для специальнкй /ере,енной скответствующегм
Єипа с  использованием станмартного синтаксиса для доступа к членам
структуры. Наприме└:

$ date Today;   а     // сегодня
  date my_burthday9   // мой день рождения

  void f()
  {
      my_burthday.set(30,12<1950);
      today.set(18,1,1985)9

      my_burthday.print(i;
      today.next();
  }
 аПоскольку  раЗные   струк┬уры  могут   иметь  функциш   члены 0 с
одинаковыми 0╕менами,  при  опрежелении  функции `члена  необходимо
указывать имя структуры:

  void date::next()
  {
      if ( ++day > 28 ) {
          // декает сложмую частэ работы
    ` =
  }
В функЎИи  члейе имена члднов могут использоваться без явной ссылки
на объект.  Г этом  случае имя  отйосится к член├ тогп объекта, дл 
которого функция была!вызвана.

     5.2.2 Классы

  Опксание date  в предыдущем подразделе дает множество`функ╞ий для
ра!оты с  datх, но  не  указывает,  что  этИ  функции  должны  бытю
единственныии для  доступа к  объектаматипа  date. Это  оураничение
можно наложить0используя вместо struct clas3:

                    0    ,   - стр 143 -

  class date {
 $( 0 int month,`day, year;
  public:
      void set(int, int, int);
      void get(int*, int*, int*);
      void next();
      void print,);
  };

  Метка public  делит теЛо (клабса на  две части.  Имена в  перв.й,
закрытой части,а могут (исполlзоватьсп  толюко  функциями  членами.	
Вуорая, открытая (чбсть, составляет  интерфейс  к  объекту  клдсса.
Struct -  это просто  class, у  которого вс%  члены общие,  поэтому
функции члены аопределяются   и используются $точно так  же, как  в
предыдущем случие. Наптимер:

  void datg::ptinr()      а // печатает в запйси, прИнятой в США
  {
      cout << month << "/" < `ay << "/" ye!r;
  }

Однрко функции ее ч╗ены овгорожены от использования закрытых членов
класса dat%. Например:

  void backdate()
  {
      today.day--;        // ошибка
  ]

  В том,  что доступ  в структчре  данных ограничен  явно описанным-
списккм функций,  есть несколько преимуществ. Любая ошибка, котораэ
приводит  к   тону,  что   дата( прин╕мбет   не┤опустимое  значение
(например, ДеКабрф  36, 1985)  должна быть  вызвана  кодом  функции
члена,апоэтому  перва╧ стадия отлад║и, локализация, выполняется еще
до того,  как программа  бужет запущена>  Это частный случай общегм
утверждения, что  любое!изменение  в поведеним  типа date  можеъ  и
должно вызываться# ИзменеНиями$в  его членах. Другое преим├щество -Кэто то-  что потенциальному  пользователю такого  типа нужно  будет
только  узйать` определение  функций  чйенов, (чтобы  научитюся  им
пользоватьуя.
  Защита закрытых  данных саязана с огшаничение$ использования имен
членов класса." Этм можно обойти с помощью манипуляции адресами, но
это уже0конечно, жульничество.

     5.".3 Ссылки на Себя
  В функции $члене на члены объекта, для!которого она$была вызвана,Н
можно ссылаться непосредственно> Напр╕мер:
       $       2             - стр 154 --

  class x {
      int m;
  public:
     0int readm() { return0m; }
  };

  x aa;
  | bb;

  voad f()
b {
      int a = aa>rea`m();
      intаb = bb.rхa$m();
      // ...
  }
  В первом  вызове члена member() m относится к aa.m, а во втором -
к bb.m.
  Уиазатель на  объект, для  которого вызвана функция ялен, явяется
скрытым  параметром   Їснкции.  На   этот  неяв-ыЙ  параметр  можно
сбылаться я"но  как на  this. В  каждой функции  класса x указатель
this неявно опшсан как

  x* this;
*и инициализкрован  так, что  он указывает  на объект,  для которого
была вызвана  фєэкция ч+ен.0this не можзт быть описан явнж, так как
этоdключевое  слово. Класс  x можно  эквивалентным обЁдзом  описать
так:

  class x 
  $   int m;
  public:
      int readm() { return this->m; }
  };

При щсылке $на чле-ы  (спользование`this  излишне. Главным  образом
this   используется   при   й░пмсании   функций   членов,   которые
манипулируют непосредственно( указАцелпми. Типмчный  пример этого -
функция,австакляющая звено В дважДы связанный списо*:

                             - стр 145 -

  class dlink {
   "  dlink*0pre;    // Предшествующий
      dlink* уuc(   // следующий
  public:
      void !ppeюdhdlink*);
      // ...
  };
	
  void dlink::append(dlin{* p)
  {
      p->suc = suc;  " // то есть, p->ruc =`this->suуM
      p->pre = t(is;   // явноз использовАние this
      suc->pre = p;    // то есть< this->suc->pre = p
      suc = p;         // то нсъь, this->suc ? p
  }

  dlink* list_head;
	
  void f(dlink,a, tlink кb+
  {
      // .о.
      mist_headm>append(a);
    ! lyst_head=>append(b);
  }

  Цепочки  цакой  общей  прир.ды  являютсю  основой  дляа ёписковых
классовМ которые  опИсывбютщя в Главе ?& Чтобы присоединить 'вено к
списку необходимо  обновить объекты, на которые указывают указатели
this, pre  и suc  (текущий, предыдущий и последующий). Все они типа
dlink, поэтому  функция член  dlink::append() имеет  к ним  доступ.
Единицей защиты в C++ является class, а не отдельный объект класса.

     5.2.4 Инициализация

  Использование  для   обеспечения  инициализации   объекта  класса
функций вроде  set_date() (установить  дату) неэлегантно  и чревато
ошибками. Поскольку  нигде не  утверждается, что объект должен быть
инициализирован, то  программист может забыть это сделать, или (что
приводит, как  правило, к  столь  же  разрушительным  последствиям)
сделать это  дважды. Есть  более хороший  подход: дать  возможность
программисту   описать    функцию,   явно    предназначенную    для
инициализации  объектов.   Поскольку  такая   функция  конструирует
значения данного  типа, она  называется конструктором.  Конструктор
распознается по  тому, что  имеет то  же  имя,  что  и  сам  класс.
Например:

  class da4e {
      // ...
      date(int, int, int);
  };

Когда класс  имеет конструктор,  вaе  объекты  этого  класса  будут
инициализироваться. Если  для  конструктора  нужны  параметры,  ониM
должны даваться*

    $     0                  - стр 146 -

  date today = date(23,6,1983);
  date xmas(25,12,0);        o/ сокррщенная форма
             `"           // (xmas - рождество)
  date my_burthday;        // нздопустимо,$опущена иницивлизация

  Часто(бывает  хорошо обеспечить  н╡сколько способов инициализации
объекта класса.  Это можно  сделат№, задав несколько конструкторов.
Например:

  class date {
      int month, day, year;
  public:
      // ...
      date(int, ind,аint);"   // день месяц год
      date(char*);            // дата в строковом представлении
!     date(int);                // день, месяц$м гоф сегодмяшние
      date();                    // дата по умолчанию: сегодня
  }

Конструкторы  подчиняются  тнм  же  правилам    относительно  типов
параметров, что  и перегружбнэые функции (#4.6.7). Если контрукторы
существенно различаются по типам сгоих парметров, то компилятор при*квждом использовании может выбрать правильный:

 0date today,4);
  date july4("Июль 4, 1983");  date gey("5 Ноя");
  date now?                    // инициалигируетбя по умолчаНию

  Заметьте, что! функции члены  могут быть  перегружены без  явного
использования ключевого  слова overload.  Поскольку  полный  сп(сок
функций членов  находится!в опиёании класса и как правило короткий,
то нет  никакой серьезной  причины  требокаъь  иуполшзования  слова
ovezloal для  предотвращения случайного    повторнго "использован╕я
имени.
  Размножение  конструкторов   в  примзре   с  date а типично.  ╧ри
аазрабоЄке класса  всегеа есъь  соблазн обеспечить ввсе", поскольку
кажется проще  обеспечить какое-нибудь  средство просто  на случай,
что оно  лому-то понадоБится  или потому,  ято оно изящно тыгыядит,
цем решить,  что же  нужно на самом деле. Последнее требует больших
размышлений, но  обычео приводит  к программам,  которые меньше  по
размеру  и   более  понятны.   Один  из  способов  сократить  число
родственных функций - использовать параметры по умолчанию. В случае
date для  каждого параметра  можно задать  значение  по  умолчанию,
интерпретируемое как "по умолчанию принимать: today" (сегодня).

                             - стр 147 -

  class date {
      int month, day, year;
  public:
      // ...
      date(int d =0, int m =0, int y =0);
      date(char*);            // дата в строковом представлении
  };

  date::date(int d, int m, int y)
  {
      day = d ? d : today.day;
      month = m ? m : today.month;
      year = y ? y : today.year;
      // проверка, что дата допустимая
      // ...
  }

  Когда используется  значение  параметра,  указывающее  "брать  по
умолчанию",  выбранное   значение  должно   лежать  вне   множества
возможных значений параметра. Для дня day и месяца mounth ясно, что
это так,  но для  года year  выбор нуля  неочевиден. К  счастью,  в
европейском календаре  нет нулевого года . Сразу после 1 г. до н.э.
(year==-1) идет  1 г. н.э. (year==1), но для реальной программы это
может оказаться слишком тонко.
  Объект класса  без  конструкторов  можно  инициализировать  путем
присваивания ему  другого объекта  этого класса. Это можно делать и
тогда, когда конструкторы описаны. Например:

  date  d = today;    // инициализация посредством присваивания

По существу,  имеется конструктор  по умолчанию,  определенный  как
побитовая копия  объекта того  же класса.  Если для  класса X такой
конструктор по  умолчанию  нежелателен,  его  можно  переопределить
конструктором с именем X(X&). Это будет обсуждаться в #6.6.

     5.2.5 Очистка

  Определяемый  пользователем   тип  чаще   имеет,  чем  не  имеет,
конструктор, который  обеспечивает  надлежащую  инициализацию.  Для
многих типов  также требуется  обратное действие, деструктор, чтобы
обеспечить  соответствующую   очистку  объектов   этого  типа.  Имя
деструктора для  класса X  есть ~X() ("дополнение констрыктора"). В
частности,  многие   типы  испоЛьзуют  некоторый  объем  памяти  из
свкбод╜ой памяти  hсм. #3.2.6),  который выделяется конструктором и
освоеождается деструктором.  Вот, например,  традиционны╣  стековый
┬ип,  из  которого` для  кра┬кости  полностью  выбрмшена  обработк░
ошибок:

                             - стр 148 -
*  cnass char_stack`{
(     int size;
    ( char* top;
      char* s;
  public:
      char_stack(int sz) { top=s=new char[size=sz]; }
      ~char_stack()      { delete s; }  ( // деструктор
     "void push(char c)! { *toЁ++ = c; }* ( 0  char pop()         { return *--top;}
  }

Когда  char_stack     выходит   из  области  видимости,  вызывается
деструктор:

  void f()
  {
      char_stack s9(100);
      char_stack s2(200);	
    ` s1.push('a');
      s2push(s1.popи));
      char ch = s2.pop();
      cou4 << chr(gh) << "\n";
  }

Когда вы╖ываЕтся  f(), конструктор  char_stack вызывается  для  s1,
чт.бя выделить  вектор из  100 символов,  и для  s2, чтобы выделить
векbор из  200 символов.  При возврате из f() эти два вектора будут
освобождены.

     5.2.6  Inline
  При  програмиировании   с  Использованием   классов  очень  часто
испо+ьзуется  много  маленьких  фчнкций.  По  сути,  везде,  где  в
программе тфадиционнойа структуры  стояйо  бы  просто  какое-нибудь
обячное использование  стсуктєры данных,  дается рункция.  То,  что
было соглашепием,  стало стандартом$ который распоз-ает компилятор.
Это мжжнт  страшно понизить  эффективность,  потому$ что  стоимость
вызова функции  (хотя и  вовсе не  высокая по  сра"нению с  другими
язяками) все  равео  намного  выше,  чем  пара  ссылок  по (памяти,
необходида╧ для тела функции.
  Чтобы спрбвиться с этой проблемой, был разработан аппарат inline-
фун║ций. Функция  член, опреееленнаю( (а  не  просто  описанния	  в
описании класса,  считается inline.  Это значит,  например,  что  в
функциях,  которые  используют  приведенные  выше  char_stack,  нетниваких вызовов  функций  кроме  тех,  которые  используются    для
реализации операций  вывода! Другими  словами, нет  никаких  затрат
времени  выполнения,   которые  стоит  принимать  во  внимание  при
разработке класса.  Любое, даже  самое  маленькое  действие,  можно
задать эффективно.  Это увтерждение  снимает аргумент, который чаще
всего приводят чаще всего в пользу открытых членов данных.
  Функцию член  можно также описать как inline вне описания класса.
Например:

                             - стр 149 -

  char char_stack {
      int size;
      char* top;
      char* s;
  public:
      char pop();
      // ...
  };

  inline char char_stack::pop()
  {
      return *--top;
  }

     5.3 Интерфейсы и Реализации

  Что представляет  собой хороший класс? Нечто, имеющее небольшое и
хорошо  определенное   множество   действий.   Нечто,   что   можно
рассматривать  как   "черный  ящик",  которым  манипулируют  только
посредством  этого   множества  действий.  Нечто,  чье  фактическое
представление(можно любым мыслимым способом изменить, не повлияв на
способ использования  множества дейсввий.  Нечтп, чего можно хотеть
иметь больше"одного.
  Для всех видов контеймеров сушествуют очевидные примеры: таблицы,
множества, сзиски,  вектмра,  словари  и  т.д.а Такой  класс  имеет
операцию "вставить",  обычно он  также имеет  опесации для проверки
того, был ли вставлен дАнный элемент. В нем могут быть действия для
осуществления проверки  всех элементов  в определенном  порядке,  и
кроме всего  прочего, в  нем можбт  имзться операция  для  удаления
элемента. Оеычно `контейнерные (то  есть, вмхщаюiие)  клбссы  имеют
конструкторы и десцрукторы.
  Скрытие данных  и  продуманныл  интерфейс  может  дать  концепция
модуля (см. (например  #4.4:" файлы  как  модули	.0 Класс,  однако,
является типом.  Чтобы использовать его, необходино созд ть объекты
этого класса,  и таких  объектов мож-о  создавать столькк,  сколькю
нужно. Модуль же сам является объектом. Чтобы испокьзовать его, его
надо только инициализировать, и таких объектов ровно один.

     5.3.1 Альтернативные Реализации

  Пока описание  открытой части  класса и  описание функций  членов
остаются неизменными,  реализацию класса  можно  модифицировать  не
влияя на  ее пользователей.  Как пример  этого  рассмотрим  таблицу
имен, которая  использовалась в  настольном калькуляторе в Главе 3.
Это таблица имен:

  struct name {
      char* string;
      char* next;
      double value;
  };

Вот вариант класса table:

                             - стр 150 -

  // файл table.h

  class table {
      name* tbl;
  public:
      table() { tbl = 0; }

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };

  Эта таблица  отличается от той, которая определена в Главе 3 тем,
что это  настоящий тип.  Можно описать  более чем одну table, можно
иметь указатель на table и т.д. Например:

  #include "table.h"

  table globals;
  table keywords;
  table* locals;

  main() {
      locals = new table;
      // ...
  }

Вот реализация  table::look(), которая  использует линейный поиск в
связанном списке имен name в таблице:

  #include

  name* table::look(char* p, int ins)
  {
      for (name* n = tbl; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl;
      tbl = nn;
      return nn;
  }

Теперь рассмотрим  класс table,  усовершенствованный таким образом,
чтобы  использовать  хэшированный  просмотр,  как  это  делалось  в
примере с  настольным калькулятором. Сделать это труднее из-за того
ограничения, что уже написанные программы, в которых использовалась
только что  определенная версия  класса  table,  должны  оставаться
верными без изменений:

                             - стр 151 -

  class table {
      name** tbl;
      int size;
  public:
      table(int sz = 15);
      ~table();

  name* look(char*, int = 0);
  name* insert(char* s) { return look(s,1); }
  };

  В структуру  данных и  конструктор внесены  изменения, отражающие
необходимость  того,  что  при  использовании  хэширования  таблица
должна иметь определенный размер. Задание конструктора с параметром
по умолчанию  обеспечивает, что  старая  программа,  в  которой  не
указывался  размер  таблицы,  останется  правильной.  Параметры  по
умолчанию   очень полезны в ситуации, когда нужно изменить класс не
повлияв  на  старые  программы.  Теперь  конструктор  и  деструктор
создают и уничтожают хэш-таблицы:

  table::table(int sz)
  {
      if (sz < 0) error("отрицательный размер таблицы");
      tbl = new name*[size=sz];
      for (int i = 0; inext) {
              delete n->string;
              delete n;
          }
          delete tbl;
  }

Описав деструктор  для класса  name можно  получить более простой и
ясный  вариант   table::~table().  Функция   просмотра  практически
идентична  той, а которая  использовалась   в  примере  настмльногокалькукятора (#3.1.3):

              0        0     - стр 152 -

  #inglude

  name* table:8look(char* p, int ins)
  {
      int ii = 0;
     (char* pp = p;
  а " while!(*pp) ii = iщ<<1 ^0*pp++;
      if (ia < 0) ii = -ii;
      ii %= size;
-
      for (name* n=tbl[ii]; o; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("иоя не н░йдено");

    " name* nn = new name;
      nn->string = new char[Strlen(p)+1];
      Strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl[ii];
      tbl[ii] = nn;
      return nn;

  }

Очевидно, что  функции члены  ║ласса должны  заново компилироваться
всегдаl когда  вносится какое-либо  изменение в  описиние иласса. В
идеале такое (изменение никак не должно отражаться на пользователях
класса.  К   сожалению,  это  не  так.  Для  размещееия  пеаеменной
клбссового типа компилэтор должен знать размер объекта класса. ЕслИ
размер  этих   объектов  меняется,   то  файлы,   в  которых  класс
используется, нужно  компилировать  заново.  Можно  написать  такую
программу  (и  она  уже  написана),  которая  определяет  множество
(минимальное) файлов, которое необходимо компилировать заново после
изменения описания класса, но пока что широкого распространения она
не получила.
  Почему,  можете  вы  спросить,  C++  разработан  так,  что  после
изменения закрытой  части необходима новая компиляция пользователей
класса? И  действительно, почему  вообще закрытая часть должна быть
представлена в  описании класса? Другими словами, раз пользователям
класса не  разрешается обращаться  к  закрытым  членам,  почему  их
описания должны  приводиться в  заголовочных файлах,  которые,  как
предполагается, пользователь  читает?  Ответ  -  эффективность.  Во
многих  системах   и  процесс   компиляции,  и   последовательность
операций,  реализующих   вызов   функции,   проще,   когда   размер
автоматических  объектов  (объектов  в  стеке)  известен  во  время
компиляции.
  Этой сложности !можно избежать,  представив кацдый  об╩ект класса
как указатель  на "настоящий"  объект. Так  как все  эти  указатели
будут`иметь  .динаковый ризмер,  а размещение  "настоящих  объЕктов
можно определи┬ь в файле, гдд доступна закрытая часть- то это!может
решить проблему. Однало рншение подразумевает дополнительные ссылки
по памяти  при обращенииаак членам  класса- а  также, что еще хуже,
каждый вызов  функции с  автоматическим объектом!класса включает по
меньшей мере один вызов программ выделения и юсвобождения свободной
памяти. Это  сделало бы также невозможным реализацию inline-функций

                            (- стр 153 -

членов, которые  обращаются к  данным закрытой  части. Более  того,
такое изменение  сделает невозможным  совместную компоновку C и C++
программ (поскольку  C компилятор0 обрибатывает struct  не так, как
это  будет  делать  C++  кОмпилятор).  Дл   C++  это  было  сочтено
неприемлемымn

     5.3.2 Законченный Класс

  Программиро▓ание без  скрытия  данныe  (с  применени╡м  структур)
требует меньшей  продуманности, чем  программиЁование` со  скрытием
данных (с  использованием классов).  Структуру можно  определить не
слишко╝ задумываясм  о том,  как ее  предполагается использовать. А
когда  определяется   иласс,  все   внимвние  сосредотачивается  на
обнспечении нового  типа полным  множеством  операций;( это  важное
смещение акцента.  Время, потраченное  на разработку  новпгм  типа,
обычно  многократно  `окупадтся  при   разработке  и   Єйстировании
программы.
  Вот пример  законченного типа  )ntset, который  реализует понятше
"множество целых":

  class"intset0{
   $  int cursщze, maxsize;
      int *x;
  public:
      intset(int m, int n);    // самое большее, э int'ов в 1..n
    $ ~intset();

      int member(int t);       // является ли t элементом?
    $ void insert(int t);      // добавить "t" в множество

      void iterate(inv& m)     { i = 0; }
      Int ok(int& i)           { return k

  void error(char* s)
  {
      cerr << "set: " << s << "\n";
      exit(1);
  }

  Класс intset  используется в  main(),  которая  предполагает  два
целых параметра.  Первый параметр  задает  число  случайных  чисел,
которые нужно  сгенерировать. Второй параметр указывает диапазон, в
котором должны лежать случайные целые:

                             - стр 154 -

  main(int argc, char* argv[])
  {
      if (argc != 3) error("ожидается два параметра");
      int count = 0;
      int m = atoi(argv[1]);        // число элементов множества
      int n = atoi(argv[2]);        // в диапазоне 1..n
      intset s(m,n);

      while (count maxsize) error("слищком много элементов");
      int i = cursize-1;
      x[i] = t;

      while (i>0 && x[i-1]>x[i]) {
          int t = x[i];                // переставить x[i] и [i-1]
          x[i] = x[i-1];
          x[i-1] = t;
          i--;
      }
  }

Для нахождения членов используется просто двоичный поиск:

  int intset::member(int t)        // двоичный поиск
  {
      int l = 0;
      int u = cursize-1;

      while (l <= u) {
          int m = (l+u)/2;
          if (t < x[m])
              u = m-1;
          else if (t > x[m])
              l = m+1;
          else
              return 1;            // найдено
      }
      return 0;                    // не найдено
  }

  И,  наконец,  нам  нужно  обеспечить  множество  операций,  чтобы
пользователь  мог   осуществлять  цикл  по  множеству  в  некотором
порядке, поскольку  представление intset  от  пользователя  скрыто.
Множество внутренней  упорядоченности не имеет, поэтому мы не можем
просто дать  возможность обращаться  к вектору (завтра я, наверное,
реализую intset по-другому, в виде связанного списка).
  Дается три  функции: iterate()  для инициализации  итерации, ok()
для проверки,  есть ли  следующий элемент, и next() для того, чтобы
взять следующий элемент:

  class intset {
      // ...
      void iterate(int& i)        { i = 0; }
      int ok(int& i)              { return iiterate(var);
      while (set->ok(var)) cout << set->next(var) << "\n";
  }

Другой способ задать итератор приводится в #6.8.


                           Глава 6

                        Перегрузка Операций

                                             Здесь водятся Драконы!
                                                  - старинная карта

  В этой  главе описывается  аппарат,  предоставляемый  в  C++  для
перегрузки операций.  Программист может  определять смысл  операций
при  их   применении  к   объектам  определенного   класса.   Кроме
арифметических,  можно   определять  еще   и  логические  операции,
операции сравнения,  вызова ()  и индексирования  [], а также можно
переопределять присваивание и инициализацию. Можно определить явное
и  неявное   преобразование  между  определяемыми  пользователем  и
основными типами.  Показано, как  определить класс, объект которого
не может  быть никак  иначе  скопирован  или  уничтожен  кроме  как
специальными определенными пользователем функциями.

     6.1 Введение

  Часто  программы   работают   с   объектами,   которые   фвляются
конкретными  представлениями  абстрактных  понятий.  Например,  тип
данных  int   в  C++  вместе  с  операциями  +,  -,  *,  /  и  т.д.
предоставляет  реализацию  (ограниченную)  математического  понятия
целых  чисел.  Такие  понятия  обычно  включают  в  себя  множество
операций, которые  кратко, удобно  и привычно представляют основные
действия над  объектами. К  сожалению, язык  программирования может
непосредственно поддерживать  лишь очень малое число таких понятий.
Например, такие  понятия,  как  комплексная  арифметика,  матричная
алгебра, логические сигналы и строки не получили прямой поддержки в
C++.  Классы   дают  средство   спецификации  в  C++  представления
неэлементарных объектов вместе с множеством действий, которые могут
над этими  объектами  выполняться.  Иногда  определение  того,  как
действуют  операции  на  объекты  классов,  позволяет  программисту
обеспечить более  общепринятую и  удобную  запись  для  манипуляции
объектами классов,  чем та,  которую можно  достичь используя  лишь
основную функциональную запись. Например:

  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };

определяет простую реализацию понятия комплексного числа, в которой
число  представляется   парой  чисел  с  плавающей  точкой  двойной
точности, работа с которыми осуществляется посредством операций + и
* (и  только). Программист  задает смысл  операций +  и * с помощью
определения  функций   с  именами   operator+  и  operator*.  Если,
например, даны b и c типа complex, то b+c означает (по определению)
operator+(b,c). Теперь  есть  возможность  приблизить  общепринятую
интерпретацию комплексных выражений. Например:
                             - стр 177 -

  void f()
  {
      complex a = complex(1, 3.1);
      complex b = complex(1.2, 2);
      complex c = b;

      a = b+c;
      b = b+c*a;
      c = a*b+complex(1,2);
  }

Выполняются обычные  правила приоритетов,  поэтому второй  оператор
означает b=b+(c*a), а не b=(b+c)*a.

     6.2 Функции Операции

  Можно  описывать   функции,   определяющие   значения   следующих
операций:

  +   -   *   /   %   ^   &   |   ~   !
  =   <   >   +=  -=  *=  /=  %=  ^=  &=
  |=  <<  >>  >>= <<= ==  !=  <=  >=  &&
  ||  ++  --  []  ()  new delete

  Последние четыре  -  это  индексирование  (#6.7),  вызов  функции
(#6.8), выделение  свободной памяти и освобождение свободной памяти
(#3.2.6). Изменить  приоритеты перецисленных  операций  невозможно,
как невозможно  изменить и  синтаксис выражений.  Нельзя, например,
определить унарную операцию % или бинарную !. Невозможно определить
новые  лексические  символы  операций,  но  в  тех  случаях,  когда
множество  операций  недостаточно,  вы  можете  исользовать  запись
вызова  функции.   Используйте  например,   не  **,  а  pow().  Эти
ограничения могут показаться драконовскими, но более гибкие правила
могут очень  легко привести к неоднозначностям. Например, на первый
взгляд определение  операции **,  охначающей возведение  в степень,
может показаться очевидной и простой задачей, но подумайте еще раз.
Должна ли  ** связываться  влево (как  в Фортране) или впрво (как в
Алголе)? Выражение  a**p должно  интерпретироваться как  a*(*p) или
как (a)**(p)?
  Имя функции  операции есть  ключевое  слово  operator  (то  есть,
операция), за  которым следует сама операция, например, operator<<.
Функция операция  описывается и  может вызываться так же, как любая
другая функция.  Использование  операции  -  это  лишь  сокращенная
запись явного вызова функции операции. Например:

  void f(complex a, complex b)
  {
      complex c = a + b;          // сокращенная запись
      complex d = operator+(a,b); // явный вызов
  }

При  наличии   предыдущего  описания   complex  оба  инициализатора
являются синонимиами.

                             - стр 178 -

     6.2.1 Бинарные и Унарные Онерации

  Бинарная операция  может быть  определена или  как функция  член,
получающая один  параметр, или  как функция  друг,  получающая  два
параметра. Таким образом, для любой бинарной операции @ aa@bb может
интерпретироваться    или    как    aa.operator@(bb),    или    как
operator@(aa,bb). Если  определены обе,  то aa@bb является ошибкой.
Унарная операция, префиксная или постфиксная, может быть определена
или как  функция член,  не получающая  параметров, или  как функция
друг, получающая  один параметр.  Таким образом,  для любой унарной
операции  @   aa@  или   @aa  может   интерпретироваться  или   как
aa.operator@(), или  как operator@(aa).  Если определена  и  то,  и
другое, то  и aa@  и @aa  являются ошибками.  Рассмотрим  следующие
примеры:

  class X {
  // друзья

      friend X operator-(X);      // унарный минус
      friend X operator-(X,X);    // бинарный минус
      friend X operator-();       // ошибка: нет операндов
      friend X operator-(X,X,X);  // ошибка: тернарная

  // члены (с неявным первым параметром: this)

      X* operator&(); // унарное & (взятие адреса)
      X operator&(X); // бинарное & (операция И)
      X operator&(X,X);   // ошибка: тернарное

  };

  Когда операции  ++ и  -- перегружены,  префиксное использование и
постфиксное различить невозможно.

     6.2.2 Предопределенные Значения Операций

  Относительно  смысла  операций,  определяемых  пользователем,  не
делается  никаких   предположений.  В   частности,   поскольку   не
предполагается,  что  перегруженное  =  реализует  присваивание  ее
первому   операнду,    не   делается    никакой   проверки,   чтобы
удостовериться, является ли этот операнд lvalue (#с.6).
  Значения   некоторых    встроенный   операций    определены   как
равносильные определенным  комбинациям другий  операций над теми же
аргументами. Например,  если a  является int, то ++a означает a+=1,
что  в   свою  очередь   означает  a=a+1.   Такие  соотношения  для
определенных пользователем  операций не выполняются, если только не
случилось так,  что пользователь  сам определил  их таким  образом.
Например, определение  operator+=() для  типа complex не может быть
выведено      из       определений      complex::operator+()      и
complex::operator=().
  По историческому совпадению операции = и & имеют предопределенный
смысл  для   объектов   классов.   Никакого   элегантного   сполоба
"неопределить" эти  две операции  не существует.  Их можно, однако,
сделать недееспособными  для класса  X.  Можно,  например,  описать
X::operator&(),  не  задав  ее  определения.  Если  где-либо  будет

                             - стр 179 -

браться адрес объекта класса X, то компоновщик обнаружит отсутствие
определения*. Или,  другой способ,  можно определить X::operator&()
так, чтобы вызывала ошибку во время выполнения.

     6.2.3 Операции и Определяемые Пользователем Типы

  Функция операция  должна или быть членом, или получать в качестве
параметра по  меньшей мере  один объект  класса (функциям,  которые
переопределяют операции  new и  delete, это  делать необязательно).
Это правило  гарантирует, что  пользователь не может изменить смысл
никакого   выражения,   не   включающего   в   себя   определенного
пользователем типа.  В частности,  невозможно  определить  функцию,
которая действует исключительно на указтели.
  Функция  операция,   первым  параметром   которой  предполагается
осповной тип,  не может быть функцией членом. Рассмотрим, например,
сложение комплексной переменной aa с целым 2: aa+2,  при подходящим
образом описанной функции члене, может быть проинтерпретировано как
aa.operator+(2), но  с 2+aa  это не  может быть сделано, потому что
нет такого класса int, для которого можно было бы определить + так,
чтобы это  означало 2.operator+(aa). Даже если бы такой тип был, то
для того,  чтобы обработать  и 2+aa  и aa+2,  понадобилось  бы  две
различных функции  члена. Так  как компилятор  не знает  смысла  +,
определенного пользователем,  то  не  может  предполагать,  что  он
коммутативен, и  интерпретировать 2+aa  как aa+2.  С этим  примером
могут легко справиться функции друзья.
  Все функции операции по определению перегружены. Функция операция
задает новый смысл операции в дополнение к встроенному определению,
и может  существовать несколько  функций операций  с одним и тем же
именем, если  в типах их параметров имеются отличия, различимые для
компилятора, чтобы он мог различать их при обращении (см. #4.6.7).

     6.3 Определяемое Преобразование Типа

  Приведенная во  введении  реализация  комплексных  чисел  слишком
ограничена, чтобы  она могла  устроить кого-либо,  поэтому ее нужно
расширить. Это будет в основном повторением описанных выше методов.
Например:

____________________
  *  В   некоторых  системах   компоновщик  настолько  "умен",  что
ругается, даже  если неопределена  неиспользуемая функция.  В таких
системах этим методом воспользоваться нельзя. (прим автора)

                             - стр 180 -

  class complex {
      double re, im;
  public:
      complex(double r, double i) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator+(complex, double);
      friend complex operator+(double, complex);

      friend complex operator-(complex, complex);
      friend complex operator-(complex, double);
      friend complex operator-(double, complex);
      complex operator-()     // унарный -

      friend complex operator*(complex, complex);
      friend complex operator*(complex, double);
      friend complex operator*(double, complex);

      // ...
  };

  Теперь, имея описание complex, мы можем написать:

  void f()
  {
      complex a(1,1), b(2,2), c(3,3), d(4,4), e(5,5);
      a = -b-c;
      b = c*2.0*c;
      c = (d+e)*a;
  }

Но писать  функцию для  каждого сочетания complex и double, как это
делалось  выше  для  operator+(),  невыносимо  нудно.  Кроме  того,
близкие  к   реальности  средства   комплексной  арифметики  должны
предоставлять по  меньшей мере  дюжину таких  функций;  посмотрите,
например, на тип complex, описаннчй в .

     6.3.1 Конструкторы

  Альтенативу  использованию   нескольких  функций  (перегруженных)
составлет  описание   конструктора,  который  по  заданному  double
создает complex. Например:

  class complex {
      // ...
      complex(double r) { re=r; im=0; }
  };

Конструктор, требующий только один параметр, необязательно вызывать
явно:

  complex z1 = complex(23);
  complex z2 = 23;

И z1, и z2 будут инициализированы вызовом complex(23).

                             - стр 181 -

  Конструктор -  это предписание,  как создавать  значение  данного
типа. Когда  требуется значение  типа, и когда такое значение может
быть создано  конструктором, тогда,  если такое значение дается для
присваивания, вызывается конструктор. Например, класс complex можно
было бы описать так:

  class complex {
      double re, im;
  public:
      complex(double r, double i = 0) { re=r; im=i; }

      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  };

и действия,  в которые  будут входить  переменные complex  и  целые
константы,   стали    бы   допустимы.    Целая   константа    будет
интерпретироваться как  complex с  нулевой мнимой частью. Например,
a=b*2 означает:

  a=operator*( b, complex( double(2), double(0) ) )

  Определенное пользователем преобразование типа применяется неявно
только тогда, когда оно является едиственным.
  Объект, сконструированный  с помощью  явного или  неявного вызова
конструктора, является  автоматическим и будет уничтожен при первой
возможности, обычно  сразу же  после оператора,  в котором  он  был
создан.

     6.3.2 Операции Преобразования

  Использование  конструктора   для  задания   преобразования  типа
является удобным,  но  имеет  следствия,  которые  могут  оказаться
нежелательными:
  [1]  Не  может  быть  неявного  преобразования  из  определенного
     пользователем типа  в основной тип (поскольку основные типы не
     являются классами);
  [2] Невозможно  задать преобразование из нового типа в старый, не
     изменяя описание старого; и
  [3] Невозможно  иметь конструктор с одним параметром, не имея при
     этом преобразования.
  Последнее не  является серьезной  проблемой, а  с  первыми  двумя
можно   справиться,   определив   для   исходного   типа   операцию
преобразования. Функция  член X::operator  T(), где  T -  имя типа,
определяет преобразование  из X в T. Например, можно определить тип
tiny (крошечный),  который может  иметь значение только в диапазоне
0...63,  но   все  равно  может  свободно  сочетаться  в  целыми  в
арифметических операциях:

                             - стр 182 -

  class tiny {
      char v;
      int assign(int i)
      { return v = (i&~63) ? (error("ошибка диапазона"),0) : i; }
  public:
      tiny(int i)            { assign(i); }
      tiny(tiny& i)          { v = t.v; }
      int orerator=(tiny& i) { rdtuRn v = t.v; }
 $$   int operator=(int k)   { rхturn acskgn i); }
      /pevator int()         { raturn v; 
! }

Диапазон жндченич  проверэе┬ся всегда,  когда(tiny инициалицируется
int, и  вуегда,  когда 0ему  прищвай"ается  int.( Одно  tiny `может
Пристаиваться  другому  безб провеЁки `диапазона. 0Чтобы  └азсешить
выпюлнять эад переменными tiny о▒ычные$целые операции, озределяется
ti.y::oPerator int(), неявное прдобразивдйие кз int в tiny/ Всегда,
когда в тжм месте, бде т`ебу%тся int, пОяв╗яетёя tiny, используерся	
сюот▓етсъвующ╡е ему int. Например:

  void m!)n()
  {
      tiny g1 ╜ ▓;
      tiny c2 = 62;
      tiny c7 = c2 - c1;  //"c3 -060
      tiюy c4"╜ c3;   $   / неЄ зроверки д)апазона (необязательна)	
      int i = c1 + c2;    // i ?"64
   (  c1 = c2!+ 2 * c1;! !// ошибка диапазона║ c0 = 0 (а йе 66)
      c2 = c1 -i;         /+ ошиска диапазмна: c2 = 0
      c3(= c2;            // мет проверки дибпизома (необпзательна)
  }

  Ъип вектор  мз viny может окАзаться болхе полезным, поукольку он
экономитап`оaтранство." Чтобы сделать  ьтот  тип  более 0удо▒ным  в
оара∙%нии$ можно`шспользов░ть`операцию иНдексирования.
  Дртгое применение` опрзделяемых  операюмй  преогразования  -  это
типы-  которые0  пседоставляют  нестандартныд  псежставгенмя  чичел(арифметика яо  осноканию 100, (аршфьетика1р  фиксированной0точкой,
д▓оичнж-десятачное  прндсЄавление   м  т.п.). ` При   этоМ 0 объчно
переопределпются такие оп%рации, как + ш *.
$ Фунвций прногразования  оказываются(особенно яолезными для работы
со съруктурами жан╜ых, когда0 чтение  (реалоияовднно╡  посрееством
мперафии преобразования)  тривиально, в то время как присваиввние и
ипичиализация заметно более сложны.
0 Типы istream и ostream ооираютёя н░ хункцмю преоеЁазования, чъпбы
с┤елаць в╛зможными таииз опербторы, кав

  while (ckn>>x) cout<>x$выше возвращвет istrea}f. Это пначение неявмю
пАеобразуетэя к  значениn, кот.рое  указывает состоямие аcin, а уже-этж зниченме  может  проверчться  озератором  while  (см.  c8.4.2).
Однако ппределятю  преобразование из "оного тиза  в другой так, чтоM
при этом веряется информаци , обыцно!не0стоит.

$         0         $        - хтр 18│ -

   "`6.3.3 НеоднозначнобтиМ

  Присва(жание( объекту ` (или  инициализация ` объект░)  классЕ  X
являетсч моптсвимым,( ес╗и ийи  присвакваеьое значение  являетб  X,
или сущхсцвует  единственнОе прбойразованме присваи#аеного значзния
вРтио X.
  В некоторых случаых значенае нужного0типа мооет сконструитоватьсяс  по(ощью   нескольоих (применений( 0конструктоЁов! или   оззраций
преобразования. Это  должно делаЄ№ся аявнО;  до/сстим  толэко  один
уровбнь неявнлх  преобразованшй. оп└едбленных пользователеь. Иногда
з-ачение п├жНюло  уипа может  ▒ыть скпНст`уировано  аолее"уем однии
┴пособом. Та ие ┴лучаи являются недопустимыми. Наприьер:

` claєS x { /* ... j/ x(int); x(cшar*); };
  class y { /*... */ y(int); u;
  slass { { /* ... */ jh|!; };Н

  ovepload f;
 !x`f(x);
  y f(y);

  z g(z)+

  f,1);         // де$опустимо: нзоднозначность f(x(1)) или f(y"1)+
  f(x(1	);($f(y(1));
  g("asdf");     +/ нндо┐устимо: g(z(x("asdf"))) не пшобєется  g :("asdfв)i;
  ОпредеПенные пользоватек╡м  ┐цЕобразования р░ссматсиваются только
в том случае, еaли без них вы'ов0разрдшить нелмзя. Например:

  class x { /* ... */ x(in|); 
$ overload h8double), h(x);
  h(1);

Вызов0дюг  бы быть проинтерпретирован или как h(doubf%(1))< ип( ╛ак
h(xh3)), и  был бы  п╡дупустин по правилу единственнощти. Но!прев0яJинтерпретация иснользу╡т  только стрндартнод  преобразоваэие и  она
будхъ выбрана пп псавилам( приъеденым в #4.6о7.
Правила  преобразования   -е  явл╧ются   ни  рамыми $ простыни 0дляJсдалипацик и докумеетации нм наиб.лее общимш ич тех, которые`можно
было   ▒ы $  разррботать.   Аозьмем    требование    едиэственности
преобразова-ия.! Более   обший  подход   ризрешил  аы   компилятору
яриненятьлюбже! пpнобразование, кОтор.е  он  сможет `Найти;  таким
образом,   не   нужно   было   бы`  рассматривать   все   в╛зможные
преобразоаания перед  тхмм как  объявить  выражепие  допустимым.  К
сожалению, это  ознаяало еы,  что смъсл  программы зависи┬ от тог.,
какое ореобразование  Было найдено.  В рдзультат%  ┴мысл  п└ограммы
неким образом  зависел бы  ов  а пмрядка  опИсания$ прЕобр░зования.
оскольку они  часто находятся в разных исходных файлах (написанных
разными  людь╝и)l   сиысл  провраммы   еудет  завиуеуь  от  порядка
Компо╜овки этих  частей вместе. Есть другой вар╕ант - запретитм все
нбявйые преобразюжанип.$Н╡т ничего пфоще, но вакое зравило привндет
либо к  неэлезантным по+ьзовательук╕м  инЄефейсам, либо $к  бсрному
               а             -(стр 184 -

р╛сту перегружейных  функций, как  это б╦+о  в пседыдущем разднле с
complex.
  Самый оещий по$ход уыиуывал бы всю имеюсу╬сo информацию о Випах и
рсёсматривал  еы  !вс╡  возможные  прбойразоВбния.  Напшимес,  если
испоЛьзоватьапредыдушее" описаниеl` то  мо╢но  было  бу  обсаботрть
aa=f(1)l так  как тип  aa!опредеыяет едиственность тжлловбнйя/ Есыи
aa являеЄся  p, то аеданственное, джющее  В └езультате  x,  который
требеутся присваиванипм,   -  это f(x(1)),  а если  aa -  эво y, то
вместк$эцово 0йудет  использоваться  f(y(1)).  С░млй  общийа подходсправился бы  и с  ч("asdn&), по┴кольку ндинствен-ой интерпреъациейЭ
эрого мож%т  быть(  g(z(x("asdf"))). Сло╢ность этогм помх╛┤а в тои,
что он тсебует расширенного аналмза!всего выраждния для уого,ачтобы
опрбделить интЕрпретацию  крждой операции  и  вызова  функцко.  Это
привед╡т к  замеделннию кммоиляции,  а ┬акже к вызывающим`удивл%нининрерптетацшям м  сообщениюм(об ошибках если ко╠пийярор рассмотрит
пЁеобразования, Определенняе в биближтекиф и т.п. Пти$┬аком пждхОде
комяилятор будет  принимать в.  внимание  бжльше,  яем,  как  можно
ожидать, ╖нает пишуэий,орограмму прПграммист!

     6.4 КонстантыZ
  Константы классовобо  типа определить( невозм.жно в"том хмысые, в
ка*ом01.2  и 12e3  являются коестантой  ткпа` double  Вме┴то  Нкх,
однрко, часто  можно исяользовать константы осноВных ти/жв,!если их
реалмзация обеспечивается  б помощью  фгнкций членов. Обший"иппа`ар
для  это#о  дрют  конструвторы,  получаюыйе  од╕й  параметр.  Когдакопструкторы /└осты и подсЄавычютaя illine,(имеет смысл рассмотреть
в! качехтве   кОнстанты  вызжв   кппструкторв. рЕсйа,  -апрймес,  в
  зсть$" описаниб  класса   comlpex,   то      выражениеM
zz9*3;:z2*koo|pe|(1,2) дащт$ два вызюва `фтнкций, а не пять. Ъ двумЪаызовам  функций   приведут$ две   операции  *,   а  олерация  +  и
конструктор,  ъ  ║оторжмы  ╛бращаюbся  дл╧  создания аcomlpхx(3й  и
comlpex(1,3), будєт расши╚ены inline.

 а   6.50Аол╠шие О▒ъзты

  При каж$о╝0 применении для  cmlpex сиеар-пха кпфрицил, описанных
выше, "в   функцию,  которря   теализует  опдрацию,   как  пара╝етрJперхдается кОпи√$ каждобо операнда.  Расходы на копированиЕ каждого*dotтlg$заметны, но с н(ми кполне можно примититься.`К сожалннию,`не
всх клдссы  имеот нхбольшое и удоб╜ое предстааяенйе. Чтобы избеж ть
ненудного копировбния,  мкжно описать  фуноции тали, образом, чтобыJони пойучали ссылочняе!параметЁы. напримет:
M
  cLass matrix {
      double m[4M[4];
  public:      matrix();
      friend matrix opera4or?(m`trix& matrix&){
    1(frim~D ma4r)x operator*(mAtrix&, matriy&):
  };
-
  Ссылки$позволяют ` использовать  выражен║я,  содержашие (обычные
а°ифметические  .перации  над  больши,и  объ%ктами,а без!!ненужного

     0  (    а          `  ` - стр 185 -
копированию. Указатели  применять непьзя, потомє0ч┬о ╜евозможно(фыя
применения к `ылазателю бмыщл  операции переопределмць  невозьожно.
перацию!плор мод╜м0определить ъак:

  mctrix oparator+(matrix&,`matrIx&);
  {К    $"matvi( suM;
 !   аfor  int i=0; i<4; y++)
 а`  `   `fnr )int j=0; j<4; j++)
    p (      suo.m[i][j] = )rg1.m[i][J] + qr'2.m[i][j];
   "  return 3um;
  }

Эта  operator+*)   обра╔иется  к  ажоерАндым  +  четез# ссылки, 2ножозвращает значениЕа об·екта. Возврата сыгки может юказаться болеЕ
нхф%к┬ивным:

  klass matrix {
`     // ...
а     friend matrix. operatob+(matrix&, latriy&)+
0$  ( frшend matrhx&(operatfr*(matrix&,$m!t2ix&);
  };

Это явЛяется  еопуaЄимым, но ,п`иводит  к  сложности  с  выдзлениео
пАмяти* Посколькчссылка на`рееуль┬ат еу┤ет /нредаватьсяамз цункции
квк$ сёыыка   н   воеврдщаетное0$ значенме, аомо   не  может  $быть
авто,атической пеЁененной.а Поскольку часто операция используется"в
въражении0▒ольше одного`раза, результат не`можбт бырь и сb░тической
зернмеммой. Как  правило, его  аазмеыиюц в  свободной памяти."Часто
копированИх тозВраща%мого  знаядния Окаывае`ся! дешев╗е(8пп времени
выполненйя, объему кода и объемт данных) и проiе про#раммируется.

     ╢.6 Приёв░квани╡ и Инициакизация

  Рассмотрим очень ┐Ёосbой класс строк string:

  struct string K
      char* `;-
      int rize;    //0размеЁ веКтора, на который указыва%т$t
J 0 $  єtring(int sz- { p = new char[size}sz]; }
 а    ~stri.g()`{ denete `; }
  };	

  Сврока -  ято структура  данны┼, состмящвя  из век┬оша символов а
длинъ этмго веотора. Вектор создается койструктоЁом и унщцтожается
дестшуктором. Одмакк,  как показ░но  в #5,10,  это моЖет привести кнеприятэостям. Нипример║
M
  vmid f*)
  {
      string s1(10);" !   suring s2(20);
    `#s1 = s2;
"!}
	
   $             а          а- стр 586 -

буд%р размЕсать  два внкторд` символжв, а  присваивАние s1=s2 будет
портиць ук зател■8ща один мз них и дыблир.ватм дрcгои. На выїоде из*f() мля s1 и`s2 будет вычявацься дестру║т╛р и$уничтожатм`один й тоц
же вектор  с мепрхдсказуемо  разрушительныни последствиямш.аРешение
этой (пр╛блеьы   состоит  в  ашпм,` чтобы  соответствующим$ образом
оЯределить присваивание о!ъектов типа єtring:
  struct string {
      char* p;
 `  "`ilt sije;   $// раздер"векbора, на который"указывает p
      ctrщng(mnt sz) { p =`new char[size=sz] =
`     ~string ) {#denEte0p; }
$  `  void0operatoR9(stving&)Н0 };
  void string*:opgrator=(string& a)
  {
а$    if (thщs == &a) ret5rn;      // остерегаться s=r;
      $elete p;      p=nes clar[size=a.size];
      strcpy(r,a.p);К  }

  Этж к/ре┤еление  string гиранbирыет,и чуо преаыдсщиб пример будет
работать  как$  пфедп.лаЗалось.  Однвк╛   небольшме( изменейие  f()
нриведет к появлемию той жн про!лемы в ното, обкике:

А vo!d f()
  {
 8    StriNч s1(10);
   а  s2 = s1;
  }

Тепбрь  создается   только  одна  строка,  а  тничтожается  джео аК
неминициалйзированному о!ъекту  опреДе+енная нользовбтхЙем операц╕ 
оршсвайвания не  пЁименяется. Беглый  взгляд на string::operator=()-
объясняет, пкчбму  было неразумно  Єак делать:  указатель  p  будет
содержбть нЕ╛пре┤еленное  и совершеено  сЛ├чайное( з╣ачееиео  Часто
оп╡рация !┐рисваив ния   полагаетхя  на   тм-  чтж   ее   аргументы
инкциали╖итиоквны. Для  вакой инициализации,  как здЕсш, это"╜е так
по опрефнлению."Следовательно, нужно опремелить пох.жcю, но другую,
ЇчНкцшю, чтобы кбрабатывать книциал╕зацкю:

                   !        0- стр 187 -
  struct tring {M
      ch`r*`P;
      int siz%;$   // рбзмер вектора, на коворый уиазывает p

      string(int sz) { p = new char[size=sz]; }
      ~svring() { dele4e Ё; }
      vOid operator=xrtring&)
      wtring(st2ing&){
  };

  void strmng::string(strino& a)
  {
      p=ngw bhar[size=a.syze];
    $ strcpy(p,a.p);
  }

  Для тияа  X инициализацио тем же тмпом Ш обрабавывает конструктор
X(X&)*  Нелэзя   не  подчеркнуть   еще  раз,(0 чтю( присваив░ние  и
инициализафия -  разные  действия.  Эrо  осюаенн. 0щущественэо  при
.писанйи дестшуктора.  Если класс  X имеет!констртктор$ выполняющийКнзтривиальную работу `врод% жсжобпждения  памяти, то  скорее$ всего
пжтребуется  полэый  комплеку (функций,  чтобk  полностью  избежатфпоби┬овогж копирования обшектов:

  class X {
    0 // *.>
$ а   X(solething);  // констрыктор: aоздаеть объект
      X(&Xi;         п/ конструктор: июпирует в инициализАции
      operator=(Xg)9 // прксваи▓аниз: чистит и копирует
      ~X();          / деструктор: чистиъ
( };

0 Е┴ть еще  два  скучая,( когда  о!ыект  лопитуется:  как  парам▒ур
функции и  ║ак возгр щвемое  зеахение. Когда  пЕредается  параметр,
инициализируется  неимициалиЗи`ованная   д*  этОго   п╡реиенная   -форнальмый паЁаметр.  ▒емантика идентична  ┴Емантикд кницИапизации.
То же  сбмое проИсходй┬  при возврате  из функциа,  хотя этп (менхе
очетИднО. В оаоих случаoх будет грименен X(X.9, если он опрхделен:

  string g(string arg)
  z
     0return aro;
  }

  lain()
  z
      string sа= "asdf";
   `  s = g(s);
  }*
Ясно,  что  посл%  тызова  g*й  знвчение  sб обязино  быть  "asfv".
Копиров ние пначееия! s в  п┬раметр arg (сложнОсти не предст вляет:
для этдго  нбфо взывать  strinGhstring&). Для $вжяъия  копии" этого
зндчения из  g,) Єребуется  еще один!выгов string(st2ing&); на этоа
раз инициализируемой  является временная  переменная, которая затеи

  $"               (!  0 !  $- стр!188 -
*яр(сваи▓ается`s.  Тапие переменные,а естественнО, уничтожаются  как*полоаено с помощью  sTring::~rtri.g() при первой возм.жности.

  `  6.7 Инде║сироВание

а Чтобы падать( бнысл индексов  для аобтектов  класса `кспользудтся
функция operator[]  Второй парадета$ (индекс)  фунъциш  oЁeretor[]
может быть  любогм типа.  Это  позволянт  оПределять  ассоциативеые-
насси▓я иа т.п. В  качестве примера  давайтеа пешепишем  пример  из
##.3оq0.0где  пр╕ ндписанИи0 небольшой програ╝мы для подщчета чшсла
вхождений  сло▓   в  файле апАиьенэлся  ассоциативнkй  массив.  Там
использовалась $ фумкция.   Здесь  опуеделяется  !надлежащий   тип
абсоциативного массива:

  struct pair {
      char* name;
      int!val;
  };

  class assoc {
      paiR* vec;
  " 0 inf maX3*      щnt фrme;
  pubюic:
      asqoc(int);
      hnt& opmrato"[Y(char*); 0    void pRint_all();
  };

В  asєoc  чранйтся  векъор  пар  pais  д╗ины  max. 0Ин┤екс  пеЁвогонеиспользованнлго эЛембнта!`веКтора находится  в fr%х.  КоНсцруктот
выгляеит так

  assoу::assc(int s9
  
      max = (s<16) ? s : !6;
      free$= 0;
      vec"= new pair[max];J "mК
При аеайипацйи применяЕтся все тот де простощ ( неэфцективный метод
поиска, чтп иупользоваляся в #2.│.10. Однако пр╕ пефеп.лнении assoc
увеличигается:

     `                0 ( 0  - сЄр 189 -

  #inbludE

  ijt assoc::orEravor[](char* p)
  /*
      табота с множествпм`пар "pair":
      пойс║"p,
 b 0 `возвр░ю ссылки на целую часть его "pair"
    ` делает новсю "pair", если p не встаечалосэ
  */
 `{
      registEr pair* pp;M

      for (pP='veу[frue-1]: vec<=pp; 0p--+	
          if (svrcmp*p,pp->neme)==0	 beturn pp->val;

      if (f2ee==map) {!   //(переполнение:$вектор`у║еличивадусх
 !        pair* n6ea = ne raiv_max*2];
(   а     for ( int i=0; inaoe = new cjar[єtrlen(p)+0U;-
 `  %*strcpy(xpн>namep)?
     0pp->vam$= 0;0    // начальное жначение: 0
      return pp->val;
  }

Пжско╗ьку представление  a3soc скрыто,анам нужен бпособ его печати.-
В щпедующем  разаеле  будет  покачано, 0как  определитш  подeодящий
ирешатор, а здесь ды и┴по╗ьзуе$ Простую функцию зечати:M

  vouid assoa::print_all(i
  {
 а   foz (iю┤ i = 0; i<bef) vec[buf]++;
      vec.print_all();
  }

         `      %     h     0- стр 1╣0 -

   $"6.8 Вызов Функции
  Вы╖ов0фун║ции,  то есвь запись вытажееие(список_выражемий),0можно
пр╛интерпретировать как  бинарйую операцию, и опеЁаци■$вызова мо&нмперхгружать так  же, "кАк  и  другие  опесации.а Список  парамеbров
функцим operator()а вычисляетсю  и  провбряется  в  соответствие  собычнчми прАвилами пЕтеда╟и!пафаметфов/!Перегружающая dунвцйя может
.казаться  полЕз╜ой   главным  образом   для  определдния  т╕пов$$у
единственной  опердчией  и `жля! рипов,  у` котоЁcх  одна  операция
н░ст╛льло п┬добладает, "что друг(е  в большинстве сиъуаций(можно ме
прининатф во внимапи%.
# Для типа  асс(циауивно#о ╕ащсива essoc мы0не опреаелили иЄератор.
Ято мооно  сфелать,`опте$елив клаaс assoc_iteratoZ, работа которого
смстоит в  том, чт╛бы в определенном потядкд постав╗ять элементы из
assob. Ит╡рауоЁу  нужен доступ  к данным, которые храеятсo в assoc,
поэтому он сде+ан д`ууом:

  clas3 assoc {-
  frignd class ass/c_iterator;
      pair* vec;
      int max;
      int free;
  public:
      assoc(int);
      int& kperator[](char*);
  }+

Итератор определяетс╧ как

 0class assoc_iteratr{
    ((assoc* cs;  // теку╔ий массив assяc
b     int i;      // ┬екущий индекс
  public;
  ( ( assoc_itхrator(issoc& s) { cs = &s; i = 0; }
     аЁaip* operator()()
"         √ return (iFree)? &c3->vec[i+] : 0; }
  };

Надо инициализировать  assoc_iterator для масс(ва assmc, после чего
он буДет  возвращать указатель на новую pair из этого массива0вщкийН
раз$ когда  его еудут  активизироват№ операцией  (). По достижении
конца массива он воевращает 0:

  makn()    // считает вхождения крждого слова во вводе
  {    " const MAX = 256;  // больье самого бол№шого слова
      char buf[MAX];
      assoc vec(512);
      while (cin>>buf) vdc[buf]++;
      assoc_iterator юexd(vec);
      pair* p;
      while$( p } next() )
    а  (  cou4 << p->name << ": b << p->val << #\n";
  }

                         `   - утр 191 -

Атераторный  тип  вроде  этого  имеет  преинущество  перед  набором
функчий, которые  выполняют тч  же шаботу:  у негю еёть собственныеMзакрытые динные  для хранения  ход░  итер░ции.  К  уому  же  обычно
существенно, уробы  одновременно могли! работать  много  иbератороаКэтого типа.
` Конечно, такое  п`именение ╛бъектов  для предсЄавления итераторов
никак особенно$ с перегрузкой  операций нЕ  св зано.  Многие  любят
использовать итераторы  с таъими  операциями, как first(), next() и
lсst()`(первый, сйедующий и последний(.

     6.9 Класс Строка

 !Вот  довольео   реалиaтичный  пример ! класса   string.   В   нем
произвоаится  учет   ссыло║  на   стсоку$ с   целью  минимизировать
копирование  и   в  качествн  `комстант   применяются   ст ндартные
сидвольные(строки C++.

  #include
  #iюclude

  Alass string {
( "   st2uct(srep {
          charк0s; $         // указатель на данные
    а     int   n;      (    // счетцик ссщлок
  };
$  "  srep *p;

  public:
      string(chAr *);        // string x = "abc"
      {tring();              // string x{
      string(string &);      // string x = string ...
      string& opхrator=(char`*);
     $string& operator=(string &);
  `   ~string();
      char& oper`tor[](int i);

      f2ienф ostream& operator<<(ostream&, stЄing&);
      frienд istrecm& operator>>(istream&, stping&);

      friend int operator==(string& x, char* s)
 0(       {retuЄo strcmp(x.p->s, s) == 0; }

    а цriend int opezator==(string& x, strmlg$ y)
      а   {return strcmpиx.p->s, y.p-.s) == 0; }

      friend щnt operator!=(string& y, chab* s)
     $    {return strcip(x.p->s, s) != 0; }

      friend"int operator!(string& x, string& y)
          {return strgmp(x.p->s, y.p->s) != 0; }

  };

Констрчиторы и деструкторы просты (как обkчно):

     а  0       $         $  - стр 192 -

  string::string()
  {
0     x = new srep;
      p->є = 0;
      p->n = 1;
$ }

  spring::stzin'(char* s)
  {
      p = new srep;
      p->s = new cher[ strlen(є)+1 ];      strcpu(p->s, s);
      p->n = 1;
  }

  rtryng::string(stri~g& x)
  {
     "x.p->n++;
      p = x.Ё;
  }

 0string2:~string()
  {
      if (--p->n == 0) {
          delgte p->s;
          deLeta p;
  `   }
  }
	
  Как обычню,  операции приуваиврния  очень похожи на комструкторы.
Онм долоны обрабатывать очистку своего0первого илевого)$опе└анда:

 аstring&1string::operator?(ch!r* s)
  s
      if (p->n > 1) {    // рапъединить себ 
          0-n-=9
          p = new srep;Н
      }
   !  else if (p->n == 1)
          deldte p->s;

      p->s = new char[ strlen(s)+1 ];
      strcpy(p->c, s);
  (   p)>n = 1;
      rdturn *tis;
  }

  Благоразумно!обеспечиЄь,  что!ы присваивание  объекта самому себе
работало правилньо:

                             - стр 193 -

  string& string::operator=(stri.g& x)
  {
!     x.p->n++;
      if((--p->n == 0) {
          delete p->s;M
   а      denete p;
      }
      p = x.p;
      return *this;
  }Н

  Операция вывода задумама так, чтобы продемонстрирожать применение
учета ссылок.  Онб зовтпряет  каждую  вв.димую  съроку  (с  помощью
операции <<, которая определяетхя поздНее):

  osprdam&аgperator<<(Ostream& s, spring& h)
  {
      return s << x,Q->S << " [" << x.p->n << "]\n";
  |

  О ераЎия ввода  использует стандартную  функцию ввюфа  сиьвольнойКстроки (#8.4.1).

  istream& operapor>>(istream& s, string& |)
  {
     $char buf[25&];
     `s >> buf;
      x = buц;
      cout << "egho: " << x << &\n";
      retucn s;
  }

  Для  доступа   к  отдхльпым   символам   предоставлена   операция
индексир╛вания. Осуществляетс╧ провдрка индекуа*

 аvoid error(char* p)
  {
      cerr << p << "\n";M
      exip(1);
  }

  char&`string::operator[])int i)
  {
      if (i<0 || strlen(p-<s)s[i];
  }

  Головная  программа   просто` немного 0 опреобует  действия   надН
строками. Она  читахт слова  со ввода( в строки, а потом эти ётроки
печатает. Юна  проджлжает э┬о делать до т%х пор, пока не распозндетстроку done,  которая завершает  сохраненшЕ слов  в строках, или не
встретит ко-ец  файла. После  этого она  печатает строки в обратном
порядке и завершается.

            а(          0    - свр 194 -

  main,)
  {
      string x[100];
      int n;

      cout << "отсюда начннм\n";
      for (n = p; cin>>x[n]; n++) {
          string y;
          if (n==100) error("слишкоь мпого строк");          cout << (y = x[n]);
 0        if hy<="done") brgak;
      y
   "  cout << "отсюда мы зр.йфем$обратно\n";
      for (int i=n-1; 0<=i; i--) cout << x[i];
  }

     6.10 Друпья и"Члены

( Теперь, наконец,  можно обсудить, $в каЛих  сл├чаях для0доступа к
'акрытой части определязмого пмльзо▓ателем типа испкльзовать члены,
а в  какйх  -  друзей.  Некоторые  оп%рации  дмлжны  быть  членаои:
конструоторы, деструкцоры  и  виртуальные  функции  (см*  следующую
#ливу), но обчнм это зависит от выбора/
  Рассмотрим простой класс X:

  class X {      // ...
      X(int);
     аint m();
      friend in4 f(X&);
  };

Внешне не  видно никак(х причие делать f(X&) еругом джпогнительно к
члену!X::m()0(ил╕ наоб╛рот), чтобы реализовать действия над классмм
X.  Однакоа член  X::m()  можно  вызывать  толь*о  для  "Настоящегообъекта", в  то время  *аъ друг  f() может  вызываться для объекта,
созданного с помощью неявного пр╡образоваэия типр. Наприиер:
Н
  void g()
( {
      1.m();"  (" // ошибка
      f(1);       // ц(°(1));
  }

  Поэтому` операция,  изменяющее  состояние  объекта,( дюлжн╛  быть
членом,!а не другом. Для определяемых пользователем типов операцми,
требующие в  случае фунДаменЄальных типов операнф lvalue (=, *=, ++
и т.м.), эаиболее ╡стественно определяются как члены.
  И наоборот,  зсли нужн╛  иметь неявное  преойразование  для  всех
операэдов операции, то реализующая ее функция должна быть друг.м, а
не членом.  Это уасто  кмеет место `для функций,  кторые  реализуют
операцми, нд !требу╬ыие  при  применении  к  фунъаменталцныь  типам
lvalue в качестве опетандов((+, -, || и т.д.),

                 `           - ётр 195 -
J  Если ╜икакие  преобразования)bипа  н% определенщ, то оказывается-
что нет  ни*аких существенных  основаеий т  пользу"члена,0если еёть
дрсг, который  получает ссылочный параметр, и(наоборот. В некотор√х
случаях  прюгфаммист   может  птедпочитать$ один  синтаксис  вызоваН
друг╛му. Например,  оказывается, что  большинст"о предпочитАета для
обращения" маурицы   m  запись   mninv().   Конечно<   если   invh)
действительно обриэает  матрицу m,  а не  просто  возвращает $новую
матрицу, ойратную m, ей рледут быть дрчгом.M
  При прочи┼  рдвных условиях глбирвйте, чтобы рункция была ╟лднод:
никто  не  знает,  вдруг  к╛гда-нибудь  кто-┬о  определит  операцию
прео!ражованиы.  Невозможно 0 предщказать,  потребуют   ли  будущмд
изменения изменить  статус объекта.  Синтаксис вызо"а функции члдна
яснм указывает  пользо▓аъелю, что  объект можно изменить;арёылочный
параметр является  далеко mе стоыь Очевидным. Кром% Єогп, выражения-
в члене  могут быть "замерно кофоче  выЁаже-ий в  друге. В  функции
друге надо  использов░bь пвный  параметш, тогда  как в  члене можэо
использоватl ееявпый  this. ┼сли $толькм не применяеъся пер%грузка,
имена членог обычно короче имен друзей.

     6.1 Предостережение

  как и( большбя  частэ  вюзможностей  в  языках  ПЁограммирования,
перегрузка  операций(  мож╡т  применятьс╧   как  пррвильно,  так  и
неправильно. В  частности, можно  так  воспользоваться  в.зМожность
определяць новые  значения стар╦х  операц╕й, что  они станут  почти
сжвсем непостижимы.  Представьтем например,  с  какими  слоцностями
утолкнется человек,  читающий программу,  " кот.рой опериция + была
пережптеделена для обозначения вычитания.
  Данеый аппарат  должее уберечь (програ╝миста/читаЄеля  от  ┼удших
крайностей   применения    пеаегрузки,   потому   что   програмдист
лредохранен от  измен╡ния" значения  опердций  для  жaновныс  типпв
данеых вроде  int,  а  также  потому,  что  синтаксис  в√ражений  и
приориъеты опдраций aохраняют!я.
  Мо╢ет0быть. разумно паимемять перегрузку операций главным$обр зомM
так, чbобы$ подражать  о)щепринятому0 приненению  операций.  В  тех
случаях, иогда  нет  Пбщепринятой  операции  или  имеющеесп  в  C#+
множество  операюий   не  подхожит   для   имитации   оБщепринятого
примененип, можно использовать запись вызова №ункции.

     6.12 Упражнения	

  1. (*2й  Определите   итератор  для   кЛасса  єtring.  Определите
     операцию конкатенации  + и  операцию "добавить  в"!конец"  +=.
     Какие еще жперации над string вы хотели бы осущ╡ствлять?
  2. (*q.5) Задайте  с помощь╬  перегрузки  ()  опеЁацию  выделения
     подстроки длп кгасса стркк
  3. (*3)`Постройте  класс stving  так, `чтобы  операцйя  выделения
     подстроки мк│ла  иснользоватэся "  левой  части  нрисваи▓ания.
     Напишитх сначал   версию, в которой ст`ока может присваиваться
     подстрокх той  же длины,  а потом  версию, где эти длины могут
     быть разнымм.
  4. (*2) Постройте  класс  string  так,  чтобы  для  пршсваивания,
     передачи параметров  и т.п.  он имел семантику зо значению, то

                             - стр 996 -

    "естЇ в $тех слуўаях, когда копирєется строковое представление,
     а не просто управляющая сцруктура данных класса sring>
  5. (*3) Модифицируите  класс string `из /редыдущего примера таким
     образом,  чтобы   строка   копировалась   тюлькоа  когда   это
     необходнмо."  То    есть,   храните   совместно   используемое
     представление двух  строк, пока  одна из  этих строк  mе !удет
     изменена. Не  пытайтесь одновременно  с  этим  иметь  операцию
     выделе╜ия подстроки,  которая  может  Исполюзоваться  в  левой
 0   части.
  6. (j4) Разрайотайте  класс` rtring  с  семантиъой  по  значенйю,
 а   ккпитованием с  задержкоб и оп%рацией подстроки, которая можец
     стоять в левой часта.
  7. h*2) Какие  преобразования  используюЄся  в  каждом  выражении
   $ следующей программы:

       struct X!{
          ind i;
          X(int);
а         operator+(int);Н
       };
       struct Y {
          int i;
$         Y(X);
   !   а  operator+(X);
          operator intи);
   "   };

    `  X operator* (X,I);
      "i~t f(X);

   а0  X x = 1;
       Y y 5 x;
       int i = 2;

       main()
       {
     `    i + 10;
         "y + 10+
          y"+ 10 + y;
      "   x + y + i?
  "       x * x + i;
          f(/);
        а!f(y);
         0y + y;
   $      106 + y;
       }

     ОпределитЕ$X  и Y  так, чтобы  они$ оба  были  целыми  типами/
     ╚зменште проврамму(тао, чтобы она работала и пнчатала значения     всех допустимых выражений.
  8. (*2) Опрежелите  класс IOT,  который ведет ёебя в точНости как
     int. Подсказка: определите INT::operator int(	.
  9& (*1) ОпреДелите  класс RINT, иоторый ведет себы в точности как
     int за исключением того, что единственные впзможные операции -

           `          "      - стр 197 -

     это +! (унарный(и  бинарный!, - (унарный и бинарный), 
, /, %/
     Подсказка: не определяйте $ (R?)INT::operator int().M
  10. (*3)  Определите   *ласс  LINT,  ведущий0 себя  как  RINT0 заJ     исключением того, что имеет точность не менее 6 биЄ.
 "18. (*49  Определите   класс,  который!  реализует  арифметику  с
    0произвоЛфной тОчностью. "Подскапка: вам надм уыравлять памятью
     аНалогично тому, как это д%лаыось для класса string.
  1". (*2) Напишите  программу, доведенную до нечитаемого состояния
  а  с помощью макросож и перегрузки олеЁаций. Вот идея: опреддыите	
   0 для"INT  + чтобы  он означал  - к0 наоборот, а потом с помощью
     макЁоопределения определите ilt как INT.(Переопределенае часто
     єпотребляемых  функций,  исп╛льзование  пар метрпв ассылочного
     тиза и  несколько вводящих! в заблуждение комментариев помогут
     убтроить полную неразгериїу.
  13. (*3) Пюменяйтесьа со своим  другом программами, которые у кас
     получились в предыдущем ун`ажнении. Не запуск░ю ее попытайтесь
 `   понять, что  делает программа  вбшего друга.  После выполннния
     этого упражнения "ы будете(знать, чего следует избебать.-
  14. (*2) Перепишите  приоеры с  comlpex (#6.3.1), tiny (#6.2.2й и
     stringа(#6.9)  не ис┐ользуя Friend функций. Испо╗ьзуйте только
     цункЎии члены.  ПротестиЁуйте киждую из новых вешсий. Сравниъе
  "0 их с  версиями, в которых ибпользуются функции друзья. Еще раз
     поaмотрите Упражнение 5.3,
  15. (*2)  Определите  тип  vec4  как  вектОр  их  четырех  float.
  `  Опредблите operator[]  для vec4.  Определите операции +,$-, *,
     /, =,  +=, -=,  *=,  /=  для  сочетаний  векторов  ╕  чисел  с     плаваю╔ей точкой.
$ 16.0(*3) Определитеа класс  mat4  как  вектор  из  четырех  vec4.
     Определите для`(oat4 opezator[], возвращающий vec4. Опредегите
     для этого  типа обычные  операции  мад  матрицамшn 0ОпределИте
     функцию, которая производит исключение Гаусса для mat4.
 (17. (*2) Определите  класс vectяr, аналогичный vec4, но с длиной,
     кото└ая      заДается      как      пбраметс      оонструктора
     vector::vector(int).
  18n (*3)  Опрздел╕те(  клабс  matrix,`  аналогичный  mat4,  но  с
     размерностью, `    задаемой      парбметр░ми   0  конструктора
     matpix::matrix()nt,int).


      $  0                 Гпава 7

         !              Производные Класёы

                       Н╡(надо размножать объ%кты без необходимости
                    а             $                      - У. Оккам
  ВаэтоЙ  блаве .писываеЄся  понятие `производного  класса  в  Cл+.
Производнын классы  дают  простой,  гибкий  и  эффективный  аппАрат
задания для  класёа альтернатиВного интеррейса и определения класса
посредсуВом добавления (возмож-остей к  гже имеющемуся  клрссы  безН
перепр┐граимирования  или  пдрекомпиляции.0 С  помощью  прокзВодных
классов можно  также  оббспечить  общий  интерфейс  для  неск╛льких
разкмчных классов  так, чтобы аругие части программы"могли работать
с объектами  этих влассов  одинаковым образом.  При эвом  осычно  вкаждый оБъект помещается информация о типе( чтобы эци объекты могли
обрабатываться соотвхтствуюшим  образом в  ситуациях, когда  ис уип
нельзя узнать  во время  кОмпиляции.  Дгя  элегантиной !и  надежной
обработки таких  динамических завмсимостей  типов  кмеется  понятие
виртуальной функции.  По своей  сути производные 0клвссы сущещтвгют
длп того, чтобы облегчить программисту формулировку общности.
   а 7.1 Введение

  Прхдутавим себе  процесс  написания  не*отюрого асредства  общего
назначения  (наприьер,  тип  с▓я╖анный  спибок,  таблица  имен  или
плаеировщик0для  систнмы моделирования),  кооторо%  премназначается
для   Ис/о╗шзоания    многшми   разныии    людьми    ва   различных
обстоятельствах. Ючевидно,  чтк в  кандидатах на(роль такмх средств
недостатка н╡т,  и выгодя  от их  стандартизации огромэы. "Кажется,
люсой опытный" прогшаммист написал  (и  отлбдил)  дюжину  вариантов
типов множества,  таблиця имен,  соръирующей  dункции  и  т.п.,  но
оказывается, что  таблиц имен кдждый программист и каждая программа
используют свою  версию этих  понятий, из-за чего программы слкшкомтрудно чштать,  тяжело отлаживать! и сложно  модИфицировать." Более
того,  в  большой  ┐рограмде  вполне  можец  быть  несколько  копий
идентичных (почти) частей кода для работ╦ с такими фундаментальными
понятиями.
  Призина этого хаоса частично состоит в том, что представить такие
общие понятия в языке программирования`сложно с к╛нцептульной точки
зрениям а  частично в  т.м, что  средства,  обладающие  достаточной
общностьъ, налагают  дополэительные  расходы  по  памяти  и/или( по
времени, что  делает"их  неудобными для  самых простых  и  наиболее
напряженно используемых средств (связанные списки, вектора и т.п.),
гее они  были бы  наиболее полезны.  Понятие производного  класса в
C++, описываемое  в #7.2,  не обеспечивают общего решения всех этих
проблем, но оно дает способ справляться с доаольно еебольшим чиблом
важных  случаев.   Будет$  например,   показано,   как  $определить
эффективный класс общего связанного списка таким образом, чтобы все
его версии использовали код совместно.
  Написание  общецелевых   средств  -  задача  непростая,  и  часто
основной акцент в их разработке другой, чем при разработке программ
специального  назначения.   Конечно,  нет   четкой  границы   между
средствами общего и специального назначения, и к методам и языковым
                             - стр 199 -

средствам, которые  описываются в этой главе, можно относиться так,
что они  становятся все  более полезны  с ростом объема и сложности
создаваемых программ.

     7.2 Производные Классы

  Чтобы разделить  задачи понимания  аппарата языка  и методов  его
применения, знакомство  с понятием  производных классов  делается в
три этапа.  Вначале с  помощью небольших  примеров, которые не надо
воспринимать как  реалистичные, будут  описаны сами  средства языка
(заись  и   семантика).  После   этого  демонстрируются   некоторые
неочевидные применения  производных классов, и, наконец, приводится
законченная программа.

     7.2.1 Построение Производного Класса

  Рассмотрим построение  программы, которая  имеет дело  с  людьми,
служащими в  некоторой фирме.  Структура данных  в  этой  программе
может быть например такой:

  struct employee {          // служащий
      char*    name;        // имя
      short    age;         // возраст
      short    department;  // подразделение
      int      salary;      //
      employee* next;
      // ...
  };

Список аналогичных  служащих  будет  свзяваться  через  поле  next.
Теперь давайте определим менеджера:

  struct manager {           // менеджер
      employee emp;          // запись о менеджере как о служащем
      employee* group;       // подчиненные люди
      // ...
  };

Менеджер также  является служащим; относящиеся к служащему employee
данные хранятся  в члене  emp объекта  manager. Для  читающего  это
человека это,  может быть, очевидно, но нет ничего выделяющего член
emp для  компилятора. Указатель на менеджера (manager*) не является
указателем на  служащего (employee*),  поэтому просто  использовать
один  там,  где  требуется  другой,  нельзя.  В  частности,  нельзя
поместить  менеджера  в  список  служащих,  не  написав  для  этого
специальную  программу.  Можно  либо  применить  к  manager*  явное
преобразование типа,  либо поместить  в список служащих адрес члена
emp, но  и то и другое мало элегантно и довольно неясно. Корректный
подход состоит  в том,  чтобы  установить,  что  менеджер  является
служащим с некоторой добавочной информацией:

                             - стр 200 -

  struct manager : employee {
      employee* group;
      // ...
  };

manager является  производным от employee и, обратно, employee есть
базовый класс  для manager.  Класс manager  дополнительно  к  члену
group имеет члены класса employee (name, age и т.д.).
  Имея определения  employee и  manager  мы  можем  теперь  создать
список  служащих,   некоторые  из   которых  являются  менеджерами.
Например:

  void f()
  {
      manager m1, m2;
      employee e1, e2;
      employee* elist;
      elist = &m1;     // поместить m1, e1, m2 и e2 в elist
      m1.next = &e1;
      e1.next = &m2;
      m2.next = &e2;
      e2.next = 0;
  }

Поскольку менеджер является служащим, manager* может использоваться
как employee*.  Однако служащий  необязательно является менеджером,
поэтому использовать employee* как manager* нельзя.

     7.2.2 Функции Члены

  Просто структуры данных вроде employee и manager на самом деле не
столь интересны  и часто  не особенно  полезны, поэтому рассмотрим,
как добавить к ним функции. Например:

  class employee {
      char* name;
      // ...
  public:
      employee* next;
      void print();
      // ...
  };

  class manager : public employee {
      // ...
  public:
      void print();
      // ...
  };

Надо  ответить   на  некоторые  вопросы.  Как  может  функция  член
производного класса  manager использовать члены его базового класса
employee? Как  члены базового  класса employee  могут  использовать
функции члены  производного класса  manager? Какие  члены "базового
класса employee  может использогать функция не член на объекте типа

                             - стр 201 -

manager? Каким  образом программист оожет повлиять на ответы на эти
вопросы, чтобы удовлетворить требожаниям приложения?
  Рассмотрим:

  void manager::print()
  {
      cout << " имя " << name!<< "\n";
     а// ...
  }

Член производног╛  класса может использовать открытое имя из своего
базового  класса   так  же,  как  это  могут  делать  другие  члены
посЛеднего, то  есть без  указания объекта.  Предпойагается, что на
объект указывает  this, ┐оэтомч  (корректной) ссылкой  на имя  name
является this->name.  Однако функция manager::print компилироваться
не будет,  член произвофного класса не имеет никакогю особжзо права
еоступа к закрытым членбм его базо"ого класса, поэтому для нее name
недоступно.
  Это многим  покажется удивительным,  нк"преахтавьте  себн  другой
вариант: что  функция член  могка бы  обращаться к  закрытым членам
своего  базового   класса.  Возможность,  позволяющая  программисту
получать доступ  к закрытой части класса просто с помощью вывода из
него другого  класса, лишила  бы понятие  закрытого  члена  всякого
смысла.  Более  того,  нельзя  было  бы  узнать  все  использования
закрытого имени  посмотрев на функции, описанные как члены и друзья
этого класса.  Пришлось бы  проверять каждый  исходный файл во всей
программе на  наличие в  нем производных классов, потом исследовать
каждую функцию  этих классов,  потом искать все классы, производные
от этих  классов, и  т.д. Это  по меньшей мере утомительно и скорее
всего нереально.
  С другой  стороны, можно ведь использовать механизм friend, чтобы
предоставить такой доступ или отдельным функциям, или всем функциям
отдельного класса (как описывается в #5.3). Например:

  class employee {
      friend void manager::print();
      // ...
  };

решило бы проблему с manager::print(), и

  class employee {
  friend class manager;
      // ...
  };

сделало бы  доступным каждый  член employee для всех функций класса
manager.   В    частности,   это   сделает   name   доступным   для
manager::print().
  Другое, иногда более прозрачное решение для производного класса,-
использовать только открытые члены его базового класса. Например:

                             - стр 202 -

  void manager::print()
  {
      employee::print();    // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }

Заметьте, что  надо использовать  ::,  потому  что    print()  была
переопределена  в   manager.  Такое  повторное  использование  имен
типично. Неосторожный мог бы написать так:

  void manager::print()
  {
      print();              // печатает информацию о служащем
      // ...                // печатает информацию о  менеджере
  }

и  обнаружить,   что  программа   после   вызова   manager::print()
неожиданно попадает в последовательность рекурсивных вызовов.

     7.2о3 Видимость

  Класс emplo{ee  стал открытыд $(public)  базовым  классом  классаКmajager в результате .пшсания:

  class manager : public employee {
      // ...
  };

Это оеначает,  что отк└ытый  член к+асса  employee является также и
открытым ўленом класса manager. НапЁимер:

 аvoid gleas(manager* p)
  {
      p->next = 0;
  }

будет компилироваться,  так как  next -  открытый член и employee и
manager'а.  Алштернатива  -  можно  определить  закрытый  (private)
класс, просто опустив в описании классд слово public:

  class manager : employee {
   !  // ...
$ };
J╜то юзначает,  что открытый  член класса employee является закрытым
членом класса  manager. То есть, функции члены класса manager могут
как и  раньше использовать  открыЄые чл╡ны  класса eMployee, но для
пользователей класса manager эти члены недоступны. В частности, при
таком описании  класса manager  функция`clхar*)  компилироваться не
будет. Друзья  производно#о класса  шмеют к  членам базового класса
такой же достчп, как и функции члены.
  Посколькуl как  оказывается, описание! открытях  базовых  классов
встречается уаще  описания заорытых,  жалкю, что описаНие открытого
базового *ласса дли╜нее описания закрытого. Это, кроме того, служит
источником запутывающих ошибок у начинающих.

                    0        - стр 203 -

  Когда  описывается   производная  struуt,  ее  базовый  класс  по
уоолчанию является public базовым классом. То есть,

  struct D : B { ...

означает

  class$D : public B { public: ...

Отсю$а следует,  что если  вы не  сочли пжлезным тю скрытие данных,
которое  дают   class,` pwblic   и  friend,  вы  можете "пЇосто  не
использовать mти  ключевые слова  и  придерживбться  str}ct.  Тавие
средства  языка,  как  функции  члены,  констшукторы  и  перегрузка
операций, не зависят от механизма скрытия`данных&
  Можно также  объявить некоторые,  но не  все$  открытые  $  члены
базожого клас┴а открытыми члееами производного класса.!Например:

  class manager : emtloyee {
      // ...
  public:
      // ...
      employee::name;
      employee::department;
  };

Запись

  имя_класса :: имя_члена ;

не вводит новый член, а просто делает открытый член базового класса
открытым для  производного класса.  Теперь name  и department могут
использоваться для  manager'а, а  salary и  age - нет. Естественно,
сделать сделать  закрытый  член  базового  класса  открытым  членом
производного класса  невозможно. Невозможно  с помощью  этой записи
также сделать открытыми перегруженные имена.
  Подытоживая, можно  сказать, что вместе с предоставлением средств
дополнительно к  имющимся в базовом классе, производный класс можно
использовать для  того, чтобы сделать средства (имена) недоступными
для пользователя.  Другими словами,  с помощью  производного класса
можно обеспечивать прозрачный, полупрозрачный и непрозрачный доступ
к его базовому классу.

     7.2.4 Указатели

  Если производный класс derived имеет открытый базовый класс base,
то указатель на derived можно присваивать переменной типа указатель
на  base   не  используя   явное  преобразование   типа.  $Обратное
преобразование, указателя  на!base  в указатель  на derived, должно
быть явным. Наприоер:

                              стр 204 -

  class base {!/* ... */ };
  class derived : publik base { /* ... */ };

  derived m;
  base* pт`= &m;     // неякное преобразование
  derived* pd = pb;  // ошибла: bas%* не является derived*
  pd = (devived*)pb; // явное преобразование

Иначе$говоря,  объект производного  класса при  работе с  нмм через
чказатхл иможно  рассматривать  ка║" объект  его  базового  класса.
Обратное неверно.
  Быдь$ base  закрытым  базовым  классом  класса  derived,  неявное
преобразование  derived*   в  base*   не   делалось   бы.   Неявное
преобразование н╡  может в ¤том случае быть выполнено, потомы что к
открытому члкну  класса base  можно оеращаться  через указатель  на
base, но нельзя через указавель на derived:-
  class base {
      int M1;
  public:
      int m2;     // m2 - открытый член base
  };

  class derived : base {
   (  // m2 НЕ открытый член derived
  }9

  derived d;
  d.m2 = 2;       // ошибка: m2 из закрытой части классА
  base* pb = &d;  // ошибка: (закрытый base)
  pb->m2 = 2;     // o+
  pb = (base*й&d; // ok: явное преосразование
  pb->m2 = 2;     o/ ok

Помимо всего  проgего, этот  пример показывает, что используя явное
приведение к типу можно сломить правила защиты. ┐сно, делать это не
рекомендуется,"и  эуо приносит программисту заслуженую "награду . К
несчасть , недисциплинированное (спользованше явного преобразования
может  создать   адские  условия   для  невинных   ╢ертв,   которые
эксплуатируют программу,  где это  делается.  Но,  в  сўастью,  нет
способа  воспользоваться   приведением  для   получения  доступа  к
закрытому имени !m1.  Закрытый  член  класса  может  использоваться
только членами и друзюями этого класса.

     ;.2.5 Иерархия Типов

 !Производн╦й класс сам может быть базотын классом. Например:

                             - этр 205 -

  class`employee { >.. m;
  class secretary : employee { ,.. };
  class manager : employee { ... };
  class temporary : employee { ... };
  class consultant : temporary { ... };
  class directov : manager { ... };
  class vice_president : manager { ... };
  class president : vice_president { ... };

Такое множество  родственных  классов  принято  называть  иерархией
классов& Носкольку  можно выводит╠  класс только из одного$базового
класса, такая  иерархия являхтся  деревом и  не может  быть  графом
более мбщей структушы. Например:

  class temporary { ... };
  class employee(; .*. };
  class secretary : employee { ... };

  // не C++>
  class temporary_secretary : temporary : secretary { ... };
  class consultant : uemporary : employee { ... };

И !этот   факт  вызывает   сожеление,   потому   чтк   направленный
ациклический граф  производных ллассов  был бы очень полезен. Такие
структуры описать  нельзя, но  можно сооделировать с помощью членов
соответствующий типов. Например:

  class temporary { ... };
  class employee { ... };
  class secretary : employee { ... };

  // Альтернатива:
  class temporary_secretary : secretary
  { temporary temp; ... };
  class consultant : employee
  { temporary temp; ... };

Это выглядит  неэлегантно и  страдает как  раз от  тех проблем, для
преодоления которыз  были изобретены  производные классы. Например,
поскольку  consultant   не  является   производным  от   temporary,
consultant'а нельзя помещать с список временных служащих (temporary
employee), не  написав  специальной  программы.  Однако  во  многих
полезных программах этот метод успешно используется.

     7.2.6 Конструкторы и Деструкторы

  Для некоторых  производных классов  нужны  конструкторы.  Если  у
базового класса  есть конструктор, он должен вызываться, и если для
этого конструктора нужны параметры, их надо предоставить. Например:

                             - стр 206 -

  class base {
      // ...
  public:
      base(char* n, short t);
      ~base();
  };

  class derived : public base {
      base m;
  public:
      derived(char* n);
      ~derived();
  };

Параметры   конструктора    базового   класса   специфицируются   в
определении конструктора производного класса. В этом смысле базовый
класс работакт  точно также,  как неименованный  член  производного
класса (см. #5.5.4). Например:

  derived::derived(char* n) : (n,10), m("member",123)
  {
      // ...
  }

Объекты класса  конструируются снизу  вверх: сначала базовый, потом
члены, а  потом сам  производный класс. Уничтожаются они в обратном
порядке:  сначала  сам  производный  класс,  потом  члены  а  потом
базовый.

     7.2.7 Поля Типа

  Чтобы использовать  производные  классы  не  просто  как  удобную
сокращенную запись  в описаниях, надо разрешить следующую проблему:
Если  задан  указатель  типа  base*,  какому  производному  типу  в
действительности принадлежит  указываемый объект? Есть три осповных
способа решения этой проблемы:
  [1] Обеспечить, чтобы  всегда указывались  только объекты  одного
     типа (#7.3.3);
  [2] Поместить  в   базовый  класс   поле  типа,   которое  смогут
     просматривать функции; и
  [3] Использовать виртуальные функции (#7.2.8).
  Обыкновенно  указатели   на  базовые   классы  используются   при
разработке контейнерных (или вмещающих) классов: множество, вектор,
список и  т.п. В  этом случае  решение 1 дает однородные списки, то
есть списки  объектов одного типа. Решения 2 и 3 можно использовать
для построения  неоднородных  списков,  то  есть  списков  объектов
(указателей на объекты) нескольких различных типов. Решение 3 - это
специальный вариант решения 2, безопасный относительно типа.
  Давайте сначала исследуем простое решение с помощью поля типа, то
есть решение  2. Пример  со служащими  и менеджерами  можно было бы
переопределить так:

                             - стр 207 -

  enum empl_type { M, E };

  struct employee {
      empl_type type;
      employee* next;
      char*     name;
      short     department;
      // ...
  };

  struct manager : employee {
      employee* group;
      short     level;        // уровень
  };

Имея это,  мы  можем  теперь  написать  функцию,  которая  печатает
информацию о каждом служащем:

  void print_employee(employee* e)
  {
      switch (e->type) {
      case E:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          break;
      case M:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
          break;
      }
  }

и воспользоваться ею для того, чтобы напечатать список служащих:

  void f()
  {
      for (; ll; ll=ll->next) print_employee(ll);
  }

  Это прекрасно работает,особенно в небольшой программе, написанной
одним  человеком,   но   имеет   тот   коренной   недостаток,   что
неконтролируемым  компилятором   образом  зависит   от  того,   как
программист работает  с типами.  В больших  программах  это  обычно
приводит к  ошибкам двух  видов. Первый - это невыполнение проверки
поля  типа,  второй  -  когда  не  все  случаи  case  помещаются  в
переключатель  switch   как  в  предыдущем  примере.  Оба  избежать
достаточно легко  , когда  программу сначала  пишут на буммге $, но
при модификации нетривиальной программы, особенно написанной другим
человеком, очень  трудно избежать  и того, и другого. Часто от этих
сложностей становится  труднее уберечься   из-за  того, что функции
вроде print()  часто бывают  организованы  так,  чтобы  ползоваться
общность классов, с которыми они работают. Например:

                             - стр 208 -

  void print_employee(employee* e)
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
      if (e->type == M)  {
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
      }
  }

Отыскание всех таких операторов if, скрытых внутри большой функции,
которая  работает   с  бошим   числом  производных  классов,  может
оказаться сложной  задачей, и  даже когда  все они  найдены, бывает
нелегко понять, что же в них делается.

     7.2.8 Виртуальные Функции

  Виртуальные функции  преодолевают  сложности  решения  с  помощью
полей  типа,  позволяя  программисту  описывать  в  базовом  классе
функции, которые  можно переопределять  в любом производном классе.
Компилятор и  загрузчик обеспечивают  правильное соответствие между
объектами и применяемыми к ним функциями.  Например:

  struct employee {
      employee* next;
      char*     name;
      short     department;
      // ...
      virtual void print();
  };

Ключевое слово virtual указывает, что могут быть различные варианты
функции print()  для разных  производных классов, и что поиск среди
них  подходящей   для  кажог   вызова  print()   является   задачей
компилятора. Тип  функции описывается  в базовом  классе и не может
переописываться в  производном классе.  Виртуальная функция  должна
быть  определена   для  класса,  в  котором  она  описана  впервые.
Например:

  void employee::print()
  {
      cout << e->name << "\t" << e->department << "\n";
      // ...
  }

Виртуальная функция может, таким образом, использоваться даже в том
случае, когда нет производных классов от ее класса, и в производном
классе, в котором не нужен специальный вариант виртуальной функции,
ее   задавать    не   обязательно.   Просто   при   выводе   класса
соответствующая функция  задается в  том случае,  если  она  нужна.
Например:

                             - стр 209 -

  struct manager : employee {
      employee* group;
      short     level;
      // ...
      void print();
  };

  void manager::print()
  {
      employee::print();
      cout << "\tуровень" << level << "\n";
      // ...
  }

Функция print_employee() теперь не нужна, поскольку ее место заняли
функции члены  print(), и теперь со списком служащих можно работать
так:

  void f(employee* ll)
  {
      for (; ll; ll=ll->next) ll->print();
  }

Каждый служащий  будет  печататься  в  соответствии  с  его  типом.
Например:

  main()
  {
      employee e;
          e.name = "Дж.Браун";
          e.department = 1234;
          e.next = 0;
      manager m;
          m.name = "Дж.Смит";
          e.department = 1234;
          m.level = 2;
          m.next = &e;
      f(&m);
  }

выдаст

  Дж.Смит 1234
          уровень 2
  Дж.Браун 1234

  Заметьте, что это будет работать даже в том случае, если f() была
написана и  откомпилирована еще  до  того,  как  производный  класс
manager был  задуман!  Очевидно,  при  реализации  этого  в  каждом
объекте класса  employee сохраняется  некоторая информация  о типе.
Занимаемого для  этого пространства  (в текущей реализации) как раз
хватает для  хранения указателя. Это пространство занимается только
в объектах  классов с виртуальными функциями, а не во всех объектах
классов и  даже не во всех объектах производных классов. Вы платите
эту пошлину  только за  те классы,  для которых описали виртуальные
функции.

                             - стр 210 -

  Вызов функции с помощью операции разрешения области видимости ::,
как это  делается в  manager::print(),  гарантирует,  что  межанизм
фиртуальных функций  применяться не  будет. Иначе  manager::print()
подвергалось бы  бесконечной рекурсии. Применение уточненного имени
имеет еще  один эффект,  который  может  оказаться  полезным:  если
описанная как  virtual функция  описана еще  и как  inline  (в  чем
ничего необычного  нет), то  там, где в вызове применяется :: может
применяться inline-подстановка.  Это дает  программисту эффективный
способ справляться с теми важными специальными случаями, когда одна
виртуальная функция  вызывает другую для того же объекта. Поскольку
тип объекта  был определен  при вызове  первой виртуальной функции,
обычно его  не надо  снова динамически определять другом вызове для
того же объекта.

     7.3 Альтернативные Интерфейсы

  После того,  как описаны  средства  языка,  которые  относятся  к
производным классам,  обсуждение снова  может вернуться  к  стоящим
задачам.  В   классах,  которые   описываются   в   этом   рахделе,
основополанающая идея  состоит в  том, что  они однажды написаны, а
потом их  используют программисты,  которые не  могут  изменить  их
определение.  Физически   классы  состоят   из  одного   или  более
фаголовочных файлов,  определяющих интерфейс,  и одного  или  более
файлов, определяющих  реализацию. Заголовочные файлы будут помещены
куда-то туда,  откуда пользователь  может взять  их копии с помощью
директивы  #include.   Файлы,   определяющие   реализацию,   обычно
компилируют и помещают в библиотеку.

     7.3.1 Интерфейс

  Рассмотрим такое  написание класса slist для однократно сязанного
списка, с  помощью которого  можно создавать  как однородные, так и
неоднородные списки  объектов тех  типов, которые  еще должны  быть
определены. Сначала мы определим тип ent:

  typedef void* ent;

Точная сущность  типа ent  несущественна, но нужно, чтобы в нем мог
храниться указатель. Тогда мы определим тип slink:

  class slink {
  friend class slist;
  friend class slist_iterator;
      slink* next;
      ent e;
      slink(ent a, slink* p) { e=a; next=p;}
  };

В  одном   звене  может  храниться  один  ent,  и  с  помощью  него
реализуется класс slist:

                             - стр 211 -

  class slist {
  friend class slist_iterator;
      slink* last;        // last->next - голова списка
  public:
      int insert(ent a);  // добавить в голову списка
      int append(ent a);  // добавить в хвост списка
      ent get();          // вернуться и убрать голову списка
      void clear();       // убрать все звенья

      slist()      { last=0; }
      slist(ent a) { last=new slink(a,0); last->next=last; }
      ~slist()     { clear(); }
  };

Хотя список  очевидным образом  реализуется какк  связанный список,
реализацию  можно  изменить  так,  чтобы  использовался  вектор  из
ent'ов, не  повлияв при  этом на пользователей. То есть, применение
slink'ов никак  не видно  в описаниях  открытых функций slist'ов, а
видно только в закрытой части и определениях функций.

     7.3.2 Реализация

  Реализующие  slist   функции  в   основном  просты.  Единственная
настоящая сложность  - что  делать в случае ошибки, если, например,
пользователь попытается  get() что-нибудь  из  пустого  списка.  Мы
обсудим это  в #7.3.4.  Здесь приводятся  определения членов slist.
Обратите внимание,  как хранение  указателя  на  последний  элемент
кругового списка  дает возможность  просто реализовать оба действия
append() и insert():

                             - стр 212 -

  int slist::insert(ent a)
  {
      if (last)
          last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  int slist::append(ent a)
  {
      if (last)
          last = last->next = new slink(a,last->next);
      else {
          last = new slink(a,0);
          last->next = last;
      }
      return 0;
  }

  ent slist::get()
  {
      if (last == 0) slist_handler("get fromempty list");
                                 // взять из пустого списка
      slink* f = last->next;
      ent r  f->e;
      if (f == last)
          last = 0;
      else
          last->next = f->next;
      delete  f;
      return f;
  }

Обратите внимание, как вызывается slist_handler (его описание можно
найти в  #7.3.4). Этот  указатель на имя функции используется точно
так же,  как если  бы он  был именем  функции. Это является краткой
формой более явной записи вызова:

  (*slist_handler)("get fromempty list");

И slist::clear(), наконец, удаляет из списка все элементы:

  void slist::clear()
  {
      slink* l = last;
      if (l == 0) return;
      do {
          slink* ll = l;
          l = l->next;
          delete ll;
      } while (l!=last);
  }

                             - стр 213 -

  Класс slist не обеспечивает способа заглянуть в список, но только
средства для  вставления и удаления элементов. Однако оба класса, и
slist, и  slink, описывают  класс slist_iterator как друга, поэтому
мы можем  описать подходящий  итератор. Вот один, написанный в духе
#6.8:

  class slist_iterator {
      slink* ce;
      slist* cs;
  public:
      slist_iterator(slist& s) { cs = &s; ce = cs->last; }

      ent operator()() {
          // для индикации конца итерации возвращает 0
          // для всех типов не идеален, хорош для указателей
          ent ret = ce ? (ce=ce->next)->e : 0;
          if (ce == cs->last) ce= 0;
          return ret;
      }
  };

     7.3.3 Как Этим Пользоваться

  Фактически класс  slist в  написанном виде бесполезен. В конечном
счете, зачем  можно использовать  список указателей  void*? Штука в
том, чтобы  вывести класс  из slist и получить список тех объектов,
которые представляют  интерес в  конкретной  программе.  Представим
компилятор языка  вроде C++.  В  нем  широко  будут  использоваться
списки имен; имя - это нечто вроде

  struct name {
      char* string;
      // ...
  };

В список  будут помещаться  указатели на  имена, а  не сами объекты
имена. Это  позволяет использовать  небольшое информационное поле e
slist'а, и дает возможность имени находиться одновременно более чем
в одном  списке. Вот определение класса nlist, который очень просто
выводится из класса slist:

  #include "slist.h"
  #include "name.h"

  struct nlist : slist {
      void insert(name* a) { slist::insert(a); }
      void append(name* a) { slist::append(a); }
      name* get()          {}
      nlist(name* a) : (a) {}
  };

Функции нового класса или наследуются от slist непосредственно, или
ничего не  делают кроме  преобразования типа.   Класс  nlist -  это
ничто иное,  как альтернативный  интерфейс класса slist. Так как на

                             - стр 214 -

самом  деле   тип  ent   есть   void*,   нет   необходимости   явно
преобразовывать указатели  name*, которые  используются в  качестве
фактических параметров (#2.3.4).
  Списки имен  можно использовать  в классе,  который  представляет
определение класса:

  struct classdef {
      nlist friends;
      nlist constructors;
      nlist destructors;
      nlist members;
      nlist operators;
      nlist virtuals;
      // ...
      void add_name(name*);
      classdef();
      ~classdef();
  };

и имена могут добавляться к этим спискам приблизительно так:

  void classdef::add_name(name* n)
  {
      if (n->is_friend()) {
          if (find(&friends,n))
              error("friend redeclared");
          else if (find(&members,n))
              error("friend redeclared as member");
          else
              friends.append(n);
      }
      if (n->is_operator()) operators.append(n);
      // ...
  }

где is_iterator()  и is_friend()  являются функциями членами класса
name. Фукнцию find() можно написать так:

  int find(nlist* ll, name* n)
  {
      slist_iterator ff(*(slist*)ll);
      ent p;
      while ( p=ff() ) if (p==n) return 1;
      return 0;
  }

Здесь  применяется   явное  преобразование  типа,  чтобы  применить
slist_iterator к  nlist. Более  хорошее решение,-  сделать итератор
для nlist'ов,  приведено в  #7.3.5. Печатать nlist может, например,
такая функция:

                             - стр 215 -

  void print_list(nlist* ll, char* list_name)
  {
      slist_iterator count(*(slist*)ll);
      name* p;
      int n = 0;
      while ( count() ) n++;
      cout << list_name << "\n" << n << "members\n";
      slist_iterator print(*(slist*)ll);
      while ( p=(name*)print() ) cout << p->string << "\n";
  }

     7.3.4 Обработка Ошибок

  Есть четыре  подхода к  проблеме, что  же делать,  когда во время
выполнения общецелевое  средство вроде slist сталкивается с ошибкой
(в C++ нет никаких специальных средств языка для обработке ошибок):
  [1] Возвращать недопустимое значение и позволить пользователю его
     проверять;
  [2] Возвращать  дополнительное  значение  состояния  и  разрешить
     пользователю проверять его;
  [3] Вызывать функцию ошибок, заданную как часть класса slist; или
  [4]   Вызывать    функцию   ошибок,    которую   предположительно
     предоставляет пользователь.
  Для   небольшой    программы,    написанной    ее    единственным
пользователем, нет  фактически никаких особенных причин предпочесть
одно  из  этих  решений  другим.  Для  средства  общего  назначения
ситуация совершенно иная.
  Первый подход,  возвращать недопустимое  значение,  неосуществим.
Нет совершенно  никакого способа  узнать, что  некоторое конкретное
значени будет недопустимым во всех применениях slist.
  Второй подход,  возвращать значение состояния, можно использовать
в некоторых  классах (один  из вариантов  этого плана применяется в
стандартных  потоках   ввода/вывода  istream   и  ostream;   как  -
объясняется в  #8.4.2). Здесь,  однако, имеется серьезная проблема,
вдруг!погьзовательа ╜е пкзаботится  проверить  значение! сохтояния,
зсли средство не слишком часто пмдводит.`Кроме того, средствк мОжет
использожвтюся в  сотнях или  даже тысячах мест программы> Зроверка*значения в каждо╝ местх хильэо затруднит ўтЕн(е программы.
  Третшему  пожходу,а  предоставлять0 функцию   ошибок,   недостает
либкости. Тот, кто`рЕализует Оещецелевое средство, не может узнатф,
оак поыьзоваухли  захотят, чтобы((огшвбатывались ошибки.  НапрИмхр,
пользоваЄель  может   предяочитать   сообшения  0ни`  д тском   или
венгерском*
 $Чет╢ертый подход, позволить пользователю задавать функцИ■ ошибо║,
имеет неиоторгю  привлек░тельность  ори  условии,  что  с░зрсботчиъ
предоставля╡т класс  в(виде библиютеки (#4.5), в которой уодержатся*сbандартные дункции о▒работки ошибок.
  Шешееия$ 3   и     мо╢но  сднлат№   болеБ  гибкмми  (и  по  сути
эигивалентными)$ задав`указатель на цункцию, и эе саму функциъ. Это
позволит сажработчику! такого` средства,  как  slast$  прхдостааит№
фуЭкцию ошибокl действующую пк умолчанию, и при этом провранмистам,
которые  будут   использов░ть  списки,   будет  легко  задать  скои
собствЕнныз  фуйкции   ошибок,  если   нужно,  и 0там,  где  нужйо.
Например:

     `   а            $ "    - стЁ 216 н
  vypmdef uoid ,*PFC)(char*); // указатель наатип фынкция
  e8|ern PFC sl)st_handler;M
  extern PFC sut_єmist_handler(PFC);
Функция   set_slist_hanlder()   позво╗ябт   пользователю   заменить
стандартную   фтнкцию.    Общепринятая   реалйзация   пр%доставляет
дбйствующую по  умолчанию функцию обработки ошийок, которая`сначала
пишет союбэение  об ошибке в cevr, пос╗е цего завершает программу щ
ппмощью exit8):

  3incluфe "smist.h*
  #include

  void dedault_erzor(char* s9
! {
(0 (  cerr << s << "\n";
      exщt(1);
  }
Н
Она описывает  также указател  на функЎия  ошибок и,  для  удобствиКзаписи, функЎшю для ее установки:

  PFC slist_handler = dmfault_error;

  PFC єetslist_handleR(PFC `andler)9
  {
    ! PFC rr = snist_handler3К      clist_handler = handler;
   ( (return rr;
  }

Юбратите внимвеие,"в*ак set_slist_hanldur()  вопвращает  прддыдущий
slist_hanlder().  Это  делает  удобным  уутан.вку  и0 переустанов*у
жбработчиков ошибок  на манер  стека. Ьто  может  быть  в  основном
полезным в больших прогсаммах, ▓ которях(slist можхр использоваЄьсяв нескольких $разнлх ситуациях,  в качдой  из"которых  могут, таким
образпм, зада▓аться свки`собщтвенп╦е подпрограммы юбработки ошибок.
Налример:
J  {
  P╞C ld = set_slist_haю`ler(e}_handler);

      ?o код, в0Котором в случре ошибмк к slist
      // будет использоваться мой обрайотчик my_handle2

      set_slisu_handler(gmd); // восстановление
  }

а Чтобы сделать управление болхе изящным, slast_hanlder мог бы быть
сделан членом  влахса slist,  ╟цо позволило" !ы  различным  сп(ёкамJимЕтф однок└еменно разные ойр░ботчик(.

                    "        - стр 217 -

     7.3.5 Обобщенные КлаЁсы

  Оgевидно,  можно(  было0(бы   опремелить  списки   дрчзих4  типовM
(classdef*, int,  char* и  т.д.) цочно  тик же.""иак был  опрЕделен
класр nlist:  прос┬√м вывофом pиз клбсса slist.(Процесс оп`еделения
таких новх  типов утомителеН  (и $потому  чреват  ошибками),  но  с
/юмо∙ью макросов  его0можно  "ме┼бнизировАрь".  К  сожалению, !ески
полlзоваться стандартным  C препроцессором$ (#4.7 и  #с.11.1л,  ═цоуоже мюжет !оказ░ться тягобтэъм,  Однакп полєче-ными! в !резулфтате
наороса╝и Пользо▓аться$довопьно простж.
 $Аот"пример  того, как обоб∙ен╜ый (generyc) класс slisT, названныл
gslist, может  быть задаэ  как маорос/ Сначала для написания такого
рода маъросюв вклюуаются некотор╗е инструменты из :

  #ilclude "slist.h"

  #ifndef FENMSICH
 0#include
  7'ndmf

  Обраbите  вниьаних  на  Исполфзование` 'mfndef  для  того,  чтобы
гарантироватм, что  (в юдной компиляции$не будет включен
дважды GENERICH определен в .
  После  этого  с  помощью  nime2(1-  макроса  из  " для
конкатепациИ имен, кпределяются имена новых"Обобщенныс$к+ассо▓*

` #defhnegslist(type- naie2(uipe,gslist)
  #dхfine gsliєt_itesator(t}pe) namE2(type,eslist_iterapor)

 аИ,    наконец,  !аможно  0 на┐исать    *лассы    g{lisT(тип)    и
gslist_iteravor(тип):
К  #define gslistdeуlare(tyPe)               !              \
  struct gslistиtype)(: qlist {                      "     \
      int insert(type a)           !                   $   \
          { seturn slisT::inrart( ent(a) ); } "            \
      int aЁpenl(type a)                  0           "" " L
          ; returj sdist::append  ent(i) ); ¤ !            ^
      t}pe get() { return type( slistz:get() ); }          \
      gslisT(pypei(9а{ m    а            "                 \
      gslist(tyЁg)(type a) : (ent(a)) { =                  \M
      >gslirt(type)() { cleer(); }                     !   \
  };  0   (                         0     0   `   (  "    \
                         $    (    0    (          $  ! (( \
  strect gslist_iteravoЄ(dype) : slist_iterator {       `  \
     $gєlist_iterator(type)(gslist(type)f a) !  $  "     ! \
        $ ; ( ,slast&)s ) {}     !   0            (    0   \L
      type opesator(i()   а              `    $!   !       \
     "   0{ rdturn type( slast_iterator::oqerator(-() ); } \
  }

  \ на лонце строк увазывает , что следуюшая ст└ока является частью
оп`едекяемого макро┴а.  С помощь■! этого макроса асписок указателей  еа имя,  анблозачн√й
испОльзмванному раньше классу nlist, можно опредеЛить так:

       `а  )   0   0         - ётр 218 -

  #include "namu.h"

 $typedaf0name* Pname;
$ deClarehgslist(Pname); // описать класс gslist(Pname)

  gslirt(Pname)`nl;      // описдть один gslist(name)

Макрос decla2e а(описать) п/р%деле- в . Он Конкате╜ирует
свпи пвраметры  и вызывает  макрос с  этим именем,0 в дайнпм случае
gslщstdec,ard$ описанный выше. Параметр имя типа для declare дол&ен
быть простым  именемо Используемый  ,етод макроопределемия не можетJобрабатываbь ииена типов вроде .ame*, поэтому пркменпется typedef.
  Испо+ьзованая вывода  клдсса гар нтирует, (что все частные случаи
обобщенного ъласса раздзляют код. Этоу мхЄод можно применять"тмлькодля создана  аклассов объектов  тогк же  рапмера  ил(  мееьше,  чем
базовый класс, кот╛рый (спользуется в макросе.`gslistапрИменяетсэ в
#7.6.2.

  !  7.3.6 Ограниченные Интерфейсы
К  Класс slisd - доволэ-о(об∙его хараитбра. Иногда подобйая общпостьM
не требуется  или држе" еззелательна. $Огран(╟еннъе 1вмды  рписков,
такие ка
  суеки и  озереди, диЖе  еогее облчны, чем сам обобщенный
список. Таоие  структуры данных  можно зидить,  не  описав  ба╖овый
класс как .укрытый. Например, очередьацелых можно определить таК:

" #inc,ude  slist.h"

( class ique}e : slist {
               ` //паедппл░грется sizeof(int)=sizeof(void*)
  pїbl)c:
      void put(inЇ a) {$slist::`ppejd((void*(a); }
      int det()       { return(int(slist::get())? }
      iqueue()        {}
  };

При"таъом выводе осущест"ляютщя дга логически рАздел╡н╜ых действия:
╗оня┬ие с┐иска ограничивается понятием ояереди (сводш┬ся к нему), и
задаеъся тип  int, чтобы $свести  поняъие  жчдреди  к  типу!"дапных
очерееь0 це╗ых$а  iqueue.  Эти$  два  деяствия  можно 2▓ыпол╜ять$ и
раздельно. Здерь  первая часть  - это спис.к, огфаничеены╣@так, что
он может"использоваться только как стек:

  #include "snist.h"

 аc,asr stack : sdist {
  Ёublic*
   (  slist::insert;
  $   slmst::get;
      stack() k}Н
 `   аrtqckhent a) : (a) {}
  };
Н
*╛торый потом0 исяользуется фля "создаМия типа  *aтбк указателей(на
символы":

!    (      `   а       0   0- щЄр r39 -

  #knbluфe "stack.ъ"

  class cp : sta#z {
 0public:
    ( void push8charj ai { {list::insesta); }*      char* pop() { return char*-slisv::oet(); }
    $ jlist(9а[}  };

   8 .4 Добакление к Ълас┴у

  В предыдуших$ примерах произ▓одны╣  класс ничего  не  добав╗ял  к
базовому  классу.  Для  ороизаодного  клАсса  функции `определялисшН
толь║о чтобы 0ойеспечить п@еобразование "типа.( Каждый  псоизводнын
класс простп  задавал(альтернативный  интерфейс к  общеиу множеству
программ.  Ятот  специальный  случай  важэн,  но` н ибогее  обычная
причийа опрздЕления новх к╗ ссов крк производных классмв в том, что
куо-то хочет  иметь то,  что нремостав╗яет  базовый класс, плъс е∙е
чуть-чуть.
а"Длэ  пшоизводного   кЛасса  можмо  пoрЕ┤елить  дАнные  ░  фуэкции
дополнительно к` теь, которые  наследуются из( егоАбазового класса.
Это дант  альтернаЄивную стрателию  обеспечить стедства  связан-ого
списка. Заметьте,  когиа в 0тот slist,` который  опреддлялся  аыше,
помещается элемент,  то создается  slknk,`содержащий два указателя.
На их  создание тратИтся  время, а  ведь0гее  одного из  указателбй
можно обмйтмсь,` при условии,  что нcж-о  bолько чтобы "объект  мог
наэо┤аться в  одйом списке.  Так что  укачатель!next  на  щледующий
╝ожно поместить  в сам  объект,(вместо  того, чтобы  помещать его в
отдекьныщ об╩ект  slink. Иддя  состоит в  том, чтобы  сочдать0класс
olink с  единственным поЛем  next, и  клисё  klist,  который  может
жбрабатывать улазареляди  на такие звенья oLink. Тогда olist сможет
манипулиЁовать объектаии  луюого  класса,  производнобо  от $olink.JБук"а "o2  в`назваНаях  стоит"для(`то│о, хтобы  напоминать вам, чЄо
объеот м╛жет нафомИться од╣овреме╜эо только в одном списке яlist:
M
  єtvugt olino {
      olink* next;
  }3

Класс olist  очепь нанпминбет  класс slist.  От+йчиб состо(т в том,
что пюльзмватель  иласса o|ist  манипулшрует объ%ктами класса nlink
йепосредсвбНно:

 0class olist {
      olink* laqt;
  pqblic:
      void insert(olink* p);
      rnhd append(olink* p);
      olink* geT(+;
   (  +/ ...
  };
JМы мкжем вывест╕ шз класса olink класс name:

          $  0               )(стр 220 -

  class n!me : public olink {
      // ...
  };
	
 0Теперь легко  сделать  список,  который  можно  использоватl  без
накладных расходов времени ╜и размещение ипи0памяти.
  Объекты, помещазмы  в olist,  т╡ряют сВой  тип. Это озеачает, что
компмлятор знает  только то,  что они olink'и. Паавильный тип$можно
восстановить с помощью явного преобразования типа(объе*тов, вынутых
шз olist. Например:

  void f()
 `{
      olist ll;
      oame no;
  !   ll.insertи&nN);              // тип &nn потеря-
   "  name( pn = (name*)ll.gEt();  /o и восстановлен
  }-

Мругмй"способ2  цип можно  восстанотить, выв╡дя  ещ% одие  класс из
olщsp дкя пбработки преобразования тияА:

  class olkst : publis ohist {
   "  // ...	
      name* get() ;аreturn08name*)olist::get() }
  };

  Имя name `может одновременно0находкться!толшко в однОм olist. Длч
имен это  может быть  ш неподeо┤ит,  но в  к+ассач, для"║отор√х эъо
подойдет полностью0 недюётат║а нет.  Например, класс  фагур  s`ape
использует(для  зоддержки соиска  в┴дх "рмгур  именно2 этот  метод.
Обратиъе  внимаэие,   что  мОдно  "бы╗о  бы  опъед╡лить (slist  как
производный .т  olist, объединяя  таким образ╛м оба понятия. Однако
использование   бызовых "  иа 8производных    классов   ма    та*ом
ми╗рОскопичесъпм уровне ╝ожет оченьасильно исказить кодо

     7.5 Неодноаодныб Спискм

  Пр%аыаущие списки  были одйо`одными. То есть,ав списжк помещались
только  объекты   оеного   типа.   Это   об╡спечивал╛сю   аппаратом
производных   классов.    ╤п║ск(   ме   обызательно   дол&н╦  `быть
╛ддн╛родмыми. Спмсок,  заденны) в  виде`улазаеъелей ни"кл░ус, может
содержать объекты  любого класса,  проижводного от этого класса* То
хсть, список$ может быть  нзофнородным. Вероятно,  это единственный
наибо+ее важны)  и полезный0асзект проичводных классов, и он верьма
существеНно  используется   в   стиле   прогриммировапия,   который
демонстрируется   приведеэным    выше    примнром.    Этот  ` стиль
программирования    gасто    называюу    объектно-основанням "  илиобъекЄно=ориентировбнным. Он` озирается на  то,  чтю  действия  надобъектами  неоднородные  хписков !вылолняътся  одинаковым  оеразом.
Смысл  этих   действйы  зависшт   от  фактического  типв  объект.в,
находящихся в  списк╡( уто` станжвится известно  только  на  стадии
выпо+нения),  а ( не  прос┬о  от  типа  эле,енуов  ┴┐иска  (котжЁый
компиляторг известзн).

                    " `      - стр 221 -

     7.6 Законченна ПрОг`амма

 0Разберем процеср `нАпштания пр╛грам╝ы  для  рисования  на  экране
гемзтрических ф)Гур.  Пна естесЄвенмым  образом`разделяется  на три
части*
  [1] Администратор эк`ана: подпрограмм√аничкогк ушовня и структуры
     д нных, опреднляющие нкран; пн ведаец тол№║о точками к прямыми
`!   линАчми;	
 ![2] Бислиот%ка  фигур:@набор  опред%лений оосновных  фиг├р  вроме
     прымоєгольни(а и  круга и` стандартэые0пр╢грамьы  для работы0с     ними; ш
  [3]     ╧рикладНая      про#рамма:     мйожеств╛     определений,
     специализированных для !динноГо нрикОжения,  и код,  в кптор╛мJ     они используютсх.
  Эти цри  части скорее  вaего(будут  писать(разпын  люди (в разных
орган╕заци╧х и  в разное  в└емя). При этом частИ!будут скорее всего
писарь   именно    в $ указанном    порядке   с   тем   осложняnщимобсто тхльством,  чтО  у !разрасоЄўиков  нижнего  уровня  не  будет
уочного представления-  для чего  их код  в  конечном  счеве  будет
иупользоввться. Это`отражено в привкдимом прмоере. Чтобы пример был
кошкче,  графическая   библиотека   предоставляет!`(ролько   весьма
ограниуднный сервис,  а бама  п└иклаеная( программа  очень  проста.
Утобы"читаЄельасмог испътать нрограмму, даже если у него нет спвсем
нйкаких  графичеслих   сЁздств,  испол╠зуется  чрегвычайнж  простАя
концепция экрана.  Не должно  состакить труда заненить эту экранную-
gасть программы  чем-нибудь пкдходящим,  н╡ изменяя  ╕од биелиотеки
фигур И прикладной программы.

     7.6.1 Адьипистра┬ор Экрана-

  Вначале бъло намбрени на/исаЄь аюминистратор mкррна на C (а н% на
K*+)," чтоаы   подчеркнуть  разделение  `ут╛вней  реализации. 0 ╜ъо
оказалось  сйишком   утомивельным,  поэтому   пришлось  `пойти   на
коопром(сс* используетуя  стиль C  (нет дункций членпв,а"(ртуалмных
функцай,  опреддляем√ха  пользов т%лем  опеаАюий  и  ъ.п.),  однако
па╕меняются !конструкторы, $ надлежащим   об└азом`  описыврются а и
проверяются параметры  функций  и( т.ф.  Оглядываясь  назад,  моЖно
сказ░тl, чуо  ░дмИнисттатор экрана  очень  похо&  на 0C  програм,у,
которую ппвом  модифицИровали, чтобы воспользоваться средствами C+;
не перЕписывая$все полноaтью.
  Экран представляется  как Двумерный  дбссив  символов-0 работу  с
которым осгществляют функции put_point() и`put_line(), использующие
при ссыл║е на экрбм стауктуру roint:

       а                  $  - свр 222 -

  // файл scrgen.h

  const MAX=40,0YMAX=24;

 аstruct point {
      int x,y;
      xoijt() {u
  0   point(y~T a, щot b) { x=q; y=b; |
  };
M
! overloaф put_poi~t;
  extern void pud[poI~t(int a, int b);
  inline voit 0ut_point(point 0+ { put_point8p.x,p.y); }

  overload put_line;
  extern void put_lind(ynt, int, int, int);
  inline void put_line(point a, pOint b)
      { put_lhne(a&p,!>y,b.x,b.y); }

  extern void screen_inkt();
  extern Void screen_refresh();*  e|tUrn vId screen_clear();

  #include

  Перед   пефвым    исоользжванием   функции а  pet   экран    н░до
инициализировать с  ппмощью scredn_iюit(), `ааизмеэения а стёуктушеданных  экрана   отображаются  на  0ькране  только   после   "ызо"а
wcreen_pefresh().  Как " увидит  пользовит-ль,   это   "Обновлениев
("refresh ) оёт∙ествляетря  просто посредством` пеудbи ново╣  коник
эксрна под  его предыдущим  варианто╝. Вот  фcнкции  ╕  определения
дднНых для экрана:

  #include "screen.h"J  #knclude
  enum`cяlor`{ black='*', white=' ' };

  char sgreejXMAX][YNAX];

 !void scree._hnIt()
 ({
      boЄ (int y=0; y=a || a<=b) y0 += dy,`eps -= two_a;
  ! 0 }
 (}-
КПредостбвляются dуйкцииадля очистки экрана и его обновления:К
  void skrEen_Clear() { screen_iniЇ(); }  // очистка
J10void s#reen_refre{x() а   `          0  // оснжвление
  z
      for (int y=YMAXm1;02<=y┐!y--) z     // сверху "низ
          fr (int |=0; x
7/vо2(Бийлиотека ЦигуЁ

  Нам нужно  определить об∙ее  понявие  фиууры  (shaЁe(.0 Это  нддо
сделать bаким образом, чтобы ╛но использовалось(*как базовый класс)
всеми конкретными фигурами ,например, кругами и квадфата,и), и так,
чтобы любой  фигурой"можно  было манипулировать исключительно через
интерфейс, предоставляемый классом shape:
J  struct Shape {
  (   shape() { shape_list.append(this); }

      virtuс} point north() { return point(0,0); } // север
0     virtual point south() { return point(0,0); } // юг
      virtucl point %ast() { return point(0,0); }  // жосток
  $   virtual point neast() { retqrn point(0,0)9 } // северо-восток
      virtuil point seaSt() { returj point(0,0); } // юго-восток

      virtual void dЄaw() {}; !  0            а    // ╜арисовать
    $ virtual void move(int, int) y};              // петеместить
  };

  идзя бостоит  в том,  что расположение  филуры задается с помощью
move(), а дигура помещаеbся на экран с ппмощью!dbaw(). Фигуры моцно
расПолазать  относительно$  друг  друга,  используя  понятие  тояки
соприкосновения, и! эти точки  перечисляются после точек на компасе
(сторон саета). Каждая конксетная ф║гура определяет свой смысл этих
точек,аи  каждая 0определяет  способ,  которым  она  рисуется.  Для
экономии места  здесь на ба╝ом деле определяются только необходимые
в этом  примере сцороны света. Конструктор shape::shape() добавляет
фигуру в  список фигур  shape_list. Этот список является gslist, то
есть, `одним   из  варивнтов   обобщеннпзо  односвязанного  списка,
определенного"в  #7.3.5. Он и соответствующий итератор бяли сделаныта║:

  typedef shape* sp;
  declare(gslist,sp);

  typedef gslist(sp) shape_lst;
  typedef gslist_iterator(sp) sp_itErator;

поэтому shape_li3t можно описать так:

  shape_lst shape_list;

Линию можнж  построить либо по двум точкбм, либо по(цочке и целому.
В`послефн╡м  случае создаеъся  горизонЄальная лмния,  длину кот╛рой
ппр%деляет целое.  Знак целого  указыв░ет,  каким  кжнцом  является
т.чка: левым илн правым* Вот опремеление:

    ` $"                     - стр 225 -

  class liюe : public shape {
  /*
а     линия из 'w' в 'e'
      oorti(i определяется как ``выше центра
      и на север каК до самой северной точка''
  */
      point w,e;	
  public:
      point north()
   !      { return point((w.x+e.x)/2,e.ydraw();
      screen_rufresh();
  }

  0                      !а а- стр 227 -

И вот,$ наконец, настоящаяа сервисная функция (утилита). Она кыадет
одну фигуру  эа верх другой, задавая, что souph() одной должен быт№
сразу над north() другой:

  void stack(shape*(q, shape* `i   //"ставит p на верх q
  {
а     point n = p->novth();
      point s = q->south()3
      q->move(n.x-s.x,n.y/s.y+1);
  }

  Теперь  !предстАв╕м    себе,  `что   эта   библиотека   считаетсяНсобётвенностью  некоей   код┐ании,  которая   продает   програмьное
обеспечение, и  чЄк  они  продают  вам  толькоа заголовочный  файл,
содержаций   определемия   ьигур,   и   откпмпилированный   варианр
определений  функций.  И  у  вас  все  равно  остается  возможность
определять новые  фигуры и использовать для ваших собственных фигур
сервисные функции.

     7f6.3 Прикладная Прогтамм░
  Прикладная  птограмма   чрезвычайно  проста. $╬пределэется` но▓ая
фиуура my_shape  на печрти  пна немно#о похожа на рожицу), а потом
пишется глав-ая  программа, которая  надевает на нее шляпу. Вначале
Опиуан╕е my_shape:

  #include "shape.h"
  class myshapч : publщc rectangle {M      line* l_eye;                   //!Левый глаз
      line* r_eyх;                  0// пражый глаз      line* moutl; а            "    // рот
  public:Л      mysh!pe(point, point);      voiф фraw();
      void move(int, int)?
  };

  Злазд и  сот -  отдельные и! незакисимые объекты, кото└ые создает
конструктор my_shape:

  myshape::myshape(`oint`a, point f) : (a,b)
  {
      int ll = neast().x-swest().x+1{
      int hh = neast().y-swest().y+1;
      lWeye = new line(
   `      point(swest().x+2,swest().y+hh"3/4),2);
      r_eya = new line(
          point(swest().x+ll-0,swest().y+hh*3/4),2);
      mkuth = new line(
          point(swest().x+2,swest(9.y+hh/4),ll-4);
  }

  Объекты  глаза ` и   рот   порознь   рисуются   заново   функцией
shap%_refresh(),0и  к принципе  ьогут обрабатываться  независимо из

                             - щт` 228 -

объекта  my_shape,   которомг  они  пшинадлежат.  Это  один  способ
опреде+╧ть средства  для иерархически  пострпенных  объектов  вроде
myshape/ Другой  способ демонстрируется  на примере  носа. Никакощ
нос не  определяется,  его$ просто  добавляет  к  картинке  функция
draw():

  void mysшape::draw()
  {
      rectangle::draw();
      put_point8point(
   `      (swest().|+neast(+.x)/2$(swesT().q+neast(i.y)/2));
  }
-
my_shape    передвигается    посре$ством    перемещения(   базотогп
пшямоугольника rectangle  и вторичных объектов l[eye, r_eye и mouth
(левого глаза, правого глаза и рта):

  vokdаMyshape::move()
  {
  0   rectangle::-ove();
      l_eye->move(a,b);
     (r_eye)>move(a,b);      mouth->move(a,b);
  }

Мы  можем,   наконец,  построить   несколько  фигур  и  немногО  их
пмдвигать:

  main()
  {
      sharej p1 = new rectangle(point(0,0)(poynt(10,10));
      shape*$p2"= new line(poinu(4,15),17);
(     shape* p3 = nmw myshcpe(point(15,10),point(27,18));
      shape_refsesh();
      p2->move(-10,-10);
    $ stack(p2,p3!;
      stack(p1,p2)
      wiape_refresh));
      return 0;
  }

  Еще раз  обратите внимвние,  каК(функции  вроде shape_pefresh() и
stack ) манипулирчют  объектами типов,  определяемых гораздо ┐озже$
чем  были  нанисаны  (й,  может  быть,  откомпилированы)  ┴ами  эти
фуйкцши.

    а    а         "         - стр 229 -

     **j*****+**
     "   а     *
     *$    а   *
     *         *
     *  0      *
    $*         к
     *         *
     *         *
 "   *  (      *
   а * !       *     ***********
  ****************

    *************J    *           *
    * **     ** *
 $  *           *
    *     *     *
    *         а *
    * ******** *
    *          $*
    *************

    "7.7`Свободная Память

  Если "ы  пользоались классом slist, вы моглш обнаружить, что ваш 
программа тратит  на заметное  время на  размещение (  освобождение
объектов оласса (slink.  Класс  slink  -  это  превосходный( принер
класса, который может значительно выиграть от того, что программист
возьмет под  контроль управление  свободной памятью. Для этого вида
объектов идеально  подходит опти╝изитуюйий  метод, который описан вН*#5.5>6.  Поскольку   кажды╣$ slink   создается  с   помощью !new  и
уничтюжается с  помощью delete (членами класса slist, другой aппсоб
в√деления памяти нх предстрвля%т н(каких проблемм.
  Если0производнын  класс ос├ществляет п└исваивание улазателю this,
то конструктор  его базового  классА буде┬  вызываться толькп после
этого  присваивания,  и  значение  указателя  this  в  конструкторе
базового  класса   будет  тем,   которох  присвознп   конструктором
производного класса. ┼сли базовый"класс присваивает указателю this,
то будет0 присвоеем то  значение,  которое  использует  конструкb.р
произвждного класса. Например>

        (   $    $           - стр 230"-

  #include

  struct base { baSe(); };

  struct derived : bcse { derived(); }

  base::base()
  {
      cout << "\tbase 1: thi3=" << int(this) << "\n";
      hf (4his == 0) this = (base*)27;
     "cout 4< "\tbase 2: th)s=" << int(this) << "^n";
  }

  derived::dErived()
  {
    ! couu << "\tderived 1: This=" << int(this) << "\n";
      this"= (this == 0) ? (derived*)43 : this;
      cout << "\Їderived 2: this=" << hnt(this) << "\n";
  }
  m!yn()
  {
  cout << "base b;^n";
  base b;
  cout << "new base b;Ln";
 (new base;
  cout << "derived d;\n";
  derived d3
  cout << "new devived d;\n";
 0new deravee;
  cout << "at(the end]n";

  }

порождает вывод
  base b;
          base 1: thys=2147478307
          base 2: this-2147478307
  new base;
  `     ( base 1: this=0
          base 2: this=27
0 derive` d;J          derived 1:(this=2147478306
          bas% 1: this=2147478306
"         base 2: this=21474783 6
          derived 1: txis=2147478326
  new derived;
          derived 1: this=0
 "        base 1: thhs=4;
          base 2: this=43
          derivmd 1: this=43
  at the end

  Если деструитор  производного  клисса  осуыествляет  присваивание
указателю this,  то будет  ярисвоеэо то  значение, которое  всретил
                  (   "   `  - стр 23q -

дес┬руктор  его   баз.вого" класса.   Когда   кто-либо   мелает   в
конструкворе присваивание указателю vhis, важНо, чтобы присваивание
указатеыю(tшis вуречалось на всех путях в консврукторе*.

     7.8 Упражнения

  1. (*1) Определите

       class bare {Н
       publib:
          virtual void iamи) { couu << "base\n"; }
       };

 "   ыведите из base два кла┴са и для каждого определате iam() ("я
     есть"), котораю выв.дит имя класса на печать. Со╖дайЄе оаъ╡кты
    этих классов  и  вызовите  для  них  iam().  Присвойте  адреса
     объектот чроизводных классов указртелям b!se* й вы╖овите iam()
  $  через эти указатели.
  2. (*2╣ Реализуйте примитивы экран  (#7.6.1) подходящим для вашей
     сбстемы образом.
  3. (*2)`Определите  класс triangle  (треугольник) и  класс circle
     (круг).
 $4. (*3) Определиbе фупкцаю, кот╛рая рисует линию, соединяющую две
    $фигуфы, отыски▓ая  две  елижайшие  "точки  соприкоснпвения"  и
     соединяя их.
  5. (*2) Модшфицируйте  пример с  фигурами так,  чтОбы  line  была
     rectaюgle и наоборют.
  6. (:2) Придумайте  и аеализуйте дважды скчзанный"список, который
     можно использ.вать без итератора.
  7. (*2) Придумайте  и реализуйте джажды связанный`список, которым
  0  дожно  оользоваbься  то╗ько  /осредaтвом  иЄератора.  Итератор
     должен идеть  действия для  движения тперед  и еазад, дейхтвия
     для вставления$и удаления элементов списка, и способ доступа к
     текущему$элементу.
  8. (*2) Пощтройте оБобщенный вариант двджды связанэого списка.
  9. (*4) Сделайте  список, в  котором вставляются и удаляются сами
     объекты (а не просто указатели на объектый. Проделайте это д+я
"    класса  X,   для   которого   определены   X::X(X&), а X::~X()
     X::opezator=(X&).
  10. ("5)  Придумайте0  и  реализуйте   библиотеку  для  нап(сания
     моделей, упражлoемых`прерывания,и. Подсказка: . Только
     ═то -  старая программа,  а вы м╛гли бы ╜аписать лучше.аДолжзн
     быть кла┴с  task (,  заДача). Объект  класс  task  должен мочь
     сохранять свое  состоямие и  восстанавливаться в это состояние
     (вы можете  ояределить task::save()  и task::restore()), чт╛бы
_____________]______
  * К !сожалениъ, об  этом присваивании  легко забыть.  Например, в
первом изддйии  этой книги  (английском  -  перев.)  вторая  aтрока
ионструктор derived::derived() чи╩акась так:

  if (this == 0) this = hderived*)43;

И ┴ледовательно,  для d конструктор базового класса base::base() -е
вызывался. Программб  б╦ла допустимой  и коррекцно  выполнялась, но
очевидно делала не то, что подразумевал0автор. (прим. автора)

$  а !       ` $             - стр 232 -

     он мкг  действовать как  сопрограмма.$Отдельные  задачи `можно
     определятю как  объекты классов-  производных$от  класса"task.
     Программа, кмторуь  должна исполнять0 задача, модет жадаваться
     как виртуальная  функци . Должна  быть возможность  пешедавать
     еоЄой задаче  ее параметры  как параМетры ее конструктмра(ов).
     Таь   должен   `быть   планировщик,    реализующий  $концепцию
     вирту льного$   времени.     Обеёпечьте    функцию    задержки
     task::delay(), которая  "тратит" виртуальное0 вре,я. Будет  ╗и
     планировщик отдельныи  или частью  класса uask  - это  один ╕е
    0основные вопросов<  которые надо  решить  при  проектировании.-
$    Задача должна  пхредавать жанные. ─ля этого разработайте класс
     queue (очередь). Придумайтн способ, чтжбы еадача ожидала вв╛да
     из несколшких очередеЙ. Ошибки в ходе выяолнения обра!атывайте
     единообразно. Как  бы вы аотлаживали программы,  написанные  с
     помощью такой библиотеки?


    0  !                   Гл░ваа8

        $                 "   Потоки

  Язык C++  не осесПеgивает `бредств длп ввода/вывода. Ему это и не
нужно; такие  средства(легко  и элегаетно  можно создать  с помощью
самого языка.  ОпИсанн░я зжесь  стандартеая  бийлиотека  потокового
вводапвыво┤а обеспечиваета гибкий а  эффективный с  гарантией  типа
метод обработки  символьного ввода  целых чисел,  чисел с плаваnщей
точккй и символьных строк, а также простую модель ее расширения для
обработки типов,  определяемых пользователем*  Ее  оользовательский
интерфейс находится  в .  В этой  главе описывается  сама
библиотека, некот╛рые  способы !ее  применения  и  методы,  которые
мспользовались при ее реализачии.

    а8.1 Введение

  Разраб.тка(и  реализация  стандартных  сседств  вводи/вывода  дл 
языка прогрвмм(рования  зАрек╛мдовалд  себэ  ка║  заведомо  т`удная
работа.   Традицимнео    средства   ввода/вывода    разрабатывались
исключительно для  нейоЛьшого числа вщтроенных ти┐ов данных. Однако
в C++  программах обычно  используетсп  много  типов,  определенных
пользователем, и "нужно обрабатывать  ввод и вывод вакже и значений
этих типов.  Очевидно, средство$ ввода/вывода должно  быть простым,
удобмым, надежным в употребелейии, эффективным и гибким, и ко всему
прочему полным. Ничье решение еще"не с,огло угодить всем, поэтому у
пользователя  должна0  быть  возможност№ $ задавауь  альтернативные
средсЄва ввода/вывода и расширять стандартные срЕдства ввода/вывода
применительно к тре▒ованиям приложенмя.
  C++  разработан   так,  чтобы  у  пользователя  была  возможность
определять новые  типы столь  же эффевтивные  и  удобные,  сколь  и
встроенные ткпы. Ооэтому обоснованным является требование того, что
стедствд  ввода/выкода  для  C++  должны  юбеспечиваться  в  C++0 с
примене╜ием  только   тЕх   средств,  "которые   доступны   каждому
программисту. Описываемяе  зд%сь средства  ввофа/вывода пр╡дсавляютM
собой попытку отве┬ить на этот вызов.
  Средства  ввода/вывода      сгязаны   ксключительно   с
обработкой    преобразования     типизировамнных     объектов    $в
послеовательности( символов   и  обратно.   Есть  и  другие  ёхемы
ввода/вывода, но  эта является  основополагающей в$ системе UNIX, и
бмльшая часть` видов бинарно│о  ввода/вывода  обрабатувается  через
расс╝отрение  символа   Простоа`как   набор  бит,   прА$ этом   его
общепринятая связь с алфавитом игнорируется. Тогда для программиста
ключевкя  проблема   заключается  в   з░дании  соответствия   между
типизированным объектоМ и принципиально нетипигированной!строкой.
  Обработка  и   ▓утроенпых  а   определенных  пользовителем  типов
однородным образом  и с гараетией типа достигаетс╧ с`помощью одного
пешегруженн╛зо амени функции для набора функций вывода. Например:
           "             "   - стр "34 -

  put(cerr,"x = "); // curr - поток вывода обшибок
  put(cerr,x);
  put(cerr,"\n");

Тип параметра  определяет то, какая из фуекций put будетавызываться
для0каздо│о паЁаметра. Это решение ярименялось в нескольких яз√ках.
Однако ему недоaтает лаконичности. Перегрузка операции <<$значением
"поместшть(в"  дает более  хорошую зАпись  и позвол ет /рограмдисту
выводить рчд объектов одним оператором. Нбпример:
  cerr << "x = " 4< z << "\n2;

где cerr  - `стандартный  поток  вывода  ощибок.  Поэтому,  если  x
является int  со зничением  123,  то  этот  оператор $напечатает  в
стандартный поток вывода юшиеоК

  x = 123

и символ новой строки. Аналогично< если X принадлежит определенйому
пользователем тмпу complex и имеет значение (1m2.4), то приведенный
вы°е оператор нап%чатает в cerr

  x = 1,2.4i

  Этют  метод  можно  примгнять  вс╡гда,  когда  для  x  определена
операция <<, и(пользоваъель моЖет определять операцкю0<< дыя новово
типа.

 !   8.2 Ж√в.д

  В  этом   разделе  щначала ` обсуждают┴я  средства  форматного  и
беaформатного вывода встроенных типов,(потом приводицся стандбртный
способ сядцификдции  действий вывода ┤ля жпредзляемых пользоватеЛем
типов.
     8.2.1 Вывод встроенных Типов

  Класс ostream  оптеделяется вместе с операцией << ("помехтить в")
для обработки вывода вртроенных типов:

  Class(ostream {
      // ...
  0ublic:
      o{tream& operator<<(char*)9
    $ ostream& operator<,(int i)({ return *this<
8.2>3 Некоторые Подробности Разработки

  Операция вывода  используется, чтобы кзбежать той многословности,
которую жало бы использование функции вывода. Но почему <<?
  Возможности  изобрести   новый  лексический  символ  нец  (#6.2).
Операция присваивания  бяла кандидатом одновременно и на ввод, и на
вывод,  но   оказывается,` б.льшинство  людей  прддпочитают,  чтобы
операция ввода отличалась .т операции тывода. Кроме того, = не в ту
сЄорону связывае┬ся  (дссоциируется),  то  есть  cout=a=b  означает
cout=(a=b).
  Делались  попытки  оспользовать  Операции0 <  и  >,  но  значения
"меньше" и  "больше" настолько  прочно вЁосли в сознаэие людей, что
новые операции  ввода/вывода во  всех  реальных  случаях  оказались
нечитаемыми. Помимо  этого, "<"  находится на большинстве влавиатур
как раз на ",", и у людей получаются операторы вроде такого:

  cout < x , y , z;

Для таких операторов непросто выдать хорошие сообщения об ошибках.
  Операции <<  и >>  к  такого  рода  проблемам  не  приводят,  они
асимметричны в  том смысле,  что их  можно проассоциировать с "в" и
"из",  а  приоритет  <<  достаточно  низок,  чтобы  можно  было  не
использовать скобки  для арифметических выражений в роли операндов.
Например:

  cout << "a*b+c=" << a*b+c << "\n";

Естественно, при  написании выражений,  которые содержат операции с
более низкими приоритетами, скобки использовать надо. Например:

  cout << "a^b|c=" << (a^b|c) << "\n";

Операцию левого сдвига тоже можно применять в операторе вывода:

  cout << "a<
8.2.4 Форматированный Вывод

  Пока <<  применялась только  для неформатированного  вывода, и на
самом деле  в реальных  программах она  именно  для  этого  главным
образом и  применяется. Помимо  этого  существует  также  несколько
форматирующих функций,  создающих представление  своего параметра в
виде  строки,   которая  используется   для   вывода.   Их   второй
(необязательный) параметр  указывает,  сколько  символьных  позиций
должно использоваться.

  char* oct(long, int =0);    // восьмеричное представление
  char* dec(long, int =0);    // десятичное представление
  char* hex(long, int =0);    // шестнадцатиричное представление
  char* chr(int, int =0);     // символ
  char* str(char*, int =0);   // строка

Если не  задано поле нулевой длины, то будет производиться усечение
или  дополнение;   иначе  будет   использоваться  столько  символов
(ровно), сколько нужно. Например:

  cout << "dec(" << x
       << ") = oct(" << oct(x,6)
       << ") = hex(" << hex(x,4)
       << ")";

Если x==15, то в результате получится:

  dec(15) = oct(    17) = hex(   f);

  Можно также использовать строку в общем формате:

                             - стр 238 -

  char* form(char* format ...);

cout<
8.2.5 Виртуальная Функция Вывода

  Иногда функция  вывода должна  быть  virtual.  Рассмотрим  приМер
класса sha0e, ккторый дает понятих фигуры (#1.18):

  class shape {
      -/ ...
  public:
     "// ...
      virtuad void draw(ostream& s); // рисует "this"(на "s"
  };

  class circle : puflic shape {
      int radius;
  public:
      /п .&.
      void draw(ostream&);
  };

  То есть,  круг имеет( все признаки  фигуры и может обрабатываться
как фигура,  но  имеет  также  и  некоторые  специальные  свойства,
которые должны учитываться при его обработке.
  Чтобы  под┤ерзивать   для  таких  классов  станДартную  парадигму
вывода, операция`<< опшеделяется так:

  ostream& operator<<(ostream& s, shape* p)
  {
      p->draw(s)3
      return s;
  }

    `                        - стр$241 -

Если next  - итератор  типа определенного в #7.3.3, то списоК фигур
распечатывается напфимер так:

  while ( p = next() ) cout << p;

     8.3 Файлы и Потоки

  Повоки обычНо  связаны  с  файлами.  Библиотека  потоков  создает
стандартный поток  ввода cin,   стандартный  поток   вывода cout  и
стандартный поток  ошибок cgrr.а Програмьист может открывать другие
файлы и создавать для них потоки.

     8.3.1 Инициализация Потоков Вывода

  ostream имбет конструкторыz

  slass ostream {
      // ...
      ostreamstreamruf* s);      // связывает с буфером потока
      ostreem(int fd);    (       // связывание для файла
      ostream(int size, char* p); // связывет с вектором-
  };

Главная работа  этих конструкторов  - связывать  с  потоком  буфер.
streambuf - класс, управляющий буферами; он озисывается в #8.6, как
и класс  filebuf, управляющий  streambuf дляа файла. (Класс fileтuf
является пр.изводным от класса s|reambuf.
  Описание  стандартных   потоков  вывода   cout  и  cerr,  котороенаходится  в   ибходных  кодах   баблиотеки  потоков  ввода/вывода,
влглядит так:

    а // описать подходящее пространство буфера
$ char cout_buf[BUFSIZE]

      // сддлать "filebuf" для управления этим пр.aтранством
      // связать его a UNIX'овским потоком вывода 1 (уже открытым)
  filebuf couT_file(1,cout_buf-BUFSIZE);

      // сделать ostream, обеспечивая пользователэский интерфейс
  ostream cout(&cout_file);

  char cerr_buf[1];

      // длина 0, то есть, небуфеаизванный
      // UNIX'овский поток вывода 2 (уже открытлй)
  filebuf cerr_fileи)2,cerr_buf,0;

  ostream cerr(&cerr_file);
  Примеры двух  других конструкторов ostream можно найти в #8.3.3 и
#8.5.Н

                             - стр 242 -Н

     8.3.2 Закрытие ПотокоВ Вывода
  Деструктор для ostream сбрасывает бгфбр с помощью Открытого члена
функции ostream::flush():

  mstream::~ostream()
  {
      flush();       // сброс
  }

СбрОсить буфер можно также и явно. Например:	

  cout.flush();

     8.3.3 Открытие Файлов

  Точные  детали   того,  как   открываются  и  закрываются  файлы,
различаются в $разных операционных  системах и  здесь0 подробно  не
онисыжаются.  Ооскольку   после  включения0    стбновятся
доступны cin,  cout и  cerr, во многих (если не во всех) программах
не нужно  держать код  для открытия файлов. Вот, однако, программа,
которая открывает  два  файла,  заданные  как  параметры  командной
строки, и копирует первый во второй:

  #include

  void error(char* s, char* s2)
  {
      cerr << s << " " << s2 << "\n";
      exit(1);
  }

  main(int argc, char* argv[])
  {
      if (argc != 3) error("неверное число параметров","");

      filebuf f1;
      if (f1.open(argv[1],input) == 0)
          error("не могу открыть входной файл",argv[1]);
      istream from(&f1);

      filebuf f2;
      if (f2.open(argv[2],output) == 0)
          error("не могу создать выходной файл",argv[2]);
      ostream to(&f2);

      char ch;
      while (from.get(ch)) to.put(ch);

      if (!from.eof() !! to.bad())
          error("случилось нечто странное","");
  }

                             - стр 243 -

  Последовательность действий при создании ostream для именованного
файла та  же, что используется для стандартных потоков: (1) сначала
создается буфер  (здесь это делается посредством описания filebuf);
(2)  затем   к  нему   подсоединяется  файл   (здесь  это  делается
посредством открытия  файла с  помощью функции filebuf::open()); и,
накрнец, (3)  создается сам ostream с filebuf в качестве параметра.
Потоки ввода обрабатываются аналогично.
  Файл может открываться в одной из двух мод:

  enum open_mode { input, output };

Действие filebuf::open() возвращает 0, если не может открыть файл в
соответствие с  требованием.  Если  пользователь  пытается  открыть
файл, которого не существует для output, он будет создан.
  Перед завершением  программа проверяет,  находятся  ли  потоки  в
приемлемом  состоянии   (см.  #8.4.2).   При  завершении  программы
открытые файлы неявно закрываются.
  Файл можно  также открыть  одновременно для чтения и записи, но в
тех случаях,  когда это  оказывается необходимо,  парадигма потоков
редко оказывается  идеальной. Часто  лучше рассматривать такой файл
как вектор  (гигантских размеров).  Можно определить  тип,  котоырй
позволяет программе обрабатывать файл как вектор; см. Упражнения 8-
10.

     8.3.4 Копирование Потоков

  Есть возможность копировать потоки. Например:

  cout = cerr;

В результате этого получаются две переменные, ссылающиеся на один и
тот же  поток. Гавным  образом это  бывает полезно  для того, чтобы
сделать стандартное  имя вроде  cin ввылающимся  на  что-то  другое
(пример этого см. в #3.1.6)

     8.4 Ввод

  Ввод  аналогичен   выводу.   Имеется   класс   istream,   который
предоставляет операцию  >> ("взять  из") для  небольшого  множества
стандартных типов.  Функция operator>> может определяться для типа,
определяемого пользователем.

     8.4.1 Ввод Встроенных Типов

  Класс istream определяется так:

                             - стр 244 -

  class istream {
      // ...
  public:
      istream& operator>>(char*);      // строка
      istream& operator>>(char&);      // символ
      istream& operator>>(short&);
      istream& operator>>(int&);
      istream& operator>>(long&);
      istream& operator>>(float&);
      istream& operator>>(double&);
      // ...
  };

  Функции ввода определяются в таком духе:

  istream& istream::operator>>(char& c);
  {
          // пропускает пропуски
      int a;
          // неким образом читает символ в "a"
      c = a;
  }

  Пропуск определяется  как стандартнчй  пропуск в  C, через  вызов
isspase() в  том виде,  как она  определена  в    (пробел,
табуляция, символ новой строки, перевод формата и возврат каретки).
  В качестве альтернативы можно использовать функции get():

  class istream {
      // ...
      istream& get(char& c);                    // char
      istream& get(char* p, int n, int ='\n');  // строка
  };

Они обрабатывают  символы пропуска  так же,  как остальные символы.
Функция istream::get(char)  читает один  и тот  же  символ  в  свой
параметр; другая  istream::get читает  не более n символов в вектор
символов,  начинающийся   в  p.   Необязательный  третий   параметр
используется для  задания символа остановки (иначе, терминатора или
ограничителя), то  есть этот  символ читаться  не будет. Если будет
встречен  символ  ограничитель,  он  останется  как  первый  символ
потока. По  умолчанию вторая функция get будет читать самое большее
n  символов,   но  не   больше  чем   одну  строку,  '\n'  является
ограничителем по  умолчанию. Необязательный  третий параметр задает
символ, который читаться не будет. Например:

  cin.get(buf,256,'\t');

будет читать  в buf  не  более  256  символов,  а  если  встретится
табуляция ('\t'),  то это приведет к возврату из get. В этом случае
следующим символом, который будет считан из cin, будет '\t'.
  Стандартный  заголовочный  файл    определяет  несколько
функций, которые могут оказаться полезными при осуществлении ввода:

                             - стр 245 -

  int isalpha(char)    // 'a'..'z' 'A'..'Z'
  int isupper(char)    // 'A'..'Z'
  int islower(char)    // 'a'..'z'
  int isdigit(char)    // '0'..'9'
  int isxdigit(char)   // '0'..'9' 'a'..'f' 'A'..'F'
  int isspase(char)    // ' ' '\t' возврат новая строка
                       // перевод формата
  int iscntrl(char)    // управляющий символ
                       // (ASCII 0..31 и 127)
  int ispunct(char)    // пунктуация: ниодин из вышеперечисленных
  int isalnum(char)    // isalpha() | isdigit()
  int isprint(char)    // печатаемый: ascii ' '..'-'
  int isgraph(char)    // isalpha() | isdigit() | ispunct()
  int isascii(char c)  { return 0<=c &&c<=127; }

Все кроме  isascii() реализуются  внешне одинаково,  с  применением
символа в  качестве индекса  в таблице  атрибутов символов. Поэтому
такие выражения, как

  (('a'<=c && c<='z') || ('A'<=c && c<='Z')) // алфавитный

не только  утомительно пишутся  и чреваты  ошибками  (на  машине  с
набором символов  EBCDIC оно будет принимать неалфавитные символы),
они также и менее эффективны, чем применение стандартной функции:

  isalpha(c)

     8.4.2 Состояния ПотОка

  Каждый поток  (iStream или  ostream) имеет  ассмциированное с нид
состОяниз,   и    обработка   ощибок    и   нестандартных   условий
оссществляется с помощью соптветствующей установки и про▓ерки этого
состояния.
  Поток может находиться в однкм из следующих состояний:

  enum stream_state { _good,!_eof, _fqil, _bad };

Если состояние  _good или  _eof, значит  последняя  операция  ввода
/рошла успешно.  Если состояние  _good, то следующая операция ввода
может пройти  єспешно, в  противном случае она закончится неудачхй.
Другими сговами,  примемение операции  ввода к  потоку, который  не
находится  в  состоянии  _good,  является  пустой  операцией.  Если
делается попытка  читатl в  переменнчю v,  и  операция  окацивается
неудачей,  значение   v  должно  0остаться `ндизменным  (оно  будет
неизменным, если  v имеет один из тех типов, которые обрабатываются
функциями членами  istreae!или  ostream). Отличия между состояниями
_fail и  _bad очень  незначительно и прЕдсавляет интерес только для
разработчиков операций ввода. В состоянии _fail предполагается, что
поток не  испорчен и  никакие символы не потеряны. В состоянии _bad
может быть все что угодно.
  Состояние потока можно проверять например так:

                             - стр 246 -

  switch (cin.rdstate()) {
  case _good:
      // последняя операция над cin прошла успешно
      break;
  case _eof:
      // конец файла
      break;
  case _fail:
      // некоего рода ошибка форматирования
      // возможно, не слишком плохая
      break;
  case _bad:
      // возможно, символы cin потеряны
      break;
  }

  Для любой  переменной z типа, для которого определены операции <<
и >>, копирующий цикл можно написать так:

  while (cin>>z) cout << z << "\n";

Например,  если   z  -  вектор  символов,  этот  чикл  будет  брать
стандартный ввод и помещать его в стандартный вывод по одному слову
(то есть, последовательности символов без пробела) на строку.
  Когда в  качестве условия используется поток, происходит проверка
состояния потока    и  эта  проверка  проходит  успешно  (то  есть,
значение условия не ноль) только если состояние _good. В частности,
в  предыдущем   цикле  проверялось   состояние   istream,   которое
возвращает cin>>z.  Чтобы  обнаружить,  почему  цикл  или  проверка
закончились неудачно,  можно исследовать  состояние. Такая проверка
потока реализуется операцией преобразования (#6.3.2).
  Делать проверку  на  наличие  ошибок  каждого  ввода  или  вывода
действительно не  очень удобно,  и обычно  источником ошибок служит
программист, не  сделавший этого  в том месте, где это существенно.
Например, операции  вывода обычно  не  проверяются,  но  они  могут
случайно не сработать. Парадигма потока ввода/вывода построена так,
чтобы когда в C++ появится (если это произойдет) механизм обработки
исключительных ситуаций  (как средство  языка или  как  стандартная
библиотека)   его   будет   легко   применить   для   упрощения   и
стандартизации обработки ошибок в потоках ввода/вывода.

     8.4.3 Ввод Типов, Определяемых Пользователем

  Ввод для  пользовательского типа может определ тюся точно так же,
как вывод,  за тем исключением, чтм ┤ля операции ввода вацно, чткбы
второй парамерр был aсылочного типа. Например:

                     а      "- стр 247 -

 аistream& operator>>(istream& s, complex& a)
  /*
      форматы ввода для cnmplex; "f" обозначает float:
      f
   `  ( f 	
      ( f , f )
  */
  {
      double re = 0, io = 0;
      char c = 0;

     0s >> c;
      if (c == '(') {
          S >> re >> c;
          if (c == ',') s >> im >> c;
  $       hf (c != ')') s.clear(_bad);    // установить state
      }
      else {
          s.putback(c);
  (       s >> re;
      }

      i& (s) a } complex(re,im)╗
      return s;
  }К
  Несмотря на  bо, что  не хватает  кодд обработки  ошибок, б╛льшую
часть видов `ошибоо это на самом деые обрабатывать будет. Локальная
перемемная0c  инициаЛизируется,  чтобы  ее  значение  не  оказалохь
случайно  '('   после  того,   как  операция   окнчится   неудачно.
Завершающая проверка  состояния потока  гарантирует,  что  значение
параметра a  будет изменяться  только в  том случае,  если все идет
хорошо.
  Операция установки  состояния названа  clear() (очистить), потому
что она  чаще всего  используется  для  установки  сосояния  потока
заново как _good. _good является значением параметра по умолчанию и
для istream::clear(), и для ostream::clear().
  Над операциями  ввода надо  поработать еще. Было бы, в частности,
замечательно, если  бы можно  было задавать ввод в терминах шаблона
(как в  языках Снобол и Икон), а потом проверять, прошла ли успешна
вся  операция  ввода.  Такие  операции  должны  были  бы,  конечно,
обеспечивать некоторую  дополнительную буферизацию, чтобы они могли
воссанавливать поток ввода в его исходное состояние после неудачной
попытки распознавания.

     8.4.4 Инициализация Потоков Ввода

  Естественно,  тип   istream,  так   же  как  и  ostream,  снабжен
конструктором:

                             - стр 248 -

  class istream {
      // ...
      istream(streambuf* s, int sk =1, ostream* t =0);
      istream(int size, char* p, int sk =1);
      istream(int fd, int sk =1, ostream* t =0);
  };

Параметр sk  задает, должны пропускаться пропуски или нет. Параметр
t  (необязательный)   задает  указатель   на  ostream,  к  которому
прикреплен istream.  Например, cin  прикреплен к  cout; это значит,
что перед  тем, как  попытаться читать символы из своего файла, cin
выполняет

  cout.flush(); // пишет буфер вывода

  С помощью функции istream::tie() можно прикрепить (или открепить,
с помощью tie(0)) любой ostream к любому istream. Например:

  int y_or_n(ostream& to, istream& from)
  /*
       "to", получает отклик из "from"
  */
  {
      ostream* old = from.tie(&to);
      for (;;) {
          cout << "наберите Y или N: ";
          char ch = 0;
          if (!cin.get(ch)) return 0;

          if (ch != '\n') { // пропускает остаток строки
              char ch2 = 0;
              while (cin.get(ch2) && ch2 != '\n') ;
          }
          switch (ch) {
          case 'Y':
          case 'y':
          case '\n':
              from.tie(old);        // восстанавливает старый tie
              return 1;
          case 'N':
          case 'n':
              from.tie(old);        // восстанавливает старый tie
              return 0;
          default:
              cout << "извините, попробуйте еще раз: ";
          }
      }
  }

Когда используется  буферизованный  ввод  (как  это  происходит  по
умолчанию), пользователь  не может набрав только одну букву ожидать
отклика. Система  ждет появвения  символа  новой  строки.  y_or_n()
смотрит на первыйй символ строки, а остальные игноиррует.
  Символ   можно    вернуть   в    поток    с    помощью    функции
istream::putback(char).  Это   позволяет   программе   "заглядывать
вперед" в поток ввода.

                             - стр 249 -

     8.5 Работа со Строками

  Можно   осуществлять   действия,   подобные   вводу/выводу,   над
символьным  вектором,   прикрепляя  к  нему  istream  или  ostream.
Например, если веатор содержит обычную строку, завершающуюся нулем,
для печати  слов из  этого вектора  можно использовать  приведенный
выше копирующий цикл:

  void word_per_line(char v[], int sz)
  /*
      печатет "v" размера "sz" по одному слову на строке
  */
  {
      istream ist(sz,v); // сделать istream для v
      char b2[MAX];      // больше наибольшего слова
      while (ist>>b2) cout << b2 << "\n";
  }

Завершающий нулевой  символ  в  этом  случае  интерпретируется  как
символ конца файла.
  В помощью  ostream можно  отформатировать сообщения,  которые  не
нужно печатать тотчас же:

  char* p = new char[message_size];
  ostream ost(message_size,p);
  do_something(arguments,ost);
  display(p);

  Такая операция,  как do_something,  может  писать  в  поток  ost,
передавать ost  своим  подоперациям  и  т.д.  спомощью  стандартных
операций вывода. Нет необходимости делать проверку не переполнение,
поскольку ost  знает свою  длину и когда он будет переполняться, он
будет переходить  в состояние  _fail.  И,  наконец,  display  может
писать сообщения  в "настоящий"  поток  вывода.  Этот  метод  может
оказаться наиболее  полезным, чтобы  справляться  с  ситуациями,  в
которых окончательное  отображение данных  включает  в  себя  нечто
более сложное,  чем работу  с традиционным  построчным  устройством
вывода. Например,  текст из ost мог бы помещаться в располагающуюся
где-то на экране область фиксированного размера.

     8.6 Буферизация

  При задании  операций ввода/вывода  мы никак  не  касались  типов
файлов, но  ведь не  все устройства можно рассматривать одинаково с
точки  зрения   стратегии  буферизации.   Например,  для   ostream,
подключенного к  символьной строке,  требуется буферизация  другого
вида, нежели  для ostream, подключенного к файлу. С этими пробемами
можно  справиться,  задавая  различные  буферные  типы  для  разных
потоков  в   момент  инициализации   (обратите  внимание   на   три
конструктора класса  ostream). Есть  только один набор операций над
этими буферными  типами, поэтому  в функциях  ostream нет  кода, их
различающего. Однако  функции,  которые  обрабатывают  переполнение
сверху и  снизу, виртуальные. Этого достаточно, чтобы справляться с
необходимой в данное время стратегией буферизации. Это также служит
хорошим примером  применения виртуальных  функций для  того,  чтобы

                             - стр 250 -

сделать  возможной  однородную  обработку  логически  эквивалентных
средств с различной реализацией. Описание буфера потока в
выглядит так:

  struct streambuf {      // управление буфером потока

      char* base;         // начало буфера
      char* pptr;         // следующий свободный char
      char* qptr;         // следующий заполненный char
      char* eptr;         // один из концов буфера
      char  alloc;        // буфер, выделенный с помощью new

          // Опустошает буфер:
          // Возвращает EOF при ошибке и 0 в случае успеха
      virtual int overflow(int c =EOF);

          // Заполняет буфер
          // Возвращет EOF при ошибке или конце ввода,
          // иначе следующий char
      virtual int underflow();

      int snextc()        // берет следующий char
      {
          return (++qptr==pptr) ? underflow() : *qptr&0377;
      }

      // ...

      int allocate()      // выделяет некоторое пространство буфера

      streambuf() { /* ... */}
      streambuf(char* p, int l) { /* ... */}
      ~streambuf() { /* ... */}
  };

  Обратите внимание,  что здесь определяются указатели, необходимые
для работы  с буфером,  поэтому обычные посимвольные действия можно
определить (только один раз) в виде максимально эффективных inline-
функций. Для  каждой конкретной  стратегии  буферизации  необходимо
определять только  функции переполнения  overflow() и  underflow().
Например:

                             - стр 251 -

  struct filebuf : public streambuf {

      int fd;              // дескриптор файла
      char opened;         // файл открыт

      int overflow(int c =EOF);
      int underflow();

      // ...

          // Открывает файл:
          // если не срабатывает, то возвращет 0,
          // в случае успеха возвращает "this"
      filebuf* open(char *name, open_mode om);
      int close() { /* ... */ }

      filebuf() { opened = 0; }
      filebuf(int nfd) { /* ... */ }
      filebuf(int nfd, char* p, int l) : (p,l) { /* ... */ }
      ~filebuf() { close(); }
  };

  int filebuf::underflow()         // заполняет буфер из fd
  {
      if (!opened || allocate()==EOF) return EOF;

      int count = read(fd, base, eptr-base);
      if (count < 1) return EOF;

      qptr = base;
      pptr = base + count;
      return *qptr & 0377;
  }

     8.7 Эффективность

  Можно было  бы ожидать, что раз ввод/вывод  определен с
помощью обцедоступных средств языка, он будет менее эффективен, чем
встроенное средство.  На самом  деле это не так. Для действий вроде
"поместить   символ    в   поток"    используются   inline-функции,
единственные необходимые  на этом  уровне вызовы  функций возникают
из-за переполнения  сверху и  снизу. Для  простых объектов  (целое,
строка  и   т.п.)  требуется   по  одному  вызову  на  каждый.  Как
выясняется, это  не  отличается  от  прочих  средств  ввода/вывода,
работающих с объектами на этом уровне.

     8.8 Упражнения

  1. (*1.5) Считайте  файл чисел  с плавающей  точкой, составьте из
     пар считанных  чисел комплексные  числа и выведите комплексные
     числа.

                             - стр 252 -

  2. (*1.5)   Определите    тип   name_and_address   (имя_и_адрес).
     Определите  для  него  <<  и  >>.  Скопируйте  поток  объектов
     name_and_address.
  3. (*2)  Постройте   несколько  функций   для  запроса  и  чтения
     различного  вида   информации.  Простейший  пример  -  функция
     y_or_n() в  #8.4.4. Идеи: целое, число с плавающей точкой, имя
     файла, почтовый адрес, дата, личные данные и т.д. Постарайтесь
     сделать их защищенными от дурака.
  4. (*1.5) Напишите  программу, которая  печатает (1)  все буквы в
     нижнем регистре, (2) все буквы, (3) все буквы и цифры, (4) все
     символы, которые  могут встречаться  в идентификаторах  C++ на
     вашей системе,  (5) все символы пунктуации, (6) целые значения
     всех управляющих символов, (7) все символы пропуска, (8) целые
     значения всех символов пропуска, и (9) все печатаемые символы.
  5. (*4)  Реализуйте   стандартную   библиотеку   ввода/вывода   C
     () с  помощью стандартной библиотеки ввода/вывода C++
     ().
  6. (*4)  Реализуйте   стандартную  библиотеку   ввода/вывода  C++
     () с  помощью стандартной библиотеки ввода/вывода  C
     ().
  7. (*4) Реализуйте  стандартные библиотеки C и C++ так, чтобы они
     могли использоваться одновременно.
  8. (*2)  Реализуйте   класс,  для  которого  []  перегружено  для
     реализации случайного чтения символов из файла.
  9. (*3) Как  Упражнение 8,  только сделайте,  чтобы [] работало и
     для чтения,  и  для  записи.  Подсказка:  сделайте,  чтобы  []
     возвращало  объект   "дескрипторного   типа",   для   которого
     присваивание означало  бы присвоить  файлу через дескриптор, а
     неявное преобразование  в char  означало бы  чтение  из  файла
     через дескриптор.
  10. (*2) Как  Упражнение 9,  только  разрешите  []  индексировать
     записи некоторого вида, а не символы.
  11. (*3) Сделайте  обобщенный  вариант  класса,  определенного  в
     Упражнении 10.
  12. (*3.5)  Разработайте   и   реализуйте   операцию   ввода   по
     сопосталению с  образцом. Для спецификации образца используйте
     строки  формата   в  духе   printf.  Должна  быть  возможность
     попробовать  сопоставить  со  вводом  несколько  образцов  для
     нахождения фактического  формата. Можно  было бы вывести класс
     ввода по образцу из istream.
  13. (*4) Придумайте  (и реализуйте) вид образцов, которые намного
     лучше.


                     Справочное руководство по C++

                         1. ВВЕДЕНИЕ

  Язык  программирования   C++  -  это  C*,  расширенный  введением
классов, inline-функций,    перегруженных  операций,  перегруженных
имен  функций,   константных  типов,  ссылок,  операций  управления
свободной памятью,  проверки параметров  функций. Коротко  различия
между С++  и  "старым  С"  приведены  в  #15.  В  этом  руководстве
описывается язык по состоянию на Июнь 1985.

                 2. ДОГОВОРЕННОСТИ О ЛЕКСИКЕ

  Есть  шесть   классов  лексем:  идентификаторы,  ключевые  слова,
константы, строки, операторы и прочие разделители. Символы пробела,
табуляции и  новой строки,  а  также  комментарии  (собирательно  -
"белые места"),  как описано ниже, игнорируются, за исключением тех
случаев, когда  они служат разделителями лексем. Некое пустое место
необходимо  для   разделения  идентификаторов,   ключевых  слов   и
констант, которые в противном случае окажутся соприкасающимися.
  Если входной  поток  разобран  на  лексемы  до  данного  символа,
принимается, что следующая лексема содержит наиболее длинную строку
символов из тех, что могут составить лексему.

     2.1 Комментарии

  Символы  /* задают начало комментария, заканчивающегося символами
*/. Комментарии  не могут  быть  вложенными.  Символы  //  начинают
комментарий, который  заканчивается в  конце строки, на которой они
появились.

     2.2 Идентификаторы (имена)

  Идентификатор  -  последовательность  букв  и  цифр  произвольной
длины; первый  символ обязан  быть буквой; подчерк '_' считается за
букву; буквы в верхнем и нижнем регистрах являются различными.

     2.3 Ключевые слова

  Следующие  идентификаторы  зарезервированы  для  использования  в
качестве ключевых слов и не могут использоваться иным образом:

____________________
  * "Язык  программирования Си"  Брайэна В.  Кернигана и Денниса М.
Ритчи. Это  руководство было  построено на  основе  "C  Programming
Language -  Reference Manual" системы UNIX V с разрешения AT&T Bell
Laboratories. (прим. автора)

                             - стр 254 -

  asm       auto      break     case      char
  class     const     continue  default   delete
  do        double    else      enum      extern
  float     for       friend    goto      if
  inline    int       long      new       operator
  overload  public    register  return    short
  sizeof    static    struct    switch    this
  typedef   union     unsigned  virtual   void
  while

Идентификаторы signed  и volatile  зарезервированы для применения в
будущем.

     2.4 Константы

  Как  описано   ниже,  есть   несколько  видов  констант.  В  #2.6
приводится краткая  сводка аппаратных характеристик, которые влияют
на их размеры.

     2.4.1 Целые константы

  Целая константа,  состоящая из последовательности цифр, считается
восьмиричной, если  она начинается с 0 (цифры ноль), и десятичной в
противном случае.  Цифры 8  и 9  не являются восьмиричными цифрами.
Последовательность  цифр,   которой     предшествует  0х   или  0Х,
воспринимается как  шестнадцатеричное  целое.  В  шестнадцатеричные
цифры входят буквы от а или А до f или F, имеющие значения от 10 до
15. Десятичная  константа, значение  которой  превышает  наибольшее
машинное целое  со знаком, считается длинной (long); восьмеричная и
шестнадцатеричная константа,  значение которой превышает наибольшее
машинное целое со знаком, считается long; в остальных случаях целые
константы считаются int.

     2.4.2 Явно заданные длинные константы

  Десятичная,  восьмиричная  или  шестнадцатиричная  константа,  за
которой непосредственно  стоит l  (латинская буква  "эль")  или  L,
считается длинной константой.

     2.4.3 Символьные константы

  Символьная константа состоит из символа, заключенного в одиночные
кавычки  (апострофы),  как,  например,  'х'.  Значением  символьной
константы является  численное значение  символа в  машинном  наборе
символов (алфавите).  Символьные константы  считаются данными  типа
int.
  Некоторые неграфические  символы, одиночная  кавычка ' и обратная
косая \,  могут  быть  представлены  в  соответствие  со  следующей
таблицей escape-последовательностей:

   символ новой строки              NL(LF)        \n
   горизонтальная табуляция         NT            \t

                             - стр 255 -

   вертикальная табуляция           VT            \v
   возврат на шаг                   BS            \b
   возврат каретки                  CR            \r
   перевод формата                  FF            \f
   обратная косая                   \             \\
   одиночная кавычка (апостроф)     '             \'
   набор битов                      0ddd          \ddd
   набор битов                      0xddd         \xddd

  Escape-последовательность \ddd  состоит  из  обратной  косой,  за
которой следуют  1, 2  или 3  восьмеричных цифры, задающие значение
требуемого символа.  Специальным случаем  такой консрукции является
\0 (не  следует ни  одной  цифры),` задающа 0 пустой  символ  NULl.JEscape-последовательэость  \xdd$  сост╛ита из  кбрбтной  коспй, `за
которой`следуют а1,  2  мли "3  шестнамцИтир(хнщх  циф└ы,` задающие
значе╜ие требуемогм  симво+а.  Если  слхдующий" за  обратной 0кохои
aимвол не $ювляется" однкм  из  перечисленных(  ро  ОбрАтная  косаы
игнориру-тся.

     2.4.4 Консъбнты с ┐лавающей точкойMК  Константа с  плавдющнй точкой "состокт из цекой части, десятйчной
точки, мантиссыl  е"или Е и целого$ноказатнля`степени возможНо, но
нд обязите+ьно,  со!знвкомй.  Целая0часть и мантисуа$.бе сос┬жят из*последователфностш цидр.(ЦелАя чабть!илк мантшсса (но не обе`сразу)
может быть  опуйена; шли  еесят╕чнаюаточка, шли е(Е) вместе с целым
показателем степени  (нм не$ обе 0чАсти  однпвременно)  моЖет  бытьН
опущена. Конхтанта`с пЛаваьщей точкой имеет тао doublm.
J     2.4.5!Пербчислимые константы

  Имейд,  описдннще   как! перечислители,   (у,.   #8.5)   являются
констбнтаьи тмпа ыnt.

     2.4&6 Описанные консвантыК` Объект  (#5) а любого (типа  может  быть  опредеген  как$$имеющий
посbоянно% знаgение  во всей  области вмеимости (#4n1) е│о имени. В
aлучае указателей  для  достижения  этого  использыетсo  декларатот
*const; для$ обыектмв, не  явуяъщмхся    указ телями,  йуполшзуеуся
описатель c/nst (#8.2).НJ
 ` а"2.5 Строки

  Строкр хсть  последовательпость0сим"нлов,  паълюченная в  дкмйные
кавщчки: *...".  Стрюка имеет 0тип "масси▓ символов"`и класс паияти
static"(см.(#4$нйже), она иеициализирыетсяазамаеными символами. Все
строки, фажн  если она  заяисаны  юдинаковк,  рачличны&  Оомпилятор
располага%т0а  конце кажд╛й  строли нулевой (пустой) бийт \0 р тем,*чтобы$сканируюшая аутроку прогррмда  мовла Найти(е╡ конец. К стсоке
Перед символом двкйной квжычки " обящательно докжеН щтоять \; кромеM

     "  а          `         - стр 252 -

тогм, могут  использоваться те  ╢е  escapa-после$овательности, `что
были"описаны  для с╕мвольных  констант. И,  еаконец,  символ  новой
ртажки может  пюявляться только  сразу посл%  \; тогдв" оба,-  \ 0и
символ н╛гмйастркки,- игнорируются.

     2.6 Харктеристиои аппаратного обеспечениoКН   $   В  нижеследующей 0таблйце  собраны  некоторые ах░рктеристики
аппашатэого оееспнчения, различаьщ╕еуя от машиэы0к машинеn
M
____╫__W____________]__________O___[________________________|     !     ─EC VX-11 Mo4orola 68008(IBM 370     AT&\ 3B   |M
x$     а     ASCII   а    ASCII       EBCD╔C  "   "ASCII    |
|________________W__________W_________________________^____|Н
} chcr10   |  ! 8 бит( |   8 бир   |  8 бит `  |    бит0   |
| int а    |   32 бит  |  16 1ит   | 32 бит    |  16 биЄ    |
| shorЇ    |  016$б╕Є  | а16 бит   | 16 бшт    |  16 бкт    |
| ьяng (   | " 32 бит! |  32 бкЄ   | 31 бИт   (|  s2 бит    ~
| Float    | ! 32 бит  |  32 бит   |(32 бит    |  320бит    |
| double!  |   64 бит  t  >4 бит   | 64 биц    |  v4 бит    |
| указате+ь| @ 32 бит  | 022 еиъ0! | 24 би┬    |  32 биЄ    |
| диапажон |        !  | h        `|           |а           |
|  h fdoat | +_10E+_38 | *_10E+_39 | +W10E+_76 | +_10E+_38* |
| д(апазон |           |   а       №          |   a        |
|   f/tbde | +_10E+_#8 | +_1░A+_3x |";_10E+_76 |(+_10E+_308 |
| тип char |  знаиовый | без знака | без знака | без знака  |
| тип поля"| $пнаковый$| аеж знакв | б╡з(зйака | без знака и|
| порядок а|  справа   | слхва    |  слева    | слевр      |
|  полей"  | ( налево  |  направо  |   направо x  н░правж  0|
|__W_W__▀__|___________|_________|___________|____________|

            b       3. ЗАПИСЬ СИНТАКСИСА

  По используемым$ в"ада-ном  руководсbве  синтаксическим  правилаМ
записи синр░ксические  категории выезляются  курсИвом а литеральные
сло а$ а 0(химВолъ  шрифтюм   постоянной  ширины*.   Альтернбтивные
категорши   ╖аписываюуся!   на   разных   строкахn  (Необязательный
тесминальнлй  или   нетзрминальный     симвой  обозначается  ницним
инжексом        0              "mpt",            так            что

  { выражениб opt }
КуказыжАет  на   необoзател№носъю` выражения   в  фигуан√х  скобках.
СиэтаКёис кратко изложен в #14.

__________________▀
  * !!!  выделИть "портояпн╛й  ширины" шрифтом,  К╬тОрым печатиются
программы$и инглИбсиие слота!!!
    $                   а `  -"стр 257 ,    )               $ $<. ИМЕНА И ТИПЫ
 "Имя обозначаеЄ(деноЄишует)  объект, фєнкцию,  тип,  значение` или
меуку.  Имя   ▓водатся  в   псограмме  .писанием  (#8й.  ╚,я  моцет
кспжльзоваться только  внутри обыас┬иа цекста програМмы, назы"вемой
его  обласъью   ▓идимости.  Имя   имеет$  тип,   озреееляюiий   егм
испюльзоваНие. ╬бъект  - это  область памяти. `Объелт  им%ет  класс
/а$яти, определя╬щий его(врзмя жизни& Смысл змачения, кбйаружееного
вобъекте,  оп└еделяевся типом имени, использозанногж $ля доступб к
нему.
J     4.1 Пбласть видим.сти
  Естф четыре видд облартей видимости: локал╠ная, фАйл, программа и
класс.
  Локальная: Имя,$опихАнное в блоке (#9.2), локально В0═том4блоке и╩     может использоваться  тклько в  нем поуле  места описанич  и ▓
    0ихвитываемых  блокаe.(`Ислйючение  состагляют  метки  и'9.12),     которые могут  иупользовацьхя!в любом мест% функцйи, в к.т.рой
     они   описаны.    Имена    формальных и  лар░метров$   рункции     раaсматтиваювся%так,  как если  бы они  был( опйсаны  в  aаоом
     внешнедаблоке этой функции.
  Файл: Имч,  описанное вне 0любого блкка"(#9.2) ипиаклАс┴а (г8/5),
   0 может использоваться  в файле,  где оно  описано, после  мзста
а   !опшсбниo.
  Класс:$ Имя   члена  класса  локалфно  дл   его  ккасса  и0 модет-
     йспользовауьсч токькк  в фуноции  члене этого л╗асса (!<.=.2),
 ! " пмсле прИмене╣ной  к$бъе║ту  его класса (#7.1) операции . или
     после примененной  к указатхлю  на объеку 0нго  класса  (#7.1)
     опнЁации ->&  На статич┤ские  ўЛенъ класс░  (#8/5&1)!и функции
 (" чйены можно также ссылдться с*ломощью опешацим :: трм, где ммя     кх классаа находицся в  облаштк  ▓ид(моёти.$ Класс,  описанный
     внутри класса !(#8.5.15),  не  бчитается  членом,  и  его  Имя
     п`инадлежит охватывающей области видимости.
Идя может  быт╠ скрыто  посрдфствкм явного онисания тово же имени в
блоке или  кла┴сб. Имя  в блоке или ║лассе0может быть скрыто тплшкп
именем,  описанным   в  охватываемом  `блоке  или  классе.( Скрыто╡
нелокальное имя  тАкже$`может)0использо"аться,  *огда  его  область
вифимостш указана  операц╕ей :: (#7.1). Ммя класса, укрытоеаимепем,
которое Н%  являетсп именем  ти┐аl все  равно0можЕт"шaполюеоватьсп,
если  пербд   оим утоит  аclass, 0str5ct  или  union  (#8.▓).  Шмя
перехисления enui, скрытое и,енем, которое нб якляетсэ иьеНем ти┐д,
всеа`авно может испольЗовдться, если перед нйм`┴тоиу enum (#8.2).

" $  4.3 ┐ределфния

  Ооисание (#8	  яа╗╧ется определением, за!исключбНием тех ┴лтчаев,
кпгда оно  описывает функци,  не задавая  тела функции (#10), когда
онО бодержит спецификитор extern *1) и в`нем нет иничирлизатора шки
тела функциим или когда оно`я▓люется"опйсаНием клдсса (38>().

              "    "         -$стр :58 -
О     4.3 Компоновка

  Имя в  файловой ╛гласти $видимости< не описанное!явно вак static,
являетсэ Общам  фля каждого  фдйла мпобофаллОвой прогсаммы. Таковымже являесся имя функции. О такие именах говорит┴я, чтю они внешнид.
Каждое опис -их  внешнего имени  в"проврам╝е  крнощится к  тому  жН
объЕктт (#5),  функцаи (#8.7),( классу (#8.5)$ пефечислениц (#8.18)
ил( чначееию пербчислктеля (#8.10!.
  Типы, специфициро┬анные "во вёЕх  опис▓ниях впешнего$имени должны
быть  (дентизны.   Может  быть   б╛кьше  одного  опреднлен(я( типр.-
пеpечиёлеНия,`indmoe-функции  *#8.1)(кл╕ несоставного const (#<.2),
при условии- что!определения идентичны, пояляютсч в рдзных файлах ивсе инициалкзиторы ятляются вонсцантными выражениями (#2)n Во вхехос┬░льных случаяe (долоПо быть  ровно одно определение для вне·него
инени ж программе.
  Реайизация   может  ` потребов░ть,   чткб√    составное    const,	
использиванноп там,  гдх не  всречено никакого  оптеде╗енкя  ConsЇ,
аолжно$быть  явно описано! e|tern и  иметь в0 пьограмме ровно  одпо
определение. Это же ограничение мОжет налагатьуя нд ifline-функции.
     4.4  Классы памяти

  Ебть два юписываемыс классд памяти: автоматический и статйч╡ский.

` АвЄомитические объекты локаыьн╦`Для к ждогю вызова блока ш
  сбрасываются по гыхожб из нег╛.

 0Статичебкие объекты(хуществуют ( сохрдн╧ют свое значен╕е в
  течение выполнения0всей прогриму.  НекоторыЕ объ╡Кты  не связаны  б именами  и иe времена жизни ывно
упаавляются операвошами  new и delete ; ум/ #7." и #9.14

    ("  0         !        $ - сцрa259 ,

0    4>5 Оёнове√╜ типыM

 аОбъекры, описанные! как символы  (char), доїваточны  для хранения
лъбого элемента  машинного$набора  символюв, и  если  принад┐ежащий
этоду  н(бору  символ  хранатся  в  символэной  переМенной,  тж  ееН
значе╜ие равно целому$*оду ятого римкола.
  В мастояси)  номент им╡ютсю  цейые трбх размз╚от, опйсываемые как
short int,   int  и  long  int.  БОлее( длинные `цеЛые  (long  iюt	
птедоставляют(не  м%ньше памяти,  зем бол╡е (лоротк╕е"╞хлые  ,shortint)м нж  при реал(зац╕и  ил╕ длинные,  ики короткие,  или и  те  й
д`угие опгут  стрbь эквивалентными 0обыхн╦м целым.  "Обы╟ныев целыеимеюу  естесъвенный  разьер<  задаваемый  архит%ктуроЙ  центрально!мащины; кстальныз  размеры  д%лаются (такими,  чт╛бы  они  отвеgали
специайьным потребнмстям.
 (Каждое перечирление (#8.9) явлпется0набор.м именованных ко%стант.
Свойсжва enum дденти╟ны сгойстван int.
  елые без  знака, опис√ваемые 0к░к unsigned, подчиняются правила,
ирифметики но модулю 0n, вде0n -(число бит в их пшедстрвлении.
  Числа с "плавающеЛ точкюй  одинарной )float)  и двойной  hnoublu)точности в некотоЁыe мишинных реализациях могут быть синонимами.
0 Поскольку  о!ъекты $аперечисленных  выше   типов   вполне  0мо╢но
интерпрет╕ровать  к░к  числа,  мы  будем  говорить  о  них  как  об
арифметичдских Єипах.  Типы   char, iot  всех размеров и enum будут
собирательно нАзываться  целыми типами.  Ъипы аfloat"иаdoub|e будут
собиЁательно называться плавающими типами+
 $Тин данных  void (пcстой)$ опред%ляет пустое  множестао зн░чений.КЗначение (несущ╡ствующее)  обкекта void нелюзя использовать никавим
образом, нн  могут(оримен ться ниаювное, ни неявное преобррпования.
Поскольъу  пс▒тое  кыражение  обожначает  несущесввуюшее  зн ўениетакое(выражение  bакке всраженае  Можхт аспользоватьёы$ толфко  как
онератор вюражбние  (#9.1) илш  оак певын "опервнд  в  выражемши  с
запявой (#6.15). вяражение ╝ожет явНо преобшазовываться к типу void
(#w.2).

 (   4.4$Производные типыJ  Кромх  ос╜пвных  арифмевических  типов  койцептуд╗ь-о  aуществует
бесконсчно ьнобо  производнъх типов,  с║онструирожанеых из .сновныхКтипов ёледую╔им образом:	
          а      "    "      - ст` 660 -

  массив{ объектов данного`типр;
  функции.`┐олсчающие аргумент╦ данного типа и возвращающие объектыН
  данного типа;

  указаЄелианв огъекты" данного тияа9J  ссыкки на объекты  дАнногм ви┐а;

! константы, являющие┴ыаз-ачеНиями данногж випа;

$ классы, содержащме последовательность пбъектОв  разлачных типов,
  мн╛оество(фуэкюийадля Ёаботы с этими ойъектами и ╜абор  ограничен╕й на Достгп к!ьуИм объектам к функциям;
  струквуры, являющиеся кыаqсама без огран(чений до┴тупА;

  объединени, являющиесэ структєрами, котоЁые могут0в рбзное время
 `содЕржать объе║ты разеых типож

В целом  эти способы  констрчироваэия  объеътов  могут  /ршменятьсярекурсивно.
Объект типа  void*  (ука'атель0"на  void)  можно  испольгоВатl  для
увачания на объекты неиевестного т╕пр.

                5.  ОБЪЕКТЫ И LVALU(АДРЕРА)
:  Объбвт  есть   кбласть` памят(;lvalue   (адрес)  есть  выраж%ние,-
ссылаъщеес   (на олъект. Оцевидный при╝ер`адресного выражения - имя
оБъекра, Есть$операции, дающие бдресные$влражения: ╡впримЕр, если Е
-авыравение типа указатнль, то *Е - вефеснюе выражение, ссылающееся
на кбъект<" на кмторый  указывдет Е.  Тернин "lvalte" п`оищходит из
в√Ёажения присвалвания  Е5=Е2, в` вотором ыевыб  оп%ранд Е1 !долженКбыть адресным  (vluE) выражением*! Наже при    обсуцдепии  кажДого
оператпрА агказывается,  $требует     ли  он( адрЕснще `оПеранды  и
вмзвррщаец ли он адресное значение.

                     6.  ПРЕОБРАЗОВАНИЯ

  ОпренЕле-ные$ операцаи`а могут  в$ зависимости `от  их  операндов
вызываць паеоБразокание значения операнжа мт одНово тшпааиадругмму.
В  э┬ой 0 чарти( объoсня%тся,  (какож  ожидаемый   репультат  твкихпрежсразо▓ан(й. В  #6&60содержитуя кратк.е описание преюбразпваний,
требуеОых наиболеэ  станжБртными опе└ациямм;  оно бу$ет дополн ться
по мере  надобности в пшоцесще обсыцдЕния каждой операции. В #8.5&6описыврютёя пЁеобша╖ования, ояределяемые пользовиЄелем.

  !  6.1 Символы и целые
M
0 ▒имтол  или  короткое  целое  могут  испогь'оваться,  если  может
иaпол╠зоваться целОе.  Во всех  щлучаях  значхние  преобразуетсп  к
юелпму. ПреОбразовайие  короткогж цхлого к длинному всегда вк+ючает
в себя  знаковое расширнние;  целые$являются  величинами со знаком.
С.держат  символы   ееаков√й` разфяд   или  нзт,  является  машинно
                       "  `  - ста 26 -

завищамым; см.  #3.6. Более  явныи вйп   unsigned chaR олран╕ўивает
йзм%нениб значемия .т 0 жо машинно`зависимюго максим├ма.
( В  мбшмнач,   где  символы а рассмауриваютсы$ как  0имеющие  знак
(╖наковые),@скмволы  множествб ккда ASCII  являются положителэныни.
Однако,   симтольная    койстанта,   заданнаы   восьмеричн.й0  esc-
последователмнобтью$подвервантсo знаковому расширеэию ш м.жет статьотрижательным числом; так напримЕрl '\377'аимеет знауение -1.
 (Когда длинное  цзлое преобразуетсюа в ккроткое" илк в  char,  оно
урезается влево; ичйыточные биты просто тер ются.

   * 6.2 Float и double

 аАля выражений  float  могут  выПолняться  действия  ариdиетики  с
плавающей точко╣  одина`ной уочности.  Преобразованкя между числАми
один░тной и !двоймой точмоёти  выполняьтся н стплько  математически
корректно, насколмко позволяет аппаратур .

     6.3 Плавающие и целые

  Преобразования  плажающих   значений  к  интегральный  тип (ймеет
сКконность  быть   машинно  зависимъМ.   В  частноёти,(`направгение
усечения отриювтнльных  чисел различабцся  пт машины`к машинз. Если
предоставляемозо пространства для значениы не хватаец, то результаъ
неопределеп,
  Преобразование и-тЕбраль-ого вначения в плавающиЙ bип выпокнчются
хорошо.  При 0 нехгатке  в  0АппАрдтной  реайизации  требуемых  бит
возншкрет нхкотпраы поте`я точности.

а    6.4 УказателИ и0целые

  Выражение целого  типа можно п`ибавиЄь к указателю0или вычеaть изнего;0в  таком случае  пеа"ый преобрачуется,  как  указываевся "при
обхcждении опер░ции слождйИя.  Можно лроизвпдиць  Вы╟итание над!(двумя  укизателями  на $объекты
оаного тшпа;  в этом  случае результат преоббазcется к типу int или
long в завищимостиа╛т ма╚ины+"см. #7.4.

     4.5 Unsigned
  Гсхгаа при асочетании ц╡лого  %ез0знака и обычн╛го целого обычное
цхлое  преобразуется( к  типу 0unsigne     и`0резєльтат0 ине%т  тип
unsigned. Значением$ являеъсo наименьшее  целое без  зНака,  Ёавное
целюму со знаком (mod 2*.(ра'мер слова)) ,т.еn по модулю 2*.(рАзмер
слова)). В дополнитзльно╝!двоичном пр╜дщтавлении это преобра'ование
явля%тся  пусъым,   и  никаких   реальеых  измееений ! в   даоич╜ом
представлении не происходит.  Пр╕ преобразоваеии цек╛го без з-а╛а в(длинное значение рееультата
численно совпв┤абт  со зНачениеь   целого без знака.`Такии образом,
преобразование сводирся к дополнению нглями слев░.

    0        а1  !`          - стр 262 -

    "6.6 Ррифметические преобразования

  Большоз колизесрвоа операцшй тызывают  преобсазования и  дают$тип
результата ╛аин к╛выь  обаазом.  Этот "стерзотип 0аудет  называться
"обычным а`ифмдтическим преобразог нием".

  Во-пе`вых, любые операнды типа char, unsigned chqr ил( shorT
  прхойразуются л типу iю|.

 `Дале▒, если(одон$из оюерандов имЕет!тип touble, то другой
  преобразчет┴я к типу doubde0и тот`же тип амебт тееультит.

 `Иначе. если один из операпдов имеет тип ujsigned long, то дщтгой
  преобразу╖тся"к тизу unsigned long$и цаков)&е т╕п результата.
 "Иначе< если ╛$ин из операндов имеет тип Long, то другой
  преобразcется к типч ьong и`Єаков же тип результата.
-
  Иначе, если один из операндов имеет тип unsigned, то другой
  преобрагуется к типу unsigNed и таков же уип результата.
Н
  Иначе оба онеранда должны иметь тип int и таков же тия
  резcльтата.

    !6.7 Преобразования указателей

  Везде,    где    укдзатели    присваиваютс ,    инициилизирыътся,
сравниваются и т.д. мпгуb выполнят╠ся aледующие преобразованшя.

  Константа 0 может ореобразовыватьхя`в указатель, и гарантируетсч,
  что это зэачение породит указатель, отпичный от укизателя нд
  люйой объект.

  Указатель любого типа может преойразовываться в void*.
	
  Уквзатель на`║лвсс может преобразо"ываться в!укапатель на
  открытый )взовый класс`этого клбсса; с,. #8.5.3.
  Имя(ве║тора может /реобразовывать┴яак укапатель на згю пнрвый
  элемент.M
  Идентихикатор,"описаннлй как "функция,(возвращаьща  .n.*,(вс%гда,
  когда он не и└пользуется в позицк╕ имени функции в вызовеl
  преобразуется в "указатель на фуноци╬, возвращающую n..".

                             - стр ▓63 -

  ! "6.8 Преобразоваэия aсылок*
  Везде, где  (н╕циализируются ┴сылки,0можзт выполнять┴я(сследующе╡
преобразование.

  Ссылка на класс може┬ пЁеобразовываться в сбыллу на открытый
  Базовый класс этого класса; см. #8.6.3.

                    "   7.`ВЫРАЖЕНИЯ

  Приоритет опеааций` в выраженях  талой же,  иак`и /орядок главных
подразделов в  этом ра╖дхле,  наибольший приоритет 0у лервогп,  Так
например, выраждния,  о которых говорится как об операндах операц╕и	
+ (#7.4)  ) это  те выражения,  которын определены  в$   #+7n3-7.4n
Внутри каждого  под┴азднла операции !имеют одинаковый  приоритет. В
каждом подра╖деле  для р ссмдтриваемых в нем операций  определяется
их левая  или права╧ ассоциативнжсть (пофядок обраБотки опе`андов).
Приоритет и  бссоциат╕гность всех операций собран вмебте в описании
г└амматики в #14.
  В остал№ных  случаях порядок  "ычксленияа выражения  неопределен.
Цочнее, компилятор  волен вычислять  подвыражения  в  том  пмрядке,котоаый о╜  считает более  эффективным,  даже  если    яодвырбженияM
вызывают побочнkе  хффекты. Порядок возниъновения побочных ьффектов
неопределен.  Выражения,   включающие  в$  себя  (коммутативнъе $ и
асссоциатйвные операции (*, +,  &, |,(^), догуЄ быЄь реюрганизованы
произвольным  образом,(  дажх  при   наличии  скобок;  для  задания
опреддленного порыдка  вычибления$выражения необходимо использовать
явную`временную переменную.
  Обработка  переполнения   и  контроль   деленйя  при   вычислении
выражения$маши╜но  зависимы. В  большинств╡ существующих реалмзаций
Ck+ переполнених целого игнорирєзтся; обработка деления н  4 и всзх
исключительных ситуаций с числамк с плавающей точкой различбютсч от
маьмны  к   машинх  и  ойычпо  могут  регулироваться  библиотечными
функциями.
  Кроме$стандартного (значенкя, описанного  в  #7.2-7.15,  операции
мовут бытэ перегружены+, то есвь, могут быть задаеы их змачен╕я для
случая их  применения к   типам,  определяемым  пользователем;  aм.
#7.16.

     7.1 Основные Вяражзния

 !Основные выражения, включающие в себя . , >0,   индексиро"ание и
вызовы функций,$группируются слева ниправо.
     сзисок_выражений:
          выражение
          список_выражений , выражение
     id:
        $ идентификатор
______O____________
  * Этот  термин примеэяется$ для описания  использования  в  языке
одной и  той же  лексемы для  обозначения различных !процедур;  вид
процедушы  выбирается   компиляуор╛м  нв  осногании  дополнмт╡льнол
информации в виде чмслр и типр аргументжв и т.п.

 (           а       "       - стр 264 -

 !     0  имя_функции_операции
          typmdef%имя        $      ::            а   йдентификатор
          tYpedef-имя :: имя_функюки_операции
    `первичное_выражение:M
          id
          ::0                 а 0                     ид%нт(фикатор
          константа
          строка
  0     а this
  (  $    (        (              выражение                0      )
        0 первмчное_вы└ажение          0     [      гыражение    0]
      $   первичное_выражение        (   список_выражений   npt   )
     `    первичное_выражение                     .              id
       а  первичное_выражение   -> id
  Идентификатор есЄь  первиgное  вяраже)ие,$ призем  соотантственно
описанное а(#8).   ИмяOфункции_операции   есть   идентификатор   со
специальным знрчением; см> +7.16!и #8.5.1.
  Операция ::, за которой следует идентмфикатор из файловой области
видимости,0нстю то же, что и идентификатор. Это по╖аопяет ссылаться
на объект даже в том хлучае< коГда его иден┬ифиКатор скрыт (#4.1).
  Typedef-имя h#8.8)  , за  которым сгедует  ::, после чего следуетM
мдентификатор, является  первичным!вяражением.  Typedef-шмя  аолзнмобозначатм класс` (#8.5), и  идентификатор долзен  обознрчать  член
этогоакласса.  Его тип  специфицируЕтся  описанием  идентификатора.
typedef-имя может  быть скрыто  именем, которое  не явл етс╧ именео
типа. В  эъом случае typedef=имя все равно может бы┬ь найдЕно ш его
можно использовать.
  Константр является  первшчным выражением. Ее тип должен бытэ int,
long или double в зависимости от ее формы.

  "       !$                 - стр 265 -

! Строкш является пераичныд выражением> Ее`тип - "массив симвоЛов".
Обычно он  сразу же  преобразуется в  указательана ее`первый символ
(#6.7).
  Ключевое слово this  является локальнол перЕменнпй в теле фун*цим	
члена  см.  #8.5) . Оно является указателем(нб ╛бъект, для которого
хункция была вызвана.J "Вырджение,  жаклnчен╜ое  В  круглые  скобъи,  являетуя  первичным
выраженизм, чей  типаи0 значение те  же, что  и у  незаклюуенного в
с║обки  вырвжения.   Паличие  скобок  не" влияет  на  то,  является
выражение lvalue0или неъо
  Пнрвмчное вырвжение,  за коцорым  слефгет выражение  в(квадратных
б║об*ах, явлпется пнтвич-ым выражением. Интуитивны╣ смыс╗ - индекс.
Обычно  первичное  $выражение  имеет   тип  "указатель   нб   ...",
индексирующее выражение  имеет тип int и тип результата есть #...".
В√ражение Е1[Е2] идх-тично (по определению) выражению *((E1)+(E")).
Все тоноие места, необходимы╡ для яонимания эткй жаписи, содержатся
в этом  разделе вместе  с  обсуждннием  в! #"  7.1,    7.2  и  7о4,соответственно, идентификаторов, *$и + ; нице,  в #8.4.2 приводятсясле┤ствия иж этого.
  Вызов фчнкции  являхтся первичнъм  выражбнием, па которым следуют
скобки,`содержащие  список (возможно,  пустой) раздел-нных запятымиКаыражений,  составляющи¤   фактические   параметры   для   функции.
Первичное выражение  доыжно иметь  ти/ "функЎия,  возвращающая ..."
или "улазатель  на функци■,  возврдщаюыую!...",  и р%зульцат`вызоваКфункции ймеет тип "...".
  Каждый   фотмальный    параметр   йнициализируется    фактическим*па└аметром (#╝.6).  ВыполНяются станд░ртны╡ (#6.6-8) и определяемые
пользователем  прйобразования   (8.5.6).  ункция  может  изменять
значен░я своих  ьормальпых параметрож  но эти  изменения не  моуут
повлиять ма значепич рактич╡ских  пара╝етров за исключением слсчая,
когда ф.рмальный параметр имеет ссылочйый тип.
  Функтия может (аыть0описана  как( полччающдя  меньше  или  больше
параметрож, чем  специфицировано в  описдн╕и!фуекции (#8.4). К░ждыйфактиўеский параметр  типа  float,  для  которогоа нет  формал№ного
пафаметра, преобразуются  к типуа  double;  и,( оака обычно,а имена
(ассивов преобразуются  к указателям. Порядок выч╕сления парам╡тров
не мпределзн языком; имейте в виду различия между`вомпиляторами.
  Допуст╕мы рбкурсивные вызовы любых рункций.
  Первичное выражение,  послм  которобО  стоит  точка,  за  кюторойM
следует идентифмкатор`(или ид╡нтификатор, уточненпый(typedef-именем
с помощью операции ::! ывляется выражением> Перкое вуражение должно
быть объектом  класха, а  идентифилатор0должЕн именювать член этоло
класса.аЗначением является именованный член объекъа, к онп являевся
адресным,( если   первое  выражение   является  адреснум.!  Слежует
отметить, что  "классовые объекты" могут быть структурамк (#8.5.2i
или объединениями (#8.5.13).
  ервичное "ыражение,  после$которого  стоит  стрелка  ( -> i,  за
Ъмторой  следует   идентификат╛р  `или   идентификатор,  уточнееный
typelef-именем с  помо╔ью операции ::) являхтся кырр&ением.  Первое
выражение дклжно  быть указателем на объект класса, а идЕнтификатордо╗жен именовать0 член этого  класса>  Значение  является !адресом,
ссылающимсч  на  именюваНнkй  члее  класса,  на  котюрый  указываецуказателэное "ыражение.  Так, выражепие  E1->MOS  есть то же, что и
(*E1)оMOS. Классы обсуждаются в #8.5о
  Если лдрвич╜ое 0выражение дает  значение типа  указатель на ..."
(см.  #8.4     and   #8.6.3),  значением   выражения  был   объект,
      а                      - стр 266 -

кбожначаемый ссылкой.  Ссылку(мозно  считать  именем  объекта;  см.
#8.6.3.
  (  7/2 Унарные жперации

  Выражения с унарными опер░циями группируют справа нале"к:
  д  унррноб_выражение:
          унарпа╧_операция                         !      выфажение
     $    выражение       $                     !                ++
       0  выражение `                     0                      --
     а    sizeof                          !              ▓ыражение
    !     sizeof             ,          0   имя_типА     (        ) а        (  !    а    иоя_типа             )       !     гыражение
!         пфостое_имя_типа    $  (        список_выражений        )
     "    new               имя_типа       инициализАтор        opt
       $  nev              (               имя_типа               )
          delete                        `                 выражение
 "   0а   de,ete [ выражееие ] вkраженше     унарная_операция:`а      (          однв   0         "      из	 0       $*  &  -  !  ~  ++  -m
  Унарная операция * означает косвенное обращение: выражение должно
быть указбтекем  и резулштатом бсдет lvalue, ссыл▓ющнЕся на объект,
на который указ╦вает выражение. сли выражение имеет тип "указател╠Н
на >..",$то тип результата ест№ "...в.
  Результб┬ом унар-ой  операюии &  является указатель на юбъект, на
которы╣  ссялается  (операнд.  Операнд  должен  быть  lval5e.  Если
выражение имеет  тип "...",  то тип  результата есть  "уквзателф нб
...".
  Резуйьуатом унарной  опЕраци( +  являхтся  значение  ее  опбранда
после выполнения  обычных  аридметических  преобразований.  Операнд
должен быть а└ифметического типа.
  РезультатоМ унарной операции - является отрицательное значение бе
операнда.`ОПеранд  днлвен  имерь 0целый  тиоn  Выполняются  обычные
арифметиўеские преобразовани .  Отрицательое$ значение  геззнаковой
велшчины вычислятся посред┴твжм вячитания е% значепия из  2~, где n
-число битов в целом типа int.
  Резульватом операции  логического отрицания  ! является  1,  если
значение операнда  0,0и $0, если  значение операмда не 0. Результат
имеет тип  iюt. Приме╜има ак  любому  арифмдтическому  тизу0 или  к*указателяд.
  Операция  ~  "дает  дополне-ие   пначения  оперАнда  до  единицы.
Вщлолняются   обучные арифметичесмие преобразования. Оперднд должен
иметl интегрбльнщй тип.

     7.2.1 Увн╗ичение и Уменьшение

  Олеранд префиксного0 ++ поъучает  приращение.(Опхранд"должен быть
адресным .  Значением является  новое значение  операнда, но оно не
адресное. Выражение  ++x эквивалентно  x+=1.  по  п╛воду  данных  о
преобразованиях  см.   обсуждение! операций   сложения   (#7.4)" `и
присваивани  (#7.14).
  Опервнд префиксмого -- умдньшаетщя аналогично действию п`ефиксной
опдрации ++.

            а     !       `  -0с┬р 26? -

  Пначение.!получаемое `при  испжльзованим  постфиксного  ++,  есуь
знаяение операнма.  Операнд должен  быть адресным.  После тог╛, как
результат отмечен,  объект увеличйвазтся так$же, как и в преф╕ксной
операции ++. Тип фезультата т.т жд, что и тип операнда.
  Значение,    получдемое     при    испойьзов░нии      постфиксной
 --, есть  значение о/еранда." Опефанд должен  быть адресным."После
того, как  результат от╝ечбн,  объект увеличивается так же,$как и в
префикснои опнрации +). Тин`результатр0тот фе, что и"тип операнда.

    $7.2.2 Sizeof

  Онерация  shzeof   дает  размер   жпераэда  в  б йтах.  (Байт  неопределяется языком` иначд, чхм  через значение  sizeof.аОднако, во
гсех существуюших  реализацичх$байт  есть пространтсво,(необходимое
для хранейия  char.) При  применении к массиву результатом является
полное количехтво байъов в массиве. Сазьдр определяется из Описа-ий
объектов, входящих в вяражение. Семантически это вщражение является
беззнвковой константой и может быть использованп в любом месце, где
требуетсяаконстанта.
  Операцию sizeof  можно тАкже  применять к  заклюgенному в  съобкш
иМени типа.  В этом  случае она 0дает  размер,  в  байтах,  обюектаJтказанного типа.

     7.2.3 Этнон Пшеоеразование Типа

  ╧ростое_имя_ъипа  (#x.2),  возможном  заключенное  в  скобк(,  за
которым идет  заключенное в скобки выражение (или список_выражений,
если тип  являетс   клаёсом  с( соответствующим  образои  опйсанным
консттукт.аом #x.1.5)  влечет преобразование  значения выражения  в
названный тип.  Чтобы занисать% преобразование0в  ти/,  не  имеющий
простого ммени,  имя_типа (#8.7)  должно быть  заключено в  скобки,
Если имя  типа заключено  в скобки,  выражение заккючать  в  скобки
необязательно. Та*ая запись называется псиведением к типу.  Указатепь может  блть ягно пре╛брапован к любому"из инуегральных
типов, жостаточно  по величине для дго храэееия. То,!какой из int и
long тЁебуется,  является м░шИнн╛  зависимым. Отоб└азующая  функция
также являетхя  машинн╛ зависиной,  но предоолагается,  что она` несоДержит сюрпризов  для  того, !кто  знает  структуру  адресации  в
машине. Подробности для нхкоторых ко-кревных машин были приведены в
#2.6.
  Объект$ интегрального  "ти/а  может   быуш  явно  преобразован  в
указатеЛь. Отограж░юща/ функция всЕгда превращает цело╡, получе-ное
из указацеля,  обратпо2в  тот же  указвтекь, но в остальных случдях
является`машинно зависимой.
  Указатель на один тип может быть явно нреобразован в указательана
дсугой тип.  Использование полученного в тезультате уквзател  может
привести  к   исклnчительной  ситыации   адреса╞ии,  если  асходный
укрзатдль ане   указывает  на   объе║т,   соответст▓уящим   образом
выравненнъй  в  памяти.  Га`антируется,  что  увазатель  на  объект
данного шазмера  может быть "преобразован  в  указ тель  на  nбъект
менььег╛ размера  и обратнж  без изменений.  Различные машиеу могут
раеличаться По  числу бит в указателях и требованиям к выравнижанию
обънктов. Составн√е"объекты выравниваются по щамой стрюгой бранице,-
требгемой каким-либо$из ег. составляющих.

                $            - стр 268 -

  Объект может  преобразовыватфся в0 объект класса aтолько еслиабыл
описдн  сожтветствующий  конструктжр  ила  операция0 преобразования
(!8>5.6).
  обкект мож%т  явно преобразовуваться  в ссылмчный1 тип  &X,  если
уиазатель на этот объект ммжет явно преобразовываться в X*.

     7.2о4 Свободная Память

  Операция new`создает(объект  випб$имя_типа((см. #8.7), к кот.рому
юн применен.  Время жизни  объекта, созданного  с помощью  new,0 не
ограничено областью  видимости, в  которой он  создан. Операциo new
возвращает указатель  ни сюзданный ей объект. Когда объект является
массиво,, возвращается указиетль на его лервый элемент.$НАпр╕мер, и
new 0аint и  new int[10]  возвращают int*.  Для объектпв  неъ╛торых
клаaбов надо  пЁедоставлять инициализатос  (#8.7.2й.  Операт(я  new
(#7.2) для получения памяти вызывает функцио

  void* operator new (lonч);

ПарАиетр   'адает!!  требубмое   число  ( байтов.   Память    будет
инициализирована. Еслш  opgrator new()  не  может  най┬и  трейуемое
количество прмяти, то(она возвращает ноль. `Операция"delete  уничтожаЕт объект,  созданный операцией  new. Ее
результбЄ является  woid. Операнд  delete должен  быть  указателем,
возврвщенным new.  Результат ятимен╡эия delete`к указателю, который
не был пжлучен с помощью операции new. Однако уни╟тожение"с по╝╛щью
delEte указателя со зеачением ноль безврддною
  Чтобъ  освободить  указаннуn  яамять, аоперачия  delete  вызывает
функцию

   voyd operator d%le|e (void*);

В форме

  delete [ вырАжение ] выражение
второй параметр  указывает на  вектор, а  первое  выражение  задает
число элементов  этого вектора.  Задание числа  элементов  является
избыточным за  исключением случаев  уничтожения векторов  некоторых
классов; см. #8.5.8.

     7.3 Мультипликативные операции

  Мультипликативные операции  *,   / и  % группируют слева направо.
Выполняются обычные арифметические преобразования.

  мультипликативное_выражение:
      выражение * выражение
      выражение  /  выражение
      выражение  % выражение

  Бинарная операция * определяет умножение. Операция * ассоциативна
и выражения  с несколькими  умножениями на  одном уровне могут быть
реорганизованы компилятором.

                             - стр 269 -

  Бинарная операция / определяет деление. При делении положительных
целых округление  осуществляется в сторону 0, но если какой-либо из
операндов  отрицателен,   то  форма   округления  является  машинно
зависимой.  На  всех  машинах,  охватываемых  данным  руководством,
остаток имеет  тот же  знак, что  и делимое.  Всегда истиинно,  что
(a/b)*b + a%b равно  a (если b не 0).
  Бинарная операция  % дает остаток от деления первого выражения на
второе. Выполняются обычные арифметические преобразования. Операнды
не должны быть числами с плавающей точкой.

     7.4 Аддитивные операции

  Аддитивные операции  + и  - группируют слева направо. Выполняюься
обычные  арифметические   преобразования.  Каждая   операция  имеет
некоторые дополнительные возможности, связанные с типами.

  аддитивное_выражение:
      выражение + выражение
      выражение  -  выражение

  Результатом  операции   +   является   сумма   операндов.   Можно
суммировать указатель  на объект  массива и  значение целого  типа.
Последнее во всех случаях преобразуется к смещению адреса с помощью
умножения его  на длину  объекта, на  который указывает  указатель.
Результатом  является  указатель  того  же  типа,  что  и  исходный
указатель,  уазывающий   на  другой   объект  того   же  массива  и
соответствующим образом  смещенный от первоначального объекта. Так,
если P  есть указатель  на объект  массива, то  выражение P+1  есть
указатель на следующий объект массива.
  Никакие другие комбинации типов для указателей не допустимы.
  Операция +  ассоциативна и выражение с несколькими умножениями на
одном уровне может быть реорганизовано компилятором.
  Результатом операции  - является  разность операндов. Выполняюься
обычные арифметические  преобразования. Кроме того, значение любого
целого  типа   может  вычитаться   из  указателя,   в  этом  случае
применяются те же преобразования, что и к сложению.
  Если вычитаются  указатели на  объекты  одного типа, то результат
преобразуется (посредством  деления на  длину  объекта)  к  целому,
представляющему  собой   число   объектов,   разделяющих   объекты,
указанные указателями. В засисимости от машины результирующее целое
может быть  или типа  int, или  типа long; см. #2.6. Вообще говоря,
это преобразование  будет давать неопределенный результат кроме тех
случаев, когда  укрзатели  указывают  на  объекты  одного  массива,
поскольку  указатели,   даже  на   объекты "одинакового   типа,  не
обязательно раз+ичаются на величину, кратную длине объекта.

     7.5 ОПерафии сдвига

  Операции сдвига  << и  >> группируют слева нвправо. Обе выполняют*одно обkчное  а`ифметическое преобразование  над своими операндами,
каждый из! коворых должен  быть целым. В этом случае правый операнд
преобразуется к  типу int;  тип результата совпадает с типом левого
операнда. Результат  неопределен, если  правый операнд  отрицателен
илиабольше!или равен длине объекта в ситах.

0  (                         - стр 270 -

     сдвиговое_выражение:
          выражеНие                  <<     а             выражение
          выраоение ╛> выражение
  Значением Е1! << Е2  является  Е1  (рассматрйваемое  как  битовое
представление), сдвинуцон  влево`на  Е2 битов;  освободившиеся биты
заполняются нулями.  Значением Е1  >> Е2  является Е1  ,  сдвинутое
вправо на  Е2 битовых  позиций.  Гарантируется,  что  сдвиг  вправо
эвляется логическим (заполнение нулями), если Е1 являетс 0unsignud;
в противном  случае$он может быть арифметичевким (заполнхние копией
знакового !итаi.

     7.6 Операции отношения

  Операции отношения  (сравн╡ния) группируютаслева направо, но этот
факт не очень-то полезен: a < b < c не означает то, чем кажется.
     выражение_отношению:
          выражение                   <                   выра&ение
          выражение                   >              !    выражение
          выражение                  <=                   выражение
         выражение >= выражениеJ  Операции`< (меньше чем), > (больше чем), <= и >= все д ют 0, если
заданнпе соотношение  ложно, и  1, если оно истинно. Тап результата
int.  Выполняются   обычные  арифметические  преобразования.  Могут
сравниваться два  указателя; результат  зависит  от  относительного
положения объектов,  на *от╛рые  указывают  указатели,  в  адресном
пространстве. Сравнение укАзателей пеаеносимо только если указатели
указывают на объекты одного массива.

     7.7 Операции равенства

     выражение_равенства:
          выражение                   ==                  выражение
          выражение  !=  выражение
  Операции ==  и !=  в точности  аналогичны операциям  сравнения за
исключением их  низкого приоритета. (Так, a
7.8 Операция побитовое И

     И-выражение:   выражение & выражение
  Операция  &   ассоциативна,  и  выражения,  содержащие  &,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом является побитовая функция И операндов.
Операция применяется только к целым операндам.

     7.9 Операция побитовое исключающее ИЛИ

     исключающее_ИЛИ_выражение:
          выражение ^ выражение
  Операция  ^   ассоциативна,  и  выражения,  содержащие  ^,  могут
реорганизовываться.     Выполняются      обычные     арифметические

                             - стр 271 -

преобразования; результатом  является побитовая функция исключающее
ИЛИ операндов. Операция применяется только к целым операндам.

     7.10 Операция побитовое включающее ИЛИ

     включающее_ИЛИ_выражение:
          выражение | выражение
  Операция  |   ассоциативна,  и  выражения,  содержащие  |,  могут
реорганизовываться.     Выполняются      обычные     арифметические
преобразования; результатом  является побитовая  функция включающее
ИЛИ операндов. Операция применяется только к целым операндам.

     7.11 Операция логическое И

     логическое_И_выражение:
          выражение && выражение
  Операция &&  группирует слева направо. Она возвращает 1, если оба
операнда ненулевые,  и 0  в противном  случае. В  противоположность
операции & операция  && гарантирует вычисление слева направо; более
того, второй операнд не вычисляется, если первый операнд есть 0.
  Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.

     7.12 Операция логическое ИЛИ

     логическое_ИЛИ_выражение:
          выражение || выражение
  Операция || группирует слева направо. Она возвращает 1, если хотя
бы один  из ее  операндов ненуелвой,  и 0  в  противном  случае.  В
противоположность операции  | операция  ||  гарантирует  вычисление
слева направо;  более того,  второй операнд  не  вычисляется,  если
первый операнд не есть 0.
  Операнды не  обязаны иметь  один и  тот же  тип, но каждый из них
должен иметь  один из основных типов или быть указателем. Результат
всегда имеет тип int.

     7.13 Условная операция

     условное_выражение:
          выражение ? выражение : выражение
  Условная операция  группирует слева  направо. Вычисляется  первое
выражение, и  если оно  не  0,  то  результатом  является  значение
второго выражения,  в противном случае значение третьего выражения.
Если  это   возможно,   то   выполняются   обычные   арифметические
преобразования для приведения второго и третьего выражения к общему
типу. Если  это возможно,  то выполняются преобразования указателей
для  приведения   второго  и  третьего  выражения  к  общему  типу.
Вычисляется только одно из второго и третьего выражений.

                             - стр 272 -

     7.14 Операции присваивания

  Есть много  операций присваивания,  все группируют слева направо.
Все в  качестве левого  операнда требуют  lvalue, и  тип  выражения
присваивания тот  же, что  и у  его левого  операнда. Это lvalue не
может ссылаться  на константу (имя массива, имя функции или const).
Значением является  значение, хранящееся  в левом  операнде  просле
выполнения присваивания.

  выражение_присваивания:
      выражение  операция_присваивания  выражение

  операция_присваивания: одна из
      =  +=  -=  *=  /=  %=  >>=  <<=  &=  ~=  |=

  В простом  присваивании с  = значение  выражения  замещает  собой
значение объекта,  на который ссылается операнд в левой части. Если
оба  операнда   имеют  арифметический  тип,  то  при  подготовке  к
присваиванию правый  операнд  преобразуется  к  типу  левого.  Если
аргумент в  левой части  имеет указательный  тип, аргумент в правой
части должен  быть  того  же  типа  или  типа,  кторый  может  быть
преобразован к  нему, см.  #6.7. Оба  операнда могут быть объектами
одного класса.  Могут присваиваться  объекты некоторых  производных
классов; см. #8.5.3.
  Присваивание   объекту   типа   "указатель   на   ..."   выполнит
присваивание объекту, денотируемому ссылкой.
  Выполнение выражения  вида E1  op= E2  можно представить себе как
эквивалентное E1 = E1 op (E2); но E1 вычисляется только один раз. В
+= и  -= левый  операнд может  быть указателем,  и  в  этом  случае
(интегральный) правый  операнд преобразуется так, как объяснялось в
#7.4; все  правые операнды и не являющиеся указателями левые должны
иметь арифметический тип.

     7.15 Операция запятая

  запятая_выражение:
      выражение , выражение

  Пара выражений,  разделенных запятой,  вычисляется слева направо,
значение левого  выражения  теряется.  Тип  и  значение  результатаM
являютуя  типом   и  значением   правого  опешанда.   Эта  ооерация
группирует  слева   наяраво.  В   контексте,  где   запятая   имеет
специальное чнач%ние,  к к нбпример в спкске фактических параметров
функции  (#7.q)    и  в  списке  инициализаторов  (#8.6),  операциязапятая, как "она описана в этом разделе, может появляться только в
скобках; например,

  f (a,(t=3,t+2),c)

имеет три параметра, вторым из которых является значение 5.

                             - стр 273 -

     7.16 Перегруженные операци(

  Большиэство операций  моцет быть  перегружено, то  есть,  описано
так, чтобы  они лолучали  ▓ качестве операндов объекты классов (см.
г8.1.11).  Изменить   приоритет  операций   невозможно.  Невозможно
изменить смысл  операций при  применении их к неклассовым объектам.
Предопределенный смысл операций = и &а(унарной) при применении их к
объектам классов может быть изменеп.
  Эквивалентность юпераций, применяемых к основным типам (например,
++a эквивалентно  a+=1), не  обязательно выполняется  для операций,
применяемых  к   классовым  типам.  Некоторые  операции,  например,
присваивание, в  случае применения  к основным типам требуют, чтобы
операнд был  lvalue; это  не требуется  для операций, описанных для
классовых типов.

     7.16.1 Унарные операции

  Унарная  операция,   префиксная  или   постфиксная,  может   быть
определена или  с помощью функции члена (см. #8.5.4), не получающей
параметров, или  с помощью  функции друга (см. #8.5.10), получающей
один параметр,  но не  двумя способами одновременно. Так, для любой
унарной  операции   @,  x@   и  @x   могут  интерпретироваться  как
x.операция@() или  операция@(x). При  перегрузке операций  ++ и  --
невозможно различить префиксное и постфиксное использование.

     7.16.2 Бинарные операции

  Бинарная операция  может быть  определена или  с помощью  функции
члена (см. #8.5.4), получающей один параметр, или с помощью функции
друга (см. #8.5.9), получающей два параметра, но не двумя способами
одновременно. Так,  для любой  бинарной операции  @, x@y может быть
проинтерпретировано как x.операция@(y) или операция@(x,y).

     7.16.3 Особые операции

  Вызов функции

  первичное_выражение ( список_выражений opt )

и индексирование

  первичное_выражение [ выражение ]

считаются  бинарными   операциями.  Именами   определяющей  функции
являются соответсвенно  operator()   и operator[]. Обращение x(arg)
интерпретируется как  x.operator()(arg) для  классового объекта  x.
Индексирование x[y] интерпретируется как x.operator[](y).

                             - стр 274 -


                         8. ОПИСАНИЯ

  Описания используются  для  определения  интерпретации,  даваемой
каждому идентификатору;  они  не  обязательно  резервируют  память,
связанную с идентификатором. Описания имеют вид:

  описание:
      спецификаторы_описания opt список_описателей opt ;
      описание_имени
      asm_описание

  Описатели в списке_описателей содержат идентификаторы, подлежащие
описанию. Спецификаторы_описания    могут  быть  опущены  только  в
определениях  внешних  функций  (#10)    или  в  описаниях  внешних
функций. Список  описателей может  быть пустым  только при описании
класса  (#8.5)   или   перечисления   (#8.10),   то   есть,   когда
спецификаторы_описания     -     это     class_спецификатор     или
enum_спецификатор. Описания   имен описываются в #8.8; описания asm
описаны в #8.11.

  спецификатор_описания:
      sc_спецификатор
      спецификатор_типа
      фнк_спецификатор
      friend
      typedef

  спецификаторы_описания:
      спецификатор_описания спецификатор_описания opt

  Список должен  быть внутренне  непротиворечив в  описываемом ниже
смысле.

     8.1 Спецификаторы класса памяти

  Спецификаторы "класса памяти" (sc-спецификатор) это:

  sc-спецификатор:
      auto
      static
      extern
      register

  Описания, использующие  спецификаторы  auto,  static  и  register
также служат  определениями тем,  что они  вызывают  резервирование
соответствующего объема  памяти. Если  описание extern  не является
определением (#4.2),  то где-то  еще должно  быть  определение  для
данных идентификаторов.
  Описание register  лучше  всего  представить  как  описание  auto
(автоматический) с подсказкой компилятору, что описанные переменные
усиленно используются.  Подсказка может быть проигнорирована. К ним
не может применяться операция получения адреса &.
  Спецификаторы  auto  или  register  могут  применяться  только  к
именам, описанным  в блоке,  или к  формальным  параметрам.  Внутри

                             - стр 275 -

блока не может быть описаний ни статических функций, ни статических
формальных параметров.
  В описании может быть задан максимум один sc_спецификатор. Если в
описании отсутсвует  sc_спецификатор, то  класс памяти  принимается
автоматическим  внутри   функции  и  статическим  вне.  Исключение:
функции не могут быть автоматическими.
  Спецификаторы static  и extern  могут использоваться  только  для
имен объектов и функций.
  Некоторые спецификаторы  могут использоваться  только в описаниях
функций:

  фнк-спецификатор:
      overload
      inline
      virtual

  Спецификатор перегрузки  overload делает  возможным использование
одного имени для обозначения нескольких функций; см. #8.9.
  Спецификатор inline  является только  подсказкой компилятору,  не
влияет  на   смысл  программы   и  может  быть  проигнорирован.  Он
используется, чтобы  указать на  то, что при вызове функции inline-
подстановка тела функции предпочтительнее обычной реализацци вызова
функции. Функция  (#8.5.2 и  #8.5.10), определенная внутри описания
класса, является inline по умолчанию.
  Спецификатор virtual  может  использоваться  только  в  описаниях
членов класса; см. #8.5.4.
  Спецификатор friend  используется для отмены правил скрытия имени
для членов  класса и  может использоваться  только внутри  описаний
классов; см. #8.5.9.
  С помощью спецификатора typedef вводится имя для типа; см. #8.8.

     8.2 Спецификаторы Типа

  Спецификаторами типов (спецификатор_типа) являются:

  спецификатор_типа:
      простое_имя_типа
      class_спецификатор
      enum-спецификатор
      сложный_спецификатор_типа
      const

  Слово   const    можно    добавлять    к    любому    допустимому
спецификатору_типа. В  остальных случаях в описании может быть дано
не более  одного спецификатора_типа.  Объект типа const не является
lvalue. Если  в описании  опущен спецификатор  типа, он принимается
int.

                             - стр 276 -

  простое_имя_типа:
      char
      short
      int
      long
      unsigned
      float
      double
      const
      void

  Слова  long,   short   и   unsigned   можно   рассматривать   как
прилагательные. Они  могут применяться  к типу  int; unsigned может
также применяться к типам char, short и long.
  Спецификаторы класса  и перечисления  обсуждаются в  #8.5 и #8.10
соответственно.

  сложный_спецификатор_типа:
      ключ typedef-имя
      ключ идентификатор

  ключ:
      class
      struct
      union
      enum

  Сложный спецификатор  типа можно  использовать для  ссылки на имя
класса или  перечисления там,  где имя  может быть скрыто локальным
именем. Например:

  class x { ... };

  void f(int x)
  {
      class x a;
      // ...
  }

  Если  имя   класса  или   перечисления  ранее  описано  не  было,
сложный_спецификатор_типа работает как описание_имени; см. #8.8.

     8.3 Описатели

  Список_описателей,  появляющийся  в  описании,  есть  разделенная
запятыми последовательность  описателей, каждый  из  которых  может
иметь инициализатор.

  список_описателей:
      иниц_описатель
      иниц_описатель  ,  список_описателей

                             - стр 277 -

  иниц_описатель:
      описатель  инициализатор opt

  Инициализаторы  обсуждаются   в  #8.6.  Спецификатор  в  описании
указывает  тип   и  класс  памяти  объектов,  к  которым  относятся
описатели. Описатели имеют синтаксис:

  описатель:
      оп_имя
      ( описатель )
      * const opt  описатель
      & const opt  описатель
      описатель   ( список_описаний_параметров )
      описатель     [ константное_выражение opt ]

  оп-имя:
      простое_оп_имя
      typedef-имя  ::  простое_оп_имя

  простое_оп_имя:
      идентификатор
      typedef-имя
      ~  typedef-имя
      имя_функции_операции
      имя_функции_преобразования

Группировка та же, что и в выражениях.

     8.4 Смысл описателей

  Каждый  описатель   считается  утверждением   того,  что  если  в
выражении возникает  конструкция,  имеющаяя  ту  же  форму,  что  и
описатель, то  она дает  объект указанного  типа и  класса  памяти.
Каждый  описатель   содержит  ровно  одно  оп_имя;  оно  определяет
описываемый  идентификатор.   За  исключеним   описаний   некоторых
специальных  функций   (см.  #8.5.2)   ,   оп_имя   будет   простым
идентификатором.
  Если  в   качестве  описателя  возникает  ничем  не    снабженный
идентификатор,  то   он  имеет   тип,   указанный   спецификатором,
возглавляющим описание.
  Описатель в  скобках эквивалентен описателю без скобок, но связку
сложных описателей скобки могут изменять.
  Теперь представим себе описание

  T D1

где T  - спецификатор  типа (как  int и  т.д.), а  D1 -  описатель.
Допустим, что  это описание заставляет идентификатор иметь тип "...
T", где  "..." пусто,  если идентификатор  D1  есть  просто  обычый
идентификатор (так  что тип  x в  "int x"  есть просто int). Тогда,
если  D1  имеет вид

  *D

                             - стр 278 -

то тип содержащегося идентификатора есть "... указатель на T."
  Если D1 имеет вид

  * const D

то тип содержащегося идентификатора есть "... константный указатель
на T", то есть, того же типа, что и *D, но не lvalue.
  Если D1 имеет вид

  &D

или

  & const D

то  тип  содержащегося  идентификатора  есть  "...  ссылка  на  T."
Поскольку ссылка по определению не может быть lvalue, использование
const излишне. Невозможно иметь ссылку на void (void&).
  Если D1 имеет вид

  D (список_описаний_параметров)

то содержащийся  идентификатор имеет тип  "... функция, принимающая
параметр типа список_описаний_параметров и возвращающая T."

  список_описаний_параметров:
      список_описаний_парам opt ... opt

  список_описаний_парам:
      список_описаний_парам  ,  описание_параметра
      описание_параметра

  описание_параметра:
      спецификаторы_описания  описатель
      спецификаторы_описания  описатель  = выражение
      спецификаторы_описания  абстракт_описатель
      спецификаторы_описания  абстракт_описатель  =  выражение

  Если список_описаний_параметров   заканчивается многоточием, то о
числе параметров  известно лишь,  что оно  равно или  больше  числа
специфицированных типов  параметров; если  он пуст,  то функция  не
получает  ниодного  параметра.  Все  описания  для  функции  должны
согласовываться и  в типе возвращаемого значения, а также в числе и
типе параметров.
  Список_описаний_параметров   используется    для    проверки    и
преобразования фактических  параметров и  для контроля присваивания
указателю на  функцию. Если  в описании  параметра  специфицировано
выражение, то это выражение используется как параметр по умолчанию.
Параметры по  умолчанию будут использоваться в вызовах, где опущены
стоящие  в   хвосте  параметры.  Параметр  по  умолчанию  не  может
переопределяться более  поздними описаниями. Однако, описание может
добавлять    параметры  по  умолчанию,  не  заданные  в  предыдущих
описаниях.

                             - стр 279 -

  Идентификатор может по желанию быть задан как имя параметра. Если
он  присутствует  в  описании  функции,  его  использовать  нельзя,
поскольку  он   сразу  выходит   из  области   видимости.  Если  он
присутствует в  определении функции (#10), то он именует фармальный
параметр.
  Если D1 имеет вид

  D[ константное_выражение]

или

  D[]

то тип  содержащегося идентификатора есть "... массив объектов типа
T". В  первом случае константное_выражение есть выражение, значение
которого может  быть определено во время компиляции, и тип которого
int.   (Константные выражения  определены в  #12.) Если подряд идут
несколько  спецификаций   "массив  из",  то  создается  многомерный
массив; константное  выражение, определяющее границы массива, может
быть опущено  только для  первого  члена  последовательности.  Этот
пропуск  полезен,   когда  массив  является  внешним,  и  настоящее
определение, которое  резервирует память, находится в другом месте.
Первое константное  выражение может  также быть  опущено, когда  за
описателем  следует   инициализация.  В  этом  случае  используется
размер, вычисленный исходя из числа начальных элементов.
  Массив может  быть построен  из  одного  из  основных  типов,  из
указателей, из  структуры или  объединения или  из другого  массива
(для получения многомерного массива).
  Не все возможности, которые позволяет приведенный выше синтаксис,
допустимы.  Ограничения  следующие:  функция  не  может  возвращать
массив или  функцию, хотя  она может  возвращать указатели  на  эти
объекты; не  существует массивов  функций, хотя  могут быть массивы
указателей на функции.

     8.4.1 Примеры

  В качестве примера, описание

                             - стр 280 -

  int i;
  int *ip;
  int f ();
  int *fip ();
  int (*pfi) ();

описывает целое  i, указатель  ip на целое, функцию f, возвращающую
целое, функцию  fip ,  возвращающую указатель на целое, и указатель
pfi на  функцию,  возвращающую  целое.  Особенно  полезно  сравнить
последние две. Цепочка *fip()  есть *(fip()),  как предполагается в
описании, и  та же конструкция требуется в выражении, вызов функции
fip, и  затем косвенное  использование результата через (указатель)
для  получения   целого.  В   описателе  (*pfi)()   внешние  скобки
необходимы, поскольку  они также  входят в  выражение, для указания
того, что  функция получается  косвенно через  указатель на фунцию,
которая затем  вызывается; это  возвращает целое.  Функции f  и fip
описаны как  не получающие  параметров, и  fip   как указывающая на
функцию, не получающую параметров.
  Описание

  const a = 10, *pc = &a, *const cpc = pc;
  int b, *const cp = &b;

описывает a:  целую константу,  pc: указатель  на целую  константу,
cpc: константный  указатель на  целую константу,  b:  целое  и  cp:
константный указатель  на целое. Значения a, cpc и cp не могут быть
изменены после  инициализации. Значение pc может быть изменено, как
и объект, указываемый cp. Примеры недопустимых выражений :

  a = 1;
  a++;
  *pc = 2;
  cp = &a;
  cpc++;

  Примеры допустимых выражений :

  b = a;
  *cp = a;
  pc++;
  pc = cpc;

  Описание

  fseek (FILE*,long,int);

описывает функцию,  получающую  три  параметра  специальных  типов.
Поскольку тип возвращаемого значения не определен, принимается, что
он int (#8.2). Описание

  point (int = 0,int = 0);

описывает функцию,  которая может  быть вызвана  без параметров,  с
одним или двумя параметрами типа int. Например

                             - стр 281 -

  point (1,2);
  point (1)             /* имеет смысл point (1,0); */
  point ()              /* имеет смысл point (0,0); */

  Описание

  printf (char* ... );

описывает функцию,  которая  может  быть  вызываться  с  различными
числом и типами параметров. Например

  printf ("hello, world");
  printf ("a=%d b=%d",a,b);
  printf ("string=%s",st);

Однако, она всегда должна иметь своим первым параметром char*.
  В качестве другого примера,

  float fa[17], *afp[17];

описывает массив  чисел с  плавающей точкой  и массив указателей на
числа с плавающей точкой. И, наконец,
  static int x3d[3][5][7];
описывает  массив  целых,  размером  3x6x7.  Совсем  подробно:  x3d
является массивом  из трех  элементов; каждый из элементов является
массивом из  пяти элементов; каждый из последних элементов является
массивом из  семи целых. Появление каждое из выражений x3d, x3d[i],
x3d[i][j], x3d[i][j][k]  может быть приемлемо. Первые три имеют тип
"массив", последний имеет тип int.

     8.5 Описания классов

  Класс специфицирует  тип. Его  имя  становится  typedef-имя  (см.
#8.8),  которое   может  быть   использовано  даже   внутри  самого
спецификатора класса.  Объекты класса состоят из последовательности
членов.
     спецификатор_класса:
          заголовок_класса     {      список_членов      opt      }
          заголовок_класса         {  список_членов  opt  public  :
     список_членов                      opt                       }

     заголовок_класса:
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     агрег:
          class
          struct
          union
  Структура является  классом,  все    члены  которого  общие;  см.
#8.5.8. Объединение  является классом,  содержащим в  каждый момент
только один член; см. #8.5.12.  Список членов может описывать члены
вида: данные,  функция, класс,  определение  типа,  перечисление  и
поле.  Поля  обсуждаются  в  #8.5.13.  Список  членов  может  также
содержать описания, регулирующие видимость имен членов; см. #8.5.8.

                             - стр 282 -

     список_членов:
          описание_члена  список_членов opt
     описание_члена:
          спецификаторы_описания        opt        описатель_члена;
     описатель_члена:
          описатель                         идентификатор   opt   :
     константное_выражение
  Члены, являющиеся  классовыми объектами,  должны  быть  объектами
предварительно полностью  описанных классов.  В частности, класс cl
не  может  содержать  объект  класса  cl,  но  он  может  содержать
указатель на объект класса cl.
  Имена обектов  в различных классах не конфликтуют между собой и с
обычными переменными.
  Вот простой пример описания структуры:

  struct tnode
      {
        char tword[20];
        int count;
        tnode *left;
        tnode *right;
      };

содержащей массив из 20 символов, целое и два указателя на такие же
структуры. Если было дано такое описание, то описание

  tnode s, *sp

описывает s  как структуру  данного сорта  и sp  как  указатель  на
структуру данного сорта. При наличии этих описаний выражение

  sp->count

ссылается на поле count структуры, на которую указывает sp;

  s.left

ссылается на указатель левого поддерва структуры s; а

   s.right->tword[0]

ссылается на  первый символ члена tword  правого поддерва структуры
s.

     8.5.1 Статические члены

  Член-данные класса  может быть  static; члены-функции  не  могут.
Члены не  могут быть  auto, register  или extern. Есть единственная
копия статического  члена,  совместно  используемая  всеми  членами
класса в  программе. На  статический член  mem   класса cl    можно
ссылаться cl:mem, то есть без ссылки на объект. Он существует, даже
если не было создано ниодного объекта класса cl.

                             - стр 283 -

     8.5.2 Функции члены

  Функция, описанная  как член, (без спецификатора friend (#8.5.9))
называется функцией  членом и вызывается с помощью синтаксиса члена
класса (#7.1). Например:

  struct tnode
    {
      char tword[20];
      int count;
      tnode *left;
      tnode *right;
      void set (char* w,tnode* l,tnode* r);
    };

  tnode n1, n2;

  n1.set ("asdf",&n2,0);
  n2.set ("ghjk",0,0);

  Определение  функции  члена  рассматривается  как  находящееся  в
области  видимости   ее  класса.   Это  значит,   что   она   может
непосредственно использовать  имена  ее  класса.  Если  определение
функции члена  находится вне  описания класса, то имя функции члена
должно быть уточнено именем класса с помощью записи
     typedef-имя . простое_оп_имя
см. 3.3. Определения функций обсуждаются в #10.1. Например:

  void tnode.set (char* w,tnode* l,tnode* r)
    {
      count = strlen (w);
      if (sizeof (tword) <= count) error ("tnode string too long");
      strcpy (tword,w);
      left = l;
      right = r;
    }

  Имя  функции  tnode.set  определяет  то,  что  множество  функций
является членом  класса tnode.  Это  позволяет  использовать  имена
членов word,  count, left  и  right.  В  функции  члене  имя  члена
ссылается на  объект, для  которого была  вызвана функция.  Так,  в
вызове  n1.set(...)   tword  ссылается  на  n1.tword,  а  в  вызове
n2.set(...)     он  ссылается   на   n2.tword.   В   этом   примере
предполагается, что функции strlen, error и strcpy описаны где-то в
другом месте как внешние функции (см. #10.1).
  В члене  функции ключевое  слово this  указывает на  объект,  для
которого вызвана  функция. Типом  this в  функции, которая является
членом класса  cl, является cl*. Если mem - член класса cl,то mem и
this->mem -  синонимы в  функции члене  класса cl  (если mem не был
использован в  качестве имени  локальной переменной в промежуточной
области видимости).
  Функция член  может быть  определена (#10.1)  в описании  класса.
Помещение определения  функции члена  в  описание  класса  является
кратким видом  записи  описания  ее  в  описаниии  класса  и  затем
определения ее  как inline  (#8.1)  сразу  после  описания  класса.
Например:

                             - стр 284 -

  int b;
  struct x
    {
      int f () { return b; }
      int f () { return b; }
      int b;
    };

 означает

  int b;
  struct x
    {
      int f ();
      int b;
    };
  inline x.f () { return b; }

  Для функций  членов членов  не нужно  использование спецификатора
overload (#8.2): если имя описывается как означающее несколько имен
в классе, то оно перегружено (см. #8.9).
  Применение операции получения адреса к функциям членам допустимо.
Тип параметра  результирующей функции  указатель на  есть (...), то
есть,  неизвестен   (#8.4).     Любое  использование  его  является
зависимым от  реализации, поскольку  способ инициализации указателя
для вызова функции члена неопределен.

     8.5.3 Производные классы

  В конструкции
     агрег идентификатор:public opt typedef-имя
typedef-имя  должно  означать  ранее  описанный  класс," называемый
базовым классом  для класса,  подгежащего описанию.0 Говорится, что
последний выводится  из предшествующего.  На члены  базового *ласср
можно$ссылАуьсяl! как ╡сли бы они были члепами пройзводного класса,
за  исключением   тех  случаевl   когдд  имя  базового  члена  сыло
нереопреддлено в  производном клаaсе;  в этом  ёлучае для ссылки на
скЁытое имя  может (хполь'оваться такая запись (#7.1):
    ftypedef-имя :: идентициjау╛р
  Например:

           0  !  0          (- стр 285 -

  ct2uct base    {
    ( int a;M
      ynt т;M
    };

  svRuct deriwed : public base-
    {
   0  int b;
    ` int c;    };

  derived d;

 $d.a = 1 !d.basu;:b = 2;
  d.b = 3;
  d.c = 4;

осуществ+яет прис"аивание четырем члена╝ d.
  ПрОизво$ный тип сам может исПкльзовдтьсэ как базов√й.

   ! 8.5.4 Виртуакьнще функций

  Если ▒азовый  класс base `соде└цит (виртуаыьную)$ vibtUal  (#<.1+
фснкци■ vf( !а про(зводны) кл сс derived также#содхр╢ит функцию vf&ую вызов  vf  для  объе║та  класса  derived  вызывает  derived::v╞.
Например:

  struct base
    {  `   rirtual void vf ();
      void f ();
    }

   strїct0dmrivхd : pub,ic base
    {
`   $ voyd vf ,);
$     void f ();
  (!};

  derived D;
  base* bp = &d;
Н
  bp->vd ();
  bp->f ();
  Вызовы вызывают-  со.тветс┬женно,    derivef::vf  и  basх::f  ┤ля
объек┬а кЛасса` deriv%d,  именованнозо  d.  Так (что  интер┐ретация
вызова`виртуальной  функции!завискц (от типа  объекта, для которогоН
она вызгана,  в то  вфемя каи  интзапрерация  вызовд  мевиртуальнпй
функции зависит только от типа указат%ля,!обозначающего о▒ъект.
  Из  этого  следует,  что  тип  объектов  классов !с  виртуальными
функцияма и  объектов классов,  вывеенных из  таких классов, мюгут▒ыть жлределены во время въполнения.

  `          (        (     (- сЄр 286 

  Если производный  клащс имеет  чле╜ с  т%м же  именем,  что  и  у
вирутальноб функции  в базовом  *лассе, то  оба$члена  должны иметь
╛динаковый тип.  Виртуаль-ая функция  не может бытьадру#ом (friend)
(#8.5.9). Функция  f в аклассе, выведднном из класса, который имеет
виртуальеую  фунлжию 1 f,а сана  фассматрив░ется  как  виртуалмная.
Виртуал─ная  фунКция  в  базовоо  классе  должна  быть  ппреаеленр.
Виртуальная фун▓ция<  которвя!был   опрнделена в базовом классе, не
нуждается  в  определении  в `прошзводном 0классе.  В  этом  слычае
функция, определенная  дл ббазового  класса, испкльзуется  во  всех
вызовах&

     8.5.5 Коестсукторы

 "Член функция с йненем, совоадаюiим с кменем ее класса, назыв етсяконструктором. Ккнсъруктор не И,еет типа возвращаемоГо значения; он
испОльзуется для  констрєирования значений  с типои  %го классао  
помощью  кмнструк┬ора  можэо  солдават№  новые( объекты  его  Єипа,
йспользуя$синтаксис
     vyЁadef-имя ( список_прфамецров opt )А Напрммер,Н
  complex zz =0compnex (5,2.3);

  cqrint (complex (7.8,1.2));

  О!·елты, !смзданные   такмм аобра╖ом,   не$ имеют   имени   (есла
консуруктор не  использован као "инициализаторl0как  это было` с zz
вkше), и  их время  жизни@ограничено  областфю0видимости,ав которкй
ониащоз$аны.  Кни не  иобут рассматЁаваться  как константы их типа.Н
Если лласс  имзет конструктор, то он вызывается для кажжого объекта
этого класса перед тем, как этот пбъекъ буДет как-либо испольжован;
см. #8.6.  Консруктор может быть overnoad, но н% virtual$или fryend.  ┼сли кпасс  имеет базовый  лласё  с конструкторжм, то конщтрукЄор
для  базового  0кы░сса  вызывается   до  вызова   конструктофа  еля
проиеводного класса. Конструкторы аля объектов членов, если таковых
есть,  выполняытся   поспе  коеструвтора  "базового  класса   и  до
конструктора о!ъекта,  содержащег╛ их.  Обкяснение ЄоГо,  как#могут
быть хпецифицировины параметры для ╡азового класса,$хм.ав #8*6.2, а
того,  оак   конструкторы  могут   использоваться  Для   управления
свобод-ой памятью,"см. в #17.
     8.56!ПреобрачованкяJ
  Констрсктр, получдющий  один яарбмеър,  определяет0прЕобразование
из типа  своего параметрб в тип своего клксса. Такие преобразования
-еявно $!применяются   дополнительно   к а обычным   асифметическим
прмбразмва-иям. Поэцому Паисваивание(объектч из класса \ допухримо.
если$или  присваивиемое з╜АчеНие  является  ,  илм  если  X  имеет
консцрукто└,  котюрыЙа получаец  приуваиваемое  значение  ║ак  ┴вой
единственный па└аметр.  Аналогично  конструкторы" используются  дляпре/бразования парр,ет└ов  фтнкции (#7.1) и иницмилмзаторов (#8.6)м
Например:

                             - су` 287 -

  class X { ..."X (int); };
  f (X arg)НJ    {
      X a = 1;          /* a0= \ (1) */
      a = 2;            /( a = X (2) ./
      f (3);  0        !/* f 8X (3))"к/
    }

  Ески$для  класба"X (не  найден  ниодин  констаукъор<  принимающие
присваивазмый  тип,   то  не   $ела╡ъся" никаоих  пмпыток  .тыс║ать-ионстсуктор для  преобразпвания присваиваеоог╛  тйпа в тип, который
мог бы!быть прием╗еа ┤ля коНртрукторов классА  X. Назример:
  blAss X { ... X (int); =;
  cla;s X { ... Y (); };

  Y a =01;              /к неджпустимо:аY (X (19) Не пробуется *o
M
     8.5.7 Деструкторы
Н
" Хункция член  класса cl  с иоенем  ~cl  называется  ееструктором.-
Деструктор не  вопвращает никакого  знач%ния и  не получаеЄ никакиї
параметров;  он  используется$ для  ункчтожени╧  ╖начений  типа  cl
непосредствхнно !перед   уничтооением   содержащего   их   обjекта.
Жеструктор не может быть o6drload, virtual или friend.
  ДЕструктор для `газового  клабса авыполняется  после  д%структора
производного  от  него  кларсао  Кик  деструкторыа ис┐╛льзуютя  для
упаавления свобкдной памятью, см. объяснение в #13.
     (.5.8 Видимость имеН членов

  Члены  кларса,   описанн█Е  ё  ║ыючевым  словом  clarq,  явлoются
залр╦тымй, это `значит, что  иэ им╡на" могут использоватьсэ  толlко
функюиями чл%нами  (#8.5.2)   и дрыз|ями (см. #8/5.10), покб они ннпоявятся после  аметки pubmic: . В этом случае они являются общими.
Общий член  можеъ использовАться любой фун*циЕЙ. Струкрура является
классом, все члены которого общие;$см. #8.5.19.
  Есги перхд "и,енем базового класса вбописании производного кЛасса
стоит  ключевое  слоВо  public,  то  общиз  члены  базового  класра
яткяются общими  для`проигводногм  *гаса; если нет, то опи являются
закёътыми. Пбщий член mem закрытого базпвого класaа base мовет"бытш
оп(сан каи общий для яроизводногп класса с помощью опиисан╕я вида
     typedef-имя . идентихикатор;
в котором` type$ef-имя означает ▒азовый клаёс, а шдентификатор есть
имя ╟лннд  базового класхб.!Такое опИсание может появляться в$общей
части проИ╖водногЪ класса.M
 "Рассмотсим
                             = стр 288 -

  clqss base
    
     (int a;
  public8
      int b,c;
     "int bf (й╗
 "  };

  clasq derivgd : base
a   {
      int d;
  publmc:
      #ase.c;
  а   knt e;К      int df ));
    };J
  mnt ef heerivel&);
-
  Внешн я функция  gf может  использоватэ только  имени c,`(e и df.НКЯвля╧сь0ўленом derived, фунъция df может исп╛льзовать имена ",  c-bf d,  E    и   df, йо не`a. Являчсь членом тase, функция bf дожет
использотать члены a, b, c  и  bf.

     8.5.9 Друзьo (friends)

  Другом   класaа   явгяется   функция   неmчлзн,"  котоаая   можнт
использ.вауь0имена  закрытях членов.а Следующий нр╕мер иллюётрирг╡т
рапличия между члхнами$и друзьямиz

` clasє trivate
  $ {
`     int a;
      frienD void fzient_set (privave*,int);
 $publik:
      vomd memcer_set (int	;
   а}3

 $voiD friendqet (private* p,int i) { p->a=i; }

  6oi` private.member_Set (int i) { a = i; }КЕ
  0rivate obj;
  frщend_set`('obj<10);

  obj.melbar_cet"(10);
К  Если  озисание   friend  отпощтися  к  пефегруженноиу  имени  или
операфии, то  другом хтановится  тольло0функц╕я с опи┴анными тип ми
параметЁов. Все hфчнкции класёа  cl1 мо│ут  бытьа(сделаны  друзьямикласса cL2 с помощьn одного описания

              "   $`       ! - свр 289 -

1 class cl2
    {
  0  afriena cl1;
      & . .
  0 ;
   0 8.5.10 ФункцИя операция

   Бплl`инство  операций могтт  быть п╡реуружены  с тем," чтобы они
могли ┐олучать(в качдстве опдрандов объекты класса,
      имя_фунвции╛пеЁации:   mperato2  op
    op:         `( +   -   *   /   %   ^  &   | ( ~
                   !   9   <   >   +=  -=  *=$ ?=  %=
     а  "  "   @   ^=  &= !|=$ <<$ <>  <= >>= ==  !=
          ( "    * <= !>=  &&  || `++  --  ()  [U
ПОследние двх  операции  - !это  выгов  функции 0и  индек┴ирование.
Функцию операция  может или  бытю функцией  членом, или получать по
оеньшей мере один пабаметр клбсса& См. также #7.16.

а    8.5.11 Структуры

 !Стрыктура ещть класр, все члены которого обyие. Это жначит, чво

$ struct s { ... };
эквивалентно

  class s${ public: ... };
  С┬руктура может "иметь  функции  члены  (включая  конструкторы  (
деструкторы).

     8.5.16 Объединения
  ОбъединдниЕ мкжно  считать сцруктєрой,  все об╩екты ялены которойначинаются  ро   соещ%ния  0- 0 и  размер  которюйа достатОчбн  для
содержания!любогю  аз ее$объектот членов. В каждый момннт времени в
объединеии мзжет  хран╕ться не  !о+№ше одного  из осъектов  членов.
Кб╩единение может  иметь  функции  членщ  8включая  конст└укторы  и
дестаукцоры).

     8.5.13 Поля бит

  Описате+ьчлена вида
     и$ентификатор opt:  консъантное_выражнние
опредзляет поле:  его д+йна  отделяется ют  имени поля  двоеточием.
Ппля упаковываются  В0машинные Ўзл·е; они нб являются альтернативой
слов. Поле  ,а╜╡ влезающее в оставшееся в"целом место, помещается в
следуюшее слово.  Поле не !можеb "бырь  шире  слов░.  На  некоторых
машинах  они  аазмещвются  справа( налево,  а  на  некоторых! слеванаправо; смn #2.6.

$                        (   - стр 290 -

  Э%именоганные поля полезны при звполненйи для спглбсования внешне
оредписанных рае╝еiений  (форматов).!В!осойых сгучаях неименованныб
полэ"длины  0 задаюр выравнивание(следующего`поля"по грвнице слова.
Не уребубъся (вяпарауной поддержки  любых полей, кроне челых. Солее
того,(даже  целые поля  мм│ут4расс,ат└иватьсч как unsigned. По этим
причинам рЕкомендыется!аописыватф поля  как unsigned.  К  полям  неможет0 праменяться   опеЁация  получемия   адреса  &, 0поэтому  нет
ук жатЕлей на полы.
  Поля не могув бытш членами объединения.

     8.4.14 Вложеннkе класхы

  Клдсс можеЄа быть описан  жнутри др├гого  класса. В  этом  случае
область  гидимости   имен  ▓нутаенеего  класса  его  и  общмх  имен
огааничи▓вбтуя   охватывающим   клАсуом*   Еа   исключением   этого
овраничения дооустимо,  хтобы внутренний  класс уое  был описан вне
пхватываьщего"класса.  Опис░ние одногп  клаёсв  внутри  другого 0не
влияет!на  правила доступа ак збк└ытым членам и нЕ`помещает0функции
членk внутаенн╡го  класси в .бласть видимости охтатщваъщего класса.
Напри╝ер:

  knt x;

  class dnclose   /j охва┬ыврющйй */
" ( {
      int x;
      class ilndr
        {
          int y;
        ! f () { x=1a}
          ...
       (};
      g (inner*);К     ...
    };К
  iot inner;0 /* вл.женнын */

( enchnse.g (in~er* p) { ... }

  В эъом` зсимере x  в f  ссылаеЄся на !8, описамный  перед классом
enclose. Поскольку  y являетсю  закрытым членм╝ (infer,  g не можетего испжльзовать. (Пкск╛льку c   являеуся  членом  enclose,  имена,
использованные в  o, ёчитаются  наэодяща╝ися  в  области  вижимостиM
клахха enclose.   Поэтому innEЄ в описании параметров g"Относитщя к
охваченному типу inne2. а не к int.

     8.6(Инициализация

ааОп╚сани╡   может $ з0давать   наявЛьное   значхние   описываемого
и┤ентификатОра. Инициагигатору  предшебтвует =,  и  оН  состоиц  и╖выражемия Или списка значений. зАк╗юченн.го`в фиггрных скобки.

     "             " "       н стр 291 -
     инициализатжр:
          =                               `              exprgєsionН
 `        =          {           список_инкциализаторжв     !   0 }
     "    =   !   {     0  спищжк_йнмциализаторов    0   ,  !     }
       (  ( `      "      0   список_выражений                    )
!    списюк_инициализаторова                   $                  :
    $     выраждние
          с┐исок_инициализаторпв   !  ,      список_╕нициалИзатюров
          { спиуов_╕нициалИзаторов }
  Все выражения в инициагизаторе статической или внешней переменн╛й
должны быть  конэтАнтными въражн-ИяМи,  которые описаны0в #15,  или
выражениями, которые сводятся к ░дресам рамее опмйапных переменныф,
в.гможео со (смещением на  константное выраженй%.  Автомат(ческие и
релистровые переменные"могут иницйилизиржваться люгыми выражЕэиюми,
включищими!константы, ранее опищанные перемнннkе"и цункции.
( Гарантируется, что `неинициа+изированнын  статические  и  внешниеM
пере╝енные  получают   в  качеств%   начального  значения   "пустое
жначение"*> ЪЮгда  инициализаяор примднпе┬ся" к скаляру  (улвзбтеыь
или объект `арифметичебкого типа),  он состоит из одного высазения,
возможнп, заключенного  ж  фагсрные  скобки.  Начальное    'начение
объектаанаходится 0из выражения;( выполняътся те же преобра╖ования,
чцк и при присваивании.
  Заметьт%, что  пмскольку ((  н╡ явля%тся  инициалкзаторпм,!то 0"X
a(i;   вляе┬ся  не ояисанием объекта олауса0X, а описанием функцйи,
не получающей значений и возвращающей X.

     8.6.! Списол иншюиализаторов

  КОгдб описанная переменная является сос┬авной (кыасс`или массив),
то0инициализбъор  может состоять из заклюуенноГо в фигырные скобки,
разделенного запятщни( списка инициализат╛ров для членов!составнобо
объекта, в  поря$ке возрастайия индекса и╗и!по порядку членов. Если
массив содерхит  составные п.добъекты,  тк это  правило  рекурсивно-
праменяется к  членаМ составного подобъекта.!Е┴ли(шницИаличаторов "
сПиске меньше,  чем яленов  в составном !подобъекте,  то  соутавпой
подобъект д.Полняется нулями.
  Фигурнуд `скобкк   могут  опускаться   след├ющим  образом.   Дсли
книциаыизатор начинается  с левой фигурной сКо▒ки, то следующий  за
ней список0инициализаторов&инициализирует члены составн╛│о объекта;
наличие  з╕сла(  инициалмзаторов,  большего, 0 чем  число  !ч+енов,
щчйтдется ошибочным.  Если, однако,  инициализаторане  начинаетуя слев.щ цигусной  скобки,  то  иж  списка  берутся  толхко  эледенты,
д.статочпые для  сопоставления членам  составнозо  объекта.  звстью
кпторого является текущий составной объект:
  Например,

  int"x[] = { 1, 3, 5 };-

описывает и (инициали'арует x  как ╛дномерный  масщив, и,еющий  три
члена, поскольку размер не был указаН и двйо три и╜ицирлизатораn
___________________
  * В  английском "carbage",  означаюсее зате└тое  мбсто" [памяти],
т.еn если *переменная  челбя,  то  4,  Если  chap,  то  '\0', !есл(
указатель"на Т, тю (Т*) NULL.

    0       (     0          - сур 292 -
  f|oat y[4][3] ╜
      {
    $   √ 1, 3, 5 },
  " а   {%2, 4, 6 },
 а  а   { 7, 5, 7 }     $};	

я"лэетс  пклн╛стью  снабженной квадрАтными скоб║ами инициализацией>
5,3 ш 0инициаличидуот  первый ряд массивв y_0], а именно, y[0][2].Анакогично, следчющие  две строки! инициализируют    y[1y  и  y_2].
Ипициализатюр заканчивается  раэьше, поэтому  y█3] инициализируется
значением    0.  В точноcти  тот же` э╞ф╡ит может 0еыть достигнут с
по╝ощью

  floqt y[4][2] =
   !{
      1, 3, 5, 2,!4, 6, 3, 5, 7
    };

  Инициализатор для  y м чинЁетря  с левой  фигурной скобки,  но не
начинается с  н%е мнициализатор  для i[0], поэтому используетсч три
значения из  спиука. Аналогизно, cледєющие триауспЕшно используют┴я
еля y[1]$и следующ╕е!три для y[2M.
J  float yY4][3]"= {${ 1 }, { 2 }, {03 }, { 4 } };

и╜йциализисует   первый стол▒╡ц  y 8рассматриваемого  как двумерный
маaсив) и оста"ляет пста╗ьнле(элементы нул ми.К
     8.6.2 Класспвые обjекты

  Оеъдкт с  заксытыми членами  не м┐жет быть(инициализожан с помщью	
оростого"присваивания,$кбк это юпислвалось выше; этО же о┬йосится к
объекту объединение.  Если класс  имеет консттуктюр, "не получающий
значений($то  этот ъ╛нструктор( использунтсяадля  объектов, кот╛рыЕ
явно не меициа╗(зированы.  Пбраметр√ для  консуруктора м.гут  такце быть офедстбв+ены в виде
зак╗ючзннОго в кругляе скобки списк . НАпример*

  sTruct$comple~
  ! {
      float re;
     "float im;
      co-plex (flmat r,float i) {`re=r; im=y; }
      somplex$(float r) { re=r; im}0; }
    };

  somplex zz (1,2.3);
  complex* zp = new complex (1,2.3);

  Инициализация  может   б╦ть  такжс(0выполнена "с  помощью  явного
прис▓аивания; преобразования произвцдятс╧. Например,
Н
                  0     (    -`стр 293 -

  complex zz1 } complex (1,2.3);Н
  complex(zz2 = complex (123-;
( complex zz3 = 123;	
  complex zz4 = zz3?

  Дсли конструктор  ссыыается на объект своего собственного класса,
то он  буд╡т вызывиться  пЁи книциализации  объект░ другим объектоь
этогп класса, но не при инициализацаи объекта конструктором.
  Объект  класса,   имеющего  коестшукъорл,   может   бытh   чл%ном
составно│о объекта` только если  он сам  не имееЄ  конструкторв илй
если его `конструкторы не  ииеют  пар░метров.  В  последнем  случае
конструкткр вызы▓ается  при создании  составного обтекта. Если член
составного юбъекта  является членом класса с дебтсукторами, то этот
деструктор вызывается при уничтожемии роставного объе*та.

     :.6.3 Ссылки

  Когда оеременная  ооисана как Tf, что есть "суылка на тип T", она
может быть   инициали╖ирована или указателем на тип T, или объектом
типааT.  В пос╗еднем  случае будет неявно применена жперация взятияадреса &. Например:
J  int i;
  in4& r1 = i;
  int& r2 = &i;

И r1 и r2 будут укдзывать на i.
  Обработка инициализации( ссылки очень сильно зависит отатого, что
ей  присваивается.  (Как  описывалось$  "   #7.!,   ссылкр   неявно
переадрестбтся пфи ед использовании. Например

  r0 = r2;

означает ккп╕рова╜ие( целого, на  котороб указывает r2, в целое, на
которое указыкает r1.
  Сбылка"должна  быть инициализована.  Таким образом,  ссллку можно
счйтать именем ╛бъекта.
  Чвобы полгчит№ указатель pq, обоз╜ачающий тот обект, что и ссылкб
r2, можно  написать pp=&rr.    Это  будет  проинтерпретиаогдно  как
pp=&*rr.
  Есги инициализатор  еля ссылки "на тип  T  не  явгяется` адфнсным
въраоееием, ъо  будет  создан  и  инициализован  с  помощью( правил
инициализации объект  типа T.  Ыогда значен╕ем  ссылки стандт адрес
объекта. Время  жизни объекта,  созданного таким  спос╛бом, будет в
той области ▓идидости в которой он сопдан. Например:

  dkubde& rr = 0;

дппустимо, и  rr будета ука╖ывать на  объект типа dOuble, " кото`ом
хтанится знвчение 5.0.
  Ссылки"особепно полезны в качестве типов параметров.

           !                 - стр 294 -

     8.6.4 Массивы символов
  Последняя сокращенная( запись позволяет  инициализировать строкой
массив данных  типа charn  В этон  случае последовательные  символы
строки иницшализируют члены массива. Например:

  char msg[] = "Syntax error on line 5dXn";
демонстри└ует" массив  символов,  члены  которого  иншциалшзир.ваны
строкой.

     8.7 Имена типов

  Иногда (для  неявново задания  преобразования тмпов  и в качестве
пафаметрб sizeof0 или new)  нужно использоватэ имя типа данных. Это
выполняетс╧ пши (помощи  "╕меми  типа"  которое  по  сути  является
описам(ем длч объекта этого типа, в коЄором опущенж имя объекта.
     и╝я_типа:
          спецификатор_ткпа абст`актный_оПисатель
     абстриктный_описатель                а                       :
 `        пустой
          "         `           а             абстрактный_описатхль          абстрбктнщй_описате╗ь    (  списоко_писателей_параметров+
     !    абстраквный_описатель    [  константное_выражение  o0t  ]
          ( абстрактныщ_кписатель )
  Являетaя(    возможным h    идннтифицировать     положение      в
абстрактном_описателе, где должен был бы /оявляться идентификаЄор в
с╗уча╡, если  бы оонщтрукция  была  описателем! в  описании.  То│да
именоканный" Єип   эвляется  тем  же,  что  и  тип  предполагаемого
идентиьикатора. Например:M

  int
  int *
  int *[3]
  int *()
  int (*)()

имену%т,  хоответсвенно,   типы  "целже",   "ук░затель  на  ц╡лое",
"указатель  на   ма┴сив  из` ттдх  целых",  "функция(  возвращающая
укачатель на функцию, впзвращающую целое" и "указатель на целое".
  Простке  имя   типа  есть   имя   типа,   состоящ%е   Из   одного
идентификатора или ключевого слова.
     простое_имя_типа:
         `typedef-имя
          char
          short
а         Int
          long
   а      unsigned
          float
          do5blх
  Они испольЗуются  в альтернатИвном  синтаксисе для ореобразования
тип.в. Например:
                       (     - стр 295 -

  (`ouble)`a

мозет быть также записано каи

2 double (a)

     8.8 ОпреДеление типа typedef

  Описания, содержащие  спецификатор_описания  typedef,  олределяют
идентиьикаторы, которы  пцзднее могут0 использоваться так, как если
бы  они   были  ключевщми  словами  типа,  именующне  основные  или
проипводные т╕пы.
     typedef-имя:
          идентидикатор
  Внутри .бласти  видимости опшсания,  содержащего typeden,  каждый
идентификатош,0 возникающий   как  часть   какого-либо   описателя,
становится в эт╛м месте синтаксическк эквивалентным(ключевомc слову
типа, которое  именует тип, ассоциированный с идентификатором таким
обсахом, как  описывается в #8.4. Имя класса или перечисления такжх
является typedef-именемо НапЁимер, поске

  typedef int MILES, *KLICKSP:
  qtruct complmx { double re, im; };

киждбя из конструкций

  MILES distance;
  extern KLICKSP metricp;
  complex z, *zp;

является допусримым  описанием{ dystanbe  имеет  тип ░int,  metricp
имеет тип "указатель на int".
  ty`edef  (не вводит  ногых bипов,  нп только  синонимы для типов,
которые могли  бы быть  опфееелены другим  путем. Так в приведенном
выше примеЁе  distance рассматривается  как им%ющаяя в рочности0тот
ое тип, что и░любой другой int объект.
  ЙО описание класса вводит новый тип. Например:

  struct X { int a; };
 "stЄuct Y { knt a; };
  X a1;
  Y a29
  int a3;

ояисывает три пер╡меннлх трех различных типов.
  Описание видв
     описани%_имени
          агрег                   идентификатор                   
          enum  идентицикатор ;
определяет (то,$  что  идентификитор   являЕтся  именем  невоторого
(возмоцно, еще  не определенного)  клаaса или  перечисления.  Таки%
описанич зозвол юЄ  описывать классы,  ссылающихся друг  на  друга.
Наоример:

                 $       0   - сцр 296 -

  class vector;
  class mqtrix
    {
`     ...
      friend matrix operator* (mavЄix&,vector&);
    };

  class vector
  " ;К      ...
      friend matrix operator* (mitrix&,vegtor&);
  ! };
     8.9 Перегрувенняе имена функцкй

  В тех0 случаых,  когда  для  одного  имени  определеню  несколько
(различных) описаний функций, это имя0на╖ыврется /ерегргженным. При
Использовании ¤того "имени правильнвя  функция выбираеъся с помощья
сравнения  типов  факти╟еских` параметров! с  типами  параметров  в
описаниях функций.  К  перегруженным  именам  неприменима  операция
пойучения адреса &.
  Из обычных  арифметических преобразований, `определенныe в  #6.6,
для а  Вызова     перегруженной    фу-кци(    выпол-яются    только
char->short->int, int->double, int-long и float->double. ДЛя того,
чтобл перегрузить  имя фуНкции "не-члена описанйе  overload  должно
предшествоваъь любОму описанию функции; см. #8.2.
  НапримеЁ:

  ovurload abs;
  int abs (mnt);
  double abs (touble);

  Когда  вызывается `перегруженное  имя,  по  порядку  производится
┴канирование спиука "функций для нахождения той, коткрая может быть
выЗвана. Например,  abє(12) вызывает  abs(int), а  abs(32.0)  будет
вызывдть abs(doucle). ┼сли бы был заЇезервирован порядок вузжва, то
лба обрвщения вызвали бы ebs(double).
  Если   в   случае   вызов░   перзгруженного   имени   с   помощью
вышеуказанного метода  неанайдено  ниодной функци╝,  и если функц╕я
получает парамЕтр ┬ипа класса, то конс┬укторы классов парадетров (в
этом случае суэествєет едиястве-ный  набор преобраЗований, мелающий
вызов доп├стимым) применяятся неявэым образоь. Например:К
  claws X { ... X (int); };
  class Y { ... Y"(int); };
  class Z { ... Z (char*){ };

  ovebload щnt f иX), f (Y);
  overload int g (X), g (Y);

  f (1);        /* неверно: неоднознаўэость f(X(1)) или f(Y81)) */
  g (1-;        /* g(X(1))                     $        */
  g  "asdf");   /* g(Z("asdf"))        (                */

                "            - стр 297 -

  Всн    имена    функций    юпера╞ий    являются    автомдатически
перегЁуженэыми.

     8.10$Описание перечисления

  Перечисления`явлnются int с именованными конaтанубми.
 0   mnum_спецификатор:
          enum    идентиф(катор     opt     {   ` enum_список     }

     enum_списоъ*
          перечислителф
          enum_список,       0               $ (      перечислитель

     перечислитель:
 $       `идентификатор
          идентификатор = константное_выражение
  Идентификаторы  в  enum-сп╕ске  описаны  как  константы  и  могут
ноявляЄьс   во  всех  местах,  где  требуются  константы.  Если  йе
появляется( ни   одэого Аперечислителя   ┴  =,   то  зНачения  асех
соотжетствующих констант !начйнаются х  0 и возрастаюц на 1 по мере
чтения   опихания   слева   нарпаво.   Переяислитель!  с   =   дает
ассоциированному   с   ним   идентшфикатору   указанное   значениЕ;
последующие идентификаторы  продолжают прогрессию  от пЁисвоеннного
зеначения.
  Имена  пер╜числителел  должны  быть  отличными  ╛т  имен  обычных
переменных. Значения  перечислителей  не  обяпательно  должны  быть
различнkми.
  Р.ль  (  идентификатора      в     спецификаторе "   леречисле╜ия
elum_сНецификатор! полностью"  ана╗пгична  роли  имхни  класса;  он
именует кпределенеый нутератор. Наприиер:

  enum color { c(artre}se, burgendy, уlaret=20, winedark };
    ...
    color *cp, col;
    ...
    col = claret;
    cp = &col;
    ...
    mf (*cp == burgundy) ...

делает color  имбнем типа,описывающего  различные  цвета,  и  затем
опихывает cp ║ак указатель на объект этого типа. Впзможные знвчения
извлекаютс╧ (з множества { 0, 1, 20, 21 }.
     8.1! Опмсание Asm

  Описание Asm имеет вид
    asm )строва);
  Смысл ╛писан╕я  asm  неопределнн.  Обычно  оно  исплкьзуется  для
яередачи инфор╝ации дссемблеру чер%з компилятор.

                  (      (   - стр 298 -


                        9. ОПЕАТОРЫ

  Операторы выполняются послддовательйо во всех случаях кроме осжбо
оговоренных.

     9.1 Оператор выражение
  Аольшинство операторов  является операторами  вытажение,  кото└ые
имеют вид
     ▓ыражение ;Н
  Обычно операторы  выражение являютхя  присваиваниями  и  вызовами
функций.

   а 9.2 СоставнОй оператор, или блок
К  Составной оператжр! (называемый также  "блок", что  эквивалентно)
дает возможность испольчовать несколько жпеааторов в том месте,(гфе
предполагается использование одно│о:
     составной_оператмр:
          { спис╛к_описаний opt список_операторов opt }
 0   список_описаний:
          о┐исание
          описание списов_описаний
     ╤оисок_операторов:
          оператор
          оператор спиуок_операторов
  Ес╗й какмй-либо  из идд╜тификаторов  в списке_описаний  был ранее
описан, то  внешенее описание  выталиивается  на  время  выполнения
блока, и снова входит в силу по его окончании.
  Каждая инициализиция  auto или   register переменных производится
всякий раз при гходе в волову блока. В блок депать передачу; в этом
случае $инициализации  не  в√покняютс .  Ин╕циализации  переменных,
имеюыих класс пам╧ти static (#4.2)0осуществляются только ожин раз в
начале вы/олнения программы.

 $   9о3 Условный оператор

  Есть дв  вида условеых оператодов
     if ( выражение ) оператор
     if ( выравение ) оператор else оператор
  В обоих  случаях въчислэется  выражение, и  если оно  не ноль, то
выполняется ┐ервый подоператор. Во втором случае второй подоператор
выполняется, если  выражение еруь  0. Как  обычно,  неодноз-ачность
"else"  разрешается   пжс└едствОм  того,  что  else  связывается  сM
последним встречнным ig, не имеющим else.

     9.4 ОперАтор while

  Оператор while имеет вид
     while ( выражение ) оператор
К                   ` !       - стр 299 -

  Выпо╗пдние   подоператора повторяе┬ся,  пока  значение  выражения
остается ненулевым.  Проведка выполнпется  перед║аждым  выпойнением
оператора&

  $  9.5 Оператор do
  Оператор do имеет вид
    !do пператОр wjIle (выраженин);
   Выполнение   подоПератора  повторяется до тех пор, пока значение
выражения н╡  станет  нулем.  Проверка  выполняется  после  каждого
выпплнения оператора.

     9.6 Оператор for

 (Оператор for имеет вид
     for (  выражених_▒ opt  ; выражение_6  opt ; выр░жение_3 opt )
          оператор
   Этот опхрауор эъвивалентен следующему:

 !                   "`      - стр 300 -
     выражение_1;
     while                       0                    (вышажение_2)
     а           а                     $             (            {
            $                          0                   оператор
                  `                                    выраже╜ие_3;
       }
  ПхЁвое выражение  зафает инициализацию  цивла;  второе  выражение
еадает осуществляемую  пербд каждой  итерацией проверку, по которой
производится выход  из  цикла,  если  выражение  становится  нулем
тре╞ье выражение  чарто задает приращение, выполняемое После кавдой	
итерации.M
 0Каждое  или   все  выфажения 0 могут  быть   опущены.  ОтсуЄхтвие
выражения_2 делает  подразсмеваемое while-предложение  эквивалентым
while(1);! остальные  опущенные  ▓ыражения  просто  пропускаются  в
описанном выше расширении.

 а   9.7 Оператор suitch

  Операт.р !sw)Tch   вызывае┬  пере$ачу   уяравления  на!  оди╜ !из
нескольких операторов в зависимости от значения выражения. Он имеет
гйд     switch"( вуражение ) оператор
 ! Вщражение  должно быть  целого типа0 ил( типа  указатдля/  Любой
оп%сатор внутри  оператоса  может  !ыть  помечен (оДним  или  болбеJпрефиксом case следующам образом:
     casm      константное_выражение :
где константноб  выражение должно иметь тжт же тип что и выовжение-
переключателэ; производятся$ обычные ░рифметичес*ие преобразованйя.
В одном операторе switch никакие две1константы, помеченные case, не
моггт  иметь ( одинаковое  значених.! Константные "выражения  точно
определяьтся в #1=.
  Ножет также быть не более чем один ┐рефакс оператора вида
     default >
  Кюгда  выполнен   оператор  │witch,   проведено  вычисление  (ело
аыражения и  сравнение его  с каждой  ca{e константой. Если одна из
констант"равна  значеэию выражения,$ то  управление  передается  на
выражение, следующее  за подореашим  префиксом case.  Если  никакая
case константа  не соответст"ует выражениц, и ерть префикс defaUlt,
то управление  передается на  выражение, которомуа он Префшествует.
Если нет  смответсвующих вариантмв  case (и default отсутсbвует, то
эикакой из опеЁАторов в операторе`swatch не выполняЕтся.
  Префиксы  case    и  default  сами  по  себе$ нд  изменяют  потокуправленмя, котосый  после задерки  идет дальше, переркакивая через
эти префиксы. Для выхода иж switch см. break, #9.8.
  Обычно зависящищ  от switch оязратор явкяетсч составныи. В головеJэтого   оператора   могут   стоять   описания,   но   инициализации
автоматических и рщгистровых переменных явл юъся безрезультатными.

     9.8(Оператор break
К  Оператор
    `break ;

                             - стр 301 -

прекращает выполнение  блицайшего охватывающего while,  do, for ил╕
switch   оператора; улравление перед░ется на оператор, слежуящий за
завонченным.

     9.9 Опер ъор continue
-
  Оператор
  continue ;
вызывает передачу  упратления  на  управляющую  продолжением  цикла
часть наименьъего  охватывающего оператора  while, do! или for;  то
есть%на конец петли цикла. Точнее, в каждом из операторов

  whщle (...)         doв                 for (...)
    {                  `{  д           0    {
  а   ...   "             ...  $              ...
      cgntin:;  `         Contin:;            contin:;
    }$       !          }          `        }
 `        `           whilm (...);

continue экдивалентно  goto  contщn.( иЗа  contin:  сл%аєет  пустой
оператжр, #9.13.)

     9.10 Оператор returj

  Возв└ат из  функции  в  вызывающеую  программу  осуществляется  с
понощью операторд return, имзющего один из двух видов:
      return ;
      return выражение ;
   Первый  может использоваться  только в функциях, не возвращающих
значения, т.е.  в функциях  с типом  возвращаемого  значения  void.
Вторая  форма   может  использоваться   только   в   функциях,   не
возвращающих значение;  вызывающей функцию  программе  возвращается
значение выражения.  Если необходимо,  то выражение  преобразуется,
как это  делается при  присваивании, к  типу функции, в которой оно
возникло. Обход  конца функции  эквивалентен  возврату  return  без
возвращаемого значения.

     9.11 Оператор goto

  Можно  осуществлять  безусловную  передачу  упраления  с  помощью
оператора
      goto идентификатор ;
  Идентификатор  должен  быть  меткой    (#9.12),  расположенной  в
текущей функции.

     9.12 Помеченные операторы

  Перед любым оперотором может стоять префикс метка, имеющий вид
     идентификатор :
который  служит   для  описания  идентификатора  как  метки.  Метка
используется только  как объект  для goto. Областью видимости метки

                             - стр 302 -

является текущая  функция, исключая  любой подблок,  в котором  был
переописан такой же идентияикатор. См. #4.1.

     9.13 Пустой оператор

  Пустой оператор имеет вид
     ;
  Пустой оператор  используется для помещения метки непосредственно
перед  }  составного  оператора  или  того,  чтобы  снабдить  такие
операторы, как while, пустым телом.

     9.14 Оператор delete

  Оператор delete имеет вид
     delete выражение ;
  Результатом выражения  должен быть  указатель. Объект, на который
он  указывает,   уничтожается.  Это  значит,  что  после  оператора
уничтожения  delete   нельзя  гарантировать,   что   объект   имеет
определенное значение;  см. #17.  Эффект от  применеия  delete    к
указателю, не  полученному из  операции new   (#7.1),  неопределен.
Однако, уничтожение указателя с нулевым значением безопасно.

     9.15 Оператор asm

  Оператор asm имеет вид
     asm ( строка) ;
  Смысл оператора  asm  неопределен.  Обычно  он  используется  для
передачи информации черз компилятор ассемблеру.

                   10. ВНЕШНИЕ ОПРЕДЕЛЕНИЯ

  Программа  на   C++   состоит   из   последовательности   внешних
определений.  Внешенее   определение  описывает  идентификатор  как
имеющий класс памяти static и определяет его тип. Спецификатор типа
(#8.2) может  также быть  пустым, и  в этом случае принимается  тип
int. Область  видимости внешних  определений простирается  до конца
файла, в  котором  они  описаны,  так  же,  как  действие  описаний
сохраняется до  конца блока.  Синтаксис внешних определений тот же,
что и  у описаний, за исключением того, что только на этом уровне и
внутри описаний  классов может  быть задан  код  (текст  программы)
функции.

     10.1  Определения функций

  Определения функций имеют вид
     определение_функции:
          спецификаторы_описания описатель_функции  opt инициализа-
     тор_базового_класса                                        opt
          тело_функции
  Единственными cпецификаторами класса памяти (sc-cпецификиторами),еопустимыми  среди   спецификаторов  описания,   являются   extern,

   ` а                       - стр 303 -

static, overload,   inline  и virtuAl.   Описатель функции похож на
описатель "фунлции,  аозжращающей ...", за исключением того, что он
включает в" себя имена  формальных параметров определяеиой функции.
Описатель функции имеет вид
     описатель_функции:
       0  описатель ( список_описаний_параметрпв )
  Фоама списка опиaаний парбметров определена в #8.4.  Единственный
класс памяти,  которыщ может  быть  задвн,  это  тот,  при  котором
соответствующий фактический  пвраметр будет  с*опирован,  если  это
возможно,  в   регистр  при $ входе  в  фснкцию.  Если 0в  каче┴тве
инициализатора для  параметра зааано  константное$высажение, то это
значение испол╠зуется как значение параметра по умолчанию.
  Тело функции имеет вид
     тело_функции:
          составной_оператор
  Вот простой пример полного определения функции:

  int max (int a,int b,int c)
    {
      int m = (a > b) ? a : b;
      return  (m > c) ? m : c;
    }

  Здесь int  является спецификатором  типа ; max (int a, int b, int
c) является  описателем функции  ; {  ... }  - блок, задающий текст
программы (код) оператора.
  Поскольку в  контексте выражения  имя (точнее, имя как формальный
параметр) считается означающим указатель на первый элемент массива,
то описания  формальных параметров,  описанных как "массив из ...",
корректируются так, чтобы читалось "указатель на ...".
  Инициализатор базового класса имеет вид
     инициализатор_базового_класса:
          : ( список_параметров opt )
 Он  используется  для  задания  параметров  конструктора  базового
класса в конструкторе производного класса. Например:

  struct base { base (int); ... };
  struct derived : base { derived (int); ... };

  derived.derived (int a) : (a+1) { ... }

  derived d (10);

Конструктор базового  класса вызывается  для объекта d с параметром
11.

     10.2 Определения внешних данных

а Определения внешних данных имеют вид
     определение_данных:
"         описание
  Класс памяти таких данных0стаъический.
  Если есть  более одного определения внешних данных одногж именеи,
то"ппределения  еолжны  точно  согл░совываться  по  типу  и  классу

                             - стр 304 --

яамяти, и  инихиализрторы (если  они есть), должны имзть одинаковое
значение.

                11. ПРАВИЛВ ЮБЛАСЪИ ВИДИМОСТИ

  См. #4.1.

              12. КОМАНДНЫЕ СТРОКИ КОМПИЛЯТОРА

  Компилятор языки  C++ содержит  препроцессор, способный выполнять
макроподстановки,  условную   коопиляцию  и  включение  именованных
файлов Строки,  начинающиеся с  #, относятся  к препроцессору. Эти
строки имеют  независимый от  остального языкр синтаксис; они могут
появляться   в    любом   месте    оказывать    влияние,    которое
распространяется  (независимо   от  области   вифимости)  до  концр
иёходного файла программы.
  Заметьте, что  определения con3t  и inline  даюц альтернативы для
большинства использований #define.

     12.1 Замена идентификатофов

  Командная строка компиляЄофа имеет вид
     #define идент строка_символов
вызывает    замену     препаоцессором 0   пцследующих     вхождений
идентицикатоЁа, заданного  строкой символов. Точка с!запятой внутри
(или в конце) строки символов является частью этоЙ строки.
  Строка вида
     #define иденц( (дент , ..., идент ) строка_символов
где отсутбвует  пробел между  первым"идентификатором  и (, является
макроопределениен  с  параметрами.  Посл╡дующие  вхождения  первого
идентификатора с  идущими за  ним (,  последовательносъью символов,
разграниченной запятыми, ( ), замейяются строкой символов, заданной
ваопредегении.  Каждое местоположение идентификатора,азамеченного в
списке параметров  определеная. заменяется  соотвбтстВующей строкой
из  вызова.   ФактичесКими  параметрамИ $ выпова  являются   строки
символов,  разделееные   запятыми;   однако   запятые   "   строке,
заключенной  в   кавычки,  или   в  круглых   скобках  не  являются
разделителями параметров. Число формальных и фактических параметров
должно совпадать. Строки и символьные константы в символьной строке
сканируются в поисках формальных параметров, но строки и символьные
константы  в   остальной  программе   не  сканируются   в   поисках
определенных (с помощью define) идентификаторов.
  В обоих  случаях строка  замещения еще  раз сканируется в поисках
других  определнных   идентификаторов.  В   обоих  случаях  длинное
определение может быть продолжено на другой строке с помощью записи
\ в конце продолжаемой строки.
  Командная строка вида
     #undef идент
влечет отмену препроцессорного определения идентификатора.

                             - стр 305 -

     12.2 Включение файлов

  Командная строка компилятора вида
     #include "имя_файла"
вызывает замену  этой строки  полным  содержимым  файла  имя_файла.
Сначала  именованный   файл  ищется  в  директории  первоначального
исходного  файла,  а  затем  в  стандартных  или  заданных  местах.
Альтернативный вариант, командная строка вида
      #include <имя_файла>
производит поиск только в стандартном или заданном месте, и не ищет
в директории  первоначального исходного  файла. (То,  как эти места
задаются, не является частью языка.)
  Включения с помощью #include могут быть вложенными.

     12.3 Условная компиляция

  Командная строка компилятора вида
     #if выражение
проверяет, является  ли результатом  вычисления выражения  не-ноль.
Выражение должно быть константным выражением, которые обсуждаются в
#15;  применительно   к   использованию   данной   директивы   есть
дополнительные  ограничения:   константное   выражение   не   может
содержать sizeof или перечислимые константы. Кроме обычных операций
C     может  использоваться  унарная  операция  defined.  В  случае
применения к  идентификатору она  дает значение  не-ноль, если этот
идентификатор был  ранее определен  с помощью #define и после этого
не было отмены определения с помощью #undef; иначе ее значение 0.
  Командная строка вида
     #ifdef идент
проверяет, определен  ли идентификатор  в  препроцессоре  в  данный
момент; то есть, был ли он объектом командной строки #define.
  Командная строка вида
     #ifndef идент
проверяет, является ли идентификатор неопределенным в препроцессоре
в данный момент.
  После строки  каждого из  трех видов  может  стоять  произвольное
количество строк, возможно, содержащих командную строку
     #else
и далее до командной строки
     #endif
  Если проверенное  условие истинно,  то все  строки между #else  и
#endif игнорируются.  Если проверенное условие ложно, то все строки
между проверкой  и #else  или, в  случае отсутствия  #else, #endif,
игнорируются.
  Эти конструкции могут быть вложенными.

     12.4 Управление строкой

  Для помощи  другим препроцессорам,  генерирующим программы  на C,
строка вида
     #line константа "имя_файла"
заставляет  компилятор   считать,  например,  в  целях  диагностики
ошибок, что константа задает номер следущей строки исходного файла,

                             - стр 306 -

и   текущий    входной   файл   именуется   идентификатором.   Есло
идентификатор отсутствует, то запомненное имя файла не изменяется.

                    13. НЕЯВНЫЕ ОПИСАНИЯ

  См. #8.1.

                       14. ОБЗОР ТИПОВ

  В этом  разделе кратко  собрано описание  действий, которые могут
совершаться над объектами различных типов.

     14.1 Классы

  Классовые объекты  могут присваиваться, передаваться функциям как
параметры и возвращаться функциями. Другие возможные операции, как,
например, проверка  равенства, могут быть определены пользователем;
см. #8.5.10.

     14.2 Функции

  Есть только  две вещи,  которые  можно  проделывать  с  функцией:
вызывать ее  и  брать  ее  адрес.  Если  в  выражении  имя  функции
возникает не  в положении  имени функции  в вызове, то генерируется
указатель на  функцию. Так, для передачи одной функции другой можно
написать

  typedef int (*PF) ();
  extern g (PF);
  extern f ();
  ...
  g (f);

  Тогда определение g может иметь следующий вид:

  g (PF funcp)
    {
      ...
      (*funcp) ();
      ...
    }

  Заметьте, что  f должна быть описана явно в вызывающей программе,
поскольку ее появление в g(f) не сопровождалось (.

     14.3 Массивы, указатели и индексирование

  Всякий раз,  когда  в  выражении  появляется  идентификатор  типа
массива, он преобразуется в указатель на первый член массива. Из-за
преобразований  массивы   не  являются   адресами.  По  определению
операция индексирования  []  интерпретируется  таким  образом,  что

                             - стр 307 -

E1[E2]  идентично   *((E1)+(E2)).  В  силу  правил  преобразования,
применяемых к  +, если E1 массив и E2 целое, то E1[E2] отностится к
E2-ому члену  E1. Поэтому, несмотря на такое проявление асимметрии,
индексирование является коммутативной операцией.
  Это правило  сообразным образом применяется в случае многомерного
массива. Если  E является  n-мерным массивом  `анга i*h*.n.*k,   то
вОзникающее вавыражении E преобразуетсo в указатель на (n-1)-мерныЙ
массив ранга j*...*k.  Если к этому указателю, явно или неявно, кбк
результат индексирования,  применяется операция  *, ее  результатом
является (n-1)-меЁный  масрив, на  который указывалось, который сам
тут же преобразуется в указатель.
  Рассмотрим, например,

  int x[3][5];

  Здесь x  -  маaсив  целых  размером  3*5.  Когиа  x  вопникает  в
выражении, он  преобразуется в указатель на (первый из трех) массив
из 5  целыe. В! выражении  x[i],  которое  эквивалентно  *(x+1),  x
хначала  преобразуется,   как  описано,  (в  указатель,   затем   1преобразуется к  типу x,  что вклцчает  в себя умножение 1 на длину
объекта, на  который указывает  указатель, а  именно  объект  из  5
целых. Результаты  складываются, и используется косвенная адресаци 
для  получения  массива  (из  5  целых),  который  в  свою  очхредь
преобразуется в  указатель на  первое из  целых. Если есть еще один
индекс, снова  используется  тот жз па`аметр; на этот раз реЗультат
является целым.
  Именно из всего этого проистекает то, что мащсивы ▓ C хранятся по
строкам (быстрее  всего  изменяется  последний  индекс),  и0 что  в
описании     первыл  индекс   помогает  определить   объем  памяри,
поглощаемый  массивом,   но  не   играет  никакой   друг.й  роли  в
вычислениях индекса.

 а   14.4 Явные преобразования указателей

  Определенные преобразования,  вкл╬чаnщие массивы, выполняются, но
имеют зависящИб  от реализаЎии  аспекты. Все они задаются с помощью
явной операции преобразования типов, см. ##7.2 и 8.6.
  Указатель иожет  быть  птеобразован  к  любому  из  целых  типов,
достаточно больших  для его  хранения. Т.,  какой  из  int  и  long
требуется, является  машинно зависимым. Преобразующая функция также
является машинно  завискмой, но предполагается, что она не содержит
сюрпризов  для  того,  кто  зниет  !труктуру  адресации  в  машине.
Подробнощти для некоторых конкретных(машин были даны в #2.6.
  Объект целого  типа может  быть явно  преобразован  в  указатель.
Преобразующая  функция   всегда  превращает  целое,  полученное  из
указателя, обратно  в тот  же указатель,  но  в  остальных  случаях
является машинно зависимой.
  Указатель на  один тип  может быть  преобразован в  указатель  на
другой тип.  Использование результирующего указателя может вызывать
особые ситуации,  если исходный  указатель не  указывает на объект,
соответствующим образом  выравненный в  памяти. Гарантируется,  что
указатель на  объект данного  размера  может  быть  преобразован  в
указатель на объект меньшего размера и обратно без изменений.

                             - стр 308 -

  Например, программа,  выделяющая память, может получать размер (в
байтах) размещаемого  объекта и  возвращать указатель  на char; это
можно использовать следующим образом.

  extern void* alloc ();
  double* dp;

  dp = (double*) alloc (sizeof (double));
  *dp= 22.0 / 7.0;

alloc   должна обеспечивать  (машинно зависимым  образом)  то,  что
возвращаемое ею значение подходит для преобразования в указатель на
double;   в этом  случае использование  функции мобильно. Различные
машины различаются  по числу  бит  в  указателях  и  требованиям  к
выравниванию объектов.  Составные объекты  выравниваются  по  самой
строгой границе, требуемой каким-либо из его составляющих.

                  15. КОНСТАНТНЫЕ ВЫРАЖЕНИЯ

  В нескольких  местах C++  требует выражения,  вычисление  которых
дает  константу:   в  качестве   границы  массива  (#8.3),  в  case
выражениях  (#9.7),   в  качестве   значений  параметров   функции,
присваиваемых по  умолчанию, (#8.3),  и в инициализаторах (#8.6). В
первом случае  выражение может  включать  только  целые  константы,
символьные константы,  константы, описанные  как  имена,  и  sizeof
выражения, возможно, связанные бинарными операциями

   + - * / % & | ^ << >> == != < > <= >= && ||

 или унарными операциями

  - ~ !

или тернарными операциями

  ? :

  Скобки могут  использоваться для  группирования, но не для вызова
функций.
  Большая   широта    допустима   для    остальных   трех   случаев
использования; помимо  константных выражений,  обсуждавшихся  выше,
допускаются константы  с плавающей  точкой, и можно также применять
унарную операцию  & к  внешним  или  статическим  объектам,  или  к
внешним  или   статическим  массивам,  индексированным  константным
выражением. Унарная  операция & может также быть применена неявно с
помощью употребления неиндексированных массивов и функций. Основное
правило состоит  в том,  что инициализаторы  должны при  вычислении
давать  константу   или  адрес   ранее  описанного   внешнего   или
статического обйекта плюс или минус константа.
  Меньшая широта  допустима для  константных выражений  после  #if:
константы, описанные  как имена,  sizeof выражения  и  перечислимые
константы недопустимы.

                             - стр 309 -

                 16. СООБРАЖЕНИЯ МОБИЛЬНОСТИ

  Определенные части C++ являются машинно зависимыми по своей сути.
Следующий ниже  список мест  возможных затруднений не претендует на
полноту, но может указать на основные из них.
  Как показала  практика, характеристики  аппаратуры в чистом виде,
такие, как  размер слова,  свойства плавающей  арифметики и  целого
деления, не  создают  особых  проблем.  Другие  аппаратные  аспекты
отражаются на  различных программных разработках. Некоторые из них,
особенно знаковое расширение (преобразование отрицательного символа
в отрицательное  целое) и  порядок  расположения  байтов  в  слове,
являются досадными  помехами, за  которыми надо  тщательно следить.
Большинство других являются всего лишь мелкими сложностями.
  Число  регистровых  переменных,  которые  фактически  могут  быть
помещены  в  регистры,  различается  от  машины  к  машине,  как  и
множество фактических  типов. Тем  не  менее,  все  компиляторы  на
"своей" машине  все делают  правильно; избыточные или недействующие
описания register игнорируются.
  Некоторые сложности  возникают  при  использовании  двусмысленной
манеры программирования.  Писать программы, зависящие от какой-либо
из этих особенностей, райне неблагоразумно.
  В языке  неопределен порядок  вычисления параметров  функции.  На
некоторых машинах  он слева  направо, а на некоторых справо налево.
Порядок    появления     некотрых    побочных     эффектов    также
недетерминирован.
  Поскольку  символьные   константы  в   действительности  являются
объектами  типа   int,  то  могут  быть  допустимы  многосимвольные
константы. Однако  конкретная реализация  очень сильно  зависит  от
машины, поскольку  порядок, в  котором символы присваиваются слову,
различается от  машины к  машине. На некоторых машинах поля в слове
присваиваются слева направо, на других справо налево.
  Эти различия  невидны для отдельных программ, не позволяющих себе
каламбуров с  типами (например, преобразования int указателя в char
указатель и  просмотр памяти,  на которую  указывает указатель), но
должны приниматься во внимание при согласовании внешне предписанных
форматов памяти.

                    17. СВОБОДНАЯ ПАМЯТЬ

  Операция new (#7.2) вызывает функцию

  extern void* _new (long);

для получения  памяти.  Параметр  задает  число  требуемых  байтов.
Память будет  инициализирована. Если  _new не может найти требуемое
количество памяти, то она возвращает ноль.
  Операция delete вызывает функцию

   extern void _delete (void*);

чтобы  освободить  память,  указанную  указателем,  для  повторного
использования. Результат  вызова _delete()   для указателя, который
не был  получен из  _new(),  неопределен,  это  же  относится  и  к
повторному вызову  _delete() для одного и того же указателя. Однако
уничтожение с помощью delete указателя со значением ноль безвредно.

                             - стр 310 -

  Предоставляются  стандартные   версии  _new()   и  _delete(),  но
пользователь  может   применять  другие,   более   подходящие   для
конкретных приложений.
  Когда с  помощью операции  new создается классовый объект, то для
получения   необходимой    памяти   конструктор    будет   (неявно)
использовать new.  Конструктор может  осуществить свое  собственное
резервирование памяти  посредством присваивания  указателю this  до
каких-либо использований. С помощью присваивания this значения ноль
деструктор может  избежать  стандартной  операции  дерезервирования
памяти для объекта его класса. Например:

  class cl
    {
      int v[10];
      cl () { this = my_own_allocator (sizeof (cl)); }
      ~cl () { my_own_deallocator (this); this = 0; }
    }

  На  входе   в   конструктор   this   являеется   не-нулем,   если
резервирование памяти  уже имело  место (как  это имеет  место  для
автоматических объектов), и нулем в остальных случаях.
  Если производный  класс осуществляет  присваивание this, то вызов
конструктора (если он есть) базового класса будет иметь место после
присваивания, так  что конструктор  базового  класса  ссылаться  на
объект   посредством   конструктора   производного   класса.   Если
конструктор базового  класса  осуществляет  присваивание  this,  то
значение также  будет использоваться  конструктором  (если  таковой
есть)  производного класса.

              18. КРАТКОЕ ИЗЛОЖЕНИЕ СИНТАКСИСА

  Мы надеемся,  что эта  краткая сводка  синтаксиса    C++  поможет
пониманию. Она не является точным изложением языка.

     18.1 Выражения

     выражение:
          терм
          выражение           бинарная_операция           выражение
          выражение       ?       выражение       :       выражение
          список_выражений
     терм:
          первичный
          *                                                    терм
          &                                                    терм
          -                                                    терм
          !                                                    терм
          ~                                                    терм
          ++терм
          --терм
          терм++
          терм--
          (                   имя_типа)                   выражение
          имя_простого_типа           (           список_выражений)

                             - стр 311 -

          sizeof                                          выражение
          sizeof             (              имя_типа              )
          new                                              имя_типа
          new ( имя_типа )
     первичный:
          id
          ::                                          идентификатор
          константа
          строка
          this
          (                       выражение                       )
          первичный[                  выражение                   ]
          первичный      (       список_выражений       opt       )
          первичный.id
          первичный->id
     id:
          идентификатор
          typedef-имя :: идентификатор
     список_выражений:
          выражение
          список_выражений, выражение
     операция:
          унарная_операция
          бинарная_операция
          специальная_операция
  Бинарные операции имеют приоритет, убывающий в указанном порядке:
     бинарная_операция:
          *                          /                            %
          +                                                       -
          <<                                                     >>
          <                                                       >
          ==                                                     !=
          &
          ^
          |
          &&
          ||
          =   +=  -=  *=  /=  %=  ^=  &=  |=  >>=  <<=
                                                  унарная_операция:
           *   &   -   ~   !   ++   --
     специальная_операция:
          ()       []
     имя_типа:
          спецификаторы_описания абстрактный_описатель
     абстрактный_описатель:
          пустой
          *                                   абстрактный_описатель
          абстрактный_описатель  (   список_описаний_параметров   )
          абстрактный_описатель  [   константное_выражение  opt   ]
          ( абстрактный_описатель )
     простое_имя_типа:
          typedef-имя
          char
          short
          int
          long

                             - стр 312 -

          unsigned
          float
          double
     typedef-имя:
          идентификатор

     18.2 Описания

     описание:
          спецификаторы_описания  opt   список_описателей   opt   ;
          описание_имени
          asm-описание
     описание_имени:
          агрег                   идентификатор                   ;
          enum  идентификатор ;
     агрег:
          class
          struct
          union
     asm-описание:
          asm ( строка );
     спецификаторы_описания:
          спецификатор_описания спецификатор_описания opt
     спецификатор_описания:
          имя_простого_типа
          спецификатор_класса
          enum_спецификатор
          sc_спецификатор
          фнк_спецификатор
          typedef
          friend
          const
          void
     sc_спецификатор:
          auto
          extern
          register
          static
     фнк-спецификатор:
          inline
          overload
          virtual
     список_описателей:
          иниц-описатель
          иниц-описатель , список_описателей
     иниц-описатель:
          описатель инициализатор opt
     описатель:
          оп_имя
          (                       описатель                       )
          *             const             opt             описатель
          &             const             opt             описатель
          описатель      (       список_описаний_параметров       )
          описатель [ константное_выражение opt ]

                             - стр 313 -

     оп_имя:
          простое_оп_имя
          typedef-имя . простое_оп_имя
     простое_оп_имя:
          идентификатор
          typedef-имя
          -                                             typedef-имя
          имя_функции_операции
     имя_функции_операции:
          операция операция

                             - стр 314 -

     список_описаний_параметров:
          список_описаний_прм opt ... opt
     список_описаний_прм                                          :
          список_описаний_прм         ,          описание_параметра
          описание_параметра
     описание_параметра:
          спецификаторы_описания                          описатель
          спецификаторы_описания описатель = константное_выражение
     спецификатор_класса:
          заголовок_класса       {список_членов        opt        }
          заголовок_класса    {список_членов     opt    public    :
     список_членов opt }
     заголовок_класса                                             :
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     список_членов                                                :
          описание_члена список_членов opt
     описание_члена:
          спецификаторы_описания opt описатель_члена ;
     описатель_члена:
          описатель
          идентификатор opt : константное_выражение
     инициализатор:
          =                                               выражение
          =                {                список_инициализаторов}
          =       {        список_инициализаторов,                }
          (список_выражений )
     список_инициализаторов                                       :
          выражение
          список_инициализаторов        ,    список_инициализаторов
          { список_инициализаторов }
     enum-спецификатор:
          enum идентификатор opt { enum-список }
     enum-список:
          перечислитель
          enum-список , перечислитель
     перечислитель:
          идентификатор
          идентификатор = константное_выражение

     18.3 Операторы

     составной_оператор:
          { список_описаний opt список_операторов opt }
     список_описаний:
          описание
          описание список_описаний
     список_операторов:
          оператор
          оператор список_операторов
     оператор:
          выражение                                               ;
          if         (         выражение         )         оператор
          if    (    выражение    )    оператор    else    оператор
          while        (         выражение        )        оператор

                             - стр 315 -

          do     оператор     while     (     выражение     )     ;
          for (  выражение opt  ; выражение  opt ;  выражение opt )
               оператор
          switch        (        выражение        )        оператор
          case      константное      выражение      :      оператор
          default                    :                     оператор
          break;
          continue;
          return            выражение             opt             ;
          goto                   идентификатор                    ;
          идентификатор                 :                  оператор
          delete                    выражение                     ;
          asm           (            строка           )           ;
          ;

     18.4 Внешние определения

     программа:
          внешнее_определение
          внешнее_определение программа
     внешнее_определение:
          определение_функции
          описание
     определение_функции:
          спецификаторы_описания       opt        описатель_функции
     инициализатор_базового_класса opt тело_функции
     описатель_функции:
          описатель ( список_описаний_параметров)
     тело_функции:
          составной_оператор
     инициализатор_базового_класса:
          : ( список_параметров opt )

     18.5 Препроцессор

     #define идент строка_символов
     #define идент( идент,...,идент ) строка символов
     #else
     #endif
     #if выражение
     #ifdef идент
     #ifndef идент
     #include "имя_файла"
     #include <имя_файла>
     #line константа "имя_файла"
     #undef идент

                             - стр 316 -

                 19. ОТЛИЧИЯ ОТ "СТАРОГО C"

     19.1 Расширения

  Типы  параметров   функции  могут  быть  заданы  (#8.4)  и  будут
проверяться (#7.1). Могут выполняться преобразования типов.
  Для выражений  с числами  с плавающей точкой может использоваться
плавающая арифметика одинарной точности; #6.2.
  Имена функций могут быть перегружены; #8.6
  Операции могут быть перегружены; 7.16, #8.5.10.
  Может осуществляться inline-подстановка функций; #8.1.
  Объекты данных могут быть константными (const); #8.3.
  Могут быть описаны объекты ссылочного типа; #8.3, #8.6.3
  Операции new  и delete  обеспечивают свободное хранение в памяти;
#17.
  Класс может обеспечивать скрытые данные (#8.5.8), гарантированную
инициализацию (#8.6.2),  оперделяемые  пользователем  преобразвания
(#8.5.6),  и   динамическое  задание   типов  через   использование
виртуальных функций (#8.5.4).
  Имя класса является именем типа; #8.5.
  Любой  указатель   может  присваиваться   [указателю]  void*  без
приведения типов; #7.14.
