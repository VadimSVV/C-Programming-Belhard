<html><head>
<title>Совместно используемые функции</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Совместно используемые функции</h4>
<p align=justify>Имя функции в заголовке объявления можно рассматривать как индивидуальную характеристику функции. Однако имени функции для её однозначной идентификации недостаточно. Здесь важен комплекс характеристик функции. При этом спецификация возвращаемого функцией значения актуальна лишь в случае, когда выражение вызова функции является частью более сложного выражения. В пределах области действия данного имени функция однозначно идентифицируется именем в сочетании со списком её параметров. Это обстоятельство позволяет реализовывать механизм совместного использования функций.
<p align=justify>При объявлении различных функций в C++ можно использовать одни и те же имена. При этом одноимённые функции различаются по спискам параметров. Отсюда становится понятным смысл понятия совместно используемых функций: одни и те же имена функций совместно используются различными списками параметров.
<p align=justify>У совместно используемых функций имеется ещё одно название. Такие функции называются перегруженными. Смысл этого названия становится понятным из следующей аналогии. В естественном языке одни и те же глаголы могут обозначать различные действия. Например, можно "ходить по комнате", "ходить под парусом", "ходить конём". В каждом из этих контекстов глагол "ходить" употребляется в новом смысле и в буквальном смысле перегружается разными смыслами.
<p align=justify>Механизм совместного использования заключается в том, в ходе трансляции исходного кода переименовываются все функции. Новые имена создаются транслятором на основе старых имен и списков типов параметров. Никакие другие характеристики функция при создании новых имён транслятором не учитываются.
<p align=justify>Приведём пример объявления совместно используемых функций. Предположим, что требуется объявить и определить несколько функций, выполняющих практически одну и ту же работу - выбор максимального значения. При этом каждая функция имеет свои собственные особенности реализации, которые связаны с количеством и типом передаваемых параметров. Очевидно, что каждой функции можно присвоить своё собственное имя, но это (будто бы) затрудняет чтение и понимание текста программы.
<p align=justify>Попытка объединения нескольких функций в одну функцию, которая в зависимости от значений параметров реализовывала бы один из алгоритмов сравнения, неоправданно усложняет структуру программы и затруднит модификацию этой самой функции.
<p align=justify>C++ предлагает компромиссное решение, в основе которого лежит так называемый алгоритм декодирования имени. В программе можно объявить несколько одноименных функций:
<pre>int max(int,int);
int max(int*,int);
int max(int,int*);
int max(int*,int*);</pre>
<p align=justify>и при этом в процессе трансляции, к имени каждой из объявленных функций будет прибавлена специальная цепочка символов, зависящая от типа и порядка параметров функции. Конкретный алгоритм декодирования зависит от транслятора. В соответствии с представленной в книге Б.Бабэ схемой декодирования имён в Borland C++, декодированные имена четвёрки функций будут выглядеть следующим образом:
<pre>@max$qii
@max$qpii
@max$qipi
@max$qpipi</pre>
<p align=justify>Заметим, что при кодировании имён транслятор не использует информацию о типе возвращаемых значений и поэтому пара функций
<pre>int max(int*,int*);
int * max(int*,int*);</pre>
<p align=justify>должна была бы получить одно и то же декодированное имя @max$qpipi, что неизбежно вызвало бы сообщение об ошибке.
<p align=justify>Причина, по которой при кодировании имён не используется информация о типе возвращаемых значений, заключается в том, что транслятор не всегда способен установить соответствие между выражениями вызова функций и их новыми именами, которые присваиваются определениям и объявлениям функций в ходе трансляции.
<p align=justify>Функция, которая возвращает целочисленное значение, в программе может быть вызвана без учёта её возвращаемого значения. Если бы транслятор ориентировался на информацию о типе возвращаемого значения, то в этом случае он бы не смог установить соответствие между вызовом и определением (транслятор должен знать, он не должен угадывать).
<p align=justify>Так что не являются совместно используемыми функции, различающиеся лишь типом возвращающего значения.
<p align=justify>Также не являются совместно используемыми функции, списки параметров которых различаются лишь применением модификаторов const или volatile, или использованием ссылки (эти спецификаторы не используются при модификации имён).
<p align=justify>Кроме того, множество вариантов совместно используемых функций объявляется и определяется внутри одной и той же области видимости имени функции. Объявляемые в различных областях видимости функции совместно не используются. Такие функции скрывают друг друга.
<p align=justify>Решение относительно вызова совместно используемой функции принимается транслятором и сводится к выбору конкретного варианта функции. Выбор производится в соответствии со специально разработанным алгоритмом, который называется алгоритмом сопоставления параметров.
<p align=justify>Этот алгоритм обеспечивает сопоставление типа значений параметров в выражениях вызова с параметрами каждого из объявленных вариантов функции. В процессе сопоставления параметров используются, по крайней мере, три различных критерия сопоставления.
<p align=justify>1.Точное сопоставление.
<p align=justify>Точное сопоставление предполагает однозначное соответствие количества, типа и порядка значений параметров выражения вызова и параметров в определении функции.
<pre>// Произвольная функция, которая возвращает целое значение.
int iFunction(float, char *);
//Объявление пары совместно используемых функций...
extern void FF(char *);      //Вариант 1...
extern void FF(int);         //Вариант 2...
//Вызов функции.
FF(0);
FF(iFunction(3.14, "QWERTY"));</pre>
<p align=justify>Поскольку нуль имеет тип int, оба вызова сопоставляется со вторым вариантом совместно используемой функции.
<p align=justify>2.Сопоставление с помощью расширения типа.
<p align=justify>При таком сопоставлении производится приведение типа значения параметра в выражении вызова к типу параметра в определении функции. Для этого используется расширение типа.
<p align=justify>Если ни для одного из вызовов точного сопоставления не произошло, то применяются следующие расширения типа:
	<ul>
	<li>Параметр типа char, unsigned char или short расширяются до типа int. Параметр типа unsigned short расширяется до типа int, если размер объекта типа int больше размера объекта типа short (это зависит от реализации). Иначе он расширяется до типа unsigned int.
	<li>Параметр типа float расширяется до типа double.
	</ul>
<p align=justify>//Объявление пары совместно используемых функций...
<pre>extern void FF(char *);      //Вариант 1...
extern void FF(int);         //Вариант 2...
//Вызов функции.
FF('a');</pre>
<p align=justify>Литера 'a' имеет тип char и значение, допускающее целочисленное расширение. Вызов сопоставляется со вторым вариантом совместно используемой функции.
<p align=justify>3.Сопоставление со стандартным преобразованием. Применяется в случае неудачи сопоставления по двум предыдущим критериям сопоставления. Фактический параметр преобразуется в соответствии с правилами стандартных преобразований. Стандартное преобразование типа реализует следующие варианты сопоставления значений параметров в выражениях вызова и параметров объявления:
	<ul>
	<li>любой целочисленный тип параметра выражения вызова сопоставляется с любым целочисленным типом параметра, включая unsigned,
	<li>значение параметра, равное нулю, сопоставляется с параметром любого числового типа, а также с параметром типа указатель, а значение параметра типа указатель на объект (любого типа) будет сопоставляться с формальным параметром типа void*.
	</ul>
<pre>//Объявление пары совместно используемых функций...
extern void FF(char *);      //Вариант 1...
extern void FF(float);       //Вариант 2...
//Вызов функции.
FF(0);</pre>
<p align=justify>В соответствии со вторым правилом стандартных преобразований, которое утверждает, что передача значения при вызове функции преобразует это значение в тип параметра функции, значение фактического параметра может быть преобразовано к значению указателя, т.е. к NULL. Вызов сопоставляется с первым вариантом функции.
<p align=justify>Можно представить шкалу соответствия типа параметров в выражениях вызова параметрам множества совместно используемых функций. При этом:
	<ul>
	<li>точное сопоставление формального и фактического параметров оценивается максимальным баллом по шкале соответствия параметров,
	<li>сопоставление с расширением типа оценивается средним баллом,
	<li>сопоставление со стандартным преобразованием оценивается низшим баллом по шкале соответствия,
	<li>несоответствие фактического и формального параметров является абсолютным нулём нашей замечательной шкалы.
	</ul>
<p align=justify>В качестве примера рассмотрим следующие ситуации сопоставления:
<p align=justify>Объявляются четыре варианта совместно используемых функций.
<pre>extern void FF(unsgned int); //Вариант 1...
extern void FF(char*);       //Вариант 2...
extern void FF(char);        //Вариант 3...
extern void FF(int);         //Вариант 4...</pre>
<p align=justify>И ещё несколько переменных различных типов...
<pre>unsigned int iVal;
int *p_iVal;
unsigned long ulVal;
Рассмотрим вызовы функций.</pre>
<ul><li>Успешные:</ul>
<pre>
FF('a');
//Успешное сопоставление с вариантом 3.
FF("iVal");
//Успешное сопоставление с вариантом 2.
FF(iVal);
//Успешное сопоставление с вариантом 1.
<ul><li>Неудачные:</ul>
FF(p_iVal);
//Сопоставления нет.
FF(ulVal);
/*
Поскольку по правилам стандартного преобразования тип unsigned long,
пусть с потерей информации, но всё же может быть преобразован в
любой целочисленный тип, сопоставление окажется неуспешным по причине
своей неоднозначности. Сопоставление происходит со всеми вариантами
функции за исключением функции, имеющей тип char*.
*/
</pre>
<p align=justify>Решение относительно вызова совместно используемой функции с несколькими параметрами принимается на основе алгоритма сопоставления параметров к каждому из параметров вызова функции. При этом применяется так называемое правило пересечения. Согласно этому правилу, из множества совместно используемых функций выбирается функция, для которой разрешение каждого параметра будет НЕ ХУЖЕ (баллы по шкале соответствия), чем для всего множества совместно используемых функций, и ЛУЧШЕ (баллы по шкале соответствия), чем для всех остальных функций, хотя бы для одного параметра. Например:
<pre>
extern MyFFF(char*, int);
extern MyFFF(int, int);
MyFFF(0, 'a');
</pre>
<p align=justify>По правилу пересечения выбирается второй вариант функции. И происходит это по двум причинам:
	<ol>
	<li>Сопоставление первого фактического параметра вызова функции и первого параметра второй функции оценивается высшим баллом по шкале соответствия параметров, поскольку константа 0 точно сопоставляется с формальным параметром типа int.
	<li>Второй параметр вызова сопоставляется со вторым формальным параметром обеих функций. При этом литера 'a' имеет тип char и значение, допускающее целочисленное расширение. Таким образом, имеет место сопоставление с помощью расширения типа.
	</ol>
<p align=justify>Вызов считается неоднозначным, если ни один из вариантов совместно используемых функций не даёт наилучшего сопоставления. Вызов также считается неоднозначным, если несколько вариантов функции дают лучшее сопоставление.
<p align=justify>Известно, что значением выражения, состоящего из имени функции, является адрес данной функции. Подобные выражения для перегруженных функций недопустимы в силу своей неоднозначности. Транслятор просто не представляет, адрес какой из функций следует определять. Однако всё же определение адреса совместно используемых функций возможно. Это можно осуществить в контексте определения и инициализации указателя на функцию. Необходимую для выбора соответствующей перегруженной функции информацию транслятор получает из спецификации соответствующего указателя.
<pre>
char* MyFF1 (int,int,int*,float);
char* MyFF1 (int,int*,float);
/* Прототипы перегруженных функций. */
:::::
char* MyFF1 (int key1, int key2, int* pVal, float fVal) {/* ... */}
char* MyFF1 (int XX, int* pXX, float FF) {/* ... */}
/* Определения перегруженных функций. */
:::::
char* (*fPointer1) (int,int,int*,float) = MyFF1;
/* Определение и инициализация указателя на первую функцию.
Транслятор делает правильный выбор. */
char* (*fPointer2) (int,int*,float);
/* Определение указателя на вторую функцию. */
fPointer2 = MyFF1;
/* И опять транслятор правильно выбирает соответствующую функцию. */
fPointer1(1,2,NULL,3.14);
fPointer2(1,NULL,3.14);
/* Вызовы функций по указателю. */
</pre>
<p align=justify>По крайней мере, в Borland C++ 4.5, аналогичная инициализация параметров-указателей на функции адресами совместно используемых функций недопустима. Можно предположить, что на этом этапе у транслятора нет ещё полной и достоверной информации обо всех совместно используемых функциях программы.
<p align=justify>В разделе, посвящённом указателям на функции, в качестве примера была приведена функция, у которой в качестве параметра был указатель на функцию. Так вот попытка предварительной инициализации параметра-указателя адресом совместно используемой функции недопустимо. Соответствующие ограничания накладываются и на использование значения по умолчанию этого параметра при вызове функции.
<pre>
void MonitorF(int,int,int*,float,char*(*)(int,int,int*,float)=MyFF1);
/*
Транслятор утверждает, что имя этих функций двусмысленно в
контексте инициализации.
*/
MonitorF(9,9,pIval,9.9);
/*
Использование значения параметра по умолчанию также невозможно.
*/
void MonitorF(int,int,int*,float,char*(*)(int,int,int*,float));
MonitorF(11,11,pIval,11.11,MyFF1);
/*
При явном указании имени функции в операторе вызова транслятор
однозначно идентифицирует функцию.
*/
</pre>
<center>
<p><font size="-1"><a href="CPP_063.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_065.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>