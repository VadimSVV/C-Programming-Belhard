<html><head>
<title>Множественное наследование</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Множественное наследование</h4>
<p align=justify>В C++ производный класс может быть порождён из любого числа непосредственных базовых классов. Наличие у производного класса более чем одного непосредственного базового класса называется множественным наследием. Синтаксически множественное наследование отличается от единичного наследования списком баз, состоящим более чем из одного элемента.
<pre>
class A
{
};
class B
{
};
class C : public A, public B
{
};
</pre>
<p align=justify>При создании объектов-представителей производного класса, порядок расположения непосредственных базовых классов в списке баз определяет очерёдность вызова конструкторов умолчания.
<p align=justify>Этот порядок влияет и на очерёдность вызова деструкторов при уничтожении этих объектов. Но эти проблемы, также как и алгоритмы выделения памяти для базовых объектов, скорее всего, относятся к вопросам реализации. Вряд ли программист должен акцентировать на этом особое внимание.
<p align=justify>Более существенным является ограничение, согласно которому одно и то же имя класса не может входить более одного раза в список баз при объявлении производного класса. Это означает, что в наборе непосредственных базовых классов, которые участвуют в формировании производного класса не должно встречаться повторяющихся элементов.
<p align=justify>Вместе с тем, один и тот же класс может участвовать в формировании нескольких (а может быть и всех) непосредственных базовых классов данного производного класса. Так что для непрямых базовых классов, участвующих в формировании производного класса не существует никаких ограничений на количество вхождений в объявление производного класса:
<pre>
class A
{
 public:
 int x0, xA;
};
class B : public A
{
 public:
 int xB;
};
class C : public A
{
 public:
 int x0, xC;
};
class D : public B, public C
{
 public:
 int x0, xD;
};
</pre>
<p align=justify>В этом примере класс A дважды используется при объявлении класса D в качестве непрямого базового класса.
<p align=justify>Для наглядного представления структуры производного класса также используются направленные ациклические графы, схемы классов и объектов.
<p align=justify>Как и раньше, самый нижний узел направленного ациклического графа, а также нижний уровень схем соответствует производному классу и фрагменту объекта, представляющего производный класс.
<p align=justify>Такой фрагмент объекта мы будем называть производным фрагментом-представителем данного класса.
<p align=justify>Верхние узлы графа и верхние уровни схем классов и объектов соответствуют базовым классам и фрагментам объектов, представляющих базовые и непосредственные базовые классы. 
<p align=justify>Эти фрагменты объекта мы будем называть базовыми и непосредственными базовыми фрагментами-представителями класса.
<p align=justify>Вот как выглядит граф ранее приведённого в качестве примера производного класса D:
<pre>
               A                          A
               B                          C
                             D
</pre>
<p align=justify>А вот как представляется структура производного класса в виде неполной схемы класса. Базовые классы располагаются на этой схеме в порядке, который соответствует списку базовых элементов в описании базы производного класса. Этот же порядок будет использован при изображении диаграмм объектов. И это несмотря на то обстоятельство, что порядок вызова конструкторов базовых классов определяется конкретной реализацией. За порядком вызова конструкторов базовых классов всегда можно наблюдать после определения их собственных версий.
<pre>
A
B
A
C
D
</pre>
<p align=justify>А вот и схема объекта производного класса.
<pre>
D MyD;
MyD ::=
A
	(int)x0;
	(int)xA;
B
	(int)xB;
A
	(int)x0;
	(int)xA;
C
	(int)x0;
D
	(int)x0;
	(int)xD;
</pre>
<p align=justify>Первое, что бросается в глаза - это множество одноимённых переменных, "разбросанных" по базовым фрагментам объекта. Да и самих базовых фрагментов здесь немало.
<p align=justify>Очевидно, что образующие объект базовые фрагменты-представители одного базового класса, по своей структуре неразличимы между собой. Несмотря на свою идентичность, все они обладают индивидуальной характеристикой - положением относительно производного фрагмента объекта.
<p align=justify>При множественном наследовании актуальной становится проблема неоднозначности, связанная с доступом к членам базовых классов. Доступ к члену базового класса является неоднозначным, если выражение доступа именует более одной функции, объекта (данные-члены класса также являются объектами), типа (об этом позже!) или перечислителя.
<p align=justify>Например, неоднозначность содержится в следующем операторе:
<pre>MyD.xA = 100;</pre>
<p align=justify>здесь предпринимается неудачная попытка изменения значения данного-члена базового фрагмента объекта MyD. Выражение доступа MyD.xA именует сразу две переменных xA. Разрешение неоднозначности сводится к построению такого выражения доступа, которое однозначно указывало бы функцию, объект, тип (об этом позже!) или перечислитель.
<p align=justify>Наша очередная задача сводится к описанию однозначных способов доступа к данным-членам класса, расположенным в разных базовых фрагментах объекта. И здесь мы впервые сталкиваемся с ограниченными возможностями операции доступа.
<pre>MyD.B::x0 = 100;</pre>
<p align=justify>Этот оператор обеспечивает изменение значения данного-члена базового фрагмента - представителя класса B. Здесь нет никаких проблем, поскольку непосредственный базовый класс B наследует данные-члены базового класса A. Поскольку в классе B отсутствуют данные-члены с именем x0, транслятор однозначно определяет принадлежность этого элемента. Итак, доступ к данному-члену базового класса A "со стороны" непосредственного базового класса B не представляет особых проблем.
<pre>MyD.C::x0 = 100;</pre>
<p align=justify>А теперь изменяется значение данного-члена базового фрагмента - представителя класса С. И опять же транслятор однозначно определяет местоположение изменяемой переменной. Переменная x0 была объявлена в непосредственном базовом классе C. И операция доступа указывает на эту переменную. А вот попытка изменения значения переменной x0, расположенной базовом фрагменте-представителе класса A "со стороны" непосредственного базового класса C обречена. Так, оператор 
<pre>MyD.A::x0 = 777;</pre>
<p align=justify>некорректен по причине неоднозначности соотнесения класса и его члена, поскольку непонятно, о каком базовом фрагменте-представителе класса A идёт речь. Выражения доступа с составными квалифицированными именами, как например,
<pre>MyD.C::A::x0</pre>
<p align=justify>в контексте нашей программы также некорректны: составное квалифицированное имя предполагает вложенное объявление класса. Это свойство операции доступа уже обсуждалось ранее, в разделах, непосредственно посвящённых операциям. Вложенные объявления будут рассмотрены ниже.
<p align=justify>Операция :: оставляет в "мёртвой зоне" целые фрагменты объектов. Однако возможность доступа к членам класса, которые оказались вне пределов досягаемости операции доступа всё же существует. Она обеспечивается указателями и операциями явного преобразования типа.
<p align=justify>Идея состоит в том, чтобы, объявив указатель на объект-представитель базового класса, попытаться его настроить с помощью операций явного преобразования типа на соответствующий фрагмент объекта производного класса. В результате недосягаемые с помощью операции доступа фрагменты объекта превращаются в безымянные объекты простой конфигурации. Доступ к их членам в этом случае обеспечивается обычными операциями косвенного обращения. Рассмотрим несколько строк, которые демонстрируют такую технику работы с недосягаемыми фрагментами.
<pre>
A* pObjA;
B* pObjB;
C* pObjC;
D* pObjD = &amp;MyD;
// Мы начинаем с объявления соответствующих указателей.
pObjC = (C*)&amp;MyD;
pObjA = (A*)pObjC;
// Произведена настройка указателей на требуемые фрагменты.
pObjA-&gt;x0 = 999;
// А это уже элементарно!
</pre>
<p align=justify>Очевидно, что можно обойтись без поэтапных преобразований и воспользоваться свойством коммутативности операции явного преобразования типа:
<pre>
((A*)(C*)pObjD)-&gt;x0 = 5;
((A*)(B*)pObjD)-&gt;x0 = 55;
// Разным фрагментам - разные значения.
</pre>
<p align=justify>Аналогичным образом обстоят дела с функциями-членами базовых классов. Этот раздел мы завершаем небольшой программой, демонстрирующей методы доступа к членам базовых фрагментов объекта производного класса.
<pre>
#include &lt;iostream.h&gt;
class A
{
public:
int x0;
int Fun1(int key);
};
int A::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from A " &lt;&lt; endl;
 cout &lt;&lt; " x0 == " &lt;&lt; x0 &lt;&lt; "..." &lt;&lt; endl;
 return 0;
}
class B: public A
{
public:
int x0;
int Fun1(int key);
int Fun2(int key);
};
int B::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from B " &lt;&lt; endl;
 cout &lt;&lt; " x0 == " &lt;&lt; x0 &lt;&lt; "..." &lt;&lt; endl;
 return 0;
}
int B::Fun2(int key)
{
 Fun1(key * 5);
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from B " &lt;&lt; endl;
 cout &lt;&lt; " x0 == " &lt;&lt; x0 &lt;&lt; "..." &lt;&lt; endl;
 return 0;
}
class C: public A
{
public:
int x0;
int Fun2(int key);
};
int C::Fun2(int key)
{
 A::x0 = 25;
 Fun1(key * 5);
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from C " &lt;&lt; endl;
 cout &lt;&lt; " x0 == " &lt;&lt; x0 &lt;&lt; "..." &lt;&lt; endl;
 return 0;
}
class D: public B, public C
{
public:
int x0;
int Fun1(int key);
};
int D::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from D " &lt;&lt; endl;
 cout &lt;&lt; " x0 == " &lt;&lt; x0 &lt;&lt; "..." &lt;&lt; endl;
 return 0;
}
void main ()
{
 D MyD;
 ObjD.x0 = 111;
 A* pObjA;
 B* pObjB;
 C* pObjC;
 D* pObjD = &amp;MyD;
 MyD.B::x0 = 100;
 MyD.C::x0 = 333;
 MyD.Fun1(1);
 pObjD-&gt;B::Fun1(1);
 pObjD-&gt;C::Fun2(1);
 pObjA = (A*) (B*) pObjD;
 ((A*) ((C*) pObjD))-&gt;Fun1(111);
 ((A*) ((B*) pObjD))-&gt;Fun1(111);
 pObjA-&gt;Fun1(111);
 pObjC = (C*)&amp;MyD;
 pObjA = (A*)pObjC;
 ((A*)(B*)pObjD)-&gt;x0 = 1;
 ((A*)(B*)pObjD)-&gt;Fun1(777);
 ((A*)(C*)pObjD)-&gt;x0 = 2;
 ((A*)(C*)pObjD)-&gt;Fun1(999);
}
</pre>
<center>
<p><font size="-1"><a href="CPP_079.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_081.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
