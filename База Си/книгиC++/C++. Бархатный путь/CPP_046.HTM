<html><head>
<title>Выбирающий оператор</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Выбирающий оператор</h4>
<pre>
<u>ВыбирающийОператор</u> ::= if (<u>Выражение</u>) <u>Оператор</u> [else <u>Оператор</u>]
                   ::= switch (<u>Выражение</u>) <u>Оператор</u> 
</pre>
<p align=justify>Определение понятия оператора выбора начнём с важного ограничения. Выражение в скобках после ключевых слов if и switch являются обязательными выражениями. От их значения зависит выполнение тела оператора выбора. Так что в этом месте нельзя использовать выражения с неопределённым значением - выражения вызова функции, возвращающей неопределённое значение.
<p align=justify>Операторы выбора определяют один из возможных путей выполнения программы.
<p align=justify>Выбирающий оператор if имеет собственное название. Его называют условным оператором.
<p align=justify>В ходе выполнения условного оператора if вычисляется значение выражения, стоящего в скобках после ключевого слова if. В том случае, если это выражение оказывается не равным нулю, выполняется первый стоящий за условием оператор. Если же значение условия оказывается равным нулю, то управление передаётся оператору, стоящему после ключевого слова else, либо следующему за условным оператором оператору.
<pre>
if (i)
 {int k = 1;}
else
 {int l = 10;}
</pre>
<p align=justify>Этот пример условного оператора интересен тем, что операторы, выполняемые после проверки условия (значение переменной i), являются операторами объявления. В ходе выполнения одного из этих операторов объявления в памяти создаётся объект типа int с именем k и значением 1, либо объект типа int с именем l и значением 10. Областью действия этих имён являются блоки операторов, заключающих данные операторы объявления. Эти объекты имеют очень короткое время жизни. Сразу после передачи управления за пределы блока эти объекты уничтожаются. Ситуация не меняется, если условный оператор переписывается следующим образом:
<pre>
if (i)
 int k = 1;
else
 int l = 10;
</pre>
<p align=justify>При этом область действия имён и время жизни объектов остаются прежними. Это позволяет несколько расширить первоначальное определение блока: операторы, входящие в выбирающий оператор также считаются блоком операторов.
<p align=justify>Подобное обстоятельство являлось причиной стремления запретить использование операторов объявлений в теле условного оператора. В справочном руководстве по C++ Б.Строуструпа по этому поводу сказано, что в случае, если объявление является единственным оператором, то в случае его выполнения возникает имя "с непонятной областью действия".
<p align=justify>Однако запрещение использования оператора объявления в условном операторе влечёт за собой очень много ещё более непонятных последствий. Именно по этой причине в последних реализациях C++ это ограничение не выполняется. Проблема области действия является проблемой из области семантики языка и не должна оказывать влияния на синтаксис оператора.
<p align=justify>Выбирающий оператор switch или оператор выбора предназначается для организации выбора из множества различных вариантов.
<p align=justify>Выражение, стоящее за ключевым словом switch обязательно должно быть выражением целого типа. Транслятор строго следит за этим. Это связано с тем, что в теле оператора могут встречаться помеченные операторы с метками, состоящими из ключевого слова case и представленного константным выражением значения. Так вот тип switch-выражения должен совпадать с типом константных выражений меток.
<p align=justify>Синтаксис выбирающего оператора допускает пустой составной оператор и пустой оператор в качестве операторов, следующих за условием выбирающего оператора:
<pre>
switch (i) ;  // Синтаксически правильный оператор выбора…
switch (j) {} // Ещё один… Такой же бесполезный и правильный…
switch (r) i++;// Этот правильный оператор также не работает.
</pre>
<p align=justify>В теле условного оператора в качестве оператора может быть использовано определение:
<pre>
switch (k) {
            int q, w, e;
           }
</pre>
<p align=justify>Этот оператор выбора содержит определения объектов с именами q, w, e.
<p align=justify>Туда могут также входить операторы произвольной сложности и конфигурации:
<pre>
switch (k) {
          int q, w, e;
          q = 10; e = 15;
          w = q + e;
         }
</pre>
<p align=justify>Входить-то они могут, а вот выполняться в процессе выполнения условного оператора не будут!
<p align=justify>А вот включение в оператор выбора операторов определений с одновременной инициализацией создаваемого объекта недопустимо. И об этом мы уже говорили. Оно вызывает сообщение об ошибке независимо от того, в каком месте оператора выбора оно располагается:
<pre>
switch (k) {
            int q = 100, w = 255, e = 1024; // Ошибка…
            default: int r = 100; // Опять ошибка…
           }
</pre>
<p align=justify>Дело в том, что в ходе выполнения оператора объявления с одновременной инициализацией создаваемого объекта происходят два события:
<p align=justify>во-первых, производится определение переменной, при котором выделяется память под объект соответствующего типа:
<pre>int q; int w; int e;</pre>
<p align=justify>во-вторых, выполняется дополнительное днйствие - нечто эквивалентное оператору присвоения:
<pre>q = 100; w = 255; e = 1024;</pre>
<p align=justify>а вот этого в данном контексте и не разрешается делать! Просто так операторы в теле условного оператора не выполняются.
<p align=justify>При этом возникает странная ситуация: создание объекта в памяти со случайным значением оказывает на процесс выполнения программы меньшее влияние, нежели создание того же самого объекта с присвоением ему конкретного значения.
<p align=justify>Казалось, логичнее было бы не делать никаких различий между операторами объявления и прочими операторами. Но дело в том, что оператор выбора состоит из одного единственного блока. И нет иного пути создания объекта с именем, область действия которого распространялась бы на всё тело оператора выбора, как разрешение объявления переменных в любой точке оператора выбора. Судя по всему, переменная создаётся до того момента, как начинают выполняться операторы в блоке. Объявление превыше всего!
<p align=justify>И всё же, какие операторы выполняются в теле оператора выбора (разумеется, за исключением объявления без инициализации)? Ответ: все подряд, начиная с одного из помеченных.
<p align=justify>Возможно, что помеченного меткой "default:". При этом в теле оператора выбора может быть не более одной такой метки.
<pre>switch (val1) default: x++;</pre>
<p align=justify>А возможно, помеченного меткой "case <u>КонстантноеВыражение</u> :". В теле оператора выбора таких операторов может быть сколь угодно много. Главное, чтобы они различались значениями константных выражений.
<p align=justify>Нам уже известно, что является константным выражением и как вычисляется его значение.
<p align=justify>Небольшой тест подтверждает факт вычисления значения константного выражения транслятором:
<pre>
switch (x)
{
       int t;// Об этом операторе уже говорили…
       case 1+2: y = 10;
       case 3:   y = 4; t = 100; // На этом месте транслятор
       //сообщит об ошибке. А откуда он узнал, что 1+2 == 3 ?
       // Сам сосчитал…
       default: cout &lt;&lt; y &lt;&lt; endl;
      }
</pre>
<p align=justify>А вот пример, который показывает, каким оразом вычисляется выражение, содержащее операцию запятая:
<pre>
int XXX = 2;
switch (XXX)
{
 case 1,2: cout &lt;&lt; "1,2"; break;
 case 2,1: cout &lt;&lt; "2,1"; break;
}
</pre>
<p align=justify>Константное выражение принимает значение правого операнда, на экран дисплея выводится первое сообщение.
<p align=justify>И ещё один вопрос. Почему множество значений выражения, располагаемого после switch, ограничивается целыми числами. Можно было бы разрешить использование выражения без ограничения на область значений. Это ограничение связано с использованием константных выражений. Каждый оператор в теле оператора выбора выполняется только при строго определённых неизменных условиях. А это означает, что выражения должны представлять константные выражения. Константные выражения в C++ являются выражениями целочисленного типа (константных выражений плавающего типа в C++ просто не существует).
<p align=justify>Рассмотрим, наконец, схему выполнения оператора switch:
	<ul>
	<li>вычисляется выражение в круглых скобках после оператора switch (предварительная стадия);
	<li>это значение последовательно сравнивается со значениями константных выражений за метками case (стадия определения начальной точки выполнения оператора);
	<li>если значения совпадают, управление передаётся соответствующему помеченному оператору (стадия выполнения);
	<li>если ни одно значение не совпадает и в теле оператора case есть оператор, помеченный меткой default, управление передаётся этому оператору (но даже в этом случае сочетание объявления с инициализацией недопустимо!) (стадия выполнения);
	<li>если ни одно значение не совпадает, и в теле оператора case нет оператора, помеченного меткой default, управление передаётся оператору, следующему за оператором switch (стадия выполнения).
	</ul>
<p align=justify>Метки case и default в теле оператора switch используются лишь при начальной проверке, на стадии определения начальной точки выполнения тела оператора. На стадии выполнения все операторы от точки выполнения и до конца тела оператора выполняются независимо от меток, если только какой-нибудь из операторов не передаст управление за пределы оператора выбора. Таким образом, программист сам должен заботиться о выходе из оператора выбора, если это необходимо. Чаще всего для этой цели используется оператор break.
<p align=justify>В этом разделе нам остаётся обсудить ещё один вопрос. Это вопрос о соответствии оператора выбора и условного оператора. На первый взгляд, оператор выбора легко может быть переписан в виде условного оператора. Рассмотрим в качестве примера следующий оператор выбора:
<pre>
int intXXX;
:::::
switch (intXXX)
{
 case 1:
    int intYYY;
/* Здесь инициализация переменной запрещена, однако определение
переменной должно выполняться. */
    break;
 case 2:
 case 3:
    intYYY = 0;
    break;
}
</pre>
<p align=justify>Казалось бы, этот оператор выбора может быть переписан в виде условного оператора:
<pre>
int intXXX;
:::::
if (intXXX == 1)
{
 int intYYY = 0; // Здесь допускается инициализация!
}
else if (intXXX == 2 || intXXX == 3) 
{
 intYYY = 0;
/*
Здесь ошибка! Переменная intYYY не объявлялась в этом блоке операторов.
*/
}
</pre>
<p align=justify>Если в операторе выбора используется локальная переменная, то для всего множества помеченных операторов из блока оператора выбора требуется единственное объявление этой переменной (лишь бы она не инициализировалась).
<p align=justify>В условном операторе переменная должна объявляться в каждом блоке.
<p align=justify>Ситуация с необъявленной в одном из блоков условного оператора переменной может быть решена путём создания внешнего блока, в который можно перенести объявления переменных, которые должны использоваться в блоках условного оператора.
<pre>
int intXXX;
:::::
if (1) 
/*
Этот условный оператор определяет внешний блок операторов, в котором
располагается объявление переменной intYYY.
*/
{
int intYYY = 0;
if (intXXX == 1)
{
 intYYY = 0;
}
else if (intXXX == 2 || intXXX == 3) 
{
 intYYY = 0;
}
}
</pre>
<p align=justify>Нам удалось преодолеть проблемы, связанные с областями действия, пространствами и областями видимости имён путём построения сложной системы вложенных блоков операторов. Простой одноблочный оператор выбора, содержащий N помеченных операторов, моделируется с помощью N+1 блока условных операторов.
<p align=justify>Однако каждый оператор хорош на своём месте.
<center>
<p><font size="-1"><a href="CPP_045.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_047.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
