<html><head>
<title>Шаблоны функций и шаблонные функции</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Шаблоны функций и шаблонные функции</h4>
<p align=justify>Рассмотрим простую функцию, реализующую алгоритм сравнения двух величин:
<pre>
int min (int iVal_1, int iVal_2)
{
return iVal_1 &lt; iVal_2 ? iVal_1 : iVal_2;
/*
Возвращается значение iVal_1, если это значение меньше iVal_2.
В противном случае возвращается значение iVal_2.
*/
}
</pre>
<p align=justify>Для каждого типа сравниваемых величин должен быть определён собственный вариант функции min(). Вот как эта функция выглядит для float:
<pre>
float min (float fVal_1, float fVal_2)
{
return fVal_1 &lt; fVal_2 ? fVal_1 : fVal_2;
}
</pre>
<p align=justify>А для double… А для…
<p align=justify>И так для всех используемых в программе типов сравниваемых величин. Мы можем бесконечно упражняться в создании совместно используемых функций, хотя можно воспользоваться средствами препроцессирования:
<pre>#define min(a,b)   ((a)&lt;(b)?(a):(b))</pre>
<p align=justify>Это определение правильно работает в простых случаях:
<pre>
min(10, 20);
min(10.0, 20.0);
</pre>
<p align=justify>В более сложных случаях могут получаться неожиданные результаты, о которых уже когда-то давно мы говорили… Это происходит из-за того, что препроцессор действует независимо от компилятора, до компилятора и вообще производит лишь простую текстовую обработку исходного модуля.
<p align=justify>C++ предоставляет ещё одно средство для решения этой задачи. При этом сохраняется присущая макроопределениям краткость и строгость контроля типов языка. Этим средством является шаблон функции.
<p align=justify>Шаблон функции позволяет определять семейство функций. Это семейство характеризуется общим алгоритмом, который может применяться к данным различных типов. При этом задание конкретного типа данных для очередного варианта функции обеспечивается специальной синтаксической конструкцией, называемой списком параметров шаблона функции. Объявление функции, которому предшествует список параметров шаблона, называется шаблоном функции.
<p align=justify>Синтаксис объявления шаблона определяется следующим множеством предложений Бэкуса-Наура:
<pre>
<u>Объявление</u> ::= <u>ОбъявлениеШаблона</u>
<u>ОбъявлениеШаблона</u> ::= template &lt;<u>СписокПараметровШаблона</u>&gt; <u>Объявление</u>
<u>СписокПараметровШаблона</u> ::= <u>ПараметрШаблона</u>
                        ::= <u>СписокПараметровШаблона</u>, <u>ПараметрШаблона</u>
<u>ПараметрШаблона</u> ::= <u>ТиповыйПараметр</u>
                ::= *****
<u>ТиповыйПараметр</u> ::= class Идентификатор
</pre>
<p align=justify>Итак, объявление и определение шаблона функции начинается ключевым словом template, за которым следует заключённый в угловые скобки и разделённый запятыми непустой список параметров шаблона. Эта часть объявления или определения обычно называется заголовком шаблона.
<p align=justify>Каждый параметр шаблона состоит из служебного слова class, за которым следует идентификатор. В контексте объявления шаблона функции служебное слово class не несёт никакой особой смысловой нагрузки. Дело в том, что аналогичная конструкция используется также и для объявления шаблона класса, где, как скоро увидим, ключевое слово class играет свою особую роль. В заголовке шаблона имена параметров шаблона должны быть уникальны.
<p align=justify>Следом за заголовком шаблона располагается прототип или определение функции - всё зависит от контекста программы. Как известно, у прототипа и определения функции также имеется собственный заголовок. Этот заголовок состоит из спецификатора возвращаемого значения (вполне возможно, что спецификатором возвращаемого значения может оказаться идентификатор из списка параметров шаблона), имя функции и список параметров. Все до одного идентификаторы из заголовка шаблона обязаны входить в список параметров функции. В этом списке они играют роль спецификаторов типа. Объявления параметров, у которых в качестве спецификатора типа используется идентификатор из списка параметров шаблона, называется шаблонным параметром. Наряду с шаблонными параметрами в список параметров функции могут также входить параметры основных и производных типов.
<p align=justify>Шаблон функции служит инструкцией для транслятора. По этой инструкции транслятор может самостоятельно построить определение новой функции.
<p align=justify>Параметры шаблона в шаблонных параметрах функции обозначают места будущей подстановки, которую осуществляет транслятор в процессе построения функции. Область действия параметров шаблона ограничивается шаблоном. Поэтому в различных шаблонах разрешено использование одних и тех же идентификаторов-имён параметров шаблона.
<p align=justify>В качестве примера рассмотрим программу, в которой для определения минимального значения используется шаблон функции min().
<pre>
template &lt;class Type&gt; Type min (Type a, Type b);
/*
Прототип шаблона функции.
Ключевое слово template обозначает начало списка параметров
шаблона. Этот список содержит единственный идентификатор Type.
Сама функция содержит два объявления шаблонных параметра,
специфицированных шаблоном параметра Type.
Спецификация возвращаемого значения также представлена шаблоном
параметра Type.
*/
int main (void)
{
min(10,20);// int min (int, int);
min(10.0,20.0);// float min (float, float);
/*
Вызовы шаблонной функции. Тип значений параметров определён.
На основе выражения вызова (транслятор должен распознать тип
параметров) и определения шаблона транслятор самостоятельно
строит различные определения шаблонных функций. И только после
этого обеспечивает передачу управления новорождённой шаблонной
функции.
*/
return 1;
}
template &lt;class Type&gt;
Type min (Type a, Type b)
{
 return a &lt; b ? a : b;
}
/*
По аналогии с определением функции, эту конструкцию будем называть
определением шаблона функции.
*/
</pre>
<p align=justify>Определение шаблона функции заставляет транслятор самостоятельно достраивать определения новых шаблонных функций, а точнее, создавать множество совместно используемых функций, у которых типы параметров и, возможно, тип возвращаемого значения зависит от типа параметров и типа возвращаемого значения в вызовах шаблонной функции. Этот процесс определения называют конкретизацией шаблона функции.
<p align=justify>В результате конкретизации шаблона функции min() транслятор строится следующий вариант программы с двумя шаблонными функциями. По выражению вызова на основе шаблона строится шаблонная функция. Почувствуйте прелесть употребления однокоренных слов! Шаблон функции и шаблонная функция - два разных понятия.
<pre>
int min (int a, int b);
float min (float a, float b);
int main (void)
{
min(10,20);
min(10.0,20.0);
return 1;
}
int min (int a, int b)
{
 return a &lt; b ? a : b;
}
float min (float a, float b)
{
 return a &lt; b ? a : b;
}
</pre>
<p align=justify>Построение шаблонной функции осуществляется на основе выражений вызова. При этом в качестве значений параметров в выражении вызова могут быть использованы значения любых типов, для которых определены используемые в теле функции операции. Так, для функции min() тип параметров зависит от области определения операции сравнения &lt;.
<p align=justify>Типы формального параметра шаблона и значения параметра выражения вызова сопоставляются без учёта каких-либо модификаторов типа. Например, если параметр шаблона в определении функции объявлен как 
<pre>
template &lt;class Type&gt;
Type min (Type *a, Type *b)
{
 return a &lt; b ? a : b;
}
и при этом вызов функции имеет вид:
int a = 10, b = 20;
int *pa = &amp;a, *pb = &amp;b;
min(pa,pb);
</pre>
<p align=justify>то в процессе конкретизации идентификатор типа Type будет замещён именем производного типа int:
<pre>
int min (int *a, int *b)
{
 return a &lt; b ? a : b;
}
</pre>
<p align=justify>В процессе конкретизации недопустимы расширения типов и другие преобразования типов параметров:
<pre>
template &lt;class Type&gt;
Type min (Type a, Type b)
{
 return a &lt; b ? a : b;
}
unsigned int a = 10;
:::::
min(1024,a);
/*
Здесь транслятор сообщит об ошибке. В вызове функции тип второго
фактического параметра модифицирован по сравнению с типом первого
параметра - int и unsigned int. Это недопустимо. В процессе
построения новой функции транслятор не распознаёт модификации типов.
В вызове функции типы параметров должны совпадать. Исправить ошибку
можно с помощью явного приведения первого параметра.
*/
min((unsigned int)1024,a);
:::::
</pre>
<p align=justify>Имя параметра шаблона в определяемой функции используется в качестве имени типа. С его помощью специализируются формальные параметры, определяется тип возвращаемого значения, определяется тип объектов, локализованных в теле функции. Имя параметра шаблона скрывает объекты с аналогичным именем в глобальной по отношению к определению шаблонной функции области видимости. Если в теле шаблонной функции необходим доступ к внешним объектам с тем же именем, следует использовать операцию изменения области видимости.
<p align=justify>И опять пример с излюбленным классом ComplexType. На множестве комплексных чисел определены лишь два отношения: равенства (предполагает одновременное равенство действительной и мнимой частей) и неравенства (предполагает все остальные случаи). В нашей новой программе мы объявим и определим шаблон функции neq(), которая будет проверять на неравенство значения различных типов.
<p align=justify>Для того, чтобы построить шаблонную функцию neq() для комплексных чисел, нам придётся дополнительно определить операторную функцию-имитатор операции != для объектов-представителей множества комплексных чисел. Это важно, поскольку операция != явным образом задействована в шаблоне neq(). Транслятор не поймёт, как трактовать символ != , а, значит, и как строить шаблонную функцию neq(ComplexType, ComplexType), если эта операторная функция не будет определена для класса ComplexType.
<pre>
#include &lt;iostream.h&gt;
template &lt;class Type&gt;
int neq (Type, Type); /*Прототип шаблона функции.*/
class ComplexType
{
 public:
 double real;
 double imag;
// Конструктор умолчания.
 ComplexType(double re = 0.0, double im = 0.0)
 {real = re; imag = im;}
/*
Операторная функция != . Без неё невозможно построение шаблонной функции neq() для комплексных чисел.
*/
 int operator != (ComplexType &amp;KeyVal)
 {
  if (real == KeyVal.real &amp;&amp; imag == KeyVal.imag) return 0;
  else                                            return 1;
 }
};
void main ()
{
 // Определены и проинициализированы переменные трёх типов.
 int i = 1, j = 2;
 float k = 1.0, l = 2.0;
 ComplexType CTw1(1.0,1.0), CTw2(2.0,2.0);
//На основе выражений вызова транслятор строит три шаблонных функции.
cout &lt;&lt; "neq() for int:" &lt;&lt; neq(i,j) &lt;&lt; endl;
cout &lt;&lt; "neq() for float:" &lt;&lt; neq(k,l) &lt;&lt; endl;
cout &lt;&lt; "neq() for ComplexType:" &lt;&lt; neq(CTw2,CTw3) &lt;&lt; endl;
}
/*Определение шаблона функции.*/
template &lt;class Type&gt;
int neq (Type a, Type b)
{
 return  a != b ? 1 : 0;
 // return  a != b; /* На самом деле, можно и так… */
}
</pre>
<p align=justify>И ещё один пример. Этот пример подтверждает обязательность включения всех параметров шаблона в список параметров шаблона определяемой функции. Независимо от того, какая роль предназначается шаблонному параметру (он вообще может не использоваться в шаблонной функции), его присутствие в списке параметров обязательно. В процессе построения шаблонной функции транслятор модифицирует весь шаблон полностью - его заголовок и его тело. Так что в теле шаблона можно объявлять переменные, специфицированные параметрами шаблона.
<pre>
#include &lt;iostream.h&gt;
#include &lt;typeinfo.h&gt; 
/*
В программе используется объект класса Type_info, позволяющий
получать информацию о типе. Здесь подключается заголовочный файл,
содержащий объявление этого класса 
*/
template &lt;class YYY, class ZZZ&gt; YYY Tf (ZZZ, YYY, int);
/*
Шаблон прототипа функции. Функция Tf возвращает значение пока
ещё неопределённого типа, обозначенного параметром шаблона YYY.
Список её параметров представлен двумя (всеми!) параметрами шаблона
и одним параметром типа int.
*/
void main()
{
cout &lt;&lt; Tf((int)   0,    '1', 10) &lt;&lt; endl;
/*
Собственно эти вызовы и управляют работой транслятора. Тип передаваемых
значений параметров предопределяет структуру шаблонной функции.
В первом случае шаблону параметра ZZZ присваивается значение "int",
шаблону параметра YYY присваивается значение "char", после чего прототип
шаблонной функции принимает вид
char Tf (int, char, int);
*/
cout &lt;&lt; Tf((float) 0,    "This is the string...", 10) &lt;&lt; endl;
/*
Во втором случае шаблону параметра ZZZ присваивается значение
"float", шаблону параметра YYY присваивается значение "char *",
после чего прототип шаблонной функции принимает вид
char* Tf (float, char *, int);
В результате, используя один общий шаблон, мы получаем две совершенно
различных совместно используемых функции.
*/
}
/*
Шаблон функции. Первый параметр не используется, поэтому в списке
параметров он представлен спецификатором объявления. Второй шаблонный
параметр определён и также зависит от шаблона, третий параметр от
шаблона не зависит.
*/
template &lt;class YYY, class ZZZ&gt; YYY Tf (ZZZ, YYY yyyVal, int x)
{
ZZZ zzzVal;
int i;
 for (i = 0; i &lt; x; i++)
 {
  cout &lt;&lt; "Tf() for " &lt;&lt; typeid(zzzVal).name() &lt;&lt; endl;
 }
 return yyyVal;
}
</pre>
<center>
<p><font size="-1"><a href="CPP_087.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_089.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
