<html><head>
<title>Указатели на объекты</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Указатели на объекты</h4>
<p align=justify>Рассмотрим простой пример.
<pre>
#include &lt;iostream.h&gt;
class A
{
};
class AB: public A
{
};
class AC: public A
{
};
void main ()
{
A *pObj;
A MyA;
pObj = &amp;MyA;
cout &lt;&lt; "OK A" &lt;&lt; endl;
AB MyAB;
AC MyAC;
pObj = &amp;MyAB;
cout &lt;&lt; "OK AB" &lt;&lt; endl;
pObj = &amp;MyAC;
cout &lt;&lt; "OK AC" &lt;&lt; endl;
}
</pre>
<p align=justify>Это очень простой пример. Пустые классы, простое наследование… Единственно, что важно в объявлении этих классов - спецификаторы доступа в описании баз производных классов. Базовый класс (его будущие члены) должен быть абсолютно доступен в производном классе. Первый оператор функции main() - объявление указателя на объект класса A. Затем следует определение объекта-представителя класса A, следом - настройка указателя на этот объект. Естественно, при этом используется операция взятия адреса. Всё это давно известно и очень просто. Следующие две строки являются определениями пары объектов, которые являются представителями двух разных производных классов…
<p align=justify>За объявлениями объектов в программе располагаются строки, которые позволяют настроить указатель на базовый класс на объект производного класса. Для настройки указателя на объект производного класса нам не потребовалось никаких дополнительных преобразований. Здесь важно только одно обстоятельство. Между классами должно существовать отношение наследования. Таким образом, проявляется важное свойство объектно-ориентированного программирования: УКАЗАТЕЛЬ НА БАЗОВЫЙ КЛАСС МОЖЕТ ССЫЛАТЬСЯ НА ОБЪЕКТЫ - ПРОИЗВОДНЫХ КЛАССОВ. Подобное, на первый взгляд, странное обстоятельство имеет своё объяснение.
<p align=justify>Рассмотрим схемы объектов MyA, MyAB, MyAC:
<pre>
MyA::=
A
MyAB::=
A
AB
MyAC::=
A
AC
</pre>
<p align=justify>Все три объекта имеют общий элемент (объекты производных классов - фрагмент) - представитель базового класса A. Исключительно благодаря этому общему элементу указатель на объект класса A можно настроить на объекты производных классов. Указателю просто присваивается адрес базового фрагмента объекта производного типа. В этом и состоит секрет подобной настройки. Как мы увидим, для указателя pObj, настроенного на объект производного класса, вообще не существует фрагмента объекта, представленного производным классом.
<pre>
pObj
A
AC
</pre>
<p align=justify>Ниже пунктирной линии - пустота. Для того чтобы убедиться в этом, мы усложним структуру класса A, определив в нём функцию Fun1. Конечно же, эта функция ничего не будет делать. Но у неё будет спецификация возвращаемого значения и непустой список параметров. Нам от неё большего и не требуется. Лишь бы сообщала о собственном вызове…
<pre>
class A
{
 public:
 int Fun1(int);
};
int A::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from A " &lt;&lt; endl;
 return 0;
}
</pre>
<p align=justify>Аналогичной модификации подвергнем производные классы AB и AC (здесь предполагаются вызовы функций-членов непосредственно из функции main(), а потому надо помнить о спецификаторе public), а затем продолжим опыты.
<pre>
class AB: public A
{
public:
int Fun1(int key);
};
int AB::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from AB " &lt;&lt; endl;
 return 0;
}
class AC: public A
{
public:
int Fun1(int key);
int Fun2(int key);// В этом классе мы объявим вторую функцию.
};
int AC::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from AC " &lt;&lt; endl;
 return 0;
}
int AC::Fun2(int key)
{
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from AC " &lt;&lt; endl;
 return 0;
}
</pre>
<p align=justify>Теперь мы займёмся функцией main(). Первая пара операторов последовательно из объекта запускает функцию-член производного класса, а затем - подобную функцию базового класса. С этой целью используется квалифицированное имя функции-члена.
<pre>
MyAC.Fun2(2);    //Вызвана AC::Fun2()…
MyAC.Fun1(2);    //Вызвана AC::Fun1()…
MyAC.A::Fun1(2); //Вызвана A::Fun1()…
</pre>
<p align=justify>Следующие строки посвящены попытке вызова функций-членов по указателю на объект базового типа. Предполагается, что в данный момент он настроен на объект MyAC.
<pre>
pObj-&gt;Fun1(2); //Вызвана A::Fun1()…
</pre>
<p align=justify>И это всё, что можно способен указатель на объект базового типа, если его настроить на объект производного типа. Ничего нового. Тип указателя на объект - базовый класс. В базовом классе существует единственная функция-член, она известна транслятору, а про структуру производного класса в базовом классе никто ничего не знает. Так что следующие операторы представляют пример того, что не следует делать с указателем на объекты базового класса, даже настроенного на объект производного класса.
<pre>
//pObj-&gt;Fun2(2);
//pObj-&gt;AC::Fun1(2);
</pre>
<p align=justify>То ли дело указатель на объект производного типа! И опять здесь нет ничего нового и неожиданного. С "нижнего этажа бункера" видны все "этажи"!
<pre>
AC* pObjAC = &amp;MyAC;
pObjAC-&gt;Fun1(2);
pObjAC-&gt;Fun2(2);
pObjAC-&gt;AC::Fun1(2);
pObjAC-&gt;Fun1(2);
pObjAC-&gt;A::Fun1(2);
</pre>
<p align=justify>И, разумеется, указатель на объект производного класса не настраивается на объект базового.
<pre>//pObjAC = &amp;MyA;</pre>
<p align=justify>Основной итог этого раздела заключается в следующем: указатель на объект базового класса можно настроить на объект производного типа. Через этот указатель можно "увидеть" лишь фрагмент объекта производного класса - его "базовую" часть - то, что объект получает в наследство от своих предков. Решение о том, какая функция должна быть вызвана, принимается транслятором. В момент выполнения программы всё уже давно решено. Какая функция будет вызвана из объекта производного типа - зависит от типа указателя, настроенного на данный объект. В этом случае мы наблюдаем классический пример статического связывания.
<center>
<p><font size="-1"><a href="CPP_077.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_079.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
