<html><head>
<title>Конструкторы и деструкторы: заключительные замечания</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Конструкторы и деструкторы: заключительные замечания</h4>
<p align=justify>В общих чертах, мы закончили описание конструкторов и деструкторов - важных элементов любого класса. Хотя в дальнейшем нам придётся ещё несколько раз обратиться к этому вопросу, главное уже позади.
<p align=justify>И всё же следует сделать несколько замечаний.
<p align=justify>Конструктор превращает фрагмент памяти в объект. Посредством операции обращения непосредственно "от имени" объекта можно вызвать функции-члены класса.
<p align=justify>Мы можем модифицировать известный нам класс комплексных чисел, определив новую функцию-член reVal(), предназначенную для вывода значения действительной части комплексного числа:
<pre>
class ComplexType
{
 public:
:::::
 // Пусть это будет встроенная функция.
 void reVal(){cout &lt;&lt; real &lt;&lt; endl;};
 :::::
};
</pre>
<p align=justify>И после определения объекта CDw1, мы можем вызывать эту функцию-член класса. В результате выполнения функции будет выведено значение действительной части объекта CDw1. Важно, что объект используется как точка вызова функции:
<pre>CDw1.PrintVal();</pre>
<p align=justify>А вот аналогичного выражения, обеспечивающего неявный вызов конструктора из объекта, как известно, не существует.
<pre>
CDw1.ComplexType(CDw1); 
// Неудачная попытка неявного вызова конструктора копирования.
// НЕ ОБЪЕКТ ДЛЯ КОНСТРУКТОРА, А КОНСТРУКТОР ДЛЯ ОБЪЕКТА!
</pre>
<p align=justify>По аналогии с конструкторами копирования и преобразования в C++ можно использовать функциональную форму операторов определения переменных основных типов. Синтаксис этих операторов напоминает операторы, содержащие выражения, вычисление которых обеспечивает вызов конструкторов копирования и преобразования:
<pre>
ComplexType CDw1(125);
ComplexType CDw2(CDw1);
int iVal1(25);    // Соответствует int iVal1 = 25;
int iVal2(iVal1); // Соответствует int iVal2 = iVal1;
</pre>
<p align=justify>Конечно же, это не имеет никакого отношения к классам. Но вместе с тем, здесь мы можем наблюдать, как меняется грамматика при введении в язык новых типов: корректное выражение для производных типов по возможности ничем не должно отличаться от выражения для основного типа. Синтаксис операторов определение и инициализации объектов производных типов влияет на синтаксис операторов определения основных типов.
<p align=justify>Последнее, что нам осталось сделать - это выяснить причины, по которым в C++ так различаются синтаксис объявления, определения и вызова конструкторов и деструкторов и обычных функций-членов класса.
<p align=justify>Причина сокрытия кода регламентных работ по созданию объекта в конструкторе очевидна. Конструктор выполняет сложную работу, связанную с распределением глобальной, локальной и, как будет скоро показано, динамической памяти и превращением фрагмента памяти в объект. Это основания языка. Содержание этого процесса просто обязано быть скрытым от пользователя (программиста) подобно тому, как скрыт программный код, который реализует, например, операцию индексации, сравнения, сдвига, вызов функций и прочие языковые конструкции.
<p align=justify>Также скрыты от нас и особенности реализации деструкторов. Не существует даже средства стандартной эффективной проверки результата выполнения деструктора: в некоторых реализациях можно обратиться к функциям-членам объекта даже после уничтожения этого объекта деструктором.
<p align=justify>Отсутствие спецификации возвращаемого значения и запрещение операции взятия адреса для конструктора и деструктора также имеют свои объективные причины.
<p align=justify>Если бы в их объявлениях присутствовала спецификация возвращаемого значения (неважно, какого) и было бы разрешено применение операции взятия адреса, то можно было бы в программе определять указатели на конструкторы и деструкторы как на обычные функции.
<p align=justify>Как известно, указатель на функцию характеризуется типом возвращаемого значения и списком параметров функции. Очевидно, что имя функции в этом случае не играет никакой роли. Но как раз имя конструктора и деструктора и позволяет транслятору различать функции, конструкторы и деструкторы. При использовании указателей для вызова функций, деструкторов и конструкторов транслятор в ряде случаев просто не сможет определить, что, собственно, хочет сделать программист в данном контексте: вызвать функцию или определить новый объект.
<p align=justify>Дополнительные ограничения при объявлении и использовании конструкторов полностью устраняют недоразумения, которые могут возникнуть при вызове функций и конструкторов.
<center>
<p><font size="-1"><a href="CPP_073.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_075.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
