<html><head>
<title>Управление исключением - блоки try и catch, операция throw</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Управление исключением - блоки try и catch, операция throw</h4>
<p align=justify>Предлагаемое в C++ решение проблемы реакции на синхронные исключительные ситуации связано с использованием так называемых контролируемых блоков операторов.
<p align=justify>Операторы, составляющие критические участки кода (например, вызов функций, в которых могут возникнуть исключительные ситуации) и операторы, определяющие перехват возможных исключений, размещаются в этих блоках отдельно от прочих "безопасных" операторов функции.
<p align=justify>Синтаксис контролируемых блоков описывается следующим множеством формул Бэкуса-Наура:
<pre>
<u>Оператор</u> ::= <u>КонтролируемыйБлокОператоров</u>
<u>КонтролируемыйБлокОператоров</u> ::= try <u>СоставнойОператор СписокРеакций</u>
<u>СписокРеакций</u> ::= <u>Реакция</u> [<u>СписокРеакций</u>]
<u>Реакция</u> ::= catch (<u>ОбъявлениеИсключения</u>) <u>СоставнойОператор</u>
<u>ОбъявлениеИсключения</u> ::= <u>СписокСпецификаторовТипа Описатель</u>
                   ::= <u>СписокСпецификаторовТипа АбстрактныйОписатель</u>
                   ::= <u>СписокСпецификаторовТипа</u>
                   ::= ...
</pre>
<p align=justify>Это одно из последних множеств БНФ на нашем пути. Всё те же знакомые описатели, любимые абстрактные описатели, и даже хорошо известное многоточие.
<p align=justify>На основе данных БНФ строим контролируемый блок операторов. Как всегда, пока важен лишь внешний вид оператора.
<pre>
<u>КонтролируемыйБлокОператоров</u>
try <u>СоставнойОператор СписокРеакций</u>
try 
 {
  Оператор
  Оператор
  Оператор
 }
СписокРеакций
try 
 {
  int retVal;
  retVal = MyFun(255);
  cout &lt;&lt; "retVal == " &lt;&lt; retVal &lt;&lt; "…" &lt;&lt; endl
 }
catch (<u>ОбъявлениеИсключения</u>) <u>СоставнойОператор</u>
СписокРеакций
try 
 {
  int retVal;
  retVal = MyFun(255);
  cout &lt;&lt; "retVal == " &lt;&lt; retVal &lt;&lt; "..." &lt;&lt; endl
 }
catch (char *) 
 {
  x = x * 25;
 }
catch (MyException MyProblem1)
 {
 cout &lt;&lt; "Неполадки типа MyException: " &lt;&lt; MyProblem1.text &lt;&lt; endl;
 }
catch (...)
 {
 cout &lt;&lt; "Нераспознанные исключения..." &lt;&lt; endl;
 }
</pre>
<p align=justify>Итак, контролируемый блок операторов. Прежде всего, это блок операторов, то есть, составной оператор. Его место - тело функции. Этот оператор может входить в любой другой блок операторов.
<p align=justify>Он начинается с ключевого слова try (поэтому дальше мы его будем называть try-блоком), следом за которым располагается так называемый блок испытания. В блоке испытания обычно размещается критический код, выполнение которого может привести к возникновению ошибки времени выполнения.
<p align=justify>За ним следует, по крайней мере, один элемент списка реакций со своим блоком перехвата. Каждый блок перехвата начинается с заголовка - ключевого слова catch, за которым в круглых скобках располагается объявление ситуации. Синтаксис объявления ситуации напоминает объявление параметра в прототипе функции. В этом объявлении не используется лишь инициализаторы.
<p align=justify>catch-блок содержит код, предназначенный для перехвата исключений. Однако без генератора исключений он абсолютно бесполезен.
<p align=justify>Возбуждение (или генерация) исключения обеспечивается операцией throw. Это весьма странная операция. Даже с точки зрения синтаксиса:
<pre>
<u>Выражение</u> ::= <u>ГенерацияИсключения</u>
<u>ГенерацияИсключения</u> ::= throw [<u>Выражение</u>]
</pre>
<p align=justify>Выражение, состоящее из одного символа операции (с пустым множеством операндов) уже является выражением. Выражением с неопределённым значением. Однако оператор на основе этого выражения построить можно!
<pre>throw;</pre>
<p align=justify>Оператор возбуждения исключения является полноправным оператором и в принципе может располагаться в любом месте программы: в теле обычной функции, функции-члена, конструкторе или деструкторе. Он может использоваться как в сочетании с контролируемыми блоками операторов, так и в "автономном" режиме.
<p align=justify>Его выполнение в автономном режиме или за пределами контролируемого блока приводит к завершению процесса выполнения программы. Точнее, сначала может быть вызвана функция unexpected, следом за которой по умолчанию запускается функция terminate. Она вызывает функцию abort для аварийного завершения работы программы.
<p align=justify>Функции unexpected и terminate в ходе выполнения программы можно заменить какие-либо другими функциями, для чего следует воспользоваться функциями set_unexpected и set_terminate. Прототипы функций set_unexpected и set_terminate обычно располагаются в заголовочном файле &lt;except.h&gt;. В качестве параметров они получают указатели на функции и возвращают значения адресов замещённых функций. Так что по ходу дела всё можно будет с помощью этих же функций вернуть назад.
<p align=justify>Пользовательские функции, замещающие функции unexpected и terminate, всё равно оказываются самыми последними функциями завершаемой программы. Именно поэтому они должны иметь тип возвращаемого значения void, а также не должны иметь параметров.
<p align=justify>Наконец, последней функцией завершаемой программы всё равно оказывается функция abort. Всевозможные ухищрения лишь откладывают момент её неизбежного вызова. Позже мы рассмотрим пример, реализующий замещение этих функций.
<p align=justify>При автономном использовании оператора возбуждения исключения, его перехват оказывается как бы и ни при чём. Однако это всего лишь частный случай, один из самых простых вариантов сценария, к которому может привести использование операции throw.
<p align=justify>Операция throw может применяться в сочетании с операндом, каковым может оказаться выражение произвольного типа и значения.
<p align=justify>Оператор, построенный на основе такого выражения, можно называть генератором исключения. А его место расположения обычно называют точкой генерации. Вот примеры разнообразных генераторов исключений:
<pre>
throw 1;
throw "Это сообщение об исключении…";
throw 2*2*fVal;
throw (int)5.5;
throw (ComplexType)125.96;
/*
Разумеется, если определён соответствующий конструктор
преобразования или функция приведения.
*/
</pre>
<p align=justify>Для генератора важны как значение выражения-исключения, так и его тип. Иногда даже конкретное значение исключения не так важно, как его тип.
<p align=justify>В качестве исключения может быть использовано значение указателя. Допускаются исключения и такого вида:
<pre>
throw NULL;
throw (void *) &amp;iVal;
</pre>
<p align=justify>И, естественно, не существует быть генераторов исключений для выражений типа void. Пустой тип не имеет значений.
<p align=justify>Обычно генератор исключения используется в сочетании с try-блоком. Их взаимодействие обеспечивается через стек вызова. Поэтому точка генерации исключения должна располагаться в теле функции, непосредственно или косвенно вызываемой из множества операторов данного try-блока. В крайнем случае, генератор исключения сам может быть одним из операторов этого try-блока.
<p align=justify>Рассмотрим небольшой пример, после которого опишем основные принципы взаимодействия генератора и блока перехвата исключений.
<p align=justify>Но сначала вспомним пару форм Бэкуса-Наура, посвящённых объявлению и определению функций. Речь пойдёт о спецификации исключения. С первого взгляда всё это уже кажется простым и понятным:
<pre>
<u>ОбъявлениеФункции</u> ::=
               [<u>СписокСпецификаторовОбъявления</u>]
                                           <u>Описатель</u>
                                            [<u>СпецификацияИсключения</u>];
<u>ОпределениеФункции</u> ::=
               [<u>СписокСпецификаторовОбъявления</u>]
                                         <u>Описатель</u>
                                          [<u>ctorИнициализатор</u>]
                                            [<u>СпецификацияИсключения</u>]
                                                          <u>ТелоФункции</u>
<u>СпецификацияИсключения</u> ::= throw ([<u>СписокТипов</u>])
<u>СписокТипов</u> ::= [<u>СписокТипов</u> ,] <u>ИмяТипа</u>
</pre>
<p align=justify>Из последнего уточнения структуры объявления и определения функции следует, что объявление и определение любой функции может быть дополнено спецификацией исключения. Эта спецификация является дополнительным элементом заголовка функции и состоит из ключевого слова throw и заключённого в круглые скобки списка типов. При этом пустой список типов эквивалентен полному отсутствию спецификации исключения.
<p align=justify>Назначение спецификации исключения мы обсудим позже, а пока - демонстрация особенностей работы механизма управления исключениями.
<center>
<p><font size="-1"><a href="CPP_089.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_091.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
