<html><head>
<title>Базовые и производные классы</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Базовые и производные классы</h4>
<p align=justify>Синтаксис наследования задаётся необязательным элементом заголовка класса, который называется спецификацией базы и описывается следующим множеством форм Бэкуса-Наура:
<pre>
<u>СпецификацияБазы</u> ::= : <u>СписокБаз</u>
<u>СписокБаз</u> ::= [<u>СписокБаз</u>,] <u>ОписательБазы</u>
<u>ОписательБазы</u> ::= <u>ПолноеИмяКласса</u>
              ::= [virtual] [<u>СпецификаторДоступа</u>] <u>ПолноеИмяКласса</u>
              ::= [<u>СпецификаторДоступа</u>] [virtual] <u>ПолноеИмяКласса</u>
</pre>
<p align=justify>Нам ещё предстоит выяснить назначение элементов описателя базы, но уже очевидно, что спецификация базы представляет собой список имён классов. Поскольку производный класс наследует данные и функции базового класса, базовые классы обязательно должны быть объявлены до объявления производного класса.
<p align=justify>Для начала рассмотрим пример объявления нескольких классов. В этом примере задаются отношения наследования между тремя классами (классы A, B, C). При этом C наследует свойства класса B, который, в свою очередь, является наследником класса A. В этом примере все члены классов объявляются со спецификатором public, к которому мы пока относимся (пока!) как к должному. В этих классах мы объявим (просто обозначим) самые простые варианты конструкторов и деструкторов. В настоящий момент нам важно исключительно их существование.
<pre>
#include &lt;iostream.h&gt;
class A {
 public:
 A(){};
 ~A(){};
 int x0;
 int f0 () {return 1;};
};
class B : public A {
 public:
 B(){};
 ~B(){};
 int x1;
 int x2;
 int xx;
 int f1 () {return 100;};
 int f2 () {return 200;};
};
class C : public B {
 public:
 C(){};
 ~C(){};
 int x1;
 int x2;
 int x3;
 int f1 () {return 1000;};
 int f3 () {return 3000;};
};
void main () {C MyObject;}
</pre>
<p align=justify>Перед нами пример простого наследования. Каждый производный класс при объявлении наследует свойства лишь одного базового класса. В качестве базового класса можно использовать лишь полностью объявленные классы. Неполного предварительного объявления здесь недостаточно. Для наглядного представления структуры производных классов используются так называемые направленные ациклические графы. Узлы этого графа представляют классы, дуги - отношение наследования.
<p align=justify>Вот как выглядит направленный ациклический граф ранее приведённого в качестве примера производного класса C:
<pre>
A
              B
                            C
</pre>
<p align=justify>Структуру производного класса можно также представить в виде таблицы (или схемы класса), отображающей общее устройство класса:
<pre>
A
B
C
</pre>
<p align=justify>В C++ различаются непосредственные и косвенные базовые классы. Непосредственный базовый класс упоминается в списке баз производного класса. Косвенным базовым классом для производного класса считается класс, который является базовым классом для одного из классов, упомянутых в списке баз данного производного класса.
<p align=justify>В нашем примере для класса C непосредственным базовым классом является B, косвенным - A. Следует иметь в виду, что порядок "сцепления" классов, образующих производный класс, зависит от реализации, а потому все схемы классов и объектов имеют характер имеют чисто иллюстративный характер.
<p align=justify>Дополним нашу схему, включив в неё объявления всех членов классов, включая, конструкторы и деструкторы.
<p align=justify>В результате мы получаем полную схему производного класса со всеми его компонентами, вместе с его непосредственными базовыми классами, а также и косвенными базовыми классами.
<pre>
A
A();	
~A();	
	int x0;
	int f0 ();
B
B();	
~B();	
	int x1;
	int x2;
	int xx;
	int f1();
	int f2();
C
C();	
~C();	
	int x1;
	int x2;
	int xx;
	int f1();
	int f2();
</pre>
<p align=justify>Это схема класса, а не объекта. Образно говоря, наша схема подобна схеме многоэтажного бункера, разделённого на три уровня. На схеме эти уровни разделяются двойными линиями. Класс C занимает самый нижний уровень. Именно этот класс имеет неограниченные (по крайней мере, в нашей версии объявления производного класса) возможности и полномочия доступа к элементам базовых классов. Именно с нижнего уровня можно изменять все (опять же, в нашей версии объявления класса) значения данных-членов класса и вызывать все (или почти все) функции-члены класса.
<p align=justify>Объект-представитель класса C является единым блоком объектов и включает собственные данные-члены класса C, а также данные-члены классов B и A. Как известно, функции-члены классов, конструкторы и деструкторы не включаются в состав объекта и располагаются в памяти отдельно от объектов. Так что схему объекта-представителя класса можно представить, буквально удалив из схемы класса функции-члены, конструкторы и деструкторы.
<p align=justify>Следует также иметь в виду, что на схеме класса располагаются лишь объявления данных-членов, тогда как схема объекта содержит обозначения определённых областей памяти, представляющих данные-члены конкретного объекта.
<p align=justify>Итак, выполнение оператора определения
<pre>C MyObj;</pre>
<p align=justify>приводит к появлению в памяти объекта под именем MyObj. Рассмотрим схему этого объекта. Её отличие от схемы класса очевидно. Здесь мы будем использовать уже известный нам метасимвол ::= (состоит из). На схеме объекта информация о типе данного-члена будет заключаться в круглые скобки.
<pre>
MyObj::=
A
	(int)x0
B
	(int)x1
	(int)x2
	(int)xx
C
	(int)x1
	(int)x2
	(int)xx
</pre>
<p align=justify>Перед нами объект сложной структуры, в буквальном смысле собранный на основе нескольких классов. В его создании принимали участие несколько конструкторов. Порядок их вызова строго регламентирован. Вначале вызываются конструкторы базовых классов. Следом вызываются конструкторы производных классов.
<p align=justify>Благодаря реализации принципа наследования, объект представляет собой цельное сооружение. Из объекта можно вызвать функции-члены базовых объектов. Эти функции наследуются производным классом от своих прямых и косвенных базовых классов. Непосредственно от объекта возможен доступ ко всем данным-членам. Данные-члены базовых классов также наследуются производными классами.
<p align=justify>Если переопределить деструкторы базовых и производных классов таким образом, чтобы они сообщали о начале своего выполнения, то за вызовом деструктора производного класса C непосредственно из объекта MyObj:
<pre>MyObj.~C();</pre>
<p align=justify>последует серия сообщений о выполнении деструкторов базовых классов. Разрушение производного объекта сопровождается разрушением его базовых компонентов. Причём порядок вызова деструкторов противоположен порядку вызова конструкторов.
<p align=justify>А вот вызвать деструктор базового класса из объекта производного класса невозможно:
<pre>MyObj.~B(); // Так нельзя. Это ошибка!</pre>
<p align=justify>Частичное разрушение объекта в C++ не допускается. БАЗОВЫЕ ДЕСТРУКТОРЫ НЕ НАСЛЕДУЮТСЯ. Таков один из принципов наследования.
<p align=justify>Если бы можно было вызывать конструктор непосредственно из объекта, аналогичное утверждение о наследовании можно было бы сделать и по поводу конструкторов.
<p align=justify>Однако утверждение о том, что базовый конструктор не наследуется так же корректно, как и утверждение о том, что стиральная машина не выполняет фигуры высшего пилотажа. Стиральная машина в принципе не летает. НИ ОДИН КОНСТРУКТОР (ДАЖЕ КОНСТРУКТОР ПРОИЗВОДНОГО КЛАССА) НЕ ВЫЗЫВАЕТСЯ ИЗ ОБЪЕКТА.
<p align=justify>К моменту начала разбора структуры производного класса, транслятору становятся известны основные характеристики базовых классов. Базовые классы включаются в состав производных классов в качестве составных элементов. Это означает, что в производном классе (в его функциях) можно обращаться к данным-членам и вызывать функции-члены базовых классов. Можно, если только этому ничего не мешает (о том, что может этому помешать - немного позже).
<p align=justify>Как раз в нашем случае в этом смысле всё в порядке, и мы приступаем к модификации исходного кода нашей программы.
<p align=justify>Прежде всего, изменим код функции с именем f1, объявленной в классе C. Мы оставим в классе лишь её объявление, а саму функцию определим вне класса, воспользовавшись при этом её квалифицированным именем.
<p align=justify>Проблемы, связанные с одноименными членами класса решаются с помощью операции разрешения области видимости. Впрочем, нам это давно известно:
<pre>
int C ::f1()
{
A::f0();
/*Вызов функции-члена класса A.*/
f0();
/*
Для вызова этой функции можно не использовать специфицированного
имени. Функция под именем f0 одна на все классы. И транслятор
безошибочно определяет её принадлежность.
*/
A::x0 = 1;
B::x0 = 2;
C::x0 = 3;
x0 = 4;
/*
К моменту разбора этой функции-члена, транслятору известна структура
всех составных классов. Переменная x0 (как и функция f0) обладает
уникальным именем и является общим достоянием базовых и производных
классов. При обращении к ней может быть использовано как её собственное
имя, так и имя с любой квалификацией. Аналогичным образом может быть
также вызвана и функция f0().
*/
B::f0();
C::f0();
/* Изменение значений данных-членов. */
//A::x1 = 1;
/* Ошибка! Переменная x1 в классе A не объявлялась.*/
B::x1 = 2;
C::x1 = 3;
x1 = 4;
/*
Переменная x1 объявляется в двух классах. Транслятор определяет
принадлежность данных-членов по квалифицированным именам. В последнем
операторе присвоения транслятор считает переменную x1 собственностью
класса C, поскольку этот оператор располагается "на территории" этого
класса. Если бы класс C не содержал объявления переменной x1, последние
три оператора были бы соотнесены с классом B.
*/
//A::xx = 1;
/* Ошибка! Переменная xx в классе A не объявлялась.*/
B::xx = 2;
C::xx = 3;
xx = 4;
/*
Аналогичным образом обстоят дела с переменной xx, объявленной
в классе B. Хотя xx не объявлялась в классе C, транслятор
рассматривает эту переменную как элемент этого класса и не
возражает против квалифицированного имени C::xx.
В последнем операторе транслятор рассматривает переменную xx как
член класса B.
*/
return 150;
}
Теперь переопределим функцию-член класса B.
При её разборе (даже если определение этой функции располагается
после объявления класса C), транслятор воспринимает лишь имена
базовых классов. В это время транслятор забывает о существовании
класса C. А потому упоминание этого имени воспринимается им как ошибка.
int B ::f1()
{
A::f0();
A::x0 = 1;
B::x0 = 2;
//C::x0 = 3;
/* Ошибка. */
x0 = 4;
B::f0();
//C::f0();
/* Ошибка. */
/* Изменение значений данных-членов. */
//A::x1 = 1;
/* Ошибка. Переменная x1 в классе A не объявлялась.*/
B::x1 = 2;
//C::x1 = 3;
/* Ошибка. */
x1 = 4;
//A::xx = 1;
/* Ошибка! Переменная xx в классе A не объявлялась.*/
B::xx = 2;
//C::xx = 3;
/* Ошибка. */
xx = 4;
return 100;
}
</pre>
<p align=justify>Нам остаётся рассмотреть, каким образом транслятор соотносит члены класса непосредственно в объекте. Для этого переопределим функцию main():
<pre>
void main ()
{
C MyObj;
MyObj.x0 = 0;
MyObj.B::x0 = 1;
MyObj.C::x0 = 2;
MyObj.f0();
MyObj.A::f0();
MyObj.C::f0();
/*
Поиск "снизу-вверх" является для транслятора обычным делом.
Транслятор способен отыскать нужные функции и данные даже у
косвенного базового класса. Главное, чтобы они были там объявлены.
И при было бы возможным однозначное соотнесение класса и его члена.
*/
MyObj.x1 = 777;
MyObj.B::x1 = 999;
cout &lt;&lt; MyObj.A::x1 &lt;&lt; "-" &lt;&lt; MyObj.B::x1;
/*
Процесс соотнесения осуществляется от потомков к предкам. Не
специфицированный член класса x1 считается членом "ближайшего"
производного класса, о чём и свидетельствует последняя тройка операторов.
*/
MyObj.B::f2();
MyObj.C::f2();
/*
И опять успешное соотнесение благодаря поиску "снизу-вверх". Недостающие
элементы в производном классе можно поискать по базовым классам. Важно,
чтобы они там были.
*/
// MyObj.A::f1();
// MyObj.A::f2();
// MyObj.A::f3();
// MyObj.B::f3();
/*
А вот "сверху вниз" транслятор смотреть не может. Предки не отвечают
за потомков.
*/
}
</pre>
<p align=justify>Таким образом, корректное обращение к членам класса в программе обеспечивается операцией разрешения области видимости. Квалифицированное имя задаёт область действия имени (класс), в котором начинается (!) поиск данного члена класса. Принципы поиска понятны из ранее приведённого примера.
<center>
<p><font size="-1"><a href="CPP_075.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_077.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
