<html><head>
<title>Работа системы управления исключением</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Работа системы управления исключением</h4>
<p align=justify>Генерацию и перехват исключений не рекомендуется использовать в целях, отличных от обработки ошибок. Считается, что это может уменьшить ясность программы.
<p align=justify>Считается также, что механизмы обработки исключением изначально создавались для обработки сравнительно редко проявляющихся ошибок и использовались чаще всего для завершения работы программы. В силу этого нет (пока нет) никакой гарантии относительно оптимальности, эффективности и надёжности этого механизма в качестве средства для обычного программного управления.
<p align=justify>Вместе с тем, далеко не каждая исключительная ситуация должна вести к завершению программы. Например, при вычислении частного от деления двух случайных чисел, система управления исключением в случае возможного деления на нуль оказывается одним из основных средств управления программой.
<p align=justify>Примерно такая же ситуация складывается и в нашем примере. Мы специально моделируем исключительные ситуации для оценки возможностей применения механизма перехвата.
<p align=justify>Мы не будем всякий раз прерывать ход выполнения программы из-за того, что возникла какая-то странная ситуация. Если мы в силах восстановить нормальный ход выполнения программы - мы должны сделать это.
<p align=justify>И если исключительная ситуация возникает в цикле - пусть её перехватчик остановит цикл. А вопросы эффективности и корректной работы со стеком - это вопросы к транслятору.
<pre>
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
/*
"Рабочее тело" одного из исключений. На его основе создаётся
объект исключения.
*/
class MyException 
{
 public:
 int CopyKey;
 char *ExcMessage;
 // Конструктор умолчания.
 MyException(): ExcMessage("Стандартное сообщение от MyException...")
  {
   CopyKey = 0;
  }
 // Конструктор копирования.
 MyException(const MyException&amp; MyExcKey)
  {
   cout &lt;&lt; "Работает конструктор копии..." &lt;&lt; endl;
   ExcMessage = strdup(MyExcKey.ExcMessage);
   CopyKey = 1; // Признак копии для деструктора.
  }
 // Деструктор освобождает динамическую память.
~MyException()
 {
  if (CopyKey &amp;&amp; ExcMessage) delete(ExcMessage);
 }
};
int MyFun() throw (int, char *);
int Fun2()  throw (int);
void main() throw (MyException)
{
int RetMainVal;
for (RetMainVal = 0; RetMainVal &gt;= 0; )
{
 try
 {
  RetMainVal = MyFun();
  cout &lt;&lt; "RetMainVal == " &lt;&lt; RetMainVal &lt;&lt; endl;
  if (RetMainVal == 9) throw MyException(); /* Вызов конструктора для создания безымянного объекта - представителя класса MyException в точке возбуждения исключения (с использованием выражения явного преобразования типа). После этого код, расположенный ниже точки генерации исключения уже не выполняется. */
  cout &lt;&lt; "Последний RetMainVal не был равен 9!"
       &lt;&lt; " Иначе были бы мы здесь..." &lt;&lt; endl;
 }
// Место расположения перехватчиков исключений.
 catch (int ExcVal)
 {
  cout &lt;&lt; "(int) ExcVal == " &lt;&lt; ExcVal &lt;&lt; endl;
 }
 catch (char *ExcMessage)
 {
  cout &lt;&lt; "(char *) ExcMessage " &lt;&lt; ExcMessage &lt;&lt; endl;
 }
 catch (MyException ExcObj)
 /*
 Безымянный объект, созданный в точке возбуждения исключения,
 инициализирует параметр обработчика исключения. С этой целью нами
 был определен специальный конструктор копирования.
 */
 {
  cout &lt;&lt; ExcObj.ExcMessage 
       &lt;&lt; "... Такое вот сообщение пришло" &lt;&lt; endl;
/*
После завершения выполнения блока обработки исключения, параметр
обработчика уничтожается. Для этого мы определили собственную версию
деструктора.
*/
 }
 cout &lt;&lt; "За пределами tryБлока: RetMainVal == "
      &lt;&lt; RetMainVal &lt;&lt; endl;
  // cout &lt;&lt; ExcMessage &lt;&lt; "!!!" &lt;&lt; endl;
  // Обработчик исключений определяет собственную область действия.
  // ExcMessage оказывается за пределами области действия имени.
}
cout &lt;&lt; "Это конец работы программы."
     &lt;&lt; " И чтобы больше никаких перехватов..." &lt;&lt; endl;
}
int MyFun() throw (int, char *)
{
 int Answer, RetMyFunVal;
 cout &lt;&lt; "MyFun &gt; ";
 cin &gt;&gt; Answer;
 cout &lt;&lt; Answer &lt;&lt; endl;
 switch (Answer)
 {
  case 1:
        throw 1;
cout &lt;&lt; "Когда рак на горе свистнет, тогда это сообщение появится.";
        break;
  case 2:
        throw "XXX";
  case 3:
        RetMyFunVal = Fun2();
        cout &lt;&lt; "Вернулись из Fun2(). RetMyFunVal = "
             &lt;&lt; RetMyFunVal &lt;&lt; endl;
        break;
 }
 cout &lt;&lt; "Привет из MyFun..." &lt;&lt; endl;
 return  Answer;
}
int Fun2() throw (int)
{
 int Answer;
 cout &lt;&lt; "Fun2 &gt; ";
 cin &gt;&gt; Answer;
 cout &lt;&lt; Answer &lt;&lt; endl;
 switch (Answer)
 {
  case 0:
        throw 1;
/*
После возбуждения исключения, процесс нормального выполнения
программы прерывается. Мы уже не попадаем в точку возврата функции.
Используя стек, минуем функцию MyFun и оказываемся непосредственно
в catch-блоке функции main, связанном с исключением типа int.
*/
  default:
        Answer *= 2;
 }
 cout &lt;&lt; "Конец работы в Fun2." &lt;&lt; endl;
 return Answer;
}
</pre>
<p align=justify>Перед нами программа-полигон для демонстрации взаимодействия генераторов исключений и перехватчиков. Функция main содержит контролируемый блок операторов. Наряду с другими операторами, он составляет тело оператора цикла for.
<p align=justify>Функция возвращает значение определённого типа. Тип возвращаемого значения является важной характеристикой функции. Спецификация возвращаемого значения явным образом указывается при объявлении и определении функции. В различных ситуациях та же функция может возбуждать исключения совершенно разных типов и классов. Средством контроля над типами возбуждаемых исключений как раз является спецификация исключений. Этот необязательный элемент в заголовке обеспечивает дополнительный контроль над функцией со стороны транслятора. Хотя функция и может без предварительной спецификации возбуждать любые исключения, им не следует пренебрегать.
<p align=justify>Транслятор следит за тем, чтобы не нарушались области действия имён объектов. Областью действия переменной, объявленной непосредственно в try-блоке, является данный try-блок. Соответственно, областью действия переменной, объявленной в одном из catch-блоков, этот самый catch-блок.
<p align=justify>try-блок содержит критический код, выполнение которого может привести к возникновению исключительных ситуаций. Возникновение исключительных ситуаций находится под контролем и сопровождается генерацией соответствующего исключения. Одна из точек генерации располагается непосредственно в try-блоке. В данном случае исключительная ситуация возникает, если вызванная перед этим функция в качестве возвращаемого значения возвращает девятку.
<p align=justify>Прочие точки генерации исключений, представляющие реакцию на гипотетические исключительные ситуации, располагаются в теле функций, вызываемых из try-блока.
<p align=justify>Возникающие в этих функциях исключительные ситуации (по нашему сценарию это реакция на конкретные значения, вводимые в интерактивном режиме) сопровождаются генерацией различных исключений.
<p align=justify>В принципе, try-блок может и не содержать участков критического кода и на контролируемом им участке программного кода может и не возникать никаких исключительных ситуаций. В этом случае выполнение этого кода ничем не будет отличаться от выполнения обычного (будто бы бывают обычные блоки) блока операторов. Впрочем, это не наш случай.
<p align=justify>И вот, наконец, свершилось! В ходе выполнения контролируемого кода, непосредственно в try-блоке или в теле одной из вызываемых из этого блока функций возникает ситуация, которая может быть квалифицирована как исключительная. Реакцией на неё является возбуждение с помощью throw-оператора соответствующего исключения. С этого момента весь ход выполнения программы меняется.
<p align=justify>Немедленно прекращается выполнение любых операторов, располагаемых следом за точкой генерации исключения. 
<p align=justify>Если точка генерации исключения оказалась в последнем операторе вызываемой функции, то отменяются все мероприятия по предполагаемому возвращению из вызываемой функции.
<p align=justify>Тем более отменяется выполнение каких-либо операторов вызова. Точка генерации исключения в определённом смысле оказывается действительно точкой. В этой самой точке принципиально меняется весь дальнейший ход выполнения программы. Сразу после возбуждения исключения начинается поиск соответствующего блока перехвата исключения.
<p align=justify>При этом область поиска ограничивается теми блоками операторов (естественно, в том числе и функциями), информация о которых была зафиксирована в стеке на момент возбуждения исключения. Это и понятно, поскольку перехват исключения производится в соответствии с принципом, согласно которому за последствия исключительной ситуации отвечает вызывающая функция. В ходе этого поиска производится действие, подобное "разматыванию" стека. И лишь возможные различия в деталях этих процессов, которые могут зависеть от конкретной реализации, служат аргументом в пользу того, чтобы не делать механизм перехвата исключения заурядным средством управления процессом выполнения.
<p align=justify>Существуют чёткие критерии соответствия блока перехвата и возбуждённого исключения. Перечислим их:
	<ul>
	<li>блок перехвата исключения соответствует возбуждённому исключению, если в их объявлении и генерации использован один и тот же тип;
	<li>если возбуждаемое исключение может быть преобразовано к типу исключения, объявленного в блоке перехвата путём неявного преобразования типа, исключение считается соответствующим данному блоку перехвата;
	<li>если возбуждаемое исключение преобразуется к типу исключения, объявленного в блоке перехвата путём явного преобразования типа, оно считается соответствующим данному блоку перехвата;
	<li>исключение, которое является объектом-представителем производного класса, соответствует блоку перехвата, в котором объявлено исключение-представитель базового класса. Таким образом, исключение производного класса может быть перехвачено в блоке перехвата, в котором объявлено исключение-представитель базового класса. Это обстоятельство следует учитывать при расположении в программе блоков, определяющих списки реакций. В списке реакций контролируемого блока операторов перехватчики исключений, порождённых базовыми классами, должны располагаться в списке исключений ниже перехватчиков исключений, представляющих производные классы;
	<li>блок перехвата, содержащий вместо объявления исключения многоточие catch (...) {/*...*/}, соответствует любому исключению. Это своего рода универсальный блок перехвата. Он должен завершать список перехватчиков, поскольку ни один блок перехвата после него не сможет быть выполнен для обработки данного исключения, поскольку все возможные исключения будут перехвачены этим блоком.
	</ul>
<p align=justify>Как известно, конструкторы и деструкторы не возвращают значений. Но в них могут быть размещены операторы генерации исключений. Если теперь программный код, обеспечивающий вызов конструкторов или деструкторов разместить в try-операторе, то можно будет организовать перехват исключения от конструкторов и деструкторов. Возбуждение исключения в конструкторе должно сопровождаться, если это необходимо, автоматическим вызовом деструкторов для уничтожения образующих этот объект составных элементов (если таковые существуют). Если исключительная ситуация возникла в ходе создания массива объектов, вызываемый в результате генерации исключения деструктор уничтожит лишь созданные на момент возникновения исключительной ситуации объекты.
<p align=justify>Если соответствующий блок перехвата был обнаружен и содержит именованный параметр, временный объект, созданный throw операцией, его инициализирует. Здесь всё происходит примерно также, как и при вызове функции. Для инициализации параметра исключения, являющегося представителем какого-либо класса, может потребоваться собственная версия конструктора копирования и деструктора. Проинициализированный именованный параметр получает доступ к информации, заложенной в исключение в момент его генерации. И здесь уместна аналогия с вызовом функции. Существует проинициализированный и поименованный параметр - будет и доступ к передаваемой информации. В ряде случаев, как и при вызове функции, без конкретного значения параметра можно и обойтись - лишь бы вовремя активизировался соответствующий обработчик и принял бы соответствующие меры по ликвидации последствий исключительной ситуации. А меры в этой связи могут быть приняты самые разнообразные. Здесь всё определяется конкретной задачей.
<p align=justify>Стартовав из try-блока, в результате возникновения исключительной ситуации, при благоприятном стечении обстоятельств, мы оказались в одном из связанных с ним блоков перехвата исключения. По сигналу тревоги, благодаря системе программирования C++, в нужное время мы прибыли в нужное место. Теперь всё зависит от программиста. Наши действия в catch-блоке практически ничем не ограничены. Выведем ли мы предупредительное сообщение на экран, исправим ли значение индекса массива, запросим ли новое значение для делителя - это транслятор не волнует. Формально мы совершили действие, в результате которого исключительная ситуация перехвачена, а её причина, возможно, что и ликвидирована. Что бы мы ни сделали catch-блоке (в конце концов, исправляя ошибку, мы можем сделать новую ошибку), будет воспринято без возражений.
<p align=justify>Находясь в catch-блоке, мы можем вообще отказаться от каких-либо неотложных мероприятий. С помощью оператора throw; можно повторно возбудить последнее исключение. Этот оператор обязательно должен быть расположен в catch-блоке. В результате повторно запускается всё тот же механизм поиска нового подходящего catch-блока. Стек при этом продолжает разматываться, и если при этом в ходе выполнения программы имела место ситуация "вложенных" контролируемых блоков (из try-блока одной функции прямо или косвенно была вызвана функция, содержащая собственный контролируемый блок), то повторно возбуждённое исключение может быть перехвачено уровнем ниже. Таким образом, можно поручить перехват исключения функции, которая была вызвана ранее и, возможно, не несёт ответственности за возникшую исключительную ситуацию. Если соответствующего перехватчика исключения не окажется, выполнение программы будет остановлено.
<p align=justify>Побывав в одном из блоков перехвата, и, возможно, выполнив какие-либо корректные действия, мы можем возобновить выполнение программы, начиная с первого оператора за пределами данного контролируемого блока операторов.
<p align=justify>Может так случиться, что исключение окажется неперехваченным. Не во всех же программах прописывается универсальный блок перехвата… Безуспешный просмотр всех записей стека в поисках соответствующего перехватчика является признаком неперехваченного исключения. Оно оказывается за пределами контролируемого блока операторов, таким же независимым и свободным, как исключение, возбуждённое в "автономном" режиме. И последней преградой на пути неперехваченного исключения встаёт функция unexpected.
<p align=justify>Эту функцию невозможно переопределить, а из-за жёстких ограничений на её список параметров (он непременно должен быть пустым), нельзя определить соответствующие совместно используемые функции. Функция unexpected - "вещь в себе", заглушка. Известно лишь, что она вызывает функцию terminate, но может вызвать и ещё какую-либо другую функцию. Изменить ситуацию на этом "последнем рубеже" можно лишь одним единственным способом - определив собственную функцию, которая должна заместить функцию unexpected в результате выполнения уже известной функции set_unexpected. Здесь ещё существует возможность исправить положение. Дальше такой возможности уже не будет.
<p align=justify>На очереди ещё одна простая программа. Это уже не полигон. Это интерактивный вычислитель частного от деления двух плавающих чисел. Эта программа в бесконечном цикле запрашивает значения делимого и делителя, а в случае возникновения исключительной ситуации возбуждает исключение. В момент возбуждения исключения, пользователю предоставляется возможность принятия решения относительно дальнейшего продолжения вычислений.
<p align=justify>Представляющий исключение класс MyDivideByZeroError обладает всем необходимым набором элементов для эффективного взаимодействия с системой управления исключениями. Он располагает конструктором умолчания для возбуждения исключения. Там же имеется конструктор копирования для инициализации соответствующего параметра в блоке перехвата исключения. Есть и деструктор, который обеспечивает освобождение динамической памяти.
<pre>
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#define YESMESS "Мы продолжаем."
#define NOMESS  "Мы завершаем."
class MyDivideByZeroError
{
char *MyErrorMessage;
public:
char ContinueKey;
MyDivideByZeroError(): MyErrorMessage(NULL)
{
char YesKey;
 cout &lt;&lt; "Зафиксировано деление на нуль." &lt;&lt; endl;
 cout &lt;&lt; "Принимать экстренные меры? (Y/N) &gt;&gt; ";
 cin &gt;&gt; YesKey;
 if ( YesKey == 'Y' || YesKey == 'y' )
 {
  ContinueKey = 1;
  MyErrorMessage = strdup(YESMESS);
 }
 else
 {
  ContinueKey = 0;
  MyErrorMessage = strdup(NOMESS);
 }
}
MyDivideByZeroError(const MyDivideByZeroError&amp; CopyVal)
{
  ContinueKey = CopyVal.ContinueKey;
  MyErrorMessage = strdup(CopyVal.MyErrorMessage);
}
~MyDivideByZeroError()
{
  if (MyErrorMessage) delete(MyErrorMessage);
}
void PrintMessage()
{
 cout &lt;&lt; MyErrorMessage &lt;&lt; endl;
}
};
float Dividor(float, float) throw(MyDivideByZeroError);
void main()
{
 float MyVal1, MyVal2;
 for (;;)
 {
//__ Начало контролируемого блока __________________________________.
  try
  {
  cout &lt;&lt; "========================================" &lt;&lt; endl;
  cout &lt;&lt; "MyVal1 &gt;&gt; ";
  cin &gt;&gt; MyVal1;
  cout &lt;&lt; "MyVal2 &gt;&gt; ";
  cin &gt;&gt; MyVal2;
  cout &lt;&lt; "Считаем... " &lt;&lt; Dividor(MyVal1, MyVal2) &lt;&lt; endl;
  cout &lt;&lt; "Получилось! ";
  }
  catch (MyDivideByZeroError MyExcept)
  {
MyExcept.PrintMessage();
if (MyExcept.ContinueKey == 0)
{
 cout &lt;&lt; "Надоело воевать с ошибками! Уходим." &lt;&lt; endl;
 break;
}
  }
//__ За пределами контролируемого блока ____________________________.
  cout &lt;&lt; "Уже за пределами блока. Мы продолжаем..." &lt;&lt; endl;
 }
}
float Dividor(float Val1, float Val2) throw(MyDivideByZeroError)
{
 if (Val2 == 0.0) throw MyDivideByZeroError();
 return Val1/Val2;
}
</pre>
<p align=justify>И, наконец, пример замещения функций unexpected и terminate. Последняя программа в этой книге.
<pre>
#include &lt;iostream.h&gt;
#include &lt;except.h&gt;
#define MAXERR 5
class MaxError;
class MyError
{
 public:
  MyError()
  {
CounterError++;
if (CounterError &gt; MAXERR)
{
 cout &lt;&lt; " Здесь MyError()... throw MaxError()!" &lt;&lt; endl;
 throw MaxError();
}
else
{
 cout &lt;&lt; " Здесь MyError()... CounterError++!" &lt;&lt; endl;
}
  }
  void ErrSay()
  {
cout &lt;&lt; " Здесь ErrSay(): " &lt;&lt; CounterError &lt;&lt; endl;
  }
  static int CounterError;
};
int MyError::CounterError = 0;
class MaxError
{
 public:
  MaxError()
  {
if (CounterMaxError == 0)
{
 /*
MaxError один раз может подправить значение счётчика MyError::CounterError.
 */
 CounterMaxError++;
 MyError::CounterError -= 2;
 cout &lt;&lt; "Здесь MaxError().. MyError::CounterError-= 2;" &lt;&lt; endl;
}
else
{
 cout &lt;&lt; " Здесь MaxError()... ###" &lt;&lt; endl;
}
  }
  static int CounterMaxError;
};
int MaxError::CounterMaxError = 0;
void RunnerProcessor();
void Run() throw(MyError);
void MyUnex();
void MyTerm();
void main()
{
unexpected_function OldUnex;
terminate_function  OldTerm;
OldUnex = set_unexpected(MyUnex);
OldTerm = set_terminate(MyTerm);
/*
Мы замещаем функции unexpected() и terminate().
Адресные переменные нужны для того, чтобы запомнить адреса старых
функций. В случае необходимости, их можно восстановить:
set_unexpected(OldUnex);
set_terminate(OldTerm);
*/
RunnerProcessor();
}
void RunnerProcessor()
{
 for (;;)
 {
  try
  {
   Run();
  }
  catch (MyError err)
  {
   err.ErrSay();
  }
 }
}
void Run() throw(MyError)
{
 cout &lt;&lt; "Работает Run()..." &lt;&lt; endl;
 throw MyError();
}
void MyUnex()
{
 /* Мы всё ещё находимся в пределах try-блока. */
 cout &lt;&lt; "Это MyUnex()..." &lt;&lt; endl;
 throw MyError();
}
void MyTerm()
{
 int MyTermKey = 0;
/*
Вышли из try-блока. Включилась система автоматического торможения.
*/
 for ( ; MyTermKey &lt; 5; )
 {
 cout &lt;&lt; "Это MyTerm()........................" &lt;&lt; MyTermKey &lt;&lt; endl;
 MyError::CounterError = 0;
 MaxError::CounterMaxError = 0;
 RunnerProcessor();
 MyTermKey += 1; /* Цикл здесь уже не циклится! */
 }
 MaxError::CounterMaxError = 0;
 throw MyError(); /* Исключения не работают! */
}
</pre>
<p align=justify>Всё. Приехали. Можно расслабиться. Можно постоять на берегу океана. Послушать шум ветра в соснах. Посмотреть на касаток в холодной прозрачной воде. Только недолго. Впереди ждут великие дела.
<center>
<p><font size="-1"><a href="CPP_090.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_093.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
