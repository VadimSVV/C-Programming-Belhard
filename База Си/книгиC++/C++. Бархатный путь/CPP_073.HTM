<html><head>
<title>Указатель this</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Указатель this</h4>
<p align=justify>Продолжаем определение класса ComplexType. Теперь объявим и определим функцию-член PrintVal, которая будет выводить значение чисел-объектов.
<p align=justify>Прототип функции разместим в классе:
<pre>void PrintVal();</pre>
<p align=justify>При определении функции используется квалифицированное имя:
<pre>
void ComplexType::PrintVal()
{
cout &lt;&lt; "(" &lt;&lt; real &lt;&lt; ", " &lt;&lt; imag &lt;&lt; "i)" &lt;&lt; endl;
cout &lt;&lt; (int)CTcharVal &lt;&lt; ", " &lt;&lt; x &lt;&lt; "…" &lt;&lt; endl;
}
</pre>
<p align=justify>Значения данных-членов объекта выводятся при выполнении выражения вызова функции PrintVal:
<pre>CDw1.PrintVal();</pre>
<p align=justify>Объекты класса имеют свои собственные экземпляры данных-членов. Данные-члены имеют свои собственные специфические значения. Вместе с тем, все объекты используют единый набор функций-членов, с помощью которого можно получить доступ к значениям данных-членов во всех объектах класса.
<p align=justify>Среди операторов функции-члена PrintVal() нет ни одного оператора, который позволял бы определить, какому объекту принадлежат данные-члены. И, тем не менее, вызов этой функции для каждого из определённых и различным образом проинициализированных объектов, в том числе и для безымянного объекта, который создаётся в результате непосредственного вызова конструктора:
<pre>ComplexType(0.0,0.0, 1).PrintVal(); ,</pre>
<p align=justify>а также вызов функции для объекта, адресуемого указателем:
<pre>pCD-&gt;PrintVal();</pre>
<p align=justify>сопровождается сообщением о значениях собственных данных-членов. Заметим, что "собственные" данные-члены объектов, как и те функции-члены класса, с которыми мы уже успели познакомиться, считаются нестатическими данными и функциями-членами класса. Существуют также и статические члены класса, к изучению свойств которых мы обратимся в недалёком будущем.
<p align=justify>Автоматическое определение принадлежности данных-членов конкретному объекту характерно для любой нестатической функции-члена класса. Объекты являются "хозяевами" нестатических данных и потому каждая нестатическая функция-член класса должна уметь распознавать "хозяйские" данные.
<p align=justify>Вряд ли алгоритм распознавания хозяина данных очень сложен. Здесь проблема заключается совсем в другом: этот алгоритм должен быть реализован практически для каждой нестатической функции-члена класса. Он используется везде, где производится обращение к данным-членам объектов, а это означает, что на программиста может быть возложена дополнительная обязанность по кодированию. Несколько обязательных строк для каждой функции-члена? Да никогда…
<p align=justify>К счастью, C++ освобождает программистов от утомительной и однообразной работы кодирования стандартного алгоритма распознавания. В C++ вообще многое делается без их участия. Функции-члены определяются как обычные функции. Транслятор переопределяет эти функции, обеспечивая при этом стандартными средствами связь между объектами и их данными. Эта связь реализуется благодаря специальному преобразованию исходного кода программы. Мы опишем это преобразование, условно разделив его на два этапа.
<p align=justify>На первом этапе каждая нестатическая функция-член преобразуется в функцию с уникальным именем и дополнительным параметром - константным указателем на объект класса. Затем преобразуются обращения к нестатическим данным-членам в операторах функции-члена. Они переопределяются с учётом нового параметра. В C++ при подобном преобразовании для обозначения дополнительного параметра-указателя (константного указателя) и постфиксного выражения с операциями обращения для обращения к нестатическим данным-членам используется одно и то же имя this. Вот как могла бы выглядеть функция-член PrintVal после её переопределения:
<pre>
void ComplexType::ComplexType_PrintVal(ComplexType const *this)
{
cout &lt;&lt; "(" &lt;&lt; this-&gt;real &lt;&lt; "," &lt;&lt; this-&gt;imag &lt;&lt; "i)" &lt;&lt; endl;
cout &lt;&lt; int(this-&gt;CTcharVal) &lt;&lt; "," &lt;&lt; x &lt;&lt; "…" &lt;&lt; endl;
}
</pre>
<p align=justify>На втором этапе преобразуются вызовы функций-членов. К списку значений параметров выражения вызова добавляется выражение, значением которого является адрес данного объекта. Это вполне корректное преобразование. Дело в том, что нестатические функции-члены всегда вызываются для конкретного объекта. И потому не составляет особого труда определить адрес объекта. Например, вызов функции-члена PrintVal() для объекта CDw1, который имеет вид
<pre>CDw1.PrintVal();</pre>
<p align=justify>после преобразования принимает вид:
<pre>ComplexType_PrintVal(&amp;CDw1);</pre>
<p align=justify>А вызов функции-члена безымянного объекта, адресуемого указателем pCD
<pre>pCD-&gt;PrintVal();</pre>
<p align=justify>преобразуется к виду
<pre>ComplexType_PrintVal(&amp;(*pCD));</pre>
<p align=justify>что эквивалентно следующему оператору:
<pre>ComplexType_PrintVal(pCD);</pre>
<p align=justify>Первый (и в нашем случае единственный) параметр в вызове новой функции является адресом конкретного объекта.
<p align=justify>В результате такого преобразования функция-член приобретает новое имя и дополнительный параметр типа указатель на объект со стандартным именем this и типом, а каждый вызов функции-члена приобретает форму вызова обычной функции.
<p align=justify>Причина изменения имени для функций-членов класса очевидна. В разных классах могут быть объявлены одноименные функции-члены. В этих условиях обращение к функции-члену класса непосредственно по имени может вызвать конфликт имён: в одной области действия имени одним и тем же именем будут обозначаться различные объекты - одноименные функции-члены разных классов. Стандартное преобразование имён позволяет решить эту проблему.
<p align=justify>Указатель this можно использовать в теле функции-члена без его дополнительного объявления. В частности, операторы функции ComplexType::PrintVal() могут быть переписаны с использованием указателя this:
<pre>
void ComplexType::PrintVal()
{
cout &lt;&lt; "(" &lt;&lt; this-&gt;real &lt;&lt; "," &lt;&lt; this-&gt;imag &lt;&lt; "i)" &lt;&lt; endl;
cout &lt;&lt; int(this-&gt;CTcharVal) &lt;&lt; "," &lt;&lt; x &lt;&lt; "…" &lt;&lt; endl;
}
</pre>
<p align=justify>Явное употребление this указателя не вызывает у транслятора никаких возражений, что свидетельствует об эквивалентности старого и нового вариантов функции. В этом случае указатель this считается не именем (имя вводится объявлением), а первичным выражением. Напомним, что имя, как и первичное выражение this являются частными случаями выражения.
<p align=justify>В ряде случаев при написании программы оправдано явное использование указателя this. При этом выражение
<pre>this</pre>
<p align=justify>представляет адрес объекта, а выражение
<pre>*this</pre>
<p align=justify>представляет сам объект:
<pre>
this-&gt;<U>ВЫРАЖЕНИЕ</U>
(*this).<U>ВЫРАЖЕНИЕ</U>
</pre>
<p align=justify>(здесь нетерминальный символ <U>ВЫРАЖЕНИЕ</U> обозначает член класса). Эти выражения обеспечивают доступ к членам уникального объекта, представленного указателем this с целью изменения значения данного, входящего в этот объект или вызова функции-члена.
<p align=justify>Следует помнить о том, что this указатель является константным указателем. Это означает, что непосредственное изменение его значение (перенастройка указателя, например, this++) недопустимо. Указатель this с самого начала настраивается на определённый объект.
<p align=justify>При описании this указателя мы не случайно подчёркивали, что этот указатель используется только для нестатических функций-членов. Использование этого указателя в статических функциях-членах класса (о них речь впереди) не имеет смысла. Дело в том, что эти функции в принципе не имеют доступа к нестатическим данным-членам класса.
<p align=justify>В объявлении нестатической функции-члена this указателю можно задавать дополнительные свойства. В частности, возможно объявление константного this указателя на константу. Синтаксис языка C++ позволяет сделать это. Среди БНФ, посвящённых синтаксису описателей, есть и такая форма:
<pre>
<u>Описатель</u> ::=
         <u>Описатель</u> (<u>СписокОбъявленийПараметров</u>) [<u>СписокCVОписателей</u>]
          ::= *****
<u>CVОписатель</u> ::= const
            ::= *****
</pre>
<p align=justify>Так что небольшая модификация функции-члена PrintVal, связанная с добавлением cvОписателя const:
<pre>void PrintVal() const;</pre>
<p align=justify>в прототипе и
<pre>
void ComplexType::PrintVal() const
{
:::::
}
</pre>
<p align=justify>в определении функции обеспечивает относительную защиту данных от возможной модификации.
<p align=justify>CVОписатель const в заголовке функции заставляет транслятор воспринимать операторы, которые содержат в качестве леводопустимых выражений имена данных-членов, возможно, в сочетании с this указателем, как ошибочные. Например, следующие операторы в этом случае оказываются недопустимы.
<pre>
this-&gt;CTcharVal = 125;
real = imag*25;
imag++;
</pre>
<p align=justify>cvОписатель const в заголовке функции не допускает непосредственной модификации значений принадлежащих объекту данных.
<p align=justify>Заметим также, что this указатель включается также в виде дополнительного параметра в список параметров конструктора. И в этом нет ничего удивительного, поскольку его значением является всего лишь область памяти, занимаемая объектом.
<center>
<p><font size="-1"><a href="CPP_072.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_074.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
