<html><head>
<title>Конструкторы. Основные свойства</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Конструкторы. Основные свойства</h4>
<p align=justify>Сначала несколько форм Бэкуса-Наура.
<pre>
<u>Объявление</u> ::= <u>ОбъявлениеФункции</u>
           ::= <u>ОпределениеФункции</u>
           ::= *****
<u>ОбъявлениеФункции</u> ::=
               [<u>СписокСпецификаторовОбъявления</u>]
                                           <u>Описатель</u>
                                            [<u>СпецификацияИсключения</u>];
<u>ОпределениеФункции</u> ::=
               [<u>СписокСпецификаторовОбъявления</u>]
                                         <u>Описатель</u>
                                          [<u>ctorИнициализатор</u>]
                                            [<u>СпецификацияИсключения</u>]
                                                          <u>ТелоФункции</u>
<u>Описатель</u> ::= <u>Описатель</u> ([<u>СписокОбъявленийПараметров</u>])
          ::= <u>dИмя</u>
<u>dИмя</u> ::= <u>ИмяКласса</u>
</pre>
<p align=justify>Используя это множество БНФ, можно строить объявления весьма странного вида:
<pre>
<u>ОбъявлениеФункции</u> ::=
<u>Описатель</u>; ::=
<u>Описатель</u> (); ::=
<u>dИмя</u> (); ::=
ComplexType ();
</pre>
<p align=justify>Объявление… без спецификатора объявления.
<pre>
<u>ОпределениеФункции</u> ::=
<u>Описатель ТелоФункции</u> ::=
<u>Описатель</u> () {} ::=
<u>dИмя</u> () {} ::=
ComplexType () {}
</pre>
<p align=justify>А это определение. Оно построено в соответствии с правилами построения функций. Не важно, что у него в теле нет ни одного оператора! Важно, что у него нет спецификатора объявления.
<p align=justify>Именно так и выглядит конструктор, альтернативный тому, который строится транслятором без участия программиста. Множество операторов (возможно пустое), оформленное в виде блока, с заголовком специального вида (ни слова о возвращаемых значениях) - нечто подобное функции-члену. Подобным образом организованная и весьма напоминающая своим синтаксисом обыкновенную функцию последовательность операторов и отвечает за создание объектов данного класса.
<p align=justify>Отметим одно очень важное обстоятельство. Имя конструктора всегда совпадает с именем класса, членом которого является объявляемый конструктор. Ни одна функция-член класса не может называться именем класса. Ни одна функция-член класса не может быть объявлена и определена без спецификатора объявления. Характерное имя и отсутствие спецификации объявления отличает конструктор от функций-членов класса.
<p align=justify>Отсутствие спецификаторов объявления означает, что конструктор не имеет абсолютно никакого отношения к вызову и возвращению значений. Конструктор не является функцией.
<p align=justify>Так что объявления функций-членов класса ComplexType
<pre>
void ComplexType();
ComplexType ComplexType();
</pre>
<p align=justify>не являются объявлениями конструктора. Для транслятора это всего лишь некорректные объявления функций-членов с пустыми списками параметров. Подобные объявления в классе ComplexType воспринимаются транслятором как ошибки.
<p align=justify>А вот построенное нами объявление действительно является объявлением конструктора:
<pre>ComplexType();</pre>
<p align=justify>И наше определение действительно является определением конструктора:
<pre>ComplexType(){}</pre>
<p align=justify>Это ничего, что конструктор такой простой, зато он от начала и до конца правильный!
<p align=justify>Как известно, в классе может быть не объявлено ни одного конструктора. В таком случае транслятор без участия программиста самостоятельно строит стандартный конструктор. Не существует классов без конструкторов, хотя классы с автоматически создаваемыми конструкторами, как ни странно, называются классами без конструкторов.
<p align=justify>В классе может быть объявлено (и определено) несколько конструкторов. Их объявления должны различаться списками параметров. Такие конструкторы по аналогии с функциями называются перегруженными (или совместно используемыми). Транслятор различает перегруженные конструкторы по спискам параметров. В этом смысле конструктор не отличается от обычной функции-члена класса:
<pre>
ComplexType(double rePar, double imPar); /* Объявление… */
ComplexType(double rePar, double imPar){/*…*/} /*Определение…*/
</pre>
<p align=justify>И ещё один вариант конструктора для класса ComplexType - на этот раз с одним параметром (его помощью, например, можно задавать значение мнимой части):
<pre>
ComplexType(double imPar); /* Объявление… */
ComplexType(double imPar){/*…*/} /*Определение…*/
</pre>
<p align=justify>Здесь мы сознательно опять оставили пустыми тела конструкторов. Необходимо сначала выяснить, какие операторы могут, а какие не могут располагаться в конструкторе.
<p align=justify>Отсутствие спецификации возвращаемого значения не означает запрета на использование оператора return в теле конструктора. В конце концов, это всего лишь оператор перехода. Но использование этого оператора в сочетании с выражением, задающим возвращаемое значение, например,
<pre>
return NULL;
либо
return MyVal;
либо
return 125;
</pre>
<p align=justify>и т.д., недопустимо. Возвращаемое значение специфицируется по типу, а как раз про тип возвращаемого конструктором значения в объявлении конструктора ничего и не сказано. Поэтому то, что обычно называется выражением явного вызова конструктора, вызовом, по сути, не является.
<p align=justify>Часто вообще невозможно сказать что-либо определённое по поводу того, что обеспечивает передачу управления конструктору - так называемое выражение вызова (или обращения к конструктору), либо выражение, которое используется для преобразования типа (постфиксный вариант выражения преобразования типа). Соответствующая БНФ уже приводилась ранее. Напомним её:
<pre>
<u>ПосфиксноеВыражение</u> ::= <u>ИмяПростогоТипа</u> ([<u>СписокВыражений</u>])
</pre>
<p align=justify><u>ИмяПростогоТипа</u> и имя конструктора совпадают. Поэтому имя простого типа можно рассматривать как имя конструктора. При вычислении значения выражения приведения для производных типов управление действительно передаётся одноименному конструктору. Без участия конструктора невозможно определить значение соответствующего выражения:
<pre>
(ComplexType) 25;
/* В этом случае мы имеем дело с выражением преобразования. При
вычислении его значения производится обращение к конструктору
ComplexType(double). */
(float) 25;
/* Здесь нет никаких обращений к конструктору. Базовый тип float
классом не является и конструкторов не имеет. Перед нами оператор,
состоящий из выражения приведения (целочисленное значение приводится
к типу float). */
float x = float(25);
/* В этом случае для определения значения выражения явного
преобразования типа, записанного в функциональной форме, также не
требуется никаких обращений к конструктору. */
ComplexType (25);
/* Казалось бы, здесь мы также имеем дело с функциональной формой
выражения явного преобразования типа - оператором на основе постфиксного
выражения. Для вычисления значения этого выражения необходимо обратиться
к конструктору ComplexType(double). */
</pre>
<p align=justify>На последнее предложение следует обратить особое внимание. Дело в том, что аналогичный оператор на основе постфиксного выражения для основных типов языка C++ воспринимается транслятором как ошибка:
<pre>
float (25);
/* Это некорректный оператор! Для любого из основных типов C++
здесь будет зафиксирована ошибка. */
</pre>
<p align=justify>Возникает, на первый взгляд, очень странная ситуация. С одной стороны, мы можем построить операторы на основе любых выражений, в том числе и на основе выражения явного приведения типа. При этом тип, к которому приводится конкретное выражение, не влияет на корректность оператора. Для производного типа принципиально лишь наличие объявления соответствующего класса. С другой стороны, оператор, построенный на основе функциональной формы выражения приведения, оказывается некорректным. Похоже, что перед нами единственный случай, при котором важно наличие соответствующего конструктора.
<p align=justify>Обращение к грамматике языка C++ позволяет объяснить подобное поведение транслятора. Он воспринимает предложения, которые начинаются с имени основного типа (в этом случае нет речи ни о каких конструкторах), как начало объявления. При этом следом за именем основного типа в объявлении может располагаться лишь один из вариантов описателя (возможно, что заключённый в круглые скобки). При анализе структуры объявления мы уже встречались с такими описателями. Заключённое в круглые скобки число (а возможно и имя ранее объявленной в каком-либо другом объявлении переменной), в контексте объявления может восприниматься лишь как альтернативная форма инициализатора, но не как описатель.
<p align=justify>Таким образом, оператор
<pre>float (25);</pre>
<p align=justify>(и ему подобные операторы для основных типов) представляется транслятору объявлением с пропущенным описателем и альтернативной формой инициализатора. Чем-то, напоминающим следующую конструкцию:
<pre>float = 25;</pre>
<p align=justify>при разборе подобного предложения транслятор, естественно, не находит ожидаемого описателя и сообщает об ошибке в объявлении.
<p align=justify>В случае производного типа, подобное выражение воспринимается как явное обращение к конструктору, в результате которого создаются безымянные объекты, время жизни которых ограничивается моментом их создания.
<p align=justify>В C++ можно построить условное выражение на основе выражения явного преобразования к одному из основных типов. Основные типы имеют простую структуру, а потому значение такого выражения определить очень просто:
<pre>
if (char(charVal)) {/*…*/}
if (float(5))   {/*…*/}
if ((int)3.14){/*…*/}
if (double (0)){/*…*/}
</pre>
<p align=justify>Включение в условия условных операторов выражений, вычисление значений которых приводит к передаче управления конструкторам, требует дополнительных усилий со стороны прораммиста. У порождаемых конструкторами объектов сложная структура и неизвестные транслятору способы определения значений, представляемых такими объектами. Кроме того, определённый в языке набор операций приспособен исключительно для работы со значениями основных типов. Транслятор не имеет абсолютно никакого представления о том, каким образом следует, например, сравнивать значения того же самого ComplexType.
<p align=justify>Однако, C++ располагает специальными средствами, которые позволяют создавать иллюзию условных выражений с объектами-операндами производных типов. Чуть позже мы рассмотрим так называемые операторные функции (или перегруженные операции), с помощью которых можно будет всё-таки сформулировать условия, подобные тем, которые формулируются относительно значений основных типов:
<pre>
if (ComplexType()){/*…*/}
if (ComplexType() &gt; 10 &amp;&amp; ComplexType() &lt;= 25 ){/*…*/}
</pre>
<p align=justify>Правда, в данном контексте за символами операций сравнения и даже за выражением "явного вызова конструктора" скрываются так называемые сокращённые формы вызова операторных функций, а не обычные операции C++.
<p align=justify>А какое условие можно сформулировать в терминах операций, пригодных для работы исключительно со значениями основных типов по поводу значения безымянного объекта производного типа, который, к тому же и погибает сразу же после своего рождения?
<p align=justify>В C++ невозможно сформулировать условие относительно сложного объекта "в целом", используя при этом стандартный набор операций, но легко можно определить значения данных-членов этого объекта. Для этого используется операция выбора компонента:
<pre>if (ComplexType().real &amp;&amp; !ComplexType().imag){/*…*/}</pre>
<p align=justify>Вот мы и узнали кое-что о свойствах объекта. Правда, объектов в условии целых два. У первого безымянного объекта мы поинтересовались значением данного-члена real, после чего он благополучно отошёл "в мир иной", у второго объекта выяснили значение данного-члена imag.
<p align=justify>Выражения вызова функций типа void так же недопустимы в контексте условия, поскольку функции void "возвращают" пустые значения. Например,
<pre>
void MyProc();
:::::
void MyProc() {/*…*/}
:::::
if (MyProc()) {/*…*/} /* Здесь ошибка */
for ( ; MyProc(); ) {/*…*/} /* Здесь ошибка */
if (ComplexType()){/*…*/} /* Это тоже ошибка */
</pre>
<p align=justify>Выражение явного преобразования типа можно расположить справа от символа операции присвоения в операторе присвоения.
<pre>
ComplexType MyVal = ComplexType ();
ComplexType MyVal = ComplexType (25);
ComplexType MyVal = (ComplexType) 25;
</pre>
<p align=justify>И опять перед нами так называемый явный вызов конструктора. Но, как сказано в справочном руководстве по C++, "явный вызов конструктора означает не то же самое, что использование того же синтаксиса для обычной функции-члена". Конструктор вызывается не для объекта класса, как другие функции-члены, а для области памяти. Для её преобразования ("превращения") в объект класса.
<p align=justify>На самом деле, здесь конструктор вызывается дважды. В первый раз при создании переменной MyVal, второй - в ходе выполнения операции явного преобразования значения, возможно, что пустого. При этом создаётся временный безымянный объект, значения данных-членов которого присваиваются переменной MyVal. Нам ещё предстоит выяснить, как работает операция присвоения на множестве производных типов, в частности, в сочетании с выражением явного преобразования типа, которое приводит к вызову конструктора. И если можно ещё как-то представить пустое значение, которое используется для начальной инициализации данных-членов вновь создаваемого объекта, то присвоение пустого значения леводопустимому выражению в принципе невозможно. Поэтому выражение вызова функции с void спецификатором в операторе присвоения недопустимо:
<pre>
int MyVal = MyProc(); /* Ошибка */
int MyVal = (void)MyProc(); /* Ошибка */
</pre>
<p align=justify>И ещё одно сравнение между конструктором и void-процедурой. Поскольку тип void - это всё же тип, мы можем объявить указатель на void-процедуру.
<pre>
void MyFunction (void);
:::::
void (*MyFunctionPointer) (void);
</pre>
<p align=justify>Указатель на функцию можно настроить на адрес конкретной функции. Для этого существует операция взятия адреса:
<pre>
MyFunctionPointer = MyFunction; /* Можно так. */
MyFunctionPointer = &amp;MyFunction; /* А можно и так. */
</pre>
<p align=justify>С конструктором всё по-другому. Мы можем определить адрес создаваемого конструктором объекта. Всё то же выражение явного преобразования типа обеспечивает обращение к конструктору, который создаёт в памяти безымянный объект, чей адрес и определяется операцией взятия адреса:
<pre>if (&amp;ComplexType()) {/*…*/}</pre>
<p align=justify>Но вот объявить указатель на конструктор и определить адрес конструктора невозможно. Объявление указателя на функцию требует стандартной спецификации типа функции. Операция взятия адреса возвращает значение определённого типа. Конструктор же не обладает стандартной спецификацией, а потому невозможно определить для него указатель и определить соответствующее значение.
<center>
<p><font size="-1"><a href="CPP_068.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_070.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
