<html><head>
<title> ласс. ќбъ€вление класса</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">—ервер поддерживаетс€<br><a class="plain" href="http://www.citmgu.ru">÷ентром »нформационных “ехнологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">—ервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4> ласс. ќбъ€вление класса</h4>
<p align=justify> ласс - это тип. Ётот производный тип вводитс€ в программу с помощью специального оператора объ€влени€ класса. ¬ объ€влении класса используетс€ ранее описанный инструментальный набор средств дл€ построени€ и преобразовани€ производных типов.
<p align=justify>ќчередное множество форм Ѕэкуса-Ќаура определ€ет синтаксис объ€влени€ класса.
<pre>
<u>ќбъ€вление</u> ::= [<u>—писок—пецификаторовќбъ€влени€</u>] [<u>—писокќписателей</u>];
<u>—писок—пецификаторовќбъ€влени€</u>
          ::= [<u>—писок—пецификаторовќбъ€влени€</u>] <u>—пецификаторќбъ€влени€</u>
<u>—пецификаторќбъ€влени€</u> ::= <u>—пецификатор“ипа</u>
                       ::= *****
<u>—пецификатор“ипа</u> ::= <u>—пецификатор ласса</u>
                 ::= <u>”точнЄнный—пецификатор“ипа</u>
                 ::= *****
<u>”точнЄнный—пецификатор“ипа</u> ::= <u> лючевое—лово ласса »м€ ласса</u>
                           ::= <u> лючевое—лово ласса</u> »дентификатор
                           ::= enum <u>»м€ѕеречислени€</u>
<u> лючевое—лово ласса</u> ::= union
                    ::= struct
                    ::= class
<u>»м€ ласса</u> ::= »дентификатор
<u>—пецификатор ласса</u> ::= <u>«аголовок ласса</u> {[<u>—писок„ленов</u>]}
<u>«аголовок ласса</u>
           ::= <u> лючевое—лово ласса</u> [»дентификатор] [<u>—пецификаци€Ѕазы</u>]
           ::= <u> лючевое—лово ласса »м€ ласса</u> [<u>—пецификаци€Ѕазы</u>]
<u> лючевое—лово ласса</u> ::= union
                    ::= struct
                    ::= class
<u>»м€ ласса</u> ::= »дентификатор
</pre>
<p align=justify>—пецификатор класса представл€ет то, что называетс€ объ€влением класса. ”точнЄнный спецификатор типа объ€вл€ет расположенный за ним идентификатор именем класса. ”точнЄнный спецификатор обеспечивает неполное предварительное объ€вление класса и перечислени€.
<p align=justify>Ќазначение и смысл необ€зательного нетерминального символа <u>—пецификаци€Ѕазы</u> будут обсуждатьс€ позже, в разделах, посв€щЄнных наследованию.
<p align=justify>ѕредварительное объ€вление обеспечиваетс€ уточнЄнным спецификатором типа и €вл€етс€ своеобразным прототипом класса или перечислени€. ≈го назначение - сообщение трансл€тору предварительной информации о том, что существует (должно существовать) объ€вление класса (или перечислени€) с таким именем. »дентификатор, используемый в контексте уточнЄнного спецификатора имени становитс€ именем класса (или именем перечислени€).
<p align=justify> ласс считаетс€ объ€вленным даже тогда, когда в нЄм полностью отсутствует информаци€ о членах класса (пустой список членов класса). Ќеименованный класс с пустым множеством членов - уже класс!
<p align=justify>»м€ класса можно употребл€ть как им€ (им€ типа) уже в списке членов этого самого класса.
<p align=justify> ласс может быть безым€нным.
<p align=justify>—ледующа€ последовательность операторов объ€влени€
<pre>
class {}; /* ќбъ€влен пустой неименованный класс.*/
class {};
class {};
class {};
/* Ёто всЄ объ€влени€. »х количество ничем не ограничиваетс€. */
struct {};
/* —труктура - это класс, объ€вленный с ключевым словом struct.
ќп€ть же пустой и неименованный.*/
</pre>
<p align=justify>не вызывает у трансл€тора никаких возражений.
<p align=justify>Ќа основе класса, пусть даже неименованного, может быть объ€влен (вернее, определЄн) объект-представитель этого класса. ¬ таком контексте объ€вление неименованного (пусть даже и пустого!) класса €вл€етс€ спецификатором объ€влени€. »мена определ€емых объектов (возможно с инициализаторами) составл€ют список описателей.
<pre>
class {} Obj1, Obj2, Obj3;/* «десь объ€вление пустого класса.*/
class {} Obj4, Obj5, Obj6;/* ѕросто нечего инициализировать.*/
class {} Obj1;
       /* ^ ќшибка. ќдноименные объекты в области действи€ имени.*/
</pre>
<p align=justify>Ќеименованные классы также можно примен€ть в сочетании со спецификатором typedef (здесь может быть объ€вление класса любой сложности - не об€зательно только пустой). —пецификатор typedef вводит новое им€ дл€ обозначени€ безым€нного класса. ќписанное им€ типа становитс€ его единственным именем.
<p align=justify>—очетание спецификатора typedef с объ€влением безым€нного класса подобно объ€влению класса с именем:
<pre>
class MyClass {/*Е*/};
typedef class {/*Е*/} MyClass;
</pre>
<p align=justify>ѕравда в первом случае класс имеет собственное им€ класса, а во втором - описанное им€ типа. »спользование описанного имени типа в пределах области действи€ имени делает эквивалентными следующие определени€ (и им подобные):
<pre>
class {} Obj1;
MyClass  Obj1;
</pre>
<p align=justify> ласс считаетс€ объ€вленным лишь после того, как в его объ€влении будет закрыта последн€€ фигурна€ скобка. ƒо этого торжественного момента информаци€ о структуре класса остаЄтс€ неполной.
<p align=justify>≈сли можно ќЅЏя¬»“№ пустой класс, то можно ќѕ–≈ƒ≈Ћ»“№ и объект-представитель пустого класса. Ёти объекты размещаютс€ в пам€ти. »х размещение предполагает выделение объекту участка пам€ти с уникальным адресом, а это означает, что объекты пустого класса имеют ненулевой размер.
<p align=justify>ƒействительно, значени€ выражений sizeof(MyClass) и sizeof(MyObj1) (это можно очень просто проверить) отличны от нул€.
<p align=justify>ј вот пустое объединение (ещЄ одна разновидность класса - класс, объ€вленный с ключевым словом union) не объ€вл€етс€:
<pre>union {}; /* Ќекорректное объ€вление объединени€. */</pre>
<p align=justify>ѕри объ€влении объединени€ требуетс€ детальна€ информаци€ о внутреннем устройстве этого объединени€.
<p align=justify>ћы продолжаем формальное определение класса. “еперь рассмотрим синтаксис объ€влени€ членов класса.
<pre>
<u>—писок„ленов</u> ::= <u>ќбъ€вление„лена ласса</u> [<u>—писок„ленов</u>]
             ::= <u>—пецификаторƒоступа</u> : [<u>—писок„ленов</u>]
<u>ќбъ€вление„лена ласса</u> ::= [<u>—писок—пецификаторовќбъ€влени€</u>]
                                      [<u>—писокќписателей„ленов ласса</u>];
                      ::= <u>ќбъ€вление‘ункции</u>
                      ::= <u>ќпределение‘ункции</u> [;]
                      ::= <u> валифицированное»м€</u>;
<u>—писокќписателей„ленов ласса</u> ::= <u>ќписатель„лена ласса</u>
                             ::= <u>—писокќписателей„ленов ласса</u>,
                                                 <u>ќписатель„лена ласса</u>
<u>ќписатель„лена ласса</u> ::= <u>ќписатель</u> [<u>„истый—пецификатор</u>]
                     ::= [<u>»дентификатор</u>] : <u> онстантное¬ыражение</u>
<u>„истый—пецификатор</u> ::= = 0
<u> валифицированное»м€ ласса</u> ::= <u>»м€ ласса</u>
                          ::= <u>»м€ ласса</u> :: <u> валифицированное»м€ ласса</u>
<u>—пецификаторƒоступа</u> ::= private
                    ::= protected
                    ::= public
</pre>
<p align=justify>—писок членов определ€ет полный набор членов данного класса. ¬ этом списке объ€вл€ютс€ все члены класса. “аковыми могут быть данные, функции-члены, ранее объ€вленные классы, перечислени€, битовые пол€, дружественные функции и даже имена типов. Ќекоторые из перечисленных пон€тий нам уже знакомы, о других речь ещЄ впереди. Ётот список не подлежит модификации. ќн формируетс€ за один раз.
<p align=justify>¬ соответствии с синтаксическими правилами, членами класса могут быть как определени€ функций, так и их прототипы. ƒействительно:
<pre>
<u>ќбъ€вление„лена ласса</u> ::= 
[<u>—писок—пецификаторовќбъ€влени€</u>] [<u>—писокќписателей„ленов ласса</u>]; ::=
<u>—пецификаторќбъ€влени€ ќписатель„лена ласса</u>; ::=
<u>—пецификатор“ипа ќписатель</u>; ::=
void <u>ќписатель</u> (<u>—писокќбъ€вленийѕараметров</u>); ::=
void ff (void);
</pre>
<p align=justify>— другой стороны, 
<pre>
<u>ќбъ€вление„лена ласса</u> ::= 
<u>ќпределение‘ункции</u> [;] ::=
<u>ќписатель</u> (<u>—писокќбъ€вленийѕараметров</u>) <u>“ело‘ункции</u> ::=
ff (void) {int iVal = 100;}
</pre>
<p align=justify>¬ соответствии с синтаксическими правилами, членами класса могут быть как определени€ функций, так и их прототипы. ƒействительно:
<pre>
<u>ќбъ€вление„лена ласса</u> ::= 
[<u>—писок—пецификаторовќбъ€влени€</u>] [<u>—писокќписателей„ленов ласса</u>]; ::=
<u>—пецификаторќбъ€влени€ ќписатель„лена ласса</u>; ::=
<u>—пецификатор“ипа ќписатель</u>; ::=
void <u>ќписатель</u> (<u>—писокќбъ€вленийѕараметров</u>); ::=
void ff (void);
</pre>
<p align=justify>— другой стороны, 
<pre>
<u>ќбъ€вление„лена ласса</u> ::= 
<u>ќпределение‘ункции</u> [;] ::=
<u>ќписатель</u> (<u>—писокќбъ€вленийѕараметров</u>) <u>“ело‘ункции</u> ::=
ff (void) {int iVal = 100;}
</pre>
<p align=justify>“очка с зап€той после определени€ функции €вл€етс€ декоративным элементом. Ќи один член класса не может входить в список членов класса дважды. ѕоэтому определ€ема€ в теле класса функци€ оказываетс€ без прототипа. ≈сли класс содержит прототип функции в качестве члена класса, функци€ располагаетс€ за пределами класса.  ак мы скоро увидим, всЄ разнообразие объ€влений и определений функций-членов трансл€тор приводит к единому стандартному виду.
<p align=justify>‘ункции-члены могут определ€тьс€ вне списка членов класса. ѕри определении функции-члена класса за пределами данного класса, в списке членов класса размещаетс€ прототип функции-члена. ј при определении функции-члена используетс€ квалифицированное им€.  валифицированное им€ состоит из последовательности имЄн классов, разделЄнных операци€ми разрешени€ области видимости. Ёта последовательность имЄн завершаетс€ именем определ€емой функции. ѕоследовательность имЄн классов в квалифицированных именах определ€етс€ степенью вложенности объ€влений классов.
<p align=justify>Ќаличие функций-членов делает объ€вление класса подобным определению (как и любые функции, функции-члены определ€ютс€).  ак сказано в —правочном руководстве по C++, "≈сли бы не исторические причины, объ€вление класса следовало называть определением класса".
<p align=justify>ƒанные-члены класса не могут объ€вл€тьс€ со спецификаторами auto, extern, register.
<p align=justify>Ќи при каких обсто€тельствах не допускаетс€ объ€вление одноименных членов. »мена данных-членов должны также отличатьс€ от имЄн функций-членов. »спользование одноимЄнных функций, констант и переменных в выражени€х в пределах одной области действи€ имЄн приводит к неоднозначности.  ак известно, им€ функции, как и им€ константы и переменной, €вл€етс€ выражени€ми. ≈сли допустить объ€вление одноимЄнных переменных, констант и функций, то в р€де случаев просто невозмо будет определить, о чЄм в программе идЄт речь.
<p align=justify>ќбъ€вл€емые в классе данные-члены, которые €вл€ютс€ представител€ми классов, должны представл€ть ранее объ€вленные классы. “рансл€тор должен знать заранее о структуре подобных данных-членов.
<p align=justify>ќписатель члена класса в объ€влении класса не может содержать инициализаторов (это всего лишь объ€вление).
<p align=justify>—труктура €вл€етс€ классом, объ€вленным с ключевым словом класса struct. „лены такого класса и базовые классы по умолчанию обладают спецификацией доступа public.
<p align=justify>Ќазначение спецификаторов доступа будет обсуждатьс€ в разделах, посв€щЄнных управлению доступом. ѕока будет достаточно в объ€влении класса указать спецификатор public. ¬ этом случае члены класса оказываютс€ доступны (к ним можно будет свободно обращатьс€) из любого оператора программы.
<p align=justify>ќбъединение €вл€етс€ классом, объ€вленным с ключевым словом класса union. ≈го члены также по умолчанию обладают спецификацией доступа public. ¬ каждый момент исполнени€ программы объединение включает единственный член класса. ¬ этом его специфика. »менно поэтому не может быть пустого объединени€. ѕозже мы вернЄмс€ к объединени€м.
<p align=justify>≈сли функци€-член определ€етс€ вне тела класса, в список членов класса включаетс€ прототип функции. ќпределение функции сопровождаетс€ квалифицированным именем, которое указывает трансл€тору на принадлежность определ€емой функции-члена классу. ѕоследн€€ часть квалифицированного имени (собственно им€ функции) должна совпадать с именем прототипа функции-члена, объ€вленного ранее в классе.
<p align=justify>ѕодобно определению данных основных типов, в программе могут быть определены объекты ранее объ€вленного типа. ¬ ходе определени€ объекта-представител€ класса выдел€етс€ пам€ть дл€ размещени€ данных-членов класса. ѕри этом непосредственно в этой области пам€ти размещаютс€ все данные-члены, за исключением данных, объ€вленных со спецификатором static (об этом спецификаторе будет сказано ниже).
<p align=justify>–азбор структуры класса осуществл€етс€ трансл€тором в несколько этапов.
<p align=justify>Ќа первом этапе исследуетс€ список данных-членов класса. »менно этот список и определ€ет общую структуру класса. ƒо окончани€ этой стадии разбора класса, а фактически до завершени€ объ€влени€ класса, его им€ в объ€влении данных-членов может быть использовано лишь в таком контексте, где не используетс€ информаци€ о размерах класса. Ёто объ€влени€ указателей, ссылок и статических членов класса (о них после).
<p align=justify>“аким образом, объект-представитель класса не может быть членом собственного класса, поскольку объект-представитель класса может быть объ€влен как член класса лишь после того, как завершено объ€вление этого класса.
<p align=justify>‘ункци€-член класса существует в единственном экземпл€ре дл€ всех объектов-представителей данного класса. ѕереобъ€вление и уточнение структуры класса в —++ недопустимо.
<p align=justify>—ери€ простых примеров демонстрирует, что можно, а что нельз€ делать при объ€влении данных-членов класса.
<pre>
class C1
{
 C1 MyC;
// Ёто ошибка. ¬ классе не допускаетс€ объ€влени€ данных-членов
// объ€вл€емого класса.
 C1* pMyC;
// ј указатель на класс объ€вить можно.
};
</pre>
<p align=justify>ƒл€ объ€влени€ таких указателей или ссылок на объекты объ€вл€емого класса достаточно неполного предварительного объ€влени€ класса. ”казатели и ссылки имеют фиксированные размеры, которые не завис€т от типа представл€емого объекта.
<pre>
class C2;
class C1
{
 C1* pMyC1;
 C2* pMyC2;
};
C2* PointOnElemOfClassC2;
</pre>
<p align=justify>Ќазначение неполного объ€влени€ подобно прототипу функции и используетс€ исключительно в цел€х предварительного информировани€ трансл€тора. ќчевидно, что создание объектов на основе предварительного неполного объ€влени€ невозможно. ќднако это не снижает ценности уточнЄнного спецификатора.
<p align=justify>Ќа втором проходе трансл€ции объ€влени€ класса осуществл€етс€ проверка списков параметров в объ€влени€х функций-членов класса, и определ€етс€ размер класса.   этому моменту трансл€тору становитс€ известна обща€ структура класса. » потому, как ни странно это выгл€дит, в классе может быть объ€влена функци€-член класса, котора€ возвращает значение объ€вл€емого класса и содержит в списке параметров параметры этого же класса:
<pre>
class C2;
class C1
{
 C1 F1(C1 par1) {return par1;};
//ќбъ€вить данные-члены класса C1 нельз€, а функцию - можно!
 C1* pMyC1;
 C2* pMyC2;
// C1 MyC;
};
C2* PointOnElemOfClassC2;
</pre>
<p align=justify>√де бы ни располагалась объ€вл€ема€ в классе функци€-член, трансл€тор приступает к еЄ разбору лишь после того, как он определ€ет общую структуру класса.
<p align=justify>¬ соответствии с формальным определением создадим наш первый класс:
<pre>
<u>—пецификатор ласса</u> ::= <u>«аголовок ласса</u> { [<u>—писок„ленов</u>] };        ::=
<u> лючевое—лово ласса</u> »дентификатор { <u>ќбъ€вление„лена ласса</u>
                                         <u>ќбъ€вление„лена ласса</u> }; ::=
class FirstClass { <u>—пецификаторќбъ€влени€ ќписатель„лена ласса</u>;
                                              <u>ќписание‘ункции</u>; }; ::=
class FirstClass { <u>—пецификаторќбъ€влени€ ќписатель„лена ласса</u>;
                                  int FirstClassFunction(void);}; ::=
class FirstClass {
                  long int* PointerToLongIntVal;
                  int FirstClassFunction(void);
                 };
</pre>
<p align=justify>«а исключением квалифицируемого имени синтаксис определени€ функции-члена класса вне класса ничем не отличаетс€ от определени€ обычной функции:
<pre>
int FirstClass::FirstClassFunction(void) 
           {
           int IntVal = 100;
           return IntVal;
           };
</pre>
<p align=justify>¬от таким получилось построенное в соответствии с грамматикой C++ определение (или объ€вление) класса.
<p align=justify>«аметим, что в C++ существует единственное ограничение, св€занное с расположением определени€ функции-члена класса (конечно, если оно располагаетс€ вне тела класса): определение должно располагатьс€ за объ€влением класса, содержащего эту функцию. »менно "за объ€влением"! Ѕез каких-либо дополнительных ограничений типа "непосредственно за" или "сразу за".
<p align=justify>Ѕолее того, в р€де случаев, например, когда требуетс€ определить функцию-член, измен€ющую состо€ние объекта другого класса, данна€ функци€-член должна располагатьс€ за объ€влением класса, состо€ние объекта которого она измен€ет. » это пон€тно. ѕри разборе такой функции-члена трансл€тор должен иметь представление о структуре класса.
<p align=justify>ƒопускаетс€ и така€ схема расположени€ объ€влений, при которой первыми располагаютс€ неполные объ€влени€ классов, следом соответствующие объ€влени€ классов и лишь затем определени€ функций-членов. ѕодобные определени€ мы будем называть отложенными определени€ми. ѕозже мы рассмотрим пример программы, в которой отложенный вариант определени€ функции-члена €вл€етс€ единственно возможным вариантом определени€.
<p align=justify> ласс - это то, что делает C++ объектно-ориентированным €зыком. Ќа основе классов создаютс€ новые производные типы и определ€ютс€ функции, которые задают поведение типа.
<p align=justify>–ассмотрим несколько строк программного кода, демонстрирующих свойства производных типов.
<pre>
class Class1 {int iVal;};
class Class2 {int iVal;};
/*
ќбъ€вление производных типов Class1 и Class2. Ёти объ€влени€
ввод€т в программу два новых производных типа. Ќесмотр€ на
тождество их структуры, это разные типы.
*/
void ff(Class1); 
/* ѕрототип функции с одним параметром типа Class1.*/
void ff(Class2);
/*
ѕрототип функции с одним параметром типа Class2. Ёто совместно
используемые (или перегруженные) функции. ќб этих функци€х мы
уже говорили.
*/
Class1 m1; /* ќбъ€вление объекта m1 типа Class1. */
Class2 m2; /* ќбъ€вление объекта m2 типа Class2. */
int m3;
m1 = m2;
m1 = m3;
m3 = m2;
/*
ѕоследние три строчки в данном контексте недопустимы.
Ќе€вное преобразование с участием производных типов в C++
невозможно. “рансл€тор не имеет никакого пон€ти€ о том, каким
образом проводить соответствующее преобразование. ѕри объ€влении
классов необходимо специально определ€ть эти алгоритмы.
*/
void ff (Class1 pp)
// ќпределение первой совместно используемой функции...
{
:::::
}
void ff (Class2 pp)
// ќпределение второй совместно используемой функции...
{
:::::
}
ff(m1);//¬ызов одной из двух совместно используемых функций...
ff(m2);//¬ызов второй функции...
</pre>
<p align=justify>≈щЄ один пример объ€влени€ класса.
<pre>
class ClassX
{
 ClassX Mm; //«десь ошибка. ќбъ€вление класса ещЄ не завершено.
 ClassX* pMm; //ќбъект типа "”казатель на объект". ¬сЄ хорошо.
 ClassX FF(char char,int i = sizeof(ClassX));
/*
ѕрототип функции. ¬торому параметру присваиваетс€ значение по
умолчанию. » напрасно! «десь ошибка. ¬ этот момент ещЄ неизвестен
размер класса ClassX.
*/
// ј вот вполне корректное определение встроенной функции.
int RR (int iVal)
{
int i = sizeof(ClassX);
          return i;
}
/*
ѕолный разбор операторов в теле функции производитс€ лишь после
полного разбора объ€влени€ класса.   этому моменту размер класса
уже будет определЄн.
*/
}
</pre>
<center>
<p><font size="-1"><a href="CPP_064.HTM">Ќазад</a> |
 <a href=INDEX.HTM>—одержание</a> |
 <a href="CPP_066.HTM">¬перед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>