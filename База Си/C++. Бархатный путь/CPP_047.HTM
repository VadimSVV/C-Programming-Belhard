<html><head>
<title>Операторы цикла</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Операторы цикла</h4>
<p align=justify>Операторы цикла задают многократное исполнение.
<pre>
<u>ОператорЦикла</u> ::= while (<u>Выражение</u>) <u>Оператор</u>
              ::=
    for (<u>ОператорИнициализацииFor</u> [<u>Выражение</u>] ; [<u>Выражение</u>] )<u>Оператор</u>
              ::= do <u>Оператор</u> while (<u>Выражение</u>);
<u>ОператорИнициализацииFor</u> ::= <u>ОператорВыражение</u>
                         ::= <u>Объявление</u>
</pre>
<p align=justify>Прежде всего, отметим эквивалентные формы операторов цикла.
<p align=justify>Оператор
<pre>for (<u>ОператорИнициализацииFor</u> [<u>ВыражениеA</u>] ;[<u>ВыражениеB</u>]) <u>Оператор</u></pre>
<p align=justify>эквивалентен оператору
<pre>
<u>ОператорИнициализацииFor</u> while (<u>ВыражениеA</u>)
{
 <u>Оператор</u>
 <u>ВыражениеB</u> ;
}
</pre>
<p align=justify>Эти операторы называются операторами с предусловием.
<p align=justify>Здесь следует обратить внимание на точку с запятой после выражения в теле оператора цикла while. Здесь выражение становится оператором.
<p align=justify>А вот условие продолжения цикла в операторе цикла while опускать нельзя. В крайнем случае, это условие может быть представлено целочисленным ненулевым литералом.
<p align=justify>Следует также обратить внимание на точку с запятой между двумя выражениями цикла for. В последнем примере они представлены символами <u>ВыражениеA</u> и <u>ВыражениеB</u>. Перед нами классический пример разделителя.
<p align=justify><u>ОператорИнициализацииFor</u> является обязательным элементом заголовка цикла. Обязательный оператор вполне может быть пустым.
<p align=justify>Рассмотрим пример оператора цикла for:
<pre>for ( ; ; ) ;</pre>
<p align=justify>Его заголовок состоит из пустого оператора (ему соответствует первая точка с запятой) и разделителя, который разделяет два пустых выражения. Тело цикла - пустой оператор.
<p align=justify>Пустое выражение, определяющее условие выполнения цикла for интерпретируется как всегда истинное условие. Отсутствие условия выполнения предполагает безусловное выполнение.
<p align=justify>Синтаксис C++ накладывает на структуру нетерминального символа <u>ОператорИнициализацииFor</u> жёсткие ограничения:
	<ul>
	<li>это всегда единственный оператор,
	<li>он не может быть блоком операторов,
	<li>единственным средством усложнения его структуры служит операция запятая.
	</ul>
<p align=justify>Эта операция управляет последовательностью выполнения образующих оператор выражений.
<p align=justify>Рассмотрим принципы работы этого оператора. Цикл состоит из четырёх этапов.
	<ul>
	<li>Прежде всего, выполняется оператор инициализации цикла. Если он не пустой, выражение за выражением, слева направо. Этот этап можно назвать этапом инициализации цикла. Он выполняется один раз, в самом начале работы цикла.
	<li>Затем вычисляется значение выражения, которое располагается слева от оператора инициализации. Это выражение называется выражением условия продолжения цикла. Сам этап можно назвать этапом определения условий выполнимости.
	<li>Если значение этого выражения отлично от нуля (т.е. истинно), выполняется оператор цикла. Этот этап можно назвать этапом выполнения тела цикла.
	<li>После этого вычисляются значения выражений, которые располагаются слева от выражения условия продолжения цикла. Этот этап можно назвать этапом вычисления шага цикла.
	<li>На последних двух этапах могут измениться значения ранее определённых переменных. А потому следующий цикл повторяется с этапа определения условий выполнимости.
	</ul>
<p align=justify>Оператор инициализации цикла - это всего лишь название оператора, который располагается в заголовке цикла. Этот оператор может инициализировать переменные, если того требует алгоритм, в этот оператор могут входить любые выражения, в конце концов, он может быть пустым. Транслятору важен синтаксис оператора, а не то, как будет выполняться данный оператор цикла.
<pre>
int qwe;
for (qwe &lt; 10; ; ) {}
// Оператор инициализатор построен на основе выражения сравнения.
for (this; ; ) {}
// Оператор инициализатор образован первичным выражением this. 
for (qwe; ; ) {}
// Оператор инициализатор образован первичным выражением qwe.
Ещё пример:
int i = 0;
int j;
int val1 = 0;
int val2;
:::::
i = 25;
j = i*2;
:::::
for ( ; i &lt; 100; i++, j--)
{
 val1 = i;
 val2 - j;
}
</pre>
<p align=justify>Мы имеем оператор цикла for, оператор инициализации которого пуст, а условие выполнения цикла основывается на значении переменной, которая была ранее объявлена и проинициализирована. Заголовок цикла является центром управления цикла. Управление циклом основывается на внешней по отношению к телу цикла информации.
<p>Ещё пример:
<pre>
for ( int i = 25, int j = i*2; i &lt; 100; i++, j--)
{
 val1 = i;
 val2 - j;
}
</pre>
<p align=justify>Заголовок нового оператора содержит пару выражений, связанных операцией запятая. Тело оператора представляет всё тот же блок операторов. Что может содержать тело оператора? Любые операторы. Всё, что может называться операторами. От самого простого пустого оператора, до блоков операторов произвольной сложности! Этот блок живёт по своим законам. В нём можно объявлять переменные и константы, а поскольку в нём определена собственная область действия имён, то объявленные в блоке переменные и константы могут скрывать одноимённые объекты с более широкой областью действия имён.
<p align=justify>А вот использование блока в операторе инициализации привело бы к дополнительным трудноразрешимым проблемам с новыми областями действия и видимости имён, вводимых в операторе инициализации. Часть переменных могла бы оказаться невидимой в теле оператора цикла.
<p align=justify>Операция запятая позволяет в единственном операторе сделать всё то, для чего обычно используется блок операторов. В качестве составных элементов (в буквальном смысле выражений-операторов) этого оператора могут использоваться даже объявления. Таким образом, в заголовке оператора цикла for можно объявлять и определять переменные.
<p align=justify>Рассмотрим несколько примеров. Так, в ходе выполнения оператора цикла
<pre>
int i;
for (i = 0; i &lt; 10; i++)
{
 int j = 0; j += i;
}
</pre>
<p align=justify>десять раз будет выполняться оператор определения переменной j. Каждый раз это будут новые объекты. Каждый раз новой переменной заново будет присваиваться новое значение одной и той же переменной i, объявленной непосредственно перед оператором цикла for.
<p align=justify>Объявление переменной i можно расположить непосредственно в теле оператора-инициализатора цикла:
<pre>
for (int i = 0; i &lt; 10; i++)
{
 int j = 0; j += i;
}
</pre>
<p align=justify>И здесь возникает одна проблема. Дело в том, что тело оператора цикла for (оператор или блок операторов) имеет ограниченную область действия имён. А область действия имени, объявленного в операторе-инициализаторе, оказывается шире этой области.
<p align=justify>Заголовок цикла for в C++ - центр управления циклом. Здесь следят за внешним миром, за тем, что происходит вне цикла. И потому все обращения к переменным и даже их новые объявления в заголовке цикла относятся к "внешней" области видимости. Следствием такого допущения (его преимущества далеко не очевидны) является правило соотнесения имени, объявленного в заголовке и области его действия.
<p align=justify>По отношению к объявлению переменной в заголовке оператора цикла for, правило соотнесения гласит, что область действия имени, объявленного в операторе инициализации цикла for, располагается в блоке, содержащем данный оператор цикла for. 
<p align=justify>А вот область действия имени переменной j при этом остаётся прежней.
<p align=justify>В теле оператора for может быть определена одноимённая переменная:
<pre>
for (int i = 0; i &lt; 10; i++)
{
 int i = 0; i += i;
}
</pre>
<p align=justify>Пространство имени переменной в операторе цикла ограничено блоком из двух операторов. В этом пространстве переменная, объявленная в заголовке, оказывается скрытой одноимённой переменной.
<p align=justify>Десять раз переменная i из оператора-инициализатора цикла будет заслоняться одноимённой переменной из оператора тела цикла. И всякий раз к нулю будет прибавляться нуль.
<p align=justify>Ещё один пример. Два расположенных друг за другом оператора цикла for содержат ошибку
<pre>
for (int i = 0, int j = 0; i &lt; 100; i++, j--)
{
// Операторы первого цикла.
}
for (int i = 0, int k = 250; i &lt; 100; i++, k--)
{
// Операторы второго цикла.
}
</pre>
<p align=justify>Всё дело в том, что, согласно правилу соотнесения имён и областей действия имён в операторе цикла for, объявления переменных в заголовке цикла оказываются в общем пространстве имён. А почему, собственно, не приписать переменные, объявленные в заголовке цикла блоку, составляющему тело цикла? У каждого из альтернативных вариантов соотнесения имеются свои достоинства и недостатки. Однако выбор сделан, что неизбежно ведёт к конфликту имён и воспринимается как попытка переобъявления ранее объявленной переменной.
<p align=justify>Эту самую пару операторов for можно переписать, например, следующим образом: 
<pre>
for (int i = 0, int j = 0; i &lt; 100; i++, j--)
{
// Здесь располагаются операторы первого цикла.
}
for (i = 0, int k = 250; i &lt; 100; i++, k--)
{
// Здесь располагаются операторы второго цикла.
}
</pre>
<p align=justify>Здесь нет ошибок, но при чтении программы может потребоваться дополнительное время для того, чтобы понять, откуда берётся имя для выражения присвоения i = 0 во втором операторе цикла. Кроме того, если предположить, что операторы цикла в данном контексте реализуют независимые шаги какого-либо алгоритма, то почему попытка перемены мест пары абсолютно независимых операторов сопровождается сообщением об ошибке:
<pre>
for (i = 0, int k = 250; i &lt; 100; i++, k--)
{
// Здесь располагаются операторы второго цикла.
}
for (int i = 0, int j = 0; i &lt; 100; i++, j--)
{
// Здесь располагаются операторы первого цикла.
}
</pre>
<p align=justify>Очевидно, что в первом операторе оказывается необъявленной переменная i. Возможно, что не очень удобно, однако, в противном случае, в центре управления циклом трудно буден следить за внешними событиями. В конце концов, никто не заставляет программиста располагать в операторе инициализации объявления переменных. Исходная пара операторов может быть с успехом переписана следующим образом:
<pre>
int i, j, k;
:::::
for (i = 0, k = 250; i &lt; 100; i++, k--)
{
// Здесь располагаются операторы второго цикла.
}
for (i = 0, j = 0; i &lt; 100; i++, j--)
{
// Здесь располагаются операторы первого цикла.
}
</pre>
<p align=justify>А вот ещё один довольно странный оператор цикла, в котором, тем не менее, абсолютно корректно соблюдены принципы областей действия имён, областей видимости имён, а также соглашения о соотнесении имён и областей их действия:
<pre>for (int x; x &lt; 10; x++) {int x = 0; x++;}</pre>
<p align=justify>Так что не забываем о том, что область действия имён в заголовке цикла шире от области действия имён в теле цикла. И вообще, если можно, избавляемся от объявлений в заголовке оператора цикла.
<p align=justify>Оператор цикла do … while называется оператором цикла с постусловием. От циклов с предусловием он отличается тем, что сначала выполняется оператор (возможно, составной), а затем проверяется условие выполнения цикла, представленное выражением, которое располагается в скобках после ключевого слова while. В зависимости от значения этого выражения возобновляется выполнение оператора. Таким образом, всегда, по крайней мере один раз, гарантируется выполнение оператора цикла.
<pre>int XXX = 0;
do {cout &lt;&lt; XXX &lt;&lt; endl; XXX++;} while (XXX &lt; 0);
</pre>
<center>
<p><font size="-1"><a href="CPP_046.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_048.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
