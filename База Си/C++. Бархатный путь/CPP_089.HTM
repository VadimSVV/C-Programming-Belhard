<html><head>
<title>Ошибки и исключительные ситуации</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Ошибки и исключительные ситуации</h4>
<p align=justify>Мы завершаем путь. Всё это время мы стремились не допускать ошибок в выражениях, операторах, объявлениях, определениях, макроопределениях, программах. Но до сих пор у нас нет чёткого представления о том, что такое ошибка.
<p align=justify>В общем случае под ошибкой мы будем понимать несоответствие правилу, алгоритму. Это рабочее определение. Конечно, правила бывают нечёткими, алгоритмы - некорректными. Это неважно. В любом случае можно сказать, что "всё не так, как должно быть". И этого достаточно.
<p align=justify>Разные ошибки проявляют себя по-разному и могут быть обнаружены в разное время, на разных стадиях жизненного цикла программы и при различных обстоятельствах.
<p align=justify>Выявлением некорректных макроопределений, несуществующих заголовочных файлов и неверных условий компиляции занимается препроцессор. Ошибки препроцессора выявляются на ранних этапах трансляции. Сами по себе они не проявляются.
<p align=justify>Транслятору C++ хорошо известен синтаксис языка. Поэтому нарушение правил порождения слов, выражений и предложений, в том числе и неуместное использование ключевых слов, достаточно легко обнаруживается на стадии трансляции.
<p align=justify>Транслятор распознаёт константные выражения различной сложности. Он способен самостоятельно производить арифметические вычисления. Так что с вопросами определения статических массивов также не возникает никаких проблем.
<p align=justify>На этапе трансляции распознаются леводопустимые выражения. Поэтому значительная часть ошибок, связанных с некорректным использованием операций присвоения также выявляется на стадии трансляции.
<p align=justify>Многие ошибки несоответствия типов также могут быть выявлены на этапе трансляции, в ходе создания объектного кода. Здесь следует вспомнить об операции явного преобразования типа, которая отключает контроль транслятора за типами.
<p align=justify>На этапе создания исполнительного модуля программа (или система) компоновки способна распознать объявленные и неопределённые переменные и функции, а также незавершённые объявления классов.
<p align=justify>В ряде случаев на этапе создания объектного кода могут выявляться неопределённые и неиспользуемые переменные, и даже потенциально опасные фрагменты кода. Транслятор может предупредить об использовании в выражениях неинициализированных переменных.
<p align=justify>Однако не все расхождения с правилами, идеальным схемами и алгоритмам могут быть обнаружены до того момента, пока программа находится в состоянии разработки.
<p align=justify>Существует категория ошибок, которые не способны выявить даже самые изощрённые препроцессоры, трансляторы и программы сборки. К их числу относятся так называемые ошибки времени выполнения. Эти ошибки проявляются в ходе выполнения программы.
<p align=justify>Мы не раз подчёркивали, что в C++ часто возникают ситуации, при которых ответственность за правильность выполнения операций, операторов и даже отдельных функций целиком возлагается на программиста. Арифметические вычисления (деление на нуль), преобразования типа, работа с индексами и адресами, корректная формулировка условий в операторах управления, работа с потоками ввода-вывода - это далеко не полный перечень неконтролируемых в C++ ситуаций.
<p align=justify>Ошибки времени выполнения, возникающие непосредственно в ходе выполнения программы, в терминах объектно-ориентированного программирования называются исключительными ситуациями. Исключительные ситуации - это события, которые прерывают нормальный ход выполнения программы.
<p align=justify>Различают синхронные и асинхронные исключительные ситуации.
<p align=justify>Синхронная исключительная ситуация возникает непосредственно в ходе выполнения программы, причём её причина заключается непосредственно в действиях, выполняемых самой программой.
<p align=justify>Асинхронные исключительные ситуации непосредственно не связаны с выполнением программы. Их причинами могут служить аппаратно возбуждаемые прерывания (например, сигналы от таймера), сообщения, поступающие от внешних устройств или даже от локальной сети.
<p align=justify>Реакция на исключительную ситуацию называется исключением.
<p align=justify>Заметим, что исключительная ситуация не всегда неожиданна. Очень часто при разработке алгоритма уже закладывается определённая реакция на вероятную ошибку.
<p align=justify>Например, функция, размещающая целочисленные значения в массиве по определённому индексу, может самостоятельно следить за допустимыми значениями индекса. Она возвращает единицу в случае успешного размещения значения и нуль, если значение параметра, определяющего индекс, не позволяет этого сделать.
<pre>
#define MAX 10
int PushIntArray(int* const, int, int);
void main()
{
int intArray[MAX];
int IndexForArray, ValueForArray;
:::::
for (;;)
{
:::::
// Значения IndexForArray и ValueForArray меняются в цикле.
if (!PushIntArray(intArray, IndexForArray, ValueForArray))
 {
 cout &lt;&lt; "Некорректное значение индекса" &lt;&lt; endl;
 IndexForArray = 0;
 }
:::::
}
:::::
}
int PushIntArray(int* const keyArray, int index, int keyVal)
{
 if (index &gt;= 0 &amp;&amp; index &lt; MAX)
 {
  keyArray[index] = keyVal;// Спрятали значение и сообщили об успехе.
  return 1;
 }
 else
 return 0; // Сообщили о неудаче.
}
</pre>
<p align=justify>Перед нами самый простой вариант исключения как формы противодействия синхронной исключительной ситуации. Из функции main вызывается функция, PushIntArray, которой в качестве параметров передаются адрес массива, значение индекса и значение, предназначенное для сохранения в массиве.
<p align=justify>Функция PushIntArray проверяет значение индекса и возвращает соответствующее сообщение. Эта функция выявляет возможные ошибки и уведомляет о них вызывающую функцию. Подобное сообщение о неудаче можно рассматривать как прообраз генерации (или возбуждения) исключения.
<p align=justify>Вызывающая функция может корректировать значение индекса: исправление выявленных ошибок (то есть реакция на исключение) - компетенция вызывающей функции.
<p align=justify>Очевидно, что не всегда исключение может быть возбуждено по такой простой схеме. Например, функция, возвращающая результат деления двух действительных чисел, должна предусматривать вероятность возникновения ситуации, при которой делитель оказывается равным нулю. Ожидаемая исключительная ситуация также может сопровождаться определённой реакцией, нейтрализующей возможные последствия вероятной ошибки.
<pre>
#include &lt;iostream.h&gt;
#define EXDIVERROR 0.0
/*
Здесь может быть определено любое значение. Это не меняет сути дела.
Так кодируется значение, предупреждающее об ошибке. Не самая хорошая
идея: некоторые корректные значения всегда будут восприниматься как
уведомления об ошибке.
*/
float exDiv (float, float);
void main()
{
float val1, val2;
:::::
if (exDiv(val1, val2) == EXDIVERROR)
{
:::::
   cout &lt;&lt; "exDiv error…";
// Здесь можно попытаться исправить ситуацию.
:::::
}
}
float exDiv (float keyVal1, float keyVal2)
{
 if (val2) return keyVal1/keyVal2;
 return    EXDIDERROR;
}
</pre>
<p align=justify>Функция exDiv может быть модифицирована следующим образом: возвращаемое целочисленное значение сообщает о ходе вычисления, а непосредственно сам результат вычисления передаётся по ссылке.
<p align=justify>Подобная схема противодействия исключительным ситуациям уже применялась при работе со стеком.
<pre>
#include &lt;iostream.h&gt;
int exDiv (float, float, float&amp;);
void main()
{
float val1, val2, resDiv;
:::::
if (!exDiv(val1, val2, resDiv))
{
:::::
   cout &lt;&lt; "exDiv error…";
:::::
}
}
int exDiv (float keyVal1, float keyVal2, float&amp; keyRes)
{
 if (val2) {keyRes = keyVal1/keyVal2; return 1;}
 return 0;
}
</pre>
<p align=justify>Ещё один возможный вариант обратной связи между вызываемой и вызывающей функциями заключается в определении специального класса, объединяющего в одном объекте возвращаемое значение и служебную информацию о результате выполнения функции. В таком случае возвращаемое значение превращается в исключение лишь в случае возникновения исключительной ситуации.
<pre>
#include &lt;iostream.h&gt;
class DivAnsver
{
 public:
 int   res;
 float fValue;
// Конструктор.
 DivAnsver(): res(1), fValue(0.0) {};
// ctorИнициализаторы в действии!
};
DivAnsver exDiv (float, float);
void main()
{
DivAnsver Ansver;
Ansver = exDiv(0.025, 0.10);
cout &lt;&lt; Ansver.fValue &lt;&lt; "..." &lt;&lt; Ansver.res &lt;&lt; endl;
Ansver = exDiv(0.025, 0.0);
cout &lt;&lt; Ansver.fValue &lt;&lt; "..." &lt;&lt; Ansver.res &lt;&lt; endl;
}
DivAnsver exDiv (float val1, float val2)
{
 DivAnsver Ans;
 if (val2) Ans.fValue = val1/val2;
 else      Ans.res = 0;
 return    Ans;
}
</pre>
<p align=justify>Функция exDiv возвращает значение объекта Ans (предопределённый конструктор копирования об этом позаботится). При этом, если деление возможно, значение данного-члена res оказывается равным единице, а fValue принимает значение частного от деления. В противном случае res устанавливается в нуль и объект Ans становится исключением.
<p align=justify>Подобным изменениям можно подвергнуть объявление класса, реализующего стек: возвращаемое функцией pop() значение объекта-представителя шаблонного класса мог бы содержать результат выполнения функции и значение содержимого стека.
<p align=justify>И опять в этом случае применима традиционная схема: вызывающая функция обращается к вызываемой функции с предложением выполнить конкретное действие. Последняя принимает решение относительно возможности выполнения этого действия и если возможно, выполняет его. В любом случае вызывающая функция уведомляется о проделанной работе, получая либо результат выполнения, либо исключение.
<p align=justify>На основе получаемой информации, вызывающая функция принимает соответствующее решение, которое может состоять в продолжении выполнения программы, попытке исправления ошибочной ситуации, либо аварийной остановке выполнения программы.
<p align=justify>Казалось бы, всё хорошо и на этом можно было бы остановиться. Однако, нет пределов совершенству!
<p align=justify>Существует целый ряд проблем, связанных с подобным способом организации программного кода. Рассмотрим некоторые из них.
<p align=justify>Структура вызывающей функции определяется множеством значений, которые может возвратить вызываемая функция. Каждое возвращаемое значение, как правило, сопровождается определённой реакцией. Чем больше вариантов возвращаемых значений и исключений, тем менее наглядным, понятным и легкочитаемым оказывается программный код вызывающей функции.
<p align=justify>С ростом числа вариантов возвращаемых значений становится всё более актуальной проблема разделения "положительных" и "отрицательных" ответов.
<p align=justify>И вообще, если вызываемая функция возвращает несколько вариантов исключений, то программный код, необходимый для адекватной реакции на ошибки, может превысить объём кода, реализующего основную логику программы.
<p align=justify>Наконец, конструкторы и деструкторы вообще не возвращают никаких значений. Поэтому они не способны сообщить о своих проблемах общепринятым способом. Для них приходится специально изобретать особые нестандартные средства взаимодействия.
<center>
<p><font size="-1"><a href="CPP_088.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_090.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
