<html><head>
<title>Инициализация объекта: параметры и инициализаторы</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Инициализация объекта: параметры и инициализаторы</h4>
<p align=justify>Совместно используемые функции различаются списками параметров. В этом смысле конструкторы подобны функциям. Рассмотрим определение конструктора с параметрами. Мы расположим его за пределами класса. При этом в классе располагается прототип конструктора, а его имя при определении заменяется квалифицированным именем:
<pre>
class ComplexType {
:::::
public:
ComplexType(double keyReal,
            double keyImag,
            char keyCTcharVal,
            int keyX);
:::::
};
:::::
ComplexType::ComplexType(double keyReal,
            double keyImag,
            char keyCTcharVal,
            int keyX)
 {
  cout &lt;&lt; "This is ComplexType("
       &lt;&lt; keyReal &lt;&lt; ","
       &lt;&lt; keyImag &lt;&lt; ","
       &lt;&lt; (int)keyCTcharVal &lt;&lt; ","
       &lt;&lt; keyX &lt;&lt; ")" &lt;&lt; endl;
  real = keyReal;
  imag = keyImag;
  CTcharVal = keyCTcharVal;
  x = keyX;
 };
</pre>
<p align=justify>А вот и подходящее определение. Мы расположим его в функции main:
<pre>
ComplexType CDw2(100,100,0,0);
/* Создаётся объект типа ComplexType под именем CDw2 с
определёнными значениями. */
int iVal(10);
/* Аналогичным образом может быть определён и проинициализирован
объект основного типа */
</pre>
<p align=justify>Заметим, что к такому же результату (но только окольными путями) приводит и такая форма оператора определения:
<pre>ComplexType CDw2 = ComplexType(100,100,0,0);</pre>
<p align=justify>И снова мы встречаем случай определения объекта посредством постфиксного выражения. Здесь опять можно говорить о явном обращении к конструктору с передачей ему параметров. Выражения явного приведения типа здесь построить невозможно, поскольку за заключённым в скобочки именем типа должно стоять унарное выражение.
<p align=justify>Заметим, что не может быть операторов определения переменных с пустым списком инициализаторов:
<pre>
ComplexType CDw1(); // Это ошибка!
int xVal();         // Это тоже не определение.
</pre>
<p align=justify>Независимо от типа определяемой переменной, подобные операторы воспринимаются транслятором как прототипы функций с пустым списком параметров, возвращающие значения соответствующего типа.
<p align=justify>При объявлении и определении функций C++ позволяет производить инициализацию параметров. Аналогичным образом может быть модифицирован прототип конструктора с параметрами:
<pre>
ComplexType(double keyReal = 0,
            double keyImag = 0,
            char keyCTcharVal = 0,
            int keyX = 0);
</pre>
<p align=justify>Но при этом программист должен быть готовым к самым неожиданным ситуациям. Последняя модификация прототипа вызывает протест со стороны транслятора. Он не может теперь однозначно соотнести оператор определения объекта с одним из вариантов конструктора. Перед нами тривиальный случай проявления проблемы сопоставления. Мы закомментируем определение самого первого конструктора (конструктора без параметров) и опять всё будет хорошо. Теперь вся работа по определению и инициализации объектов обеспечивается единственным конструктором с проинициализированными параметрами.
<p align=justify>Конструктор, управление которому передаётся в результате выполнения оператора определения без параметров, называется конструктором умолчания. К конструкторам умолчания относятся следующие конструкторы:
	<ul>
	<li>конструктор, автоматически создаваемый транслятором,
	<li>определяемый программистом конструктор с пустым списком параметров,
	<li>конструктор с проинициализированными по умолчанию параметрами.
	</ul>
<p align=justify>Внесём ещё одно изменение в текст нашей программы. На этот раз мы добавим спецификатор const в объявление данного-члена класса x:
<pre>
class ComplexType
{
:::::
const int x;
:::::
}
</pre>
<p align=justify>И опять возникают новые проблемы. На этот раз они связаны с попыткой присвоения значения константе. Как известно, объявление данного-члена класса не допускает инициализации, а для того, чтобы константный член класса в процессе создания объекта всё же мог получить требуемое значение, в C++ используется так называемый ctorИнициализатор (именно так называется эта конструкция в справочном руководстве по C++ Б.Строуструппа). Мы не будем гадать, в чём заключается смысл этого названия, а лучше заново воспроизведем несколько форм Бэкуса-Наура.
<pre>
<u>ОпределениеФункции</u> ::= [<u>СписокСпецификаторовОбъявления</u>]
                                                <u>Описатель</u>
                                                 [<u>ctorИнициализатор</u>]
                                                          <u>ТелоФункции</u>
<u>ctorИнициализатор</u> ::= : <u>СписокИнициализаторовЧленовКласса</u>
<u>СписокИнициализаторовЧленовКласса</u> ::= <u>ИнициализаторЧленаКласса</u>
                                [, <u>СписокИнициализаторовЧленовКласса</u>]
<u>ИнициализаторЧленаКласса</u> ::= <u>ПолноеИмяКласса</u>([<u>СписокВыражений</u>])
                         ::= Идентификатор([<u>СписокВыражений</u>])
<u>ПолноеИмяКласса</u> ::= <u>КвалифицированноеИмяКласса</u>
                ::= :: <u>КвалифицированноеИмяКласса</u>
</pre>
<p align=justify>Для исследования свойств ctorИнициализатора, подвергнем нашу программу очередной модификации. Мы закомментируем все ранее построенные объявления и определения конструкторов и те из операторов определения объектов класса ComplexType, которые содержали значения, определяющие начальные значения данных-членов. И сразу же начинаем определение новых вариантов конструкторов.
<pre>
ComplexType():x(1)
 {
  cout &lt;&lt; "Здесь ComplexType():x(" &lt;&lt; x &lt;&lt; ")" &lt;&lt; endl;
 };
</pre>
<p align=justify>Перед нами конструктор с ctorИнициализатором. Эта конструкция позволяет решать проблемы начальной инициализации константных данных-членов. При работе с данными-членами класса транслятор рассматривает операцию присвоения как изменение начального значения члена. Инициализатор же отвечает непосредственно за установку этого САМОГО ПЕРВОГО значения.
<p align=justify>В список инициализаторов разрешено включать все нестатические членам класса (объявленным без спецификатора static), но не более одного раза. Так что следующий вариант конструктора будет восприниматься как ошибочный:
<pre>
ComplexType():x(1), x(2) // Ошибка.
{
:::::
}
</pre>
<p align=justify>Нетерминальный символ <u>ПолноеИмяКласса</u> определяет синтаксис инициализации нестатических объектов так называемого базового класса (об этом позже). В этом случае список выражений как раз обеспечивает инициализацию членов базового класса.
<p align=justify>Добавим в объявление нашего класса объявление массива. Инициализация массива-члена класса при определении объекта не вызывает особых проблем (здесь следует вспомнить раздел, посвящённый массивам-параметрам). Однако в C++ отсутствует возможность инициализации нестатического константного массива-члена класса. Так что можно не стараться выписывать подобные объявления:
<pre>const int xx[2]; // Бессмысленное объявление.</pre>
<p align=justify>всё равно массив xx[2] невозможно проинициализировать. Все варианты инициализации константного нестатического массива будут отвергнуты.
<pre>
ComplexType():xx(1,2) {/*…*/};
ComplexType():xx({1,2}) {/*…*/};
ComplexType():xx[0](1), xx[1](2) {/*…*/};
</pre>
<p align=justify>Согласно БНФ, в состав инициализатора могут входить только имена или квалифицированные имена. Для обозначения элемента массива этого недостаточно. Как минимум, здесь требуется выражение индексации, которое указывало бы номер элемента массива.
<p align=justify>И всё же выход из такой ситуации существует. Можно объявить константный указатель на константу, которому в выражении инициализации можно присвоить имя ранее определённого массива:
<pre>
:::::
const int DefVal[2] = {1,2};
class ComplexType
{
:::::
const int const * px;
/* Объявили константный указатель на константу. */
:::::
ComplexType():px(DefVal) {/*…*/};
:::::
};
</pre>
<p align=justify>Окольными путями мы всё же достигаем желаемого результата. Константный указатель на константу контролирует константный массив.
<p align=justify>Услугами инициализатора могут пользоваться не только константные члены, а инициализирующие значения можно строить на основе самых разных выражений. Главное, чтобы используемые в этих выражениях имена располагались в соответствующих областях видимости:
<pre>
ComplexType():px(DefVal),
              x(px[0]), // Транслятор уже знает, что такое px.
             CTcharVal(32),
             real(100),
             imag(real/25) // И здесь тоже всё в порядке.
{
// Здесь располагается тело конструктора.
:::::
}
</pre>
<center>
<p><font size="-1"><a href="CPP_069.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_071.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
