<html><head>
<title>Виртуальные функции</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Виртуальные функции</h4>
<p align=justify>Очередная модификация базового класса приводит к неожиданным последствиям. Эта модификация состоит в изменении спецификатора функции-члена базового класса. Мы (впервые!) используем спецификатор virtual в объявлении функции. Функции, объявленные со спецификатором virtual, называются виртуальными функциями. Введение виртуальных функций в объявление базового класса (всего лишь один спецификатор) имеет столь значительные последствия для методологии объектно-ориентированного программирования, что мы лишний раз приведём модифицированное объявление класса A:
<pre>
class A
{
 public:
 virtual int Fun1(int);
};
</pre>
<p align=justify>Один дополнительный спецификатор в объявлении функции и больше никаких (пока никаких) изменений в объявлениях производных классов. Как всегда, очень простая функция main(). В ней мы определяем указатель на объект базового класса, настраиваем его на объект производного типа, после чего по указателю мы вызываем функцию Fun1():
<pre>
void main ()
{
 A *pObj;
 A MyA;
 AB MyAB;
 pObj = &amp;MyA;
 pObj-&gt;Fun1(1);
 AC MyAC;
 pObj = &amp;MyAC;
 pObj-&gt;Fun1(1);
}
</pre>
<p align=justify>Если бы не спецификатор virtual, результат выполнения выражения вызова
<pre>pObj-&gt;Fun1(1);</pre>
<p align=justify>был бы очевиден: как известно, выбор функции определяется типом указателя.
<p align=justify>Однако спецификатор virtual меняет всё дело. Теперь выбор функции определяется типом объекта, на который настраивается указатель базового класса. Если в производном классе объявляется нестатическая функция, у которой имя, тип возвращаемого значения и список параметров совпадают с аналогичными характеристиками виртуальной функции базового класса, то в результате выполнения выражения вызова вызывается функция-член производного класса.
<p align=justify>Сразу надо заметить, что возможность вызова функции-члена производного класса по указателю на базовый класс не означает, что появилась возможность наблюдения за объектом "сверху вниз" из указателя на объект базового класса. Невиртуальные функции-члены и данные по-прежнему недоступны. И в этом можно очень легко убедиться. Для этого достаточно попробовать сделать то, что мы уже однажды проделали - вызвать неизвестную в базовом классе функцию-член производного класса:
<pre>
//pObj-&gt;Fun2(2);
//pObj-&gt;AC::Fun1(2);
</pre>
<p align=justify>Результат отрицательный. Указатель, как и раньше, настроен лишь на базовый фрагмент объекта производного класса. И всё же вызов функций производного класса возможен. Когда-то, в разделах, посвящённых описанию конструкторов, нами был рассмотрен перечень регламентных действий, которые выполняются конструктором в ходе преобразования выделенного фрагмента памяти в объект класса. Среди этих мероприятий упоминалась инициализация таблиц виртуальных функций.
<p align=justify>Наличие этих самых таблиц виртуальных функций можно попытаться обнаружить с помощью операции sizeof. Конечно, здесь всё зависит от конкретной реализации, но, по крайней мере, в версии Borland C++ объект-представитель класса, содержащего объявления виртуальных функций, занимает больше памяти, нежели объект аналогичного класса, в котором те же самые функции объявлены без спецификатора virtual.
<pre>cout &lt;&lt; "Размеры объекта: " &lt;&lt; sizeof(MyAC) &lt;&lt; "…" &lt;&lt; endl;</pre>
<p align=justify>Так что объект производного класса приобретает дополнительный элемент - указатель на таблицу виртуальных функций. Схему такого объекта можно представить следующим образом (указатель на таблицу мы обозначим идентификатором vptr, таблицу виртуальных функций - идентификатором vtbl):
<pre>
MyAC::=
vptr
A
AC
vtbl::=
&amp;AC::Fun1
</pre>
<p align=justify>На нашей новой схеме объекта указатель на таблицу (массив из одного элемента) виртуальных функций не случайно отделён от фрагмента объекта, представляющего базовый класс лишь пунктирной линией. Он находится в поле зрения этого фрагмента объекта. Благодаря доступности этого указателя оператор вызова виртуальной функции Fun1
<pre>pObj-&gt;Fun1(1);</pre>
<p align=justify>можно представить следующим образом:
<pre>(*(pObj-&gt;vptr[0])) (pObj,1);</pre>
<p align=justify>Здесь только на первый взгляд всё запутано и непонятно. На самом деле, в этом операторе нет ни одного не известного нам выражения.
<p align=justify>Здесь буквально сказано следующее:
<p align=justify>ВЫЗВАТЬ ФУНКЦИЮ, РАСПОЛОЖЕННУЮ ПО НУЛЕВОМУ ИНДЕКСУ ТАБЛИЦЫ ВИРТУАЛЬНЫХ ФУНКЦИЙ vtbl (в этой таблице у нас всего один элемент), АДРЕС НАЧАЛА КОТОРОЙ МОЖНО НАЙТИ ПО УКАЗАТЕЛЮ vptr.
<p align=justify>В СВОЮ ОЧЕРЕДЬ, ЭТОТ УКАЗАТЕЛЬ ДОСТУПЕН ПО УКАЗАТЕЛЮ pObj, НАСТРОЕННОМУ НА ОБЪЕКТ MyAC. ФУНКЦИИ ПЕРЕДАЁТСЯ ДВА (!) ПАРАМЕТРА, ПЕРВЫЙ ИЗ КОТОРЫХ ЯВЛЯЕТСЯ АДРЕСОМ ОБЪЕКТА MyAC (значение для this указателя!), ВТОРОЙ - ЦЕЛОЧИСЛЕННЫМ ЗНАЧЕНИЕМ, РАВНЫМ 1.
<p align=justify>Вызов функции-члена базового класса обеспечивается посредством квалифицированного имени.
<pre>pObj-&gt;A::Fun1(1);</pre>
<p align=justify>В этом операторе мы отказываемся от услуг таблицы виртуальных функций. При этом мы сообщаем транслятору о намерении вызвать функцию-член базового класса. Механизм поддержки виртуальных функций строг и очень жёстко регламентирован. Указатель на таблицу виртуальных функций обязательно включается в самый "верхний" базовый фрагмент объекта производного класса. В таблицу указателей включаются адреса функций-членов фрагмента самого "нижнего" уровня, содержащего объявления этой функции.
<p align=justify>Мы в очередной раз модифицируем объявление классов A, AB и объявляем новый класс ABC.
<p align=justify>Модификация классов A и AB сводится к объявлению в них новых функций-членов:
<pre>
class A
{
public:
 virtual int Fun1(int key);
 virtual int Fun2(int key);
};
:::::
int A::Fun2(int key)
{
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from A " &lt;&lt; endl;
 return 0;
}
class AB: public A
{
public:
int Fun1(int key);
int Fun2(int key);
};
:::::
int AB::Fun2(int key)
{
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from AB " &lt;&lt; endl;
 return 0;
}
Класс ABC является производным от класса AB:
class ABC: public AB
{
public:
int Fun1(int key);
};
int ABC::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from ABC " &lt;&lt; endl;
 return 0;
}
</pre>
<p align=justify>В этот класс входит объявление функции-члена Fun1, которая объявляется в косвенном базовом классе A как виртуальная функция. Кроме того, этот класс наследует от непосредственной базы функцию-член Fun2. Эта функция также объявляется в базовом классе A как виртуальная. Мы объявляем объект-представитель класса ABC:
<pre>ABC MyABC;</pre>
<p align=justify>Его схему можно представить следующим образом:
<pre>
MyABC::=
vptr
A
AB
ABC
vtbl::=
&amp;AB::Fun2
&amp;ABC::Fun1
</pre>
<p align=justify>Таблица виртуальных функций сейчас содержит два элемента. Мы настраиваем указатель на объект базового класса на объект MyABC, затем вызываем функции-члены:
<pre>
pObj = &amp;MyABC;
pObj-&gt;Fun1(1);
pObj-&gt;Fun2(2);
</pre>
<p align=justify>В этом случае невозможно вызвать функцию-член AB::Fun1(), поскольку её адрес не содержится в списке виртуальных функций, а с верхнего уровня объекта MyABC, на который настроен указатель pObj, она просто не видна. Таблица виртуальных функций строится конструктором в момент создания объекта соответствующего объекта. Безусловно, транслятор обеспечивает соответствующее кодирование конструктора. Но транслятор не в состоянии определить содержание таблицы виртуальных функций для конкретного объекта. Это задача времени исполнения. Пока таблица виртуальных функций не будет построена для конкретного объекта, соответствующая функция-член производного класса не сможет быть вызвана. В этом легко убедиться, после очередной модификации объявления классов.
<p align=justify>Программа невелика, поэтому имеет смысл привести её текст полностью. Не следует обольщаться по поводу операции доступа к компонентам класса ::. Обсуждение связанных с этой операцией проблем ещё впереди.
<pre>
#include &lt;iostream.h&gt;
class A
{
public:
virtual int Fun1(int key);
};
int A::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from A." &lt;&lt; endl;
 return 0;
}
class AB: public A
{
public:
AB() {Fun1(125);};
int Fun2(int key);
};
int AB::Fun2(int key)
{
 Fun1(key * 5);
 cout &lt;&lt; " Fun2( " &lt;&lt; key &lt;&lt; " ) from AB." &lt;&lt; endl;
 return 0;
}
class ABC: public AB
{
public:
int Fun1(int key);
};
int ABC::Fun1(int key)
{
 cout &lt;&lt; " Fun1( " &lt;&lt; key &lt;&lt; " ) from ABC." &lt;&lt; endl;
 return 0;
}
void main ()
{
 ABC MyABC; // Вызывается A::Fun1().
 MyABC.Fun1(1);        // Вызывается ABC::Fun1().
 MyABC.Fun2(1);        // Вызываются AB::Fun2() и ABC::Fun1().
 MyABC.A::Fun1(1);     // Вызывается A::Fun1().
 A *pObj = &amp;MyABC;     // Определяем и настраиваем указатель.
 cout &lt;&lt; "==========" &lt;&lt; endl;
 pObj-&gt;Fun1(2);         // Вызывается ABC::Fun1().
 //pObj-&gt;Fun2(2); // Эта функция через указатель недоступна !!!
 pObj-&gt;A::Fun1(2);      // Вызывается A::Fun1().
}
</pre>
<p align=justify>Теперь в момент создания объекта MyABC
<pre>
ABC MyABC;
</pre>
<p align=justify>из конструктора класса AB (а он вызывается раньше конструктора класса ABC), будет вызвана функция A::Fun1(). Эта функция является членом класса A. Объект MyABC ещё до конца не сформирован, таблица виртуальных функций ещё не заполнена, о существовании функции ABC::Fun1() ещё ничего не известно. После того, как объект MyABC будет окончательно сформирован, таблица виртуальных функций заполнится, а указатель pObj будет настроен на объект MyABC, вызов функции A::Fun1() через указатель pObj будет возможен лишь с использованием полного квалифицированного имени этой функции:
<pre>
pObj-&gt;Fun1(1);    // Это вызов функции ABC::Fun1()!
pObj-&gt;A::Fun1(1); // Очевидно, что это вызов функции A::Fun1()!
</pre>
<p align=justify>Заметим, что вызов функции-члена Fun1 непосредственно из объекта MyABC приводит к аналогичному результату:
<pre>MyABC.Fun1(1);    // Вызов функции ABC::Fun1().</pre>
<p align=justify>А попытка вызова невиртуальной функции AB::Fun2() через указатель на объект базового класса заканчивается неудачей. В таблице виртуальных функций адреса этой функции нет, а с верхнего уровня объекта "посмотреть вниз" невозможно.
<pre>//pObj-&gt;Fun2(2); // Так нельзя!</pre>
<p align=justify>Результат выполнения этой программки наглядно демонстрирует специфику использования виртуальных функций. Всего несколько строк…
<pre>
Fun1(125) from A.
Fun1(1) from ABC.
Fun1(5) from ABC.
Fun2(1) from AB.
Fun1(1) from A.
==========
Fun1(2) from ABC.
Fun1(2) from A.
</pre>
<p align=justify>Один и тот же указатель в ходе выполнения программы может настраиваться на объекты-представители различных производных классов. В результате в буквальном смысле одно и то выражение вызова функции-члена обеспечивает выполнение совершенно разных функций. Впервые мы сталкиваемся с так называемым ПОЗДНИМ или ОТЛОЖЕННЫМ СВЯЗЫВАНИЕМ.
<p align=justify>Заметим, что спецификация virtual относится только к функциям. Виртуальных данных-членов не существует. Это означает, что не существует возможности обратиться к данным-членам объекта производного класса по указателю на объект базового класса, настроенному на объект производного класса.
<p align=justify>С другой стороны, очевидно, что если можно вызвать замещающую функцию, то непосредственно "через" эту функцию открывается доступ ко всем функциям и данным-членам членам производного класса и далее "снизу-вверх" ко всем неприватным функциям и данным-членам непосредственных и косвенных базовых классов. При этом из функции становятся доступны все неприватные данные и функции базовых классов.
<p align=justify>И ещё один маленький пример, демонстрирующий изменение поведение объекта-представителя производного класса после того, как одна из функция базового класса становится виртуальной.
<pre>
#include &lt;iostream.h&gt;
class A
{
 public:
 void funA () {xFun();};
 /*virtual*/void xFun () {cout &lt;&lt;"this is void A::xFun();"&lt;&lt; endl;};
};
class B: public A
{
 public:
 void xFun () {cout &lt;&lt;"this is void B::xFun ();"&lt;&lt;endl;};
};
void main()
{
 B objB;
 objB.funA();
}
</pre>
<p align=justify>В начале спецификатор virtual а определении функции A::xFun() закомментирован. Процесс выполнения программы состоит в определении объекта-представителя objB производного класса B и вызова для этого объекта функции-члена funA(). Эта функция наследуется из базового класса, она одна и очевидно, что её идентификация не вызывает у транслятора никаких проблем. Эта функция принадлежит базовому классу, а это означает, что в момент её вызова, управление передаётся "на верхний уровень" объекта objB. На этом же уровне располагается одна из функций с именем xFun(), и именно этой функции передаётся управление в ходе выполнения выражения вызова в теле функции funA(). Мало того, из функции funA() просто невозможно вызвать другую одноименную функцию. В момент разбора структуры класса A транслятор вообще не имеет никакого представления о структуре класса B. Функция xFun() - член класса B оказывается недостижима из функции funA().
<p align=justify>Но если раскомментировать спецификатор virtual в определении функции A::xFun(), между двумя одноименными функциями установится отношение замещения, а порождение объекта objB будет сопровождаться созданием таблицы виртуальных функций, в соответствии с которой будет вызываться замещающая функция член класса B. Теперь для вызова замещаемой функции необходимо использовать её квалифицированное имя:
<pre>
void A::funA ()
 {
     xFun();
  A::xFun();
 }
</pre>
<center>
<p><font size="-1"><a href="CPP_078.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_080.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
