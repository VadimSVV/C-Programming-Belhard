<html><head>
<title>Представление операций для классов. Операторные функции</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Представление операций для классов. Операторные функции</h4>
<p align=justify>Классы вводят в программу производные типы. Такие типы могут входить в списки параметров функций и определять тип возвращаемого значения. В вызовах функций при передаче параметров и возвращении значений данные производных типов используются в программе наравне с данными базовых типов. В условиях фактического равноправия производных и основных типов данных должна существовать возможность сохранения привычной структуры выражений при работе с данными производных типов.
<p align=justify>Это означает, что выражение для вычисления суммы двух слагаемых уже известного нам типа ComplexType по своей структуре не должно отличаться от соответствующих выражений для слагаемых типа int или float. Но большинство операций языка C++ определены лишь для основных типов данных. Использование в качестве операндов операций выражений производных типов вызывает ошибки трансляции. Поэтому в классе ComplexType и были определены специальные функции-члены, реализующие арифметические операции над множеством комплексных чисел.
<p align=justify>И всё же возможность сохранения привычной структуры выражений для производных типов в C++ существует.
<p align=justify>Вернёмся к известному классу ComplexType. Мы определим два объекта класса ComplexType, после чего воспользуемся операцией присвоения.
<pre>
ComplexType ctVal1(3.14, 0.712);
ComplexType ctVal2, ctVal3;
/* Комплексные числа со случайными значениями данных-членов.*/
:::::
ctVal2 = ctVal1;
ctVal3 = ctVal2 = ctVal1;
/* Операция присвоения коммутативна.*/
</pre>
<p align=justify>Если теперь вывести значения данных-членов объектов ctVal2 и ctVal3, то окажется, что они полностью совпадают со значениями данных-членов объекта ctVal1. Операция присваивания изначально определена для объектов класса ComplexType. Её можно рассматривать как предопределённую операцию, которая обеспечивает фактически побитовое копирование объекта, стоящего справа от символа = в объект, расположенный слева от этого знака.
<p align=justify>Подобно любому другому выражению, выражение присваивания имеет собственное значение. Это значение равно выражению, стоящему справа от операции =. В ходе выполнения программы изменяется значение l-выражения в выражении присваивания, после чего значение этого выражения оказывается равным изменённому значению этого самого l-выражения.
<p align=justify>Строго говоря, операцию присваивания для объектов производных типов нельзя называть операцией. Как и ранее рассмотренные нами "операции" приведения, она является операторной функцией. Это значит, что при её объявлении используется специальное имя, состоящее из ключевого слова operator с символом операции, а для её вызова можно использовать полную и сокращённую форму.
<p align=justify>Мы приступаем к очередной модификации объявления класса ComplexType с целью переопределения новой операторной функции, реализующей то, что можно называть "операцией присваивания".
<p align=justify>Работу по объявлению этой функции мы начнём с того, что попытаемся представить её общий вид:
	<ul>
	<li>функция объявляется как нестатический член класса и вызывается для объекта, которому надо присвоить соответствующее значение;
	<li>её имя состоит из ключевого слова operator, за которым, очевидно, следует символ = ;
	<li>основное назначение функции состоит в присваивании значения (множества значений) одного объекта другому. Следовательно, операторная функция operator=() должна иметь, по крайней мере, один параметр, который должен представлять присваиваемое значение;
	<li>и последнее, очень важное обстоятельство. Операторная функция operator=() должна возвращать новое значение объекта и по форме вызова должна создавать видимость коммутативности, поскольку этим свойством обладает операция присвоения.
	</ul>
<pre>
class ComplexType
{
:::::
ComplexType operator = (const ComplexType &amp;);
/*
Ссылка на константу при объявлении параметра не является обязательным
условием для объявления операторной функции. Но это гарантия того,
что присваиваемое значение не будет изменено в результате обращения
к данным-членам. Операторная функция operator=() возвращает значение
(именно значение!) объект класса ComplexType. Это не самый оптимальный
способ обеспечения коммутативности операторной функции. Но при этом
обеспечивается подобие операторной функции операции присваивания.
*/
:::::
}
:::::
ComplexType ComplexType::operator = (const ComplexType&amp; ctKey)
{
 cout &lt;&lt; "This is operator = (ComplexType&amp; ctKey)..." &lt;&lt; endl;
/* Подтверждение о том, что выполняется именно эта функция. */
 this-&gt;real = ctKey.real;
 this-&gt;imag = ctKey.imag;
 this-&gt;CTcharVal = ctKey.CTcharVal;
 this-&gt;x = ctKey.x;
/*
Теперь вся ответственность за корректность процесса копирования целиком
и полностью возлагается на программиста.
*/
return *this;
/*
Мы возвращаем значение объекта, представленного this указателем.
*/
}
:::::
/*
Будем считать, что объекты ctVal1 и ctVal2 уже определены. Осталось
рассмотреть варианты вызовов этой функции.
*/
ctVal2.operator = (ctVal1);
/* Вариант полной формы вызова функции.*/
ctVal2 = ctVal1;
/*
Вариант сокращённой формы вызова функции. Операция обращения, ключевое
слово operator в составном имени операторной функции и скобки,
заключающие выражение, представляющее значение параметра опускаются.
Создаётся иллюзия использования обычной операции присваивания.
*/
/*
Демонстрация коммутативности операторной функции присваивания.
*/
ctVal3.operator = (ctVal2.operator = (ctVal1));
/*
Операторная функция operator=() вызывается непосредственно из объекта
ctVal3 со значением атрибута (ссылкой на объект), который сам в свою
очередь является результатом применения операторной функции operator=()
к объекту ctVal2 с параметром-ссылкой на объект ctVal1. Всё очень просто
и красиво!
*/
ctVal3 = ctVal2 = ctVal1;
/*
Сокращённая форма коммутативного вызова операторной функции присваивания.
*/
</pre>
<p align=justify>При объявлении и определении операторных функций (в том числе и operator=() ), используется синтаксическая конструкция, обозначаемая в терминах формальной грамматики нетерминальным символом <u>ИмяФункцииОперации</u>. Несколько форм Бэкуса-Наура позволяют однозначно определить это понятие:
<pre>
<u>Имя</u> ::= <u>ИмяФункцииОперации</u>
    ::= *****
<u>ИмяФункцииОперации</u> ::= operator <u>СимволОперации</u>
<u>СимволОперации</u> ::= 
                +|-|*|?|%|^|&amp;|~|!|,|=|&lt;|&gt;|&lt;=|&gt;=|++|--|&lt;&lt;|&gt;&gt;|==|!=|&amp;&amp;|
                |||+=|-=|*=|&lt;&lt;=|&gt;&gt;=|[]|()|-&gt;|-&gt;*|new|delete|
</pre>
<p align=justify>Как следует из приведённых БНФ, большинство символов операций языка C++ могут участвовать в создании так называемых имён функций операций или операторных функций. То есть на основе этих символов можно объявлять операторные функции, сокращённая форма вызова которых позволяет создавать видимость применения операций к объектам производных типов.
<p align=justify>C++ не накладывает никаких ограничений на семантику этих самых операторных функций. Наша операторная функция operator=() могла бы вообще не заниматься присвоением значений данных-членов. Она могла бы не возвращать никаких значений. Само собой, что тогда выражение вызова этой функции не могло бы быть коммутативным. А единственный параметр можно было бы передавать по значению. Но тогда всякий раз при вызове функции неизбежно должен был бы вызываться конструктор копирования, который бы создавал в области активации функции копию объекта, которую впоследствии должен был бы разрушать деструктор.
<p align=justify>Операторная функция operator=(), как и любая другая функция, может быть перегружена. Например, объявление параметра типа int, позволило бы присваивать комплексным числам целочисленные значения. Здесь нет пределов совершенствования. В принципе, механизм операторных функций регламентирует лишь внешний вид заголовка функции (его "операторное" имя, количество параметров, в ряде случаев - возвращаемое значение). Информация о заголовке принципиальна, поскольку от этого зависит форма сокращённого вызова операторной функции.
<p align=justify>Ещё несколько замечаний по поводу спецификации возвращаемого значения операторной функции.
<p align=justify>Операторная функция operator=() может вообще не возвращать никаких значений. Сокращённая форма вызова
<pre>ctVal2 = ctVal1;</pre>
<p align=justify>с точки зрения транслятора абсолютно корректна и полностью соответствует следующим прототипам:
<pre>
void ComplexType::operator = (const ComplexType&amp; ctKey);
void ComplexType::operator = (ComplexType&amp; ctKey);
void ComplexType::operator = (ComplexType ctKey);
</pre>
<p align=justify>Правда, в таком случае ни о какой коммутативности, "безопасности" и эффективности вновь определяемой операторной функции нет и быть не может.
<p align=justify>С другой стороны, уже существующий вариант нашей операторной функции также может быть оптимизирован. Функция может возвращать не ОБЪЕКТ (ЗНАЧЕНИЕ), а ССЫЛКУ на объект.
<p align=justify>В этом случае при возвращении значения не будет создано временного объекта. Также не будет вызываться деструктор для его уничтожения. Модификация операторной функции operator=() минимальна - всего лишь дополнительная ptrОперация &amp; в спецификации возвращаемого значения (мы приводим здесь только прототип новой версии функции):
<pre>ComplexType&amp; operator = (const ComplexType &amp;);</pre>
<p align=justify>Всё остальное транслятор исправит самостоятельно, так что никаких дополнительных модификаций в тексте программы производить не придётся. Эта функция будет эффективней, правда, семантика выражения её вызова будет отличаться от семантики соответствующего выражения присвоения с базовыми типами. В первом случае результатом выполнения выражения оказывается присваиваемое значение, во втором - ссылка на объект.
<p align=justify>Следующий пример является подтверждением того факта, что при объявлении операторных функций полностью отсутствуют чёткие правила. Это подтверждает следующий пример, посвящённый объявлению и вызову различных вариантов операторных функций operator():
<pre>
ComplexType&amp; operator () (const ComplexType&amp;);
/* Первый вариант совместно используемой функции operator().*/
void operator () (int);
/* Второй вариант совместно используемой функции operator().*/
:::::
/*
Определения этих функций. Как всегда, они не делают ничего полезного…
*/
ComplexType&amp; ComplexType::operator () (const ComplexType &amp;ctKey)
{
 cout &lt;&lt; "This is operator (ComplexType&amp; ctKey)..." &lt;&lt; endl;
 return *this;
}
void ComplexType::operator () (int iKey)
{
 cout &lt;&lt; "This is operator ( " &lt;&lt; iKey &lt;&lt; " )..." &lt;&lt; endl;
}
:::::
/*
Полные и сокращённые формы вызова этих функций. Первая операторная
функция коммутативна.
*/
CDw2.operator()(CDw1);
CDw2(CDw1);
CDw3.operator()(CDw2.operator()(CDw1));
CDw3(CDw2(CDw1));
CDw2.operator()(25);
CDw2(50);
</pre>
<p align=justify>И это ещё не всё! Ещё не рассматривались варианты операторной функции operator() с несколькими параметрами. И здесь следует вспомнить о функциях с переменным количеством параметров. Это не единственный, но наиболее оптимальный подход к объявлению операторной функции operator() с несколькими параметрами. Здесь мы не будем вдаваться в детали алгоритма извлечения информации из списка параметров (мы их уже обсуждали раньше), а ограничимся лишь общей схемой объявления и вариантами выражения вызова. В нашей версии (всего лишь одной из возможных!), первым параметром функции всегда будет целое число:
<pre>
ComplexType&amp; operator () (int, ...);// Прототип.
:::::
ComplexType&amp; ComplexType::operator () (int iKey, ...)
{
 cout &lt;&lt; "This is operator ( " &lt;&lt; iKey &lt;&lt; ", ...)" &lt;&lt; endl;
 return *this;
}
:::::
CDw2(50);
CDw2(50, 100);
CDw2(50, "Это тоже вызов операторной функции", 3.14, 0,123456789);
</pre>
<p align=justify>В C++ может быть объявлено более трёх десятков различных вариантов операторных функций. К этому выводу приводит анализ списка символов операций, которые потенциально могут входить в качестве элемента имени операции.
<p align=justify>Здесь не имеет смысла описывать все возможные операторные функции по отдельности. В этом разделе мы рассмотрим ещё несколько интересных "нетипичных" случаев объявления, в следующих разделах будут описаны типичные общие схемы объявлений операторных функций.
<p align=justify>Как известно, операция косвенного обращения -&gt; является бинарной операцией. Её первым операндом является указатель на объект, вторым - имя члена класса.
<p align=justify>Однако в C++ соответствующий операторный аналог представляется операторной функцией без параметров. Кроме того, для этой функции регламентируется тип возвращаемого значения. Она должна обязательно возвращать указатель либо ссылку на объект некоторого класса.
<p align=justify>Рассмотрим различные варианты объявления, определения и вызова этой операторной функции.
<p align=justify>Первый вариант тривиален:
<pre>
:::::
ComplexType* operator -&gt; ();
:::::
ComplexType* ComplexType::operator -&gt; ()
{
 cout &lt;&lt; "This is operator -&gt; ()..." &lt;&lt; endl;
 return this;
}
:::::
</pre>
<p align=justify>Таково, в общих чертах, объявление и определение функции. Функция без параметров.
<pre>
:::::
if (CDw2.operator-&gt;() == NULL) cout &lt;&lt; "!!!" &lt;&lt; endl;
:::::
</pre>
<p align=justify>Это полная форма вызова в выражении равенства в составе условного оператора.
<pre>
:::::
CDw3-&gt;real = 125.07; 
(CDw3.operator-&gt;())-&gt;real = 125.07; 
:::::
</pre>
<p align=justify>Сокращённая и полная формы вызова операторной функции в составе оператора присвоения. Функция возвращает адрес, к которому применяется обычная двухместная операция косвенного обращения.
<p align=justify>А вот более простого варианта сокращённой формы вызова функции operator-&gt;(), наподобие того, который ранее использовался в составе условного оператора, в C++ не существует. Правильно построенных выражений вида (xObject-&gt;) с единственным операндом, где -&gt; является символом операции, в C++ нет, поскольку -&gt; бинарная операция.
<p align=justify>Из-за того, что не всегда удаётся различить по контексту выражение вызова функции и операцию косвенного обращения, сокращённый вызов операторной функции operator-&gt;() используется исключительно для имитации выражений с операцией косвенного обращения.
<p align=justify>Операторная функция operator-&gt;() возвращает указатель на объект, и как любая нестатическая функция-член класса должна вызываться непосредственно "из объекта". Эта прописная истина не представляла бы никакого интереса, если бы в C++ существовали жёсткие ограничения на тип возвращаемого значения функции-члена класса. Но таких ограничений для операторных функций в C++ не существует, а потому возможны и такие экзотические варианты операторных функций:
<pre>
:::::
class ComplexType
{
:::::
};
:::::
class rrr // Объявляется новый класс.
{
 public:
 ComplexType* pComplexVal;
// Собственные версии конструкторов и деструкторов.
 rrr ()
 {
 pComplexVal = new ComplexType;
 // Порождение собственного экземпляра объекта ComplexType.
 }
~rrr ()
 {
  if (pComplexVal) = delete pComplexVal;
 }
// Наконец, встроенная операторная функция.
 ComplexType* operator -&gt; ()
 {
 cout &lt;&lt; "This is operator -&gt; ()..." &lt;&lt; endl;
 return pComplexVal;
 }
};
:::::
// А это уже собственно фрагмент программы…
rrr rrrVal; // Определяем объект - представитель класса rrr.
cout &lt;&lt; rrrVal -&gt;real &lt;&lt; " real." &lt;&lt; endl;
:::::
Сокращённая форма вызова операторной функции operator-&gt;() имеет вид rrrVal-&gt;real и интерпретируется транслятором как (rrrVal.operator-&gt;())-&gt;real, о чём и свидетельствует оператор, содержащий полную форму вызова этой операторной функции.
:::::
cout &lt;&lt; (rrrVal.operator-&gt;())-&gt;imag &lt;&lt; " imag." &lt;&lt; endl;
:::::
</pre>
<p align=justify>В этом случае из объекта-представителя класса rrr вызывается операторная функция, в обязательном порядке возвращающая адрес объекта-представителя класса ComplexType, к которому сразу же (!) применяется операция косвенного обращения.
<p align=justify>Здесь мы рассмотрели три операторные функции, сокращённая форма вызова которых имитировала операции присвоения, вызова и косвенного обращения. Эти операторные функции занимают особое место среди прочих операторных функций.
<p align=justify>Во-первых, описанные в этом разделе способы объявления и определения этих функций не имеет альтернативы.
<p align=justify>Во-вторых, на внешний вид объявления и формы вызова этих функций наложили свой отпечаток особенности синтаксиса и семантики соответствующих операций. Так, операция присвоения возвращает значение (или ссылку на значение), при этом, одновременно изменяя значение первого операнда (объекта, из которого осуществляется вызов операторной функции), бинарная операция косвенного обращения имитируется функцией без параметров, а операторная функция вызова может быть объявлена со списком параметров переменной длины.
<center>
<p><font size="-1"><a href="CPP_084.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_086.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
