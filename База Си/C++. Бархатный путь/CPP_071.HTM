<html><head>
<title>Конструктор копирования</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h4>Конструктор копирования</h4>
<p align=justify>Если определить переменную основного типа и присвоить ей значение, то выражение, состоящее из имени переменной, получит соответствующее значение. Имя означенной переменной можно расположить справа от знака операции присвоения. В результате выполнения этой операции присвоения, леводопустимое выражение окажется равным значению ранее объявленной и проинициализированной нами переменной. Произойдёт копирование значений объектов.
<pre>
int iVal1;
int iVal2;
iVal1 = 100;
iVal2 = iVal1;
</pre>
<p align=justify>Это нам давно известно. Это тривиально. Менее тривиальным оказывается результат выполнения операции присвоения для объектов-представителей класса.
<p align=justify>Вернёмся к старой версии конструктора (её проще повторно воспроизвести, чем описывать словами) и снова модифицируем main процедуру нашей программы. Мы определяем новый объект, используем операцию присвоения и наблюдаем за результатами:
<pre>
ComplexType()
{
 real = 0.0;
 imag = 0.0;
 CTcharVal = 0;
 x = 0;
 cout &lt;&lt; "Здесь ComplexType() конструктор!" &lt;&lt; endl;
}
:::::
void main()
{
 ComplexType CDw1;
 ComplexType CDw2 = CDw1;
 cout &lt;&lt; "(" &lt;&lt; CDw1.real &lt;&lt; ", " &lt;&lt; CDw1.imag &lt;&lt; "i)" &lt;&lt; endl;
 cout &lt;&lt; (int)CDw1.CTcharVal &lt;&lt; ", " &lt;&lt; CDw1.x &lt;&lt; "…" &lt;&lt; endl;
 cout &lt;&lt; "(" &lt;&lt; CDw2.real &lt;&lt; ", " &lt;&lt; CDw2.imag &lt;&lt; "i)" &lt;&lt; endl;
 cout &lt;&lt; (int)CDw2.CTcharVal &lt;&lt; ", " &lt;&lt; CDw2.x &lt;&lt; "…" &lt;&lt; endl;
}
</pre>
<p align=justify>Наша программа состоит из двух операторов определения, один из которых содержит описатель-инициализатор, и двух пар операторов вывода, которые сообщают о состоянии новорожденных объектов.
<p align=justify>В программе определяется два объекта. Можно предположить, что у этих объектов окажутся одинаковые значения данных-членов. Было бы странно, если бы результат операции присвоения для основных типов по своему результату отличался бы от операции присвоения для данных производных типов.
<p align=justify>Действительно, судя по поступающим сообщениям, оба объекта успешно были созданы и существуют с одинаковыми значениями данных-членов. При этом мы имеем дело с разными объектами, которые располагаются по разным адресам. В этом можно убедиться, если добавить оператор вывода в конец функции main:
<pre>if (&amp;CDw1 != &amp;CDw2) cout &lt;&lt; "OK!" &lt;&lt; endl;
                                      /* Сообщить о разных адресах.*/
</pre>
<p align=justify>И всё же выполнение этой тривиальной программы приводит к неожиданному результату: создавая два объекта, мы наблюдаем всего одно сообщение о работе конструктора.
<p align=justify>Остаётся предположить, что за процесс создания объекта с одновременным копированием значений данных-членов другого объекта, отвечает конструктор ещё неизвестного нам типа.
<p align=justify>Так и есть! Такой конструктор существует и называется конструктором копирования. Вместе с конструктором умолчания, конструктор копирования входит в обязательный набор конструкторов для любого класса. Реализация механизма копирования значений для транслятора не является неразрешимой задачей. Конструктор копирования всего лишь создаёт копии объектов. Этот процесс реализуется при помощи стандартного программного кода. И построить такой код транслятор способен самостоятельно.
<p align=justify>Здесь и далее, в примерах нами будет применяться операция присвоения = . В определённом смысле эта операция подобна конструктору. Реализующий эту операцию код автоматически создаётся на этапе трансляции для любого класса. Как и генерация кода стандартных конструкторов, это не самая сложная задача.
<p align=justify>Подобно конструктору умолчания, конструктор копирования наряду с уже известной нам формой вызова
<pre>ComplexType CDw2 = CDw1;</pre>
<p align=justify>имеет несколько альтернативных, приводящих к аналогичному конечному результату вызовов:
<pre>
ComplexType CDw2(CDw1);
ComplexType CDw3 = ComplexType(CDw1);
</pre>
<p align=justify>Обе альтернативные формы вызова напоминают нам уже известные формы вызова конструкторов с параметрами. Чтобы восстановить структуру заголовка конструктора копирования, мы должны лишь определить тип его параметра.
<p align=justify>На первый взгляд, здесь всё просто. В качестве значения параметра конструктору передаётся имя объекта, значит можно предположить, что тип параметра конструктора копирования соответствует данному классу. Так, в нашем случае, конструктор копирования класса ComplexType должен был бы иметь параметр типа ComplexType. Однако это не так. И вот почему.
<p align=justify>В C++ конструктор копирования является единственным средством создания копий объекта.
<p align=justify>С другой стороны, конструктор копирования - это конструктор, который поддерживает стандартный интерфейс вызова функций. Это означает, что параметры при обращении к конструктору, подобно параметрам функции передаются по значению. Если выражение вызова содержит значения параметров, то в ходе его реализации в области активации функции создаётся копия этих значений.
<p align=justify>В таком случае, вызов конструктора копирования сопровождался бы построением в области активации конструктора копии объекта. Для этого пришлось бы использовать конструктор копирования как единственное средство построения копии объекта. Таким образом, вызов подобного конструктора копирования сопровождался бы бесконечной рекурсией.
<p align=justify>Итак, КОНСТРУКТОР КОПИРОВАНИЯ КЛАССА X НЕ МОЖЕТ ИМЕТЬ ПАРАМЕТР ТИПА X. Это аксиома.
<p align=justify>На самом деле, в конструкторе копирования класса X в качестве параметра используется ссылка на объект этого класса. Причём эта ссылка объявляется со спецификатором const. И в этом нет ничего странного. Как известно, выражение вызова функции с параметром типа X ничем не отличается от выражения вызова функции, у которой параметром является ссылка на объект типа X. При вызове такой функции не приходится копировать объекты как параметры. Передача адреса не требует копирования объекта, а значит, при этом не будет и рекурсии.
<p align=justify>Конструктор копирования - обязательный элемент любого класса. Он также может быть переопределён подобно конструктору умолчания. При этом работа со ссылками в конструкторе копирования не требует явного использования операции разыменования. А спецификатор const (конструктор копирования работает с адресом объекта) предохраняет объект-параметр от случайной модификации в теле конструктора.
<center>
<p><font size="-1"><a href="CPP_070.HTM">Назад</a> |
 <a href=INDEX.HTM>Содержание</a> |
 <a href="CPP_072.HTM">Вперед</a>
</font></center>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
